<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="dlp_v2.html">Cloud Data Loss Prevention (DLP) API</a> . <a href="dlp_v2.projects.html">projects</a> . <a href="dlp_v2.projects.image.html">image</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#redact">redact(parent, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Redacts potentially sensitive info from an image.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="redact">redact(parent, body=None, x__xgafv=None)</code>
  <pre>Redacts potentially sensitive info from an image.
This method has limits on input size, processing time, and output size.
See https://cloud.google.com/dlp/docs/redacting-sensitive-data-images to
learn more.

When no InfoTypes or CustomInfoTypes are specified in this request, the
system will automatically choose what detectors to run. By default this may
be all types, but may change over time as detectors are updated.

Args:
  parent: string, The parent resource name, for example projects/my-project-id. (required)
  body: object, The request body.
    The object takes the form of:

{ # Request to search for potentially sensitive info in an image and redact it
      # by covering it with a colored rectangle.
    &quot;imageRedactionConfigs&quot;: [ # The configuration for specifying what content to redact from images.
      { # Configuration for determining how redaction of images should occur.
        &quot;infoType&quot;: { # Type of information detected by the API. # Only one per info_type should be provided per request. If not
            # specified, and redact_all_text is false, the DLP API will redact all
            # text that it matches against all info_types that are found, but not
            # specified in another ImageRedactionConfig.
          &quot;name&quot;: &quot;A String&quot;, # Name of the information type. Either a name of your choosing when
              # creating a CustomInfoType, or one of the names listed
              # at https://cloud.google.com/dlp/docs/infotypes-reference when specifying
              # a built-in type. InfoType names should conform to the pattern
              # `[a-zA-Z0-9_]{1,64}`.
        },
        &quot;redactionColor&quot;: { # Represents a color in the RGB color space. # The color to use when redacting content from an image. If not specified,
            # the default is black.
          &quot;green&quot;: 3.14, # The amount of green in the color as a value in the interval [0, 1].
          &quot;blue&quot;: 3.14, # The amount of blue in the color as a value in the interval [0, 1].
          &quot;red&quot;: 3.14, # The amount of red in the color as a value in the interval [0, 1].
        },
        &quot;redactAllText&quot;: True or False, # If true, all text found in the image, regardless whether it matches an
            # info_type, is redacted. Only one should be provided.
      },
    ],
    &quot;locationId&quot;: &quot;A String&quot;, # The geographic location to process the request. Reserved for future
        # extensions.
        # Location is restricted to &#x27;global&#x27;, &#x27;us&#x27;, &#x27;asia&#x27;, and &#x27;europe&#x27;.
    &quot;byteItem&quot;: { # Container for bytes to inspect or redact. # The content must be PNG, JPEG, SVG or BMP.
      &quot;data&quot;: &quot;A String&quot;, # Content data to inspect or redact.
      &quot;type&quot;: &quot;A String&quot;, # The type of data stored in the bytes string. Default will be TEXT_UTF8.
    },
    &quot;includeFindings&quot;: True or False, # Whether the response should include findings along with the redacted
        # image.
    &quot;inspectConfig&quot;: { # Configuration description of the scanning process. # Configuration for the inspector.
        # When used with redactContent only info_types and min_likelihood are currently
        # used.
      &quot;minLikelihood&quot;: &quot;A String&quot;, # Only returns findings equal or above this threshold. The default is
          # POSSIBLE.
          # See https://cloud.google.com/dlp/docs/likelihood to learn more.
      &quot;contentOptions&quot;: [ # List of options defining data content to scan.
          # If empty, text, images, and other content will be included.
        &quot;A String&quot;,
      ],
      &quot;infoTypes&quot;: [ # Restricts what info_types to look for. The values must correspond to
          # InfoType values returned by ListInfoTypes or listed at
          # https://cloud.google.com/dlp/docs/infotypes-reference.
          #
          # When no InfoTypes or CustomInfoTypes are specified in a request, the
          # system may automatically choose what detectors to run. By default this may
          # be all types, but may change over time as detectors are updated.
          #
          # If you need precise control and predictability as to what detectors are
          # run you should specify specific InfoTypes listed in the reference,
          # otherwise a default list will be used, which may change over time.
        { # Type of information detected by the API.
          &quot;name&quot;: &quot;A String&quot;, # Name of the information type. Either a name of your choosing when
              # creating a CustomInfoType, or one of the names listed
              # at https://cloud.google.com/dlp/docs/infotypes-reference when specifying
              # a built-in type. InfoType names should conform to the pattern
              # `[a-zA-Z0-9_]{1,64}`.
        },
      ],
      &quot;excludeInfoTypes&quot;: True or False, # When true, excludes type information of the findings.
      &quot;customInfoTypes&quot;: [ # CustomInfoTypes provided by the user. See
          # https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more.
        { # Custom information type provided by the user. Used to find domain-specific
            # sensitive information configurable to the data in question.
          &quot;surrogateType&quot;: { # Message for detecting output from deidentification transformations # Message for detecting output from deidentification transformations that
              # support reversing.
              # such as
              # [`CryptoReplaceFfxFpeConfig`](/dlp/docs/reference/rest/v2/organizations.deidentifyTemplates#cryptoreplaceffxfpeconfig).
              # These types of transformations are
              # those that perform pseudonymization, thereby producing a &quot;surrogate&quot; as
              # output. This should be used in conjunction with a field on the
              # transformation such as `surrogate_info_type`. This CustomInfoType does
              # not support the use of `detection_rules`.
          },
          &quot;likelihood&quot;: &quot;A String&quot;, # Likelihood to return for this CustomInfoType. This base value can be
              # altered by a detection rule if the finding meets the criteria specified by
              # the rule. Defaults to `VERY_LIKELY` if not specified.
          &quot;infoType&quot;: { # Type of information detected by the API. # CustomInfoType can either be a new infoType, or an extension of built-in
              # infoType, when the name matches one of existing infoTypes and that infoType
              # is specified in `InspectContent.info_types` field. Specifying the latter
              # adds findings to the one detected by the system. If built-in info type is
              # not specified in `InspectContent.info_types` list then the name is treated
              # as a custom info type.
            &quot;name&quot;: &quot;A String&quot;, # Name of the information type. Either a name of your choosing when
                # creating a CustomInfoType, or one of the names listed
                # at https://cloud.google.com/dlp/docs/infotypes-reference when specifying
                # a built-in type. InfoType names should conform to the pattern
                # `[a-zA-Z0-9_]{1,64}`.
          },
          &quot;regex&quot;: { # Message defining a custom regular expression. # Regular expression based CustomInfoType.
            &quot;groupIndexes&quot;: [ # The index of the submatch to extract as findings. When not
                # specified, the entire match is returned. No more than 3 may be included.
              42,
            ],
            &quot;pattern&quot;: &quot;A String&quot;, # Pattern defining the regular expression. Its syntax
                # (https://github.com/google/re2/wiki/Syntax) can be found under the
                # google/re2 repository on GitHub.
          },
          &quot;detectionRules&quot;: [ # Set of detection rules to apply to all findings of this CustomInfoType.
              # Rules are applied in order that they are specified. Not supported for the
              # `surrogate_type` CustomInfoType.
            { # Deprecated; use `InspectionRuleSet` instead. Rule for modifying a
                # `CustomInfoType` to alter behavior under certain circumstances, depending
                # on the specific details of the rule. Not supported for the `surrogate_type`
                # custom infoType.
              &quot;hotwordRule&quot;: { # The rule that adjusts the likelihood of findings within a certain # Hotword-based detection rule.
                  # proximity of hotwords.
                &quot;likelihoodAdjustment&quot;: { # Message for specifying an adjustment to the likelihood of a finding as # Likelihood adjustment to apply to all matching findings.
                    # part of a detection rule.
                  &quot;relativeLikelihood&quot;: 42, # Increase or decrease the likelihood by the specified number of
                      # levels. For example, if a finding would be `POSSIBLE` without the
                      # detection rule and `relative_likelihood` is 1, then it is upgraded to
                      # `LIKELY`, while a value of -1 would downgrade it to `UNLIKELY`.
                      # Likelihood may never drop below `VERY_UNLIKELY` or exceed
                      # `VERY_LIKELY`, so applying an adjustment of 1 followed by an
                      # adjustment of -1 when base likelihood is `VERY_LIKELY` will result in
                      # a final likelihood of `LIKELY`.
                  &quot;fixedLikelihood&quot;: &quot;A String&quot;, # Set the likelihood of a finding to a fixed value.
                },
                &quot;hotwordRegex&quot;: { # Message defining a custom regular expression. # Regular expression pattern defining what qualifies as a hotword.
                  &quot;groupIndexes&quot;: [ # The index of the submatch to extract as findings. When not
                      # specified, the entire match is returned. No more than 3 may be included.
                    42,
                  ],
                  &quot;pattern&quot;: &quot;A String&quot;, # Pattern defining the regular expression. Its syntax
                      # (https://github.com/google/re2/wiki/Syntax) can be found under the
                      # google/re2 repository on GitHub.
                },
                &quot;proximity&quot;: { # Message for specifying a window around a finding to apply a detection # Proximity of the finding within which the entire hotword must reside.
                    # The total length of the window cannot exceed 1000 characters. Note that
                    # the finding itself will be included in the window, so that hotwords may
                    # be used to match substrings of the finding itself. For example, the
                    # certainty of a phone number regex &quot;\(\d{3}\) \d{3}-\d{4}&quot; could be
                    # adjusted upwards if the area code is known to be the local area code of
                    # a company office using the hotword regex &quot;\(xxx\)&quot;, where &quot;xxx&quot;
                    # is the area code in question.
                    # rule.
                  &quot;windowBefore&quot;: 42, # Number of characters before the finding to consider.
                  &quot;windowAfter&quot;: 42, # Number of characters after the finding to consider.
                },
              },
            },
          ],
          &quot;exclusionType&quot;: &quot;A String&quot;, # If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding
              # to be returned. It still can be used for rules matching.
          &quot;dictionary&quot;: { # Custom information type based on a dictionary of words or phrases. This can # A list of phrases to detect as a CustomInfoType.
              # be used to match sensitive information specific to the data, such as a list
              # of employee IDs or job titles.
              #
              # Dictionary words are case-insensitive and all characters other than letters
              # and digits in the unicode [Basic Multilingual
              # Plane](https://en.wikipedia.org/wiki/Plane_%28Unicode%29#Basic_Multilingual_Plane)
              # will be replaced with whitespace when scanning for matches, so the
              # dictionary phrase &quot;Sam Johnson&quot; will match all three phrases &quot;sam johnson&quot;,
              # &quot;Sam, Johnson&quot;, and &quot;Sam (Johnson)&quot;. Additionally, the characters
              # surrounding any match must be of a different type than the adjacent
              # characters within the word, so letters must be next to non-letters and
              # digits next to non-digits. For example, the dictionary word &quot;jen&quot; will
              # match the first three letters of the text &quot;jen123&quot; but will return no
              # matches for &quot;jennifer&quot;.
              #
              # Dictionary words containing a large number of characters that are not
              # letters or digits may result in unexpected findings because such characters
              # are treated as whitespace. The
              # [limits](https://cloud.google.com/dlp/limits) page contains details about
              # the size limits of dictionaries. For dictionaries that do not fit within
              # these constraints, consider using `LargeCustomDictionaryConfig` in the
              # `StoredInfoType` API.
            &quot;wordList&quot;: { # Message defining a list of words or phrases to search for in the data. # List of words or phrases to search for.
              &quot;words&quot;: [ # Words or phrases defining the dictionary. The dictionary must contain
                  # at least one phrase and every phrase must contain at least 2 characters
                  # that are letters or digits. [required]
                &quot;A String&quot;,
              ],
            },
            &quot;cloudStoragePath&quot;: { # Message representing a single file or path in Cloud Storage. # Newline-delimited file of words in Cloud Storage. Only a single file
                # is accepted.
              &quot;path&quot;: &quot;A String&quot;, # A url representing a file or path (no wildcards) in Cloud Storage.
                  # Example: gs://[BUCKET_NAME]/dictionary.txt
            },
          },
          &quot;storedType&quot;: { # A reference to a StoredInfoType to use with scanning. # Load an existing `StoredInfoType` resource for use in
              # `InspectDataSource`. Not currently supported in `InspectContent`.
            &quot;name&quot;: &quot;A String&quot;, # Resource name of the requested `StoredInfoType`, for example
                # `organizations/433245324/storedInfoTypes/432452342` or
                # `projects/project-id/storedInfoTypes/432452342`.
            &quot;createTime&quot;: &quot;A String&quot;, # Timestamp indicating when the version of the `StoredInfoType` used for
                # inspection was created. Output-only field, populated by the system.
          },
        },
      ],
      &quot;includeQuote&quot;: True or False, # When true, a contextual quote from the data that triggered a finding is
          # included in the response; see Finding.quote.
      &quot;ruleSet&quot;: [ # Set of rules to apply to the findings for this InspectConfig.
          # Exclusion rules, contained in the set are executed in the end, other
          # rules are executed in the order they are specified for each info type.
        { # Rule set for modifying a set of infoTypes to alter behavior under certain
            # circumstances, depending on the specific details of the rules within the set.
          &quot;infoTypes&quot;: [ # List of infoTypes this rule set is applied to.
            { # Type of information detected by the API.
              &quot;name&quot;: &quot;A String&quot;, # Name of the information type. Either a name of your choosing when
                  # creating a CustomInfoType, or one of the names listed
                  # at https://cloud.google.com/dlp/docs/infotypes-reference when specifying
                  # a built-in type. InfoType names should conform to the pattern
                  # `[a-zA-Z0-9_]{1,64}`.
            },
          ],
          &quot;rules&quot;: [ # Set of rules to be applied to infoTypes. The rules are applied in order.
            { # A single inspection rule to be applied to infoTypes, specified in
                # `InspectionRuleSet`.
              &quot;hotwordRule&quot;: { # The rule that adjusts the likelihood of findings within a certain # Hotword-based detection rule.
                  # proximity of hotwords.
                &quot;likelihoodAdjustment&quot;: { # Message for specifying an adjustment to the likelihood of a finding as # Likelihood adjustment to apply to all matching findings.
                    # part of a detection rule.
                  &quot;relativeLikelihood&quot;: 42, # Increase or decrease the likelihood by the specified number of
                      # levels. For example, if a finding would be `POSSIBLE` without the
                      # detection rule and `relative_likelihood` is 1, then it is upgraded to
                      # `LIKELY`, while a value of -1 would downgrade it to `UNLIKELY`.
                      # Likelihood may never drop below `VERY_UNLIKELY` or exceed
                      # `VERY_LIKELY`, so applying an adjustment of 1 followed by an
                      # adjustment of -1 when base likelihood is `VERY_LIKELY` will result in
                      # a final likelihood of `LIKELY`.
                  &quot;fixedLikelihood&quot;: &quot;A String&quot;, # Set the likelihood of a finding to a fixed value.
                },
                &quot;hotwordRegex&quot;: { # Message defining a custom regular expression. # Regular expression pattern defining what qualifies as a hotword.
                  &quot;groupIndexes&quot;: [ # The index of the submatch to extract as findings. When not
                      # specified, the entire match is returned. No more than 3 may be included.
                    42,
                  ],
                  &quot;pattern&quot;: &quot;A String&quot;, # Pattern defining the regular expression. Its syntax
                      # (https://github.com/google/re2/wiki/Syntax) can be found under the
                      # google/re2 repository on GitHub.
                },
                &quot;proximity&quot;: { # Message for specifying a window around a finding to apply a detection # Proximity of the finding within which the entire hotword must reside.
                    # The total length of the window cannot exceed 1000 characters. Note that
                    # the finding itself will be included in the window, so that hotwords may
                    # be used to match substrings of the finding itself. For example, the
                    # certainty of a phone number regex &quot;\(\d{3}\) \d{3}-\d{4}&quot; could be
                    # adjusted upwards if the area code is known to be the local area code of
                    # a company office using the hotword regex &quot;\(xxx\)&quot;, where &quot;xxx&quot;
                    # is the area code in question.
                    # rule.
                  &quot;windowBefore&quot;: 42, # Number of characters before the finding to consider.
                  &quot;windowAfter&quot;: 42, # Number of characters after the finding to consider.
                },
              },
              &quot;exclusionRule&quot;: { # The rule that specifies conditions when findings of infoTypes specified in # Exclusion rule.
                  # `InspectionRuleSet` are removed from results.
                &quot;dictionary&quot;: { # Custom information type based on a dictionary of words or phrases. This can # Dictionary which defines the rule.
                    # be used to match sensitive information specific to the data, such as a list
                    # of employee IDs or job titles.
                    #
                    # Dictionary words are case-insensitive and all characters other than letters
                    # and digits in the unicode [Basic Multilingual
                    # Plane](https://en.wikipedia.org/wiki/Plane_%28Unicode%29#Basic_Multilingual_Plane)
                    # will be replaced with whitespace when scanning for matches, so the
                    # dictionary phrase &quot;Sam Johnson&quot; will match all three phrases &quot;sam johnson&quot;,
                    # &quot;Sam, Johnson&quot;, and &quot;Sam (Johnson)&quot;. Additionally, the characters
                    # surrounding any match must be of a different type than the adjacent
                    # characters within the word, so letters must be next to non-letters and
                    # digits next to non-digits. For example, the dictionary word &quot;jen&quot; will
                    # match the first three letters of the text &quot;jen123&quot; but will return no
                    # matches for &quot;jennifer&quot;.
                    #
                    # Dictionary words containing a large number of characters that are not
                    # letters or digits may result in unexpected findings because such characters
                    # are treated as whitespace. The
                    # [limits](https://cloud.google.com/dlp/limits) page contains details about
                    # the size limits of dictionaries. For dictionaries that do not fit within
                    # these constraints, consider using `LargeCustomDictionaryConfig` in the
                    # `StoredInfoType` API.
                  &quot;wordList&quot;: { # Message defining a list of words or phrases to search for in the data. # List of words or phrases to search for.
                    &quot;words&quot;: [ # Words or phrases defining the dictionary. The dictionary must contain
                        # at least one phrase and every phrase must contain at least 2 characters
                        # that are letters or digits. [required]
                      &quot;A String&quot;,
                    ],
                  },
                  &quot;cloudStoragePath&quot;: { # Message representing a single file or path in Cloud Storage. # Newline-delimited file of words in Cloud Storage. Only a single file
                      # is accepted.
                    &quot;path&quot;: &quot;A String&quot;, # A url representing a file or path (no wildcards) in Cloud Storage.
                        # Example: gs://[BUCKET_NAME]/dictionary.txt
                  },
                },
                &quot;regex&quot;: { # Message defining a custom regular expression. # Regular expression which defines the rule.
                  &quot;groupIndexes&quot;: [ # The index of the submatch to extract as findings. When not
                      # specified, the entire match is returned. No more than 3 may be included.
                    42,
                  ],
                  &quot;pattern&quot;: &quot;A String&quot;, # Pattern defining the regular expression. Its syntax
                      # (https://github.com/google/re2/wiki/Syntax) can be found under the
                      # google/re2 repository on GitHub.
                },
                &quot;excludeInfoTypes&quot;: { # List of exclude infoTypes. # Set of infoTypes for which findings would affect this rule.
                  &quot;infoTypes&quot;: [ # InfoType list in ExclusionRule rule drops a finding when it overlaps or
                      # contained within with a finding of an infoType from this list. For
                      # example, for `InspectionRuleSet.info_types` containing &quot;PHONE_NUMBER&quot;` and
                      # `exclusion_rule` containing `exclude_info_types.info_types` with
                      # &quot;EMAIL_ADDRESS&quot; the phone number findings are dropped if they overlap
                      # with EMAIL_ADDRESS finding.
                      # That leads to &quot;555-222-2222@example.org&quot; to generate only a single
                      # finding, namely email address.
                    { # Type of information detected by the API.
                      &quot;name&quot;: &quot;A String&quot;, # Name of the information type. Either a name of your choosing when
                          # creating a CustomInfoType, or one of the names listed
                          # at https://cloud.google.com/dlp/docs/infotypes-reference when specifying
                          # a built-in type. InfoType names should conform to the pattern
                          # `[a-zA-Z0-9_]{1,64}`.
                    },
                  ],
                },
                &quot;matchingType&quot;: &quot;A String&quot;, # How the rule is applied, see MatchingType documentation for details.
              },
            },
          ],
        },
      ],
      &quot;limits&quot;: { # Configuration to control the number of findings returned. # Configuration to control the number of findings returned.
        &quot;maxFindingsPerItem&quot;: 42, # Max number of findings that will be returned for each item scanned.
            # When set within `InspectJobConfig`,
            # the maximum returned is 2000 regardless if this is set higher.
            # When set within `InspectContentRequest`, this field is ignored.
        &quot;maxFindingsPerInfoType&quot;: [ # Configuration of findings limit given for specified infoTypes.
          { # Max findings configuration per infoType, per content item or long
              # running DlpJob.
            &quot;maxFindings&quot;: 42, # Max findings limit for the given infoType.
            &quot;infoType&quot;: { # Type of information detected by the API. # Type of information the findings limit applies to. Only one limit per
                # info_type should be provided. If InfoTypeLimit does not have an
                # info_type, the DLP API applies the limit against all info_types that
                # are found but not specified in another InfoTypeLimit.
              &quot;name&quot;: &quot;A String&quot;, # Name of the information type. Either a name of your choosing when
                  # creating a CustomInfoType, or one of the names listed
                  # at https://cloud.google.com/dlp/docs/infotypes-reference when specifying
                  # a built-in type. InfoType names should conform to the pattern
                  # `[a-zA-Z0-9_]{1,64}`.
            },
          },
        ],
        &quot;maxFindingsPerRequest&quot;: 42, # Max number of findings that will be returned per request/job.
            # When set within `InspectContentRequest`, the maximum returned is 2000
            # regardless if this is set higher.
      },
    },
  }

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Results of redacting an image.
    &quot;redactedImage&quot;: &quot;A String&quot;, # The redacted image. The type will be the same as the original image.
    &quot;inspectResult&quot;: { # All the findings for a single scanned item. # The findings. Populated when include_findings in the request is true.
      &quot;findings&quot;: [ # List of findings for an item.
        { # Represents a piece of potentially sensitive content.
          &quot;quoteInfo&quot;: { # Message for infoType-dependent details parsed from quote. # Contains data parsed from quotes. Only populated if include_quote was set
              # to true and a supported infoType was requested. Currently supported
              # infoTypes: DATE, DATE_OF_BIRTH and TIME.
            &quot;dateTime&quot;: { # Message for a date time object. # The date time indicated by the quote.
                # e.g. 2018-01-01, 5th August.
              &quot;date&quot;: { # Represents a whole or partial calendar date, e.g. a birthday. The time of day # One or more of the following must be set.
                  # Must be a valid date or time value.
                  # and time zone are either specified elsewhere or are not significant. The date
                  # is relative to the Proleptic Gregorian Calendar. This can represent:
                  #
                  # * A full date, with non-zero year, month and day values
                  # * A month and day value, with a zero year, e.g. an anniversary
                  # * A year on its own, with zero month and day values
                  # * A year and month value, with a zero day, e.g. a credit card expiration date
                  #
                  # Related types are google.type.TimeOfDay and `google.protobuf.Timestamp`.
                &quot;year&quot;: 42, # Year of date. Must be from 1 to 9999, or 0 if specifying a date without
                    # a year.
                &quot;month&quot;: 42, # Month of year. Must be from 1 to 12, or 0 if specifying a year without a
                    # month and day.
                &quot;day&quot;: 42, # Day of month. Must be from 1 to 31 and valid for the year and month, or 0
                    # if specifying a year by itself or a year and month where the day is not
                    # significant.
              },
              &quot;timeZone&quot;: { # Time zone of the date time object. # Time zone
                &quot;offsetMinutes&quot;: 42, # Set only if the offset can be determined. Positive for time ahead of UTC.
                    # E.g. For &quot;UTC-9&quot;, this value is -540.
              },
              &quot;dayOfWeek&quot;: &quot;A String&quot;, # Day of week
              &quot;time&quot;: { # Represents a time of day. The date and time zone are either not significant # Time of day
                  # or are specified elsewhere. An API may choose to allow leap seconds. Related
                  # types are google.type.Date and `google.protobuf.Timestamp`.
                &quot;hours&quot;: 42, # Hours of day in 24 hour format. Should be from 0 to 23. An API may choose
                    # to allow the value &quot;24:00:00&quot; for scenarios like business closing time.
                &quot;minutes&quot;: 42, # Minutes of hour of day. Must be from 0 to 59.
                &quot;seconds&quot;: 42, # Seconds of minutes of the time. Must normally be from 0 to 59. An API may
                    # allow the value 60 if it allows leap-seconds.
                &quot;nanos&quot;: 42, # Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
              },
            },
          },
          &quot;infoType&quot;: { # Type of information detected by the API. # The type of content that might have been found.
              # Provided if `excluded_types` is false.
            &quot;name&quot;: &quot;A String&quot;, # Name of the information type. Either a name of your choosing when
                # creating a CustomInfoType, or one of the names listed
                # at https://cloud.google.com/dlp/docs/infotypes-reference when specifying
                # a built-in type. InfoType names should conform to the pattern
                # `[a-zA-Z0-9_]{1,64}`.
          },
          &quot;labels&quot;: { # The labels associated with this `Finding`.
              #
              # Label keys must be between 1 and 63 characters long and must conform
              # to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
              #
              # Label values must be between 0 and 63 characters long and must conform
              # to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
              #
              # No more than 10 labels can be associated with a given finding.
              #
              # Examples:
              # * `&quot;environment&quot; : &quot;production&quot;`
              # * `&quot;pipeline&quot; : &quot;etl&quot;`
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;likelihood&quot;: &quot;A String&quot;, # Confidence of how likely it is that the `info_type` is correct.
          &quot;name&quot;: &quot;A String&quot;, # Resource name in format
              # projects/{project}/locations/{location}/findings/{finding} Populated only
              # when viewing persisted findings.
          &quot;location&quot;: { # Specifies the location of the finding. # Where the content was found.
            &quot;codepointRange&quot;: { # Generic half-open interval [start, end) # Unicode character offsets delimiting the finding.
                # These are relative to the finding&#x27;s containing element.
                # Provided when the content is text.
              &quot;start&quot;: &quot;A String&quot;, # Index of the first character of the range (inclusive).
              &quot;end&quot;: &quot;A String&quot;, # Index of the last character of the range (exclusive).
            },
            &quot;byteRange&quot;: { # Generic half-open interval [start, end) # Zero-based byte offsets delimiting the finding.
                # These are relative to the finding&#x27;s containing element.
                # Note that when the content is not textual, this references
                # the UTF-8 encoded textual representation of the content.
                # Omitted if content is an image.
              &quot;start&quot;: &quot;A String&quot;, # Index of the first character of the range (inclusive).
              &quot;end&quot;: &quot;A String&quot;, # Index of the last character of the range (exclusive).
            },
            &quot;container&quot;: { # Represents a container that may contain DLP findings. # Information about the container where this finding occurred, if available.
                # Examples of a container include a file, table, or database record.
              &quot;updateTime&quot;: &quot;A String&quot;, # Findings container modification timestamp, if applicable.
                  # For Google Cloud Storage contains last file modification timestamp.
                  # For BigQuery table contains last_modified_time property.
                  # For Datastore - not populated.
              &quot;rootPath&quot;: &quot;A String&quot;, # The root of the container.
                  # Examples:
                  # - For BigQuery table `project_id:dataset_id.table_id`, the root is
                  #  `dataset_id`
                  # - For Google Cloud Storage file `gs://bucket/folder/filename.txt`, the root
                  #  is `gs://bucket`
              &quot;projectId&quot;: &quot;A String&quot;, # Project where the finding was found.
                  # Can be different from the project that owns the finding.
              &quot;version&quot;: &quot;A String&quot;, # Findings container version, if available
                  # (&quot;generation&quot; for Google Cloud Storage).
              &quot;relativePath&quot;: &quot;A String&quot;, # The rest of the path after the root.
                  # Examples:
                  # - For BigQuery table `project_id:dataset_id.table_id`, the relative path is
                  #  `table_id`
                  # - Google Cloud Storage file `gs://bucket/folder/filename.txt`, the relative
                  #  path is `folder/filename.txt`
              &quot;fullPath&quot;: &quot;A String&quot;, # A string representation of the full container name.
                  # Examples:
                  # - BigQuery: &#x27;Project:DataSetId.TableId&#x27;
                  # - Google Cloud Storage: &#x27;gs://Bucket/folders/filename.txt&#x27;
              &quot;type&quot;: &quot;A String&quot;, # Container type, for example BigQuery or Google Cloud Storage.
            },
            &quot;contentLocations&quot;: [ # List of nested objects pointing to the precise location of the finding
                # within the file or record.
              { # Precise location of the finding within a document, record, image, or metadata
                  # container.
                &quot;containerVersion&quot;: &quot;A String&quot;, # Findings container version, if available
                    # (&quot;generation&quot; for Google Cloud Storage).
                &quot;containerName&quot;: &quot;A String&quot;, # Name of the container where the finding is located.
                    # The top level name is the source file name or table name. Names of some
                    # common storage containers are formatted as follows:
                    #
                    # * BigQuery tables:  `{project_id}:{dataset_id}.{table_id}`
                    # * Cloud Storage files: `gs://{bucket}/{path}`
                    # * Datastore namespace: {namespace}
                    #
                    # Nested names could be absent if the embedded object has no string
                    # identifier (for an example an image contained within a document).
                &quot;documentLocation&quot;: { # Location of a finding within a document. # Location data for document files.
                  &quot;fileOffset&quot;: &quot;A String&quot;, # Offset of the line, from the beginning of the file, where the finding
                      # is located.
                },
                &quot;recordLocation&quot;: { # Location of a finding within a row or record. # Location within a row or record of a database table.
                  &quot;fieldId&quot;: { # General identifier of a data field in a storage service. # Field id of the field containing the finding.
                    &quot;name&quot;: &quot;A String&quot;, # Name describing the field.
                  },
                  &quot;tableLocation&quot;: { # Location of a finding within a table. # Location within a `ContentItem.Table`.
                    &quot;rowIndex&quot;: &quot;A String&quot;, # The zero-based index of the row where the finding is located. Only
                        # populated for resources that have a natural ordering, not BigQuery. In
                        # BigQuery, to identify the row a finding came from, populate
                        # BigQueryOptions.identifying_fields with your primary key column names and
                        # when you store the findings the value of those columns will be stored
                        # inside of Finding.
                  },
                  &quot;recordKey&quot;: { # Message for a unique key indicating a record that contains a finding. # Key of the finding.
                    &quot;datastoreKey&quot;: { # Record key for a finding in Cloud Datastore.
                      &quot;entityKey&quot;: { # A unique identifier for a Datastore entity. # Datastore entity key.
                          # If a key&#x27;s partition ID or any of its path kinds or names are
                          # reserved/read-only, the key is reserved/read-only.
                          # A reserved/read-only key is forbidden in certain documented contexts.
                        &quot;partitionId&quot;: { # Datastore partition ID. # Entities are partitioned into subsets, currently identified by a project
                            # ID and namespace ID.
                            # Queries are scoped to a single partition.
                            # A partition ID identifies a grouping of entities. The grouping is always
                            # by project and namespace, however the namespace ID may be empty.
                            #
                            # A partition ID contains several dimensions:
                            # project ID and namespace ID.
                          &quot;projectId&quot;: &quot;A String&quot;, # The ID of the project to which the entities belong.
                          &quot;namespaceId&quot;: &quot;A String&quot;, # If not empty, the ID of the namespace to which the entities belong.
                        },
                        &quot;path&quot;: [ # The entity path.
                            # An entity path consists of one or more elements composed of a kind and a
                            # string or numerical identifier, which identify entities. The first
                            # element identifies a _root entity_, the second element identifies
                            # a _child_ of the root entity, the third element identifies a child of the
                            # second entity, and so forth. The entities identified by all prefixes of
                            # the path are called the element&#x27;s _ancestors_.
                            #
                            # A path can never be empty, and a path can have at most 100 elements.
                          { # A (kind, ID/name) pair used to construct a key path.
                              #
                              # If either name or ID is set, the element is complete.
                              # If neither is set, the element is incomplete.
                            &quot;kind&quot;: &quot;A String&quot;, # The kind of the entity.
                                # A kind matching regex `__.*__` is reserved/read-only.
                                # A kind must not contain more than 1500 bytes when UTF-8 encoded.
                                # Cannot be `&quot;&quot;`.
                            &quot;id&quot;: &quot;A String&quot;, # The auto-allocated ID of the entity.
                                # Never equal to zero. Values less than zero are discouraged and may not
                                # be supported in the future.
                            &quot;name&quot;: &quot;A String&quot;, # The name of the entity.
                                # A name matching regex `__.*__` is reserved/read-only.
                                # A name must not be more than 1500 bytes when UTF-8 encoded.
                                # Cannot be `&quot;&quot;`.
                          },
                        ],
                      },
                    },
                    &quot;bigQueryKey&quot;: { # Row key for identifying a record in BigQuery table.
                      &quot;rowNumber&quot;: &quot;A String&quot;, # Row number inferred at the time the table was scanned. This value is
                          # nondeterministic, cannot be queried, and may be null for inspection
                          # jobs. To locate findings within a table, specify
                          # `inspect_job.storage_config.big_query_options.identifying_fields` in
                          # `CreateDlpJobRequest`.
                      &quot;tableReference&quot;: { # Message defining the location of a BigQuery table. A table is uniquely # Complete BigQuery table reference.
                          # identified  by its project_id, dataset_id, and table_name. Within a query
                          # a table is often referenced with a string in the format of:
                          # `&lt;project_id&gt;:&lt;dataset_id&gt;.&lt;table_id&gt;` or
                          # `&lt;project_id&gt;.&lt;dataset_id&gt;.&lt;table_id&gt;`.
                        &quot;projectId&quot;: &quot;A String&quot;, # The Google Cloud Platform project ID of the project containing the table.
                            # If omitted, project ID is inferred from the API call.
                        &quot;datasetId&quot;: &quot;A String&quot;, # Dataset ID of the table.
                        &quot;tableId&quot;: &quot;A String&quot;, # Name of the table.
                      },
                    },
                    &quot;idValues&quot;: [ # Values of identifying columns in the given row. Order of values matches
                        # the order of `identifying_fields` specified in the scanning request.
                      &quot;A String&quot;,
                    ],
                  },
                },
                &quot;containerTimestamp&quot;: &quot;A String&quot;, # Findings container modification timestamp, if applicable.
                    # For Google Cloud Storage contains last file modification timestamp.
                    # For BigQuery table contains last_modified_time property.
                    # For Datastore - not populated.
                &quot;metadataLocation&quot;: { # Metadata Location # Location within the metadata for inspected content.
                  &quot;type&quot;: &quot;A String&quot;, # Type of metadata containing the finding.
                  &quot;storageLabel&quot;: { # Storage metadata label to indicate which metadata entry contains findings. # Storage metadata.
                    &quot;key&quot;: &quot;A String&quot;,
                  },
                },
                &quot;imageLocation&quot;: { # Location of the finding within an image. # Location within an image&#x27;s pixels.
                  &quot;boundingBoxes&quot;: [ # Bounding boxes locating the pixels within the image containing the finding.
                    { # Bounding box encompassing detected text within an image.
                      &quot;top&quot;: 42, # Top coordinate of the bounding box. (0,0) is upper left.
                      &quot;width&quot;: 42, # Width of the bounding box in pixels.
                      &quot;height&quot;: 42, # Height of the bounding box in pixels.
                      &quot;left&quot;: 42, # Left coordinate of the bounding box. (0,0) is upper left.
                    },
                  ],
                },
              },
            ],
          },
          &quot;quote&quot;: &quot;A String&quot;, # The content that was found. Even if the content is not textual, it
              # may be converted to a textual representation here.
              # Provided if `include_quote` is true and the finding is
              # less than or equal to 4096 bytes long. If the finding exceeds 4096 bytes
              # in length, the quote may be omitted.
          &quot;createTime&quot;: &quot;A String&quot;, # Timestamp when finding was detected.
          &quot;jobName&quot;: &quot;A String&quot;, # The job that stored the finding.
          &quot;jobCreateTime&quot;: &quot;A String&quot;, # Time the job started that produced this finding.
          &quot;triggerName&quot;: &quot;A String&quot;, # Job trigger name, if applicable, for this finding.
          &quot;resourceName&quot;: &quot;A String&quot;, # The job that stored the finding.
        },
      ],
      &quot;findingsTruncated&quot;: True or False, # If true, then this item might have more findings than were returned,
          # and the findings returned are an arbitrary subset of all findings.
          # The findings list might be truncated because the input items were too
          # large, or because the server reached the maximum amount of resources
          # allowed for a single API call. For best results, divide the input into
          # smaller batches.
    },
    &quot;extractedText&quot;: &quot;A String&quot;, # If an image was being inspected and the InspectConfig&#x27;s include_quote was
        # set to true, then this field will include all text, if any, that was found
        # in the image.
  }</pre>
</div>

</body></html>