<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="dialogflow_v3beta1.html">Dialogflow API</a> . <a href="dialogflow_v3beta1.projects.html">projects</a> . <a href="dialogflow_v3beta1.projects.locations.html">locations</a> . <a href="dialogflow_v3beta1.projects.locations.agents.html">agents</a> . <a href="dialogflow_v3beta1.projects.locations.agents.flows.html">flows</a> . <a href="dialogflow_v3beta1.projects.locations.agents.flows.pages.html">pages</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#create">create(parent, body=None, languageCode=None, x__xgafv=None)</a></code></p>
<p class="firstline">Creates a page in the specified flow.</p>
<p class="toc_element">
  <code><a href="#delete">delete(name, force=None, x__xgafv=None)</a></code></p>
<p class="firstline">Deletes the specified page.</p>
<p class="toc_element">
  <code><a href="#get">get(name, languageCode=None, x__xgafv=None)</a></code></p>
<p class="firstline">Retrieves the specified page.</p>
<p class="toc_element">
  <code><a href="#list">list(parent, languageCode=None, pageSize=None, pageToken=None, x__xgafv=None)</a></code></p>
<p class="firstline">Returns the list of all pages in the specified flow.</p>
<p class="toc_element">
  <code><a href="#list_next">list_next(previous_request, previous_response)</a></code></p>
<p class="firstline">Retrieves the next page of results.</p>
<p class="toc_element">
  <code><a href="#patch">patch(name, body=None, languageCode=None, updateMask=None, x__xgafv=None)</a></code></p>
<p class="firstline">Updates the specified page.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="create">create(parent, body=None, languageCode=None, x__xgafv=None)</code>
  <pre>Creates a page in the specified flow.

Args:
  parent: string, Required. The flow to create a page for. Format: `projects//locations//agents//flows/`. (required)
  body: object, The request body.
    The object takes the form of:

{ # A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page).
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the page, unique within the agent.
  &quot;entryFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the session is entering the page.
    &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
      { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        &quot;cases&quot;: [ # A list of cascading if-else conditions.
          { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
            &quot;caseContent&quot;: [ # A list of case content.
              { # The list of messages or conditional cases to activate for this case.
                &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                  &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                    &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                  },
                  &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                  },
                  &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                    &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                  },
                  &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                    &quot;segments&quot;: [ # Segments this audio response is composed of.
                      { # Represents one segment of audio.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                        &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                        &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                      },
                    ],
                  },
                  &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                    &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                  },
                  &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                  &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                  },
                  &quot;text&quot;: { # The text response message. # Returns a text response.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;text&quot;: [ # Required. A collection of text responses.
                      &quot;A String&quot;,
                    ],
                  },
                },
              },
            ],
            &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
          },
        ],
      },
    ],
    &quot;messages&quot;: [ # The list of rich message responses to present to the user.
      { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
        },
        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
        },
        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
        },
        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
          &quot;segments&quot;: [ # Segments this audio response is composed of.
            { # Represents one segment of audio.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
            },
          ],
        },
        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
        },
        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        },
        &quot;text&quot;: { # The text response message. # Returns a text response.
          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
          &quot;text&quot;: [ # Required. A collection of text responses.
            &quot;A String&quot;,
          ],
        },
      },
    ],
    &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
      { # Setting a parameter value.
        &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
        &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
      },
    ],
    &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
    &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
  },
  &quot;eventHandlers&quot;: [ # Handlers associated with the page to handle events such as webhook errors, no match or no input.
    { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
      &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
      &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
      &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
      &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
      &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
            &quot;cases&quot;: [ # A list of cascading if-else conditions.
              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                &quot;caseContent&quot;: [ # A list of case content.
                  { # The list of messages or conditional cases to activate for this case.
                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  },
                ],
                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
              },
            ],
          },
        ],
        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
            },
            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
              &quot;segments&quot;: [ # Segments this audio response is composed of.
                { # Represents one segment of audio.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                },
              ],
            },
            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
            },
            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
            },
            &quot;text&quot;: { # The text response message. # Returns a text response.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text responses.
                &quot;A String&quot;,
              ],
            },
          },
        ],
        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
          { # Setting a parameter value.
            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
          },
        ],
        &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
      },
    },
  ],
  &quot;form&quot;: { # A form is a data model that groups related parameters that can be collected from the user. The process in which the agent prompts the user and collects parameter values from the user is called form filling. A form can be added to a page. When form filling is done, the filled parameters will be written to the session. # The form associated with the page, used for collecting parameters relevant to the page.
    &quot;parameters&quot;: [ # Parameters to collect from the user.
      { # Represents a form parameter.
        &quot;defaultValue&quot;: &quot;&quot;, # The default value of an optional parameter. If the parameter is required, the default value will be ignored.
        &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the parameter, unique within the form.
        &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
        &quot;fillBehavior&quot;: { # Configuration for how the filling of a parameter should be handled. # Required. Defines fill behavior for the parameter.
          &quot;initialPromptFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # Required. The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text responses.
                              &quot;A String&quot;,
                            ],
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text responses.
                    &quot;A String&quot;,
                  ],
                },
              },
            ],
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
          &quot;repromptEventHandlers&quot;: [ # The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are: * `sys.no-match-`, where N can be from 1 to 6 * `sys.no-match-default` * `sys.no-input-`, where N can be from 1 to 6 * `sys.no-input-default` * `sys.invalid-parameter` `initial_prompt_fulfillment` provides the first prompt for the parameter. If the user&#x27;s response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the `sys.no-match-1`/`sys.no-input-1` handler (if defined) will be called to provide a prompt. The `sys.no-match-2`/`sys.no-input-2` handler (if defined) will respond to the next no-match/no-input event, and so on. A `sys.no-match-default` or `sys.no-input-default` handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed. A `sys.invalid-parameter` handler can be defined to handle the case where the parameter values have been `invalidated` by webhook. For example, if the user&#x27;s response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the `sys.invalid-parameter` handler (if defined) will be called to provide a prompt. If the event handler for the corresponding event can&#x27;t be found on the parameter, `initial_prompt_fulfillment` will be re-prompted.
            { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
              &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
              &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
              &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
              &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
              &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                  { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                    &quot;cases&quot;: [ # A list of cascading if-else conditions.
                      { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                        &quot;caseContent&quot;: [ # A list of case content.
                          { # The list of messages or conditional cases to activate for this case.
                            &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                            &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          },
                        ],
                        &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                      },
                    ],
                  },
                ],
                &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                  { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                    },
                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                        { # Represents one segment of audio.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                        },
                      ],
                    },
                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                    },
                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                    },
                    &quot;text&quot;: { # The text response message. # Returns a text response.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;text&quot;: [ # Required. A collection of text responses.
                        &quot;A String&quot;,
                      ],
                    },
                  },
                ],
                &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                  { # Setting a parameter value.
                    &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                    &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                  },
                ],
                &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
                &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
              },
            },
          ],
        },
        &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
        &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
        &quot;required&quot;: True or False, # Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them. Required parameters must be filled before form filling concludes.
      },
    ],
  },
  &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the page. Required for the Pages.UpdatePage method. Pages.CreatePage populates the name automatically. Format: `projects//locations//agents//flows//pages/`.
  &quot;transitionRouteGroups&quot;: [ # Ordered list of `TransitionRouteGroups` associated with the page. Transition route groups must be unique within a page. * If multiple transition routes within a page scope refer to the same intent, then the precedence order is: page&#x27;s transition route -&gt; page&#x27;s transition route group -&gt; flow&#x27;s transition routes. * If multiple transition route groups within a page contain the same intent, then the first group in the ordered list takes precedence. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
    &quot;A String&quot;,
  ],
  &quot;transitionRoutes&quot;: [ # A list of transitions for the transition rules of this page. They route the conversation to another page in the same flow, or another flow. When we are in a certain page, the TransitionRoutes are evalauted in the following order: * TransitionRoutes defined in the page with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in flow with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in the page with only condition specified. * TransitionRoutes defined in the transition route groups with only condition specified.
    { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
      &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
      &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
      &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
      &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
      &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
      &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
            &quot;cases&quot;: [ # A list of cascading if-else conditions.
              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                &quot;caseContent&quot;: [ # A list of case content.
                  { # The list of messages or conditional cases to activate for this case.
                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  },
                ],
                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
              },
            ],
          },
        ],
        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
            },
            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
              &quot;segments&quot;: [ # Segments this audio response is composed of.
                { # Represents one segment of audio.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                },
              ],
            },
            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
            },
            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
            },
            &quot;text&quot;: { # The text response message. # Returns a text response.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text responses.
                &quot;A String&quot;,
              ],
            },
          },
        ],
        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
          { # Setting a parameter value.
            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
          },
        ],
        &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
      },
    },
  ],
}

  languageCode: string, The language of the following fields in `page`: * `Page.entry_fulfillment.messages` * `Page.form.parameters.fill_behavior.initial_prompt_fulfillment.messages` * `Page.form.parameters.fill_behavior.reprompt_event_handlers.messages` * `Page.transition_routes.trigger_fulfillment.messages` * `Page.transition_route_groups.transition_routes.trigger_fulfillment.messages` If not specified, the agent&#x27;s default language is used. [Many languages](https://cloud.google.com/dialogflow/cx/docs/reference/language) are supported. Note: languages must be enabled in the agent before they can be used.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page).
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the page, unique within the agent.
  &quot;entryFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the session is entering the page.
    &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
      { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        &quot;cases&quot;: [ # A list of cascading if-else conditions.
          { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
            &quot;caseContent&quot;: [ # A list of case content.
              { # The list of messages or conditional cases to activate for this case.
                &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                  &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                    &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                  },
                  &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                  },
                  &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                    &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                  },
                  &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                    &quot;segments&quot;: [ # Segments this audio response is composed of.
                      { # Represents one segment of audio.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                        &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                        &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                      },
                    ],
                  },
                  &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                    &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                  },
                  &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                  &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                  },
                  &quot;text&quot;: { # The text response message. # Returns a text response.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;text&quot;: [ # Required. A collection of text responses.
                      &quot;A String&quot;,
                    ],
                  },
                },
              },
            ],
            &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
          },
        ],
      },
    ],
    &quot;messages&quot;: [ # The list of rich message responses to present to the user.
      { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
        },
        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
        },
        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
        },
        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
          &quot;segments&quot;: [ # Segments this audio response is composed of.
            { # Represents one segment of audio.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
            },
          ],
        },
        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
        },
        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        },
        &quot;text&quot;: { # The text response message. # Returns a text response.
          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
          &quot;text&quot;: [ # Required. A collection of text responses.
            &quot;A String&quot;,
          ],
        },
      },
    ],
    &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
      { # Setting a parameter value.
        &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
        &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
      },
    ],
    &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
    &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
  },
  &quot;eventHandlers&quot;: [ # Handlers associated with the page to handle events such as webhook errors, no match or no input.
    { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
      &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
      &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
      &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
      &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
      &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
            &quot;cases&quot;: [ # A list of cascading if-else conditions.
              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                &quot;caseContent&quot;: [ # A list of case content.
                  { # The list of messages or conditional cases to activate for this case.
                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  },
                ],
                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
              },
            ],
          },
        ],
        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
            },
            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
              &quot;segments&quot;: [ # Segments this audio response is composed of.
                { # Represents one segment of audio.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                },
              ],
            },
            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
            },
            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
            },
            &quot;text&quot;: { # The text response message. # Returns a text response.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text responses.
                &quot;A String&quot;,
              ],
            },
          },
        ],
        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
          { # Setting a parameter value.
            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
          },
        ],
        &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
      },
    },
  ],
  &quot;form&quot;: { # A form is a data model that groups related parameters that can be collected from the user. The process in which the agent prompts the user and collects parameter values from the user is called form filling. A form can be added to a page. When form filling is done, the filled parameters will be written to the session. # The form associated with the page, used for collecting parameters relevant to the page.
    &quot;parameters&quot;: [ # Parameters to collect from the user.
      { # Represents a form parameter.
        &quot;defaultValue&quot;: &quot;&quot;, # The default value of an optional parameter. If the parameter is required, the default value will be ignored.
        &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the parameter, unique within the form.
        &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
        &quot;fillBehavior&quot;: { # Configuration for how the filling of a parameter should be handled. # Required. Defines fill behavior for the parameter.
          &quot;initialPromptFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # Required. The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text responses.
                              &quot;A String&quot;,
                            ],
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text responses.
                    &quot;A String&quot;,
                  ],
                },
              },
            ],
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
          &quot;repromptEventHandlers&quot;: [ # The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are: * `sys.no-match-`, where N can be from 1 to 6 * `sys.no-match-default` * `sys.no-input-`, where N can be from 1 to 6 * `sys.no-input-default` * `sys.invalid-parameter` `initial_prompt_fulfillment` provides the first prompt for the parameter. If the user&#x27;s response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the `sys.no-match-1`/`sys.no-input-1` handler (if defined) will be called to provide a prompt. The `sys.no-match-2`/`sys.no-input-2` handler (if defined) will respond to the next no-match/no-input event, and so on. A `sys.no-match-default` or `sys.no-input-default` handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed. A `sys.invalid-parameter` handler can be defined to handle the case where the parameter values have been `invalidated` by webhook. For example, if the user&#x27;s response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the `sys.invalid-parameter` handler (if defined) will be called to provide a prompt. If the event handler for the corresponding event can&#x27;t be found on the parameter, `initial_prompt_fulfillment` will be re-prompted.
            { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
              &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
              &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
              &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
              &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
              &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                  { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                    &quot;cases&quot;: [ # A list of cascading if-else conditions.
                      { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                        &quot;caseContent&quot;: [ # A list of case content.
                          { # The list of messages or conditional cases to activate for this case.
                            &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                            &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          },
                        ],
                        &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                      },
                    ],
                  },
                ],
                &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                  { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                    },
                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                        { # Represents one segment of audio.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                        },
                      ],
                    },
                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                    },
                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                    },
                    &quot;text&quot;: { # The text response message. # Returns a text response.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;text&quot;: [ # Required. A collection of text responses.
                        &quot;A String&quot;,
                      ],
                    },
                  },
                ],
                &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                  { # Setting a parameter value.
                    &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                    &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                  },
                ],
                &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
                &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
              },
            },
          ],
        },
        &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
        &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
        &quot;required&quot;: True or False, # Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them. Required parameters must be filled before form filling concludes.
      },
    ],
  },
  &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the page. Required for the Pages.UpdatePage method. Pages.CreatePage populates the name automatically. Format: `projects//locations//agents//flows//pages/`.
  &quot;transitionRouteGroups&quot;: [ # Ordered list of `TransitionRouteGroups` associated with the page. Transition route groups must be unique within a page. * If multiple transition routes within a page scope refer to the same intent, then the precedence order is: page&#x27;s transition route -&gt; page&#x27;s transition route group -&gt; flow&#x27;s transition routes. * If multiple transition route groups within a page contain the same intent, then the first group in the ordered list takes precedence. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
    &quot;A String&quot;,
  ],
  &quot;transitionRoutes&quot;: [ # A list of transitions for the transition rules of this page. They route the conversation to another page in the same flow, or another flow. When we are in a certain page, the TransitionRoutes are evalauted in the following order: * TransitionRoutes defined in the page with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in flow with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in the page with only condition specified. * TransitionRoutes defined in the transition route groups with only condition specified.
    { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
      &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
      &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
      &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
      &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
      &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
      &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
            &quot;cases&quot;: [ # A list of cascading if-else conditions.
              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                &quot;caseContent&quot;: [ # A list of case content.
                  { # The list of messages or conditional cases to activate for this case.
                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  },
                ],
                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
              },
            ],
          },
        ],
        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
            },
            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
              &quot;segments&quot;: [ # Segments this audio response is composed of.
                { # Represents one segment of audio.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                },
              ],
            },
            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
            },
            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
            },
            &quot;text&quot;: { # The text response message. # Returns a text response.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text responses.
                &quot;A String&quot;,
              ],
            },
          },
        ],
        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
          { # Setting a parameter value.
            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
          },
        ],
        &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
      },
    },
  ],
}</pre>
</div>

<div class="method">
    <code class="details" id="delete">delete(name, force=None, x__xgafv=None)</code>
  <pre>Deletes the specified page.

Args:
  name: string, Required. The name of the page to delete. Format: `projects//locations//agents//Flows//pages/`. (required)
  force: boolean, This field has no effect for pages with no incoming transitions. For pages with incoming transitions: * If `force` is set to false, an error will be returned with message indicating the incoming transitions. * If `force` is set to true, Dialogflow will remove the page, as well as any transitions to the page (i.e. Target page in event handlers or Target page in transition routes that point to this page will be cleared).
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } The JSON representation for `Empty` is empty JSON object `{}`.
}</pre>
</div>

<div class="method">
    <code class="details" id="get">get(name, languageCode=None, x__xgafv=None)</code>
  <pre>Retrieves the specified page.

Args:
  name: string, Required. The name of the page. Format: `projects//locations//agents//flows//pages/`. (required)
  languageCode: string, The language to retrieve the page for. The following fields are language dependent: * `Page.entry_fulfillment.messages` * `Page.form.parameters.fill_behavior.initial_prompt_fulfillment.messages` * `Page.form.parameters.fill_behavior.reprompt_event_handlers.messages` * `Page.transition_routes.trigger_fulfillment.messages` * `Page.transition_route_groups.transition_routes.trigger_fulfillment.messages` If not specified, the agent&#x27;s default language is used. [Many languages](https://cloud.google.com/dialogflow/cx/docs/reference/language) are supported. Note: languages must be enabled in the agent before they can be used.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page).
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the page, unique within the agent.
  &quot;entryFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the session is entering the page.
    &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
      { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        &quot;cases&quot;: [ # A list of cascading if-else conditions.
          { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
            &quot;caseContent&quot;: [ # A list of case content.
              { # The list of messages or conditional cases to activate for this case.
                &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                  &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                    &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                  },
                  &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                  },
                  &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                    &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                  },
                  &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                    &quot;segments&quot;: [ # Segments this audio response is composed of.
                      { # Represents one segment of audio.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                        &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                        &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                      },
                    ],
                  },
                  &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                    &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                  },
                  &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                  &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                  },
                  &quot;text&quot;: { # The text response message. # Returns a text response.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;text&quot;: [ # Required. A collection of text responses.
                      &quot;A String&quot;,
                    ],
                  },
                },
              },
            ],
            &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
          },
        ],
      },
    ],
    &quot;messages&quot;: [ # The list of rich message responses to present to the user.
      { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
        },
        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
        },
        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
        },
        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
          &quot;segments&quot;: [ # Segments this audio response is composed of.
            { # Represents one segment of audio.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
            },
          ],
        },
        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
        },
        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        },
        &quot;text&quot;: { # The text response message. # Returns a text response.
          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
          &quot;text&quot;: [ # Required. A collection of text responses.
            &quot;A String&quot;,
          ],
        },
      },
    ],
    &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
      { # Setting a parameter value.
        &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
        &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
      },
    ],
    &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
    &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
  },
  &quot;eventHandlers&quot;: [ # Handlers associated with the page to handle events such as webhook errors, no match or no input.
    { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
      &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
      &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
      &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
      &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
      &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
            &quot;cases&quot;: [ # A list of cascading if-else conditions.
              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                &quot;caseContent&quot;: [ # A list of case content.
                  { # The list of messages or conditional cases to activate for this case.
                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  },
                ],
                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
              },
            ],
          },
        ],
        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
            },
            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
              &quot;segments&quot;: [ # Segments this audio response is composed of.
                { # Represents one segment of audio.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                },
              ],
            },
            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
            },
            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
            },
            &quot;text&quot;: { # The text response message. # Returns a text response.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text responses.
                &quot;A String&quot;,
              ],
            },
          },
        ],
        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
          { # Setting a parameter value.
            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
          },
        ],
        &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
      },
    },
  ],
  &quot;form&quot;: { # A form is a data model that groups related parameters that can be collected from the user. The process in which the agent prompts the user and collects parameter values from the user is called form filling. A form can be added to a page. When form filling is done, the filled parameters will be written to the session. # The form associated with the page, used for collecting parameters relevant to the page.
    &quot;parameters&quot;: [ # Parameters to collect from the user.
      { # Represents a form parameter.
        &quot;defaultValue&quot;: &quot;&quot;, # The default value of an optional parameter. If the parameter is required, the default value will be ignored.
        &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the parameter, unique within the form.
        &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
        &quot;fillBehavior&quot;: { # Configuration for how the filling of a parameter should be handled. # Required. Defines fill behavior for the parameter.
          &quot;initialPromptFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # Required. The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text responses.
                              &quot;A String&quot;,
                            ],
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text responses.
                    &quot;A String&quot;,
                  ],
                },
              },
            ],
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
          &quot;repromptEventHandlers&quot;: [ # The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are: * `sys.no-match-`, where N can be from 1 to 6 * `sys.no-match-default` * `sys.no-input-`, where N can be from 1 to 6 * `sys.no-input-default` * `sys.invalid-parameter` `initial_prompt_fulfillment` provides the first prompt for the parameter. If the user&#x27;s response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the `sys.no-match-1`/`sys.no-input-1` handler (if defined) will be called to provide a prompt. The `sys.no-match-2`/`sys.no-input-2` handler (if defined) will respond to the next no-match/no-input event, and so on. A `sys.no-match-default` or `sys.no-input-default` handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed. A `sys.invalid-parameter` handler can be defined to handle the case where the parameter values have been `invalidated` by webhook. For example, if the user&#x27;s response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the `sys.invalid-parameter` handler (if defined) will be called to provide a prompt. If the event handler for the corresponding event can&#x27;t be found on the parameter, `initial_prompt_fulfillment` will be re-prompted.
            { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
              &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
              &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
              &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
              &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
              &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                  { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                    &quot;cases&quot;: [ # A list of cascading if-else conditions.
                      { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                        &quot;caseContent&quot;: [ # A list of case content.
                          { # The list of messages or conditional cases to activate for this case.
                            &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                            &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          },
                        ],
                        &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                      },
                    ],
                  },
                ],
                &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                  { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                    },
                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                        { # Represents one segment of audio.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                        },
                      ],
                    },
                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                    },
                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                    },
                    &quot;text&quot;: { # The text response message. # Returns a text response.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;text&quot;: [ # Required. A collection of text responses.
                        &quot;A String&quot;,
                      ],
                    },
                  },
                ],
                &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                  { # Setting a parameter value.
                    &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                    &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                  },
                ],
                &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
                &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
              },
            },
          ],
        },
        &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
        &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
        &quot;required&quot;: True or False, # Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them. Required parameters must be filled before form filling concludes.
      },
    ],
  },
  &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the page. Required for the Pages.UpdatePage method. Pages.CreatePage populates the name automatically. Format: `projects//locations//agents//flows//pages/`.
  &quot;transitionRouteGroups&quot;: [ # Ordered list of `TransitionRouteGroups` associated with the page. Transition route groups must be unique within a page. * If multiple transition routes within a page scope refer to the same intent, then the precedence order is: page&#x27;s transition route -&gt; page&#x27;s transition route group -&gt; flow&#x27;s transition routes. * If multiple transition route groups within a page contain the same intent, then the first group in the ordered list takes precedence. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
    &quot;A String&quot;,
  ],
  &quot;transitionRoutes&quot;: [ # A list of transitions for the transition rules of this page. They route the conversation to another page in the same flow, or another flow. When we are in a certain page, the TransitionRoutes are evalauted in the following order: * TransitionRoutes defined in the page with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in flow with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in the page with only condition specified. * TransitionRoutes defined in the transition route groups with only condition specified.
    { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
      &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
      &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
      &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
      &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
      &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
      &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
            &quot;cases&quot;: [ # A list of cascading if-else conditions.
              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                &quot;caseContent&quot;: [ # A list of case content.
                  { # The list of messages or conditional cases to activate for this case.
                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  },
                ],
                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
              },
            ],
          },
        ],
        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
            },
            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
              &quot;segments&quot;: [ # Segments this audio response is composed of.
                { # Represents one segment of audio.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                },
              ],
            },
            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
            },
            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
            },
            &quot;text&quot;: { # The text response message. # Returns a text response.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text responses.
                &quot;A String&quot;,
              ],
            },
          },
        ],
        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
          { # Setting a parameter value.
            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
          },
        ],
        &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
      },
    },
  ],
}</pre>
</div>

<div class="method">
    <code class="details" id="list">list(parent, languageCode=None, pageSize=None, pageToken=None, x__xgafv=None)</code>
  <pre>Returns the list of all pages in the specified flow.

Args:
  parent: string, Required. The flow to list all pages for. Format: `projects//locations//agents//flows/`. (required)
  languageCode: string, The language to list pages for. The following fields are language dependent: * `Page.entry_fulfillment.messages` * `Page.form.parameters.fill_behavior.initial_prompt_fulfillment.messages` * `Page.form.parameters.fill_behavior.reprompt_event_handlers.messages` * `Page.transition_routes.trigger_fulfillment.messages` * `Page.transition_route_groups.transition_routes.trigger_fulfillment.messages` If not specified, the agent&#x27;s default language is used. [Many languages](https://cloud.google.com/dialogflow/cx/docs/reference/language) are supported. Note: languages must be enabled in the agent before they can be used.
  pageSize: integer, The maximum number of items to return in a single page. By default 100 and at most 1000.
  pageToken: string, The next_page_token value returned from a previous list request.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The response message for Pages.ListPages.
  &quot;nextPageToken&quot;: &quot;A String&quot;, # Token to retrieve the next page of results, or empty if there are no more results in the list.
  &quot;pages&quot;: [ # The list of pages. There will be a maximum number of items returned based on the page_size field in the request.
    { # A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page).
      &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the page, unique within the agent.
      &quot;entryFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the session is entering the page.
        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
            &quot;cases&quot;: [ # A list of cascading if-else conditions.
              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                &quot;caseContent&quot;: [ # A list of case content.
                  { # The list of messages or conditional cases to activate for this case.
                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  },
                ],
                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
              },
            ],
          },
        ],
        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
            },
            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
              &quot;segments&quot;: [ # Segments this audio response is composed of.
                { # Represents one segment of audio.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                },
              ],
            },
            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
            },
            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
            },
            &quot;text&quot;: { # The text response message. # Returns a text response.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text responses.
                &quot;A String&quot;,
              ],
            },
          },
        ],
        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
          { # Setting a parameter value.
            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
          },
        ],
        &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
      },
      &quot;eventHandlers&quot;: [ # Handlers associated with the page to handle events such as webhook errors, no match or no input.
        { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
          &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
          &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
          &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
          &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
          &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text responses.
                              &quot;A String&quot;,
                            ],
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text responses.
                    &quot;A String&quot;,
                  ],
                },
              },
            ],
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
        },
      ],
      &quot;form&quot;: { # A form is a data model that groups related parameters that can be collected from the user. The process in which the agent prompts the user and collects parameter values from the user is called form filling. A form can be added to a page. When form filling is done, the filled parameters will be written to the session. # The form associated with the page, used for collecting parameters relevant to the page.
        &quot;parameters&quot;: [ # Parameters to collect from the user.
          { # Represents a form parameter.
            &quot;defaultValue&quot;: &quot;&quot;, # The default value of an optional parameter. If the parameter is required, the default value will be ignored.
            &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the parameter, unique within the form.
            &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
            &quot;fillBehavior&quot;: { # Configuration for how the filling of a parameter should be handled. # Required. Defines fill behavior for the parameter.
              &quot;initialPromptFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # Required. The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
                &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                  { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                    &quot;cases&quot;: [ # A list of cascading if-else conditions.
                      { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                        &quot;caseContent&quot;: [ # A list of case content.
                          { # The list of messages or conditional cases to activate for this case.
                            &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                            &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          },
                        ],
                        &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                      },
                    ],
                  },
                ],
                &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                  { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                    },
                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                        { # Represents one segment of audio.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                        },
                      ],
                    },
                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                    },
                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                    },
                    &quot;text&quot;: { # The text response message. # Returns a text response.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;text&quot;: [ # Required. A collection of text responses.
                        &quot;A String&quot;,
                      ],
                    },
                  },
                ],
                &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                  { # Setting a parameter value.
                    &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                    &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                  },
                ],
                &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
                &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
              },
              &quot;repromptEventHandlers&quot;: [ # The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are: * `sys.no-match-`, where N can be from 1 to 6 * `sys.no-match-default` * `sys.no-input-`, where N can be from 1 to 6 * `sys.no-input-default` * `sys.invalid-parameter` `initial_prompt_fulfillment` provides the first prompt for the parameter. If the user&#x27;s response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the `sys.no-match-1`/`sys.no-input-1` handler (if defined) will be called to provide a prompt. The `sys.no-match-2`/`sys.no-input-2` handler (if defined) will respond to the next no-match/no-input event, and so on. A `sys.no-match-default` or `sys.no-input-default` handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed. A `sys.invalid-parameter` handler can be defined to handle the case where the parameter values have been `invalidated` by webhook. For example, if the user&#x27;s response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the `sys.invalid-parameter` handler (if defined) will be called to provide a prompt. If the event handler for the corresponding event can&#x27;t be found on the parameter, `initial_prompt_fulfillment` will be re-prompted.
                { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                  &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                  &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                  &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                  &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                  &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                    &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                      { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                        &quot;cases&quot;: [ # A list of cascading if-else conditions.
                          { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                            &quot;caseContent&quot;: [ # A list of case content.
                              { # The list of messages or conditional cases to activate for this case.
                                &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                                &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                  &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                    &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                  },
                                  &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                  },
                                  &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                    &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                  },
                                  &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                    &quot;segments&quot;: [ # Segments this audio response is composed of.
                                      { # Represents one segment of audio.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                        &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                        &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                      },
                                    ],
                                  },
                                  &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                    &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                  },
                                  &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                  &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                  },
                                  &quot;text&quot;: { # The text response message. # Returns a text response.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;text&quot;: [ # Required. A collection of text responses.
                                      &quot;A String&quot;,
                                    ],
                                  },
                                },
                              },
                            ],
                            &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                          },
                        ],
                      },
                    ],
                    &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                      { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                        },
                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                            { # Represents one segment of audio.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                            },
                          ],
                        },
                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                        },
                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                        },
                        &quot;text&quot;: { # The text response message. # Returns a text response.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;text&quot;: [ # Required. A collection of text responses.
                            &quot;A String&quot;,
                          ],
                        },
                      },
                    ],
                    &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                      { # Setting a parameter value.
                        &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                        &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                      },
                    ],
                    &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
                    &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                  },
                },
              ],
            },
            &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
            &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
            &quot;required&quot;: True or False, # Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them. Required parameters must be filled before form filling concludes.
          },
        ],
      },
      &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the page. Required for the Pages.UpdatePage method. Pages.CreatePage populates the name automatically. Format: `projects//locations//agents//flows//pages/`.
      &quot;transitionRouteGroups&quot;: [ # Ordered list of `TransitionRouteGroups` associated with the page. Transition route groups must be unique within a page. * If multiple transition routes within a page scope refer to the same intent, then the precedence order is: page&#x27;s transition route -&gt; page&#x27;s transition route group -&gt; flow&#x27;s transition routes. * If multiple transition route groups within a page contain the same intent, then the first group in the ordered list takes precedence. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
        &quot;A String&quot;,
      ],
      &quot;transitionRoutes&quot;: [ # A list of transitions for the transition rules of this page. They route the conversation to another page in the same flow, or another flow. When we are in a certain page, the TransitionRoutes are evalauted in the following order: * TransitionRoutes defined in the page with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in flow with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in the page with only condition specified. * TransitionRoutes defined in the transition route groups with only condition specified.
        { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
          &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
          &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
          &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
          &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
          &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
          &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text responses.
                              &quot;A String&quot;,
                            ],
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text responses.
                    &quot;A String&quot;,
                  ],
                },
              },
            ],
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
        },
      ],
    },
  ],
}</pre>
</div>

<div class="method">
    <code class="details" id="list_next">list_next(previous_request, previous_response)</code>
  <pre>Retrieves the next page of results.

Args:
  previous_request: The request for the previous page. (required)
  previous_response: The response from the request for the previous page. (required)

Returns:
  A request object that you can call &#x27;execute()&#x27; on to request the next
  page. Returns None if there are no more items in the collection.
    </pre>
</div>

<div class="method">
    <code class="details" id="patch">patch(name, body=None, languageCode=None, updateMask=None, x__xgafv=None)</code>
  <pre>Updates the specified page.

Args:
  name: string, The unique identifier of the page. Required for the Pages.UpdatePage method. Pages.CreatePage populates the name automatically. Format: `projects//locations//agents//flows//pages/`. (required)
  body: object, The request body.
    The object takes the form of:

{ # A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page).
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the page, unique within the agent.
  &quot;entryFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the session is entering the page.
    &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
      { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        &quot;cases&quot;: [ # A list of cascading if-else conditions.
          { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
            &quot;caseContent&quot;: [ # A list of case content.
              { # The list of messages or conditional cases to activate for this case.
                &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                  &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                    &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                  },
                  &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                  },
                  &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                    &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                  },
                  &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                    &quot;segments&quot;: [ # Segments this audio response is composed of.
                      { # Represents one segment of audio.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                        &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                        &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                      },
                    ],
                  },
                  &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                    &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                  },
                  &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                  &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                  },
                  &quot;text&quot;: { # The text response message. # Returns a text response.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;text&quot;: [ # Required. A collection of text responses.
                      &quot;A String&quot;,
                    ],
                  },
                },
              },
            ],
            &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
          },
        ],
      },
    ],
    &quot;messages&quot;: [ # The list of rich message responses to present to the user.
      { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
        },
        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
        },
        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
        },
        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
          &quot;segments&quot;: [ # Segments this audio response is composed of.
            { # Represents one segment of audio.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
            },
          ],
        },
        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
        },
        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        },
        &quot;text&quot;: { # The text response message. # Returns a text response.
          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
          &quot;text&quot;: [ # Required. A collection of text responses.
            &quot;A String&quot;,
          ],
        },
      },
    ],
    &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
      { # Setting a parameter value.
        &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
        &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
      },
    ],
    &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
    &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
  },
  &quot;eventHandlers&quot;: [ # Handlers associated with the page to handle events such as webhook errors, no match or no input.
    { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
      &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
      &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
      &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
      &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
      &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
            &quot;cases&quot;: [ # A list of cascading if-else conditions.
              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                &quot;caseContent&quot;: [ # A list of case content.
                  { # The list of messages or conditional cases to activate for this case.
                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  },
                ],
                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
              },
            ],
          },
        ],
        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
            },
            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
              &quot;segments&quot;: [ # Segments this audio response is composed of.
                { # Represents one segment of audio.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                },
              ],
            },
            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
            },
            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
            },
            &quot;text&quot;: { # The text response message. # Returns a text response.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text responses.
                &quot;A String&quot;,
              ],
            },
          },
        ],
        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
          { # Setting a parameter value.
            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
          },
        ],
        &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
      },
    },
  ],
  &quot;form&quot;: { # A form is a data model that groups related parameters that can be collected from the user. The process in which the agent prompts the user and collects parameter values from the user is called form filling. A form can be added to a page. When form filling is done, the filled parameters will be written to the session. # The form associated with the page, used for collecting parameters relevant to the page.
    &quot;parameters&quot;: [ # Parameters to collect from the user.
      { # Represents a form parameter.
        &quot;defaultValue&quot;: &quot;&quot;, # The default value of an optional parameter. If the parameter is required, the default value will be ignored.
        &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the parameter, unique within the form.
        &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
        &quot;fillBehavior&quot;: { # Configuration for how the filling of a parameter should be handled. # Required. Defines fill behavior for the parameter.
          &quot;initialPromptFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # Required. The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text responses.
                              &quot;A String&quot;,
                            ],
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text responses.
                    &quot;A String&quot;,
                  ],
                },
              },
            ],
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
          &quot;repromptEventHandlers&quot;: [ # The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are: * `sys.no-match-`, where N can be from 1 to 6 * `sys.no-match-default` * `sys.no-input-`, where N can be from 1 to 6 * `sys.no-input-default` * `sys.invalid-parameter` `initial_prompt_fulfillment` provides the first prompt for the parameter. If the user&#x27;s response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the `sys.no-match-1`/`sys.no-input-1` handler (if defined) will be called to provide a prompt. The `sys.no-match-2`/`sys.no-input-2` handler (if defined) will respond to the next no-match/no-input event, and so on. A `sys.no-match-default` or `sys.no-input-default` handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed. A `sys.invalid-parameter` handler can be defined to handle the case where the parameter values have been `invalidated` by webhook. For example, if the user&#x27;s response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the `sys.invalid-parameter` handler (if defined) will be called to provide a prompt. If the event handler for the corresponding event can&#x27;t be found on the parameter, `initial_prompt_fulfillment` will be re-prompted.
            { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
              &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
              &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
              &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
              &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
              &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                  { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                    &quot;cases&quot;: [ # A list of cascading if-else conditions.
                      { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                        &quot;caseContent&quot;: [ # A list of case content.
                          { # The list of messages or conditional cases to activate for this case.
                            &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                            &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          },
                        ],
                        &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                      },
                    ],
                  },
                ],
                &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                  { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                    },
                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                        { # Represents one segment of audio.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                        },
                      ],
                    },
                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                    },
                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                    },
                    &quot;text&quot;: { # The text response message. # Returns a text response.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;text&quot;: [ # Required. A collection of text responses.
                        &quot;A String&quot;,
                      ],
                    },
                  },
                ],
                &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                  { # Setting a parameter value.
                    &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                    &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                  },
                ],
                &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
                &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
              },
            },
          ],
        },
        &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
        &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
        &quot;required&quot;: True or False, # Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them. Required parameters must be filled before form filling concludes.
      },
    ],
  },
  &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the page. Required for the Pages.UpdatePage method. Pages.CreatePage populates the name automatically. Format: `projects//locations//agents//flows//pages/`.
  &quot;transitionRouteGroups&quot;: [ # Ordered list of `TransitionRouteGroups` associated with the page. Transition route groups must be unique within a page. * If multiple transition routes within a page scope refer to the same intent, then the precedence order is: page&#x27;s transition route -&gt; page&#x27;s transition route group -&gt; flow&#x27;s transition routes. * If multiple transition route groups within a page contain the same intent, then the first group in the ordered list takes precedence. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
    &quot;A String&quot;,
  ],
  &quot;transitionRoutes&quot;: [ # A list of transitions for the transition rules of this page. They route the conversation to another page in the same flow, or another flow. When we are in a certain page, the TransitionRoutes are evalauted in the following order: * TransitionRoutes defined in the page with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in flow with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in the page with only condition specified. * TransitionRoutes defined in the transition route groups with only condition specified.
    { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
      &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
      &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
      &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
      &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
      &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
      &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
            &quot;cases&quot;: [ # A list of cascading if-else conditions.
              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                &quot;caseContent&quot;: [ # A list of case content.
                  { # The list of messages or conditional cases to activate for this case.
                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  },
                ],
                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
              },
            ],
          },
        ],
        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
            },
            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
              &quot;segments&quot;: [ # Segments this audio response is composed of.
                { # Represents one segment of audio.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                },
              ],
            },
            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
            },
            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
            },
            &quot;text&quot;: { # The text response message. # Returns a text response.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text responses.
                &quot;A String&quot;,
              ],
            },
          },
        ],
        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
          { # Setting a parameter value.
            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
          },
        ],
        &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
      },
    },
  ],
}

  languageCode: string, The language of the following fields in `page`: * `Page.entry_fulfillment.messages` * `Page.form.parameters.fill_behavior.initial_prompt_fulfillment.messages` * `Page.form.parameters.fill_behavior.reprompt_event_handlers.messages` * `Page.transition_routes.trigger_fulfillment.messages` * `Page.transition_route_groups.transition_routes.trigger_fulfillment.messages` If not specified, the agent&#x27;s default language is used. [Many languages](https://cloud.google.com/dialogflow/cx/docs/reference/language) are supported. Note: languages must be enabled in the agent before they can be used.
  updateMask: string, The mask to control which fields get updated. If the mask is not present, all fields will be updated.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page).
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the page, unique within the agent.
  &quot;entryFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the session is entering the page.
    &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
      { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        &quot;cases&quot;: [ # A list of cascading if-else conditions.
          { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
            &quot;caseContent&quot;: [ # A list of case content.
              { # The list of messages or conditional cases to activate for this case.
                &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                  &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                    &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                  },
                  &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                  },
                  &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                    &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                  },
                  &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                    &quot;segments&quot;: [ # Segments this audio response is composed of.
                      { # Represents one segment of audio.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                        &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                        &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                      },
                    ],
                  },
                  &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                    &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                  },
                  &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                  &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                  },
                  &quot;text&quot;: { # The text response message. # Returns a text response.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;text&quot;: [ # Required. A collection of text responses.
                      &quot;A String&quot;,
                    ],
                  },
                },
              },
            ],
            &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
          },
        ],
      },
    ],
    &quot;messages&quot;: [ # The list of rich message responses to present to the user.
      { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
        },
        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
        },
        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
        },
        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
          &quot;segments&quot;: [ # Segments this audio response is composed of.
            { # Represents one segment of audio.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
            },
          ],
        },
        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
        },
        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        },
        &quot;text&quot;: { # The text response message. # Returns a text response.
          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
          &quot;text&quot;: [ # Required. A collection of text responses.
            &quot;A String&quot;,
          ],
        },
      },
    ],
    &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
      { # Setting a parameter value.
        &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
        &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
      },
    ],
    &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
    &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
  },
  &quot;eventHandlers&quot;: [ # Handlers associated with the page to handle events such as webhook errors, no match or no input.
    { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
      &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
      &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
      &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
      &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
      &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
            &quot;cases&quot;: [ # A list of cascading if-else conditions.
              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                &quot;caseContent&quot;: [ # A list of case content.
                  { # The list of messages or conditional cases to activate for this case.
                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  },
                ],
                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
              },
            ],
          },
        ],
        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
            },
            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
              &quot;segments&quot;: [ # Segments this audio response is composed of.
                { # Represents one segment of audio.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                },
              ],
            },
            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
            },
            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
            },
            &quot;text&quot;: { # The text response message. # Returns a text response.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text responses.
                &quot;A String&quot;,
              ],
            },
          },
        ],
        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
          { # Setting a parameter value.
            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
          },
        ],
        &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
      },
    },
  ],
  &quot;form&quot;: { # A form is a data model that groups related parameters that can be collected from the user. The process in which the agent prompts the user and collects parameter values from the user is called form filling. A form can be added to a page. When form filling is done, the filled parameters will be written to the session. # The form associated with the page, used for collecting parameters relevant to the page.
    &quot;parameters&quot;: [ # Parameters to collect from the user.
      { # Represents a form parameter.
        &quot;defaultValue&quot;: &quot;&quot;, # The default value of an optional parameter. If the parameter is required, the default value will be ignored.
        &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the parameter, unique within the form.
        &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
        &quot;fillBehavior&quot;: { # Configuration for how the filling of a parameter should be handled. # Required. Defines fill behavior for the parameter.
          &quot;initialPromptFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # Required. The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text responses.
                              &quot;A String&quot;,
                            ],
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text responses.
                    &quot;A String&quot;,
                  ],
                },
              },
            ],
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
          &quot;repromptEventHandlers&quot;: [ # The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are: * `sys.no-match-`, where N can be from 1 to 6 * `sys.no-match-default` * `sys.no-input-`, where N can be from 1 to 6 * `sys.no-input-default` * `sys.invalid-parameter` `initial_prompt_fulfillment` provides the first prompt for the parameter. If the user&#x27;s response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the `sys.no-match-1`/`sys.no-input-1` handler (if defined) will be called to provide a prompt. The `sys.no-match-2`/`sys.no-input-2` handler (if defined) will respond to the next no-match/no-input event, and so on. A `sys.no-match-default` or `sys.no-input-default` handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed. A `sys.invalid-parameter` handler can be defined to handle the case where the parameter values have been `invalidated` by webhook. For example, if the user&#x27;s response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the `sys.invalid-parameter` handler (if defined) will be called to provide a prompt. If the event handler for the corresponding event can&#x27;t be found on the parameter, `initial_prompt_fulfillment` will be re-prompted.
            { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
              &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
              &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
              &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
              &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
              &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                  { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                    &quot;cases&quot;: [ # A list of cascading if-else conditions.
                      { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                        &quot;caseContent&quot;: [ # A list of case content.
                          { # The list of messages or conditional cases to activate for this case.
                            &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                            &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          },
                        ],
                        &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                      },
                    ],
                  },
                ],
                &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                  { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                    },
                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                        { # Represents one segment of audio.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                        },
                      ],
                    },
                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                    },
                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                    },
                    &quot;text&quot;: { # The text response message. # Returns a text response.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;text&quot;: [ # Required. A collection of text responses.
                        &quot;A String&quot;,
                      ],
                    },
                  },
                ],
                &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                  { # Setting a parameter value.
                    &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                    &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                  },
                ],
                &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
                &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
              },
            },
          ],
        },
        &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
        &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
        &quot;required&quot;: True or False, # Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them. Required parameters must be filled before form filling concludes.
      },
    ],
  },
  &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the page. Required for the Pages.UpdatePage method. Pages.CreatePage populates the name automatically. Format: `projects//locations//agents//flows//pages/`.
  &quot;transitionRouteGroups&quot;: [ # Ordered list of `TransitionRouteGroups` associated with the page. Transition route groups must be unique within a page. * If multiple transition routes within a page scope refer to the same intent, then the precedence order is: page&#x27;s transition route -&gt; page&#x27;s transition route group -&gt; flow&#x27;s transition routes. * If multiple transition route groups within a page contain the same intent, then the first group in the ordered list takes precedence. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
    &quot;A String&quot;,
  ],
  &quot;transitionRoutes&quot;: [ # A list of transitions for the transition rules of this page. They route the conversation to another page in the same flow, or another flow. When we are in a certain page, the TransitionRoutes are evalauted in the following order: * TransitionRoutes defined in the page with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in flow with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in the page with only condition specified. * TransitionRoutes defined in the transition route groups with only condition specified.
    { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
      &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
      &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
      &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
      &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
      &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
      &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
            &quot;cases&quot;: [ # A list of cascading if-else conditions.
              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                &quot;caseContent&quot;: [ # A list of case content.
                  { # The list of messages or conditional cases to activate for this case.
                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  },
                ],
                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
              },
            ],
          },
        ],
        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
            },
            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
              &quot;segments&quot;: [ # Segments this audio response is composed of.
                { # Represents one segment of audio.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                },
              ],
            },
            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
            },
            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
            },
            &quot;text&quot;: { # The text response message. # Returns a text response.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text responses.
                &quot;A String&quot;,
              ],
            },
          },
        ],
        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
          { # Setting a parameter value.
            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
          },
        ],
        &quot;tag&quot;: &quot;A String&quot;, # The tag used by the webhook to identify which fulfillment is being called. This field is required if `webhook` is specified.
        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
      },
    },
  ],
}</pre>
</div>

</body></html>