<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="discoveryengine_v1alpha.html">Discovery Engine API</a> . <a href="discoveryengine_v1alpha.locations.html">locations</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#lookupWidgetConfig">lookupWidgetConfig(location, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Gets the Widget Config using the uuid.</p>
<p class="toc_element">
  <code><a href="#widgetCompleteQuery">widgetCompleteQuery(location, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Performs a user input completion with keyword suggestion. Similar to the CompletionService.CompleteQuery method, but a widget version that allows CompleteQuery without API Key. It supports CompleteQuery with or without JWT token.</p>
<p class="toc_element">
  <code><a href="#widgetConverseConversation">widgetConverseConversation(location, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Converse a conversation with Widget.</p>
<p class="toc_element">
  <code><a href="#widgetSearch">widgetSearch(location, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Performs a search. Similar to the SearchService.Search method, but a widget version that allows search without API Key. It supports search with or without JWT token.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="lookupWidgetConfig">lookupWidgetConfig(location, body=None, x__xgafv=None)</code>
  <pre>Gets the Widget Config using the uuid.

Args:
  location: string, Required. The location resource where lookup widget will be performed. Format: `locations/{location}` (required)
  body: object, The request body.
    The object takes the form of:

{ # Request message for WidgetService.LookupWidgetConfig method.
  &quot;widgetConfigId&quot;: &quot;A String&quot;, # Required. The UUID of the Widget Config.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response message for WidgetService.LookupWidgetConfig method.
  &quot;anonymousWidgetConfig&quot;: { # WidgetConfig captures configs at the Widget level. # The Anonymous Widget Config associated with the UUID.
    &quot;allowPublicAccess&quot;: True or False, # Whether allow no-auth integration with widget. If set true, public access to search or other solutions from widget is allowed without authenication token provided by customer hosted backend server.
    &quot;allowlistedDomains&quot;: [ # Allowlisted domains that can load this widget.
      &quot;A String&quot;,
    ],
    &quot;collectionComponents&quot;: [ # Output only. Collection components that lists all collections and child data stores associated with the widget config, those data sources can be used for filtering in widget service APIs, users can return results that from selected data sources.
      { # Read-only collection component that contains data store collections fields that may be used for filtering
        &quot;dataStoreComponents&quot;: [ # For the data store collection, list of the children data stores.
          { # Read-only data store component that contains data stores fields that may be used for filtering, it&#x27;s the child of `CollectionComponent`.
            &quot;displayName&quot;: &quot;A String&quot;, # The display name of the data store.
            &quot;id&quot;: &quot;A String&quot;, # Output only. the identifier of the data store, used for widget service. For now it refers to data_store_id, in the future we will migrate the field to encrypted data store name UUID.
            &quot;name&quot;: &quot;A String&quot;, # The name of the data store. It should be data store resource name Format: `projects/{project_number}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`. For APIs under WidgetService, such as LookUpWidgetConfig, the project number and location part is erased in this field.
          },
        ],
        &quot;displayName&quot;: &quot;A String&quot;, # The display name of the collection.
        &quot;id&quot;: &quot;A String&quot;, # Output only. the identifier of the collection, used for widget service. For now it refers to collection_id, in the future we will migrate the field to encrypted collection name UUID.
        &quot;name&quot;: &quot;A String&quot;, # The name of the collection. It should be collection resource name. Format: `projects/{project_number}/locations/{location}/collections/{collection_id}`. For APIs under WidgetService, such as LookUpWidgetConfig, the project number and location part is erased in this field.
      },
    ],
    &quot;configId&quot;: &quot;A String&quot;, # Output only. Unique obfuscated identifier of a WidgetConfig.
    &quot;contentSearchSpec&quot;: { # A specification for configuring the behavior of content search. # The content search spec that configs the desired behavior of content search.
      &quot;chunkSpec&quot;: { # Specifies the chunk spec to be returned from the search response. Only available if the SearchRequest.ContentSearchSpec.search_result_mode is set to CHUNKS # Specifies the chunk spec to be returned from the search response. Only available if the SearchRequest.ContentSearchSpec.search_result_mode is set to CHUNKS
        &quot;numNextChunks&quot;: 42, # The number of next chunks to be returned of the current chunk. The maximum allowed value is 3. If not specified, no next chunks will be returned.
        &quot;numPreviousChunks&quot;: 42, # The number of previous chunks to be returned of the current chunk. The maximum allowed value is 3. If not specified, no previous chunks will be returned.
      },
      &quot;extractiveContentSpec&quot;: { # A specification for configuring the extractive content in a search response. # If there is no extractive_content_spec provided, there will be no extractive answer in the search response.
        &quot;maxExtractiveAnswerCount&quot;: 42, # The maximum number of extractive answers returned in each search result. An extractive answer is a verbatim answer extracted from the original document, which provides a precise and contextually relevant answer to the search query. If the number of matching answers is less than the `max_extractive_answer_count`, return all of the answers. Otherwise, return the `max_extractive_answer_count`. At most five answers are returned for each SearchResult.
        &quot;maxExtractiveSegmentCount&quot;: 42, # The max number of extractive segments returned in each search result. Only applied if the DataStore is set to DataStore.ContentConfig.CONTENT_REQUIRED or DataStore.solution_types is SOLUTION_TYPE_CHAT. An extractive segment is a text segment extracted from the original document that is relevant to the search query, and, in general, more verbose than an extractive answer. The segment could then be used as input for LLMs to generate summaries and answers. If the number of matching segments is less than `max_extractive_segment_count`, return all of the segments. Otherwise, return the `max_extractive_segment_count`.
        &quot;numNextSegments&quot;: 42, # Return at most `num_next_segments` segments after each selected segments.
        &quot;numPreviousSegments&quot;: 42, # Specifies whether to also include the adjacent from each selected segments. Return at most `num_previous_segments` segments before each selected segments.
        &quot;returnExtractiveSegmentScore&quot;: True or False, # Specifies whether to return the confidence score from the extractive segments in each search result. This feature is available only for new or allowlisted data stores. To allowlist your data store, contact your Customer Engineer. The default value is `false`.
      },
      &quot;searchResultMode&quot;: &quot;A String&quot;, # Specifies the search result mode. If unspecified, the search result mode is based on DataStore.DocumentProcessingConfig.chunking_config: * If DataStore.DocumentProcessingConfig.chunking_config is specified, it defaults to `CHUNKS`. * Otherwise, it defaults to `DOCUMENTS`.
      &quot;snippetSpec&quot;: { # A specification for configuring snippets in a search response. # If `snippetSpec` is not specified, snippets are not included in the search response.
        &quot;maxSnippetCount&quot;: 42, # [DEPRECATED] This field is deprecated. To control snippet return, use `return_snippet` field. For backwards compatibility, we will return snippet if max_snippet_count &gt; 0.
        &quot;referenceOnly&quot;: True or False, # [DEPRECATED] This field is deprecated and will have no affect on the snippet.
        &quot;returnSnippet&quot;: True or False, # If `true`, then return snippet. If no snippet can be generated, we return &quot;No snippet is available for this page.&quot; A `snippet_status` with `SUCCESS` or `NO_SNIPPET_AVAILABLE` will also be returned.
      },
      &quot;summarySpec&quot;: { # A specification for configuring a summary returned in a search response. # If `summarySpec` is not specified, summaries are not included in the search response.
        &quot;ignoreAdversarialQuery&quot;: True or False, # Specifies whether to filter out adversarial queries. The default value is `false`. Google employs search-query classification to detect adversarial queries. No summary is returned if the search query is classified as an adversarial query. For example, a user might ask a question regarding negative comments about the company or submit a query designed to generate unsafe, policy-violating output. If this field is set to `true`, we skip generating summaries for adversarial queries and return fallback messages instead.
        &quot;ignoreNonSummarySeekingQuery&quot;: True or False, # Specifies whether to filter out queries that are not summary-seeking. The default value is `false`. Google employs search-query classification to detect summary-seeking queries. No summary is returned if the search query is classified as a non-summary seeking query. For example, `why is the sky blue` and `Who is the best soccer player in the world?` are summary-seeking queries, but `SFO airport` and `world cup 2026` are not. They are most likely navigational queries. If this field is set to `true`, we skip generating summaries for non-summary seeking queries and return fallback messages instead.
        &quot;includeCitations&quot;: True or False, # Specifies whether to include citations in the summary. The default value is `false`. When this field is set to `true`, summaries include in-line citation numbers. Example summary including citations: BigQuery is Google Cloud&#x27;s fully managed and completely serverless enterprise data warehouse [1]. BigQuery supports all data types, works across clouds, and has built-in machine learning and business intelligence, all within a unified platform [2, 3]. The citation numbers refer to the returned search results and are 1-indexed. For example, [1] means that the sentence is attributed to the first search result. [2, 3] means that the sentence is attributed to both the second and third search results.
        &quot;languageCode&quot;: &quot;A String&quot;, # Language code for Summary. Use language tags defined by [BCP47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). Note: This is an experimental feature.
        &quot;modelPromptSpec&quot;: { # Specification of the prompt to use with the model. # If specified, the spec will be used to modify the prompt provided to the LLM.
          &quot;preamble&quot;: &quot;A String&quot;, # Text at the beginning of the prompt that instructs the assistant. Examples are available in the user guide.
        },
        &quot;modelSpec&quot;: { # Specification of the model. # If specified, the spec will be used to modify the model specification provided to the LLM.
          &quot;version&quot;: &quot;A String&quot;, # The model version used to generate the summary. Supported values are: * `stable`: string. Default value when no value is specified. Uses a generally available, fine-tuned model. For more information, see [Answer generation model versions and lifecycle](https://cloud.google.com/generative-ai-app-builder/docs/answer-generation-models). * `preview`: string. (Public preview) Uses a preview model. For more information, see [Answer generation model versions and lifecycle](https://cloud.google.com/generative-ai-app-builder/docs/answer-generation-models).
        },
        &quot;summaryResultCount&quot;: 42, # The number of top results to generate the summary from. If the number of results returned is less than `summaryResultCount`, the summary is generated from all of the results. At most 10 results for documents mode, or 50 for chunks mode, can be used to generate a summary. The chunks mode is used when SearchRequest.ContentSearchSpec.search_result_mode is set to CHUNKS.
        &quot;useSemanticChunks&quot;: True or False, # If true, answer will be generated from most relevant chunks from top search results. This feature will improve summary quality. Note that with this feature enabled, not all top search results will be referenced and included in the reference list, so the citation source index only points to the search results listed in the reference list.
      },
    },
    &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp the WidgetConfig was created.
    &quot;dataStoreType&quot;: &quot;A String&quot;, # Output only. The type of the parent data store.
    &quot;dataStoreUiConfigs&quot;: [ # Configurable UI configurations per data store.
      { # UI component configuration for data store.
        &quot;facetField&quot;: [ # Facet fields that store the mapping of fields to end user widget appearance.
          { # Facet fields that store the mapping of fields to end user widget appearance.
            &quot;displayName&quot;: &quot;A String&quot;, # Optional. The field name that end users will see.
            &quot;field&quot;: &quot;A String&quot;, # Required. Registered field name. The format is `field.abc`.
          },
        ],
        &quot;fieldsUiComponentsMap&quot;: { # The key is the UI component. Mock. Currently supported `title`, `thumbnail`, `url`, `custom1`, `custom2`, `custom3`. The value is the name of the field along with its device visibility. The 3 custom fields are optional and can be added or removed. `title`, `thumbnail`, `url` are required UI components that cannot be removed.
          &quot;a_key&quot;: { # Facet field that maps to a UI Component.
            &quot;deviceVisibility&quot;: [ # The field visibility on different types of devices.
              &quot;A String&quot;,
            ],
            &quot;displayTemplate&quot;: &quot;A String&quot;, # The template to customize how the field is displayed. An example value would be a string that looks like: &quot;Price: {value}&quot;.
            &quot;field&quot;: &quot;A String&quot;, # Required. Registered field name. The format is `field.abc`.
          },
        },
        &quot;id&quot;: &quot;A String&quot;, # Output only. the identifier of the data store, used for widget service. For now it refers to data_store_id, in the future we will migrate the field to encrypted data store name UUID.
        &quot;name&quot;: &quot;A String&quot;, # The name of the data store. It should be data store resource name Format: `projects/{project_number}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`. For APIs under WidgetService, such as LookUpWidgetConfig, the project number and location part is erased in this field.
      },
    ],
    &quot;displayName&quot;: &quot;A String&quot;, # Required. The human readable widget config display name. Used in Discovery UI. This field must be a UTF-8 encoded string with a length limit of 128 characters. Otherwise, an INVALID_ARGUMENT error is returned.
    &quot;enableAutocomplete&quot;: True or False, # Whether or not to enable autocomplete.
    &quot;enableConversationalSearch&quot;: True or False, # Whether to allow conversational search (LLM, multi-turn) or not (non-LLM, single-turn).
    &quot;enableQualityFeedback&quot;: True or False, # Turn on or off collecting the search result quality feedback from end users.
    &quot;enableResultScore&quot;: True or False, # Whether to show the result score.
    &quot;enableSafeSearch&quot;: True or False, # Whether to enable safe search.
    &quot;enableSearchAsYouType&quot;: True or False, # Whether to enable search-as-you-type behavior for the search widget
    &quot;enableSnippetResultSummary&quot;: True or False, # Turn on or off summary for each snippets result.
    &quot;enableSummarization&quot;: True or False, # Turn on or off summarization for the search response.
    &quot;enableWebApp&quot;: True or False, # Whether to enable standalone web app.
    &quot;facetField&quot;: [ # The configuration and appearance of facets in the end user view.
      { # Facet fields that store the mapping of fields to end user widget appearance.
        &quot;displayName&quot;: &quot;A String&quot;, # Optional. The field name that end users will see.
        &quot;field&quot;: &quot;A String&quot;, # Required. Registered field name. The format is `field.abc`.
      },
    ],
    &quot;fieldsUiComponentsMap&quot;: { # The key is the UI component. Mock. Currently supported `title`, `thumbnail`, `url`, `custom1`, `custom2`, `custom3`. The value is the name of the field along with its device visibility. The 3 custom fields are optional and can be added or removed. `title`, `thumbnail`, `url` are required UI components that cannot be removed.
      &quot;a_key&quot;: { # Facet field that maps to a UI Component.
        &quot;deviceVisibility&quot;: [ # The field visibility on different types of devices.
          &quot;A String&quot;,
        ],
        &quot;displayTemplate&quot;: &quot;A String&quot;, # The template to customize how the field is displayed. An example value would be a string that looks like: &quot;Price: {value}&quot;.
        &quot;field&quot;: &quot;A String&quot;, # Required. Registered field name. The format is `field.abc`.
      },
    },
    &quot;industryVertical&quot;: &quot;A String&quot;, # Output only. The industry vertical that the WidgetConfig registers. The WidgetConfig industry vertical is based on the associated Engine.
    &quot;llmEnabled&quot;: True or False, # Output only. Whether LLM is enabled in the corresponding data store.
    &quot;minimumDataTermAccepted&quot;: True or False, # Output only. Whether the customer accepted data use terms.
    &quot;name&quot;: &quot;A String&quot;, # Immutable. The full resource name of the widget config. Format: `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/widgetConfigs/{widget_config_id}`. This field must be a UTF-8 encoded string with a length limit of 1024 characters.
    &quot;resultDisplayType&quot;: &quot;A String&quot;, # The type of snippet to display in UCS widget. - RESULT_DISPLAY_TYPE_UNSPECIFIED for existing users. - SNIPPET for new non-enterprise search users. - EXTRACTIVE_ANSWER for new enterprise search users.
    &quot;solutionType&quot;: &quot;A String&quot;, # Required. Immutable. Specifies the solution type that this WidgetConfig can be used for.
    &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp the WidgetConfig was updated.
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="widgetCompleteQuery">widgetCompleteQuery(location, body=None, x__xgafv=None)</code>
  <pre>Performs a user input completion with keyword suggestion. Similar to the CompletionService.CompleteQuery method, but a widget version that allows CompleteQuery without API Key. It supports CompleteQuery with or without JWT token.

Args:
  location: string, Required. The location resource where widget complete query will be performed. Format: `locations/{location}` (required)
  body: object, The request body.
    The object takes the form of:

{ # Request message for WidgetService.WidgetCompleteQuery method.
  &quot;additionalParams&quot;: { # AdditionalParams message for WidgetService methods for security and privacy enhancement. # Additional params for security and privacy enhancement.
    &quot;token&quot;: &quot;A String&quot;, # Token that used for non-human user check.
  },
  &quot;completeQueryRequest&quot;: { # Request message for CompletionService.CompleteQuery method. # Required. The CompleteQuery request to perform auto-complete suggestion query.
    &quot;dataStore&quot;: &quot;A String&quot;, # Required. The parent data store resource name for which the completion is performed, such as `projects/*/locations/global/collections/default_collection/dataStores/default_data_store`.
    &quot;includeTailSuggestions&quot;: True or False, # Indicates if tail suggestions should be returned if there are no suggestions that match the full query. Even if set to true, if there are suggestions that match the full query, those are returned and no tail suggestions are returned.
    &quot;query&quot;: &quot;A String&quot;, # Required. The typeahead input used to fetch suggestions. Maximum length is 128 characters.
    &quot;queryModel&quot;: &quot;A String&quot;, # Specifies the autocomplete data model. This overrides any model specified in the Configuration &gt; Autocomplete section of the Cloud console. Currently supported values: * `document` - Using suggestions generated from user-imported documents. * `search-history` - Using suggestions generated from the past history of SearchService.Search API calls. Do not use it when there is no traffic for Search API. * `user-event` - Using suggestions generated from user-imported search events. * `document-completable` - Using suggestions taken directly from user-imported document fields marked as completable. Default values: * `document` is the default model for regular dataStores. * `search-history` is the default model for site search dataStores.
    &quot;userPseudoId&quot;: &quot;A String&quot;, # A unique identifier for tracking visitors. For example, this could be implemented with an HTTP cookie, which should be able to uniquely identify a visitor on a single device. This unique identifier should not change if the visitor logs in or out of the website. This field should NOT have a fixed value such as `unknown_visitor`. This should be the same identifier as UserEvent.user_pseudo_id and SearchRequest.user_pseudo_id. The field must be a UTF-8 encoded string with a length limit of 128 characters. Otherwise, an `INVALID_ARGUMENT` error is returned.
  },
  &quot;configId&quot;: &quot;A String&quot;, # Required. The UUID of the WidgetConfig. This field is used to identify the widget configuration, set of models used to make the auto complete query.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response message for WidgetService.WidgetCompleteQuery method.
  &quot;uToken&quot;: &quot;A String&quot;, # The token in response.
  &quot;widgetQuerySuggestions&quot;: [ # Results of the matched query suggestions in widget. The result list is ordered and the first result is a top suggestion.
    { # Suggestions as search queries.
      &quot;suggestion&quot;: &quot;A String&quot;, # The suggestion for the query.
    },
  ],
}</pre>
</div>

<div class="method">
    <code class="details" id="widgetConverseConversation">widgetConverseConversation(location, body=None, x__xgafv=None)</code>
  <pre>Converse a conversation with Widget.

Args:
  location: string, Required. The location resource where widget converse conversation will be performed. Format: `locations/{location}` (required)
  body: object, The request body.
    The object takes the form of:

{ # Request message for WidgetService.WidgetConverseConversation method.
  &quot;additionalParams&quot;: { # AdditionalParams message for WidgetService methods for security and privacy enhancement. # Additional params for security and privacy enhancement.
    &quot;token&quot;: &quot;A String&quot;, # Token that used for non-human user check.
  },
  &quot;configId&quot;: &quot;A String&quot;, # Required. The UUID of the WidgetConfig. This field is used to identify the widget configuration, set of models used to make the user event collection.
  &quot;conversationId&quot;: &quot;A String&quot;, # The id of the Conversation to get. Use &quot;-&quot; to activate auto session mode, which automatically creates a new conversation inside a ConverseConversation session.
  &quot;converseConversationRequest&quot;: { # Request message for ConversationalSearchService.ConverseConversation method. # Required. The ConverseConversationRequest request to perform converse a conversation. The ServingConfig id will be `default_search` by default.
    &quot;boostSpec&quot;: { # Boost specification to boost certain documents. # Boost specification to boost certain documents in search results which may affect the converse response. For more information on boosting, see [Boosting](https://cloud.google.com/retail/docs/boosting#boost)
      &quot;conditionBoostSpecs&quot;: [ # Condition boost specifications. If a document matches multiple conditions in the specifictions, boost scores from these specifications are all applied and combined in a non-linear way. Maximum number of specifications is 20.
        { # Boost applies to documents which match a condition.
          &quot;boost&quot;: 3.14, # Strength of the condition boost, which should be in [-1, 1]. Negative boost means demotion. Default is 0.0. Setting to 1.0 gives the document a big promotion. However, it does not necessarily mean that the boosted document will be the top result at all times, nor that other documents will be excluded. Results could still be shown even when none of them matches the condition. And results that are significantly more relevant to the search query can still trump your heavily favored but irrelevant documents. Setting to -1.0 gives the document a big demotion. However, results that are deeply relevant might still be shown. The document will have an upstream battle to get a fairly high ranking, but it is not blocked out completely. Setting to 0.0 means no boost applied. The boosting condition is ignored. Only one of the (condition, boost) combination or the boost_control_spec below are set. If both are set then the global boost is ignored and the more fine-grained boost_control_spec is applied.
          &quot;boostControlSpec&quot;: { # Specification for custom ranking based on customer specified attribute value. It provides more controls for customized ranking than the simple (condition, boost) combination above. # Complex specification for custom ranking based on customer defined attribute value.
            &quot;attributeType&quot;: &quot;A String&quot;, # The attribute type to be used to determine the boost amount. The attribute value can be derived from the field value of the specified field_name. In the case of numerical it is straightforward i.e. attribute_value = numerical_field_value. In the case of freshness however, attribute_value = (time.now() - datetime_field_value).
            &quot;controlPoints&quot;: [ # The control points used to define the curve. The monotonic function (defined through the interpolation_type above) passes through the control points listed here.
              { # The control points used to define the curve. The curve defined through these control points can only be monotonically increasing or decreasing(constant values are acceptable).
                &quot;attributeValue&quot;: &quot;A String&quot;, # Can be one of: 1. The numerical field value. 2. The duration spec for freshness: The value must be formatted as an XSD `dayTimeDuration` value (a restricted subset of an ISO 8601 duration value). The pattern for this is: `nDnM]`.
                &quot;boostAmount&quot;: 3.14, # The value between -1 to 1 by which to boost the score if the attribute_value evaluates to the value specified above.
              },
            ],
            &quot;fieldName&quot;: &quot;A String&quot;, # The name of the field whose value will be used to determine the boost amount.
            &quot;interpolationType&quot;: &quot;A String&quot;, # The interpolation type to be applied to connect the control points listed below.
          },
          &quot;condition&quot;: &quot;A String&quot;, # An expression which specifies a boost condition. The syntax and supported fields are the same as a filter expression. See SearchRequest.filter for detail syntax and limitations. Examples: * To boost documents with document ID &quot;doc_1&quot; or &quot;doc_2&quot;, and color &quot;Red&quot; or &quot;Blue&quot;: `(document_id: ANY(&quot;doc_1&quot;, &quot;doc_2&quot;)) AND (color: ANY(&quot;Red&quot;, &quot;Blue&quot;))`
        },
      ],
    },
    &quot;conversation&quot;: { # External conversation proto definition. # The conversation to be used by auto session only. The name field will be ignored as we automatically assign new name for the conversation in auto session.
      &quot;endTime&quot;: &quot;A String&quot;, # Output only. The time the conversation finished.
      &quot;messages&quot;: [ # Conversation messages.
        { # Defines a conversation message.
          &quot;createTime&quot;: &quot;A String&quot;, # Output only. Message creation timestamp.
          &quot;reply&quot;: { # Defines a reply message to user. # Search reply.
            &quot;references&quot;: [ # References in the reply.
              { # Defines reference in reply.
                &quot;anchorText&quot;: &quot;A String&quot;, # Anchor text.
                &quot;end&quot;: 42, # Anchor text end index.
                &quot;start&quot;: 42, # Anchor text start index.
                &quot;uri&quot;: &quot;A String&quot;, # URI link reference.
              },
            ],
            &quot;reply&quot;: &quot;A String&quot;, # DEPRECATED: use `summary` instead. Text reply.
            &quot;summary&quot;: { # Summary of the top N search result specified by the summary spec. # Summary based on search results.
              &quot;safetyAttributes&quot;: { # Safety Attribute categories and their associated confidence scores. # A collection of Safety Attribute categories and their associated confidence scores.
                &quot;categories&quot;: [ # The display names of Safety Attribute categories associated with the generated content. Order matches the Scores.
                  &quot;A String&quot;,
                ],
                &quot;scores&quot;: [ # The confidence scores of the each category, higher value means higher confidence. Order matches the Categories.
                  3.14,
                ],
              },
              &quot;summarySkippedReasons&quot;: [ # Additional summary-skipped reasons. This provides the reason for ignored cases. If nothing is skipped, this field is not set.
                &quot;A String&quot;,
              ],
              &quot;summaryText&quot;: &quot;A String&quot;, # The summary content.
              &quot;summaryWithMetadata&quot;: { # Summary with metadata information. # Summary with metadata information.
                &quot;citationMetadata&quot;: { # Citation metadata. # Citation metadata for given summary.
                  &quot;citations&quot;: [ # Citations for segments.
                    { # Citation info for a segment.
                      &quot;endIndex&quot;: &quot;A String&quot;, # End of the attributed segment, exclusive.
                      &quot;sources&quot;: [ # Citation sources for the attributed segment.
                        { # Citation source.
                          &quot;referenceIndex&quot;: &quot;A String&quot;, # Document reference index from SummaryWithMetadata.references. It is 0-indexed and the value will be zero if the reference_index is not set explicitly.
                        },
                      ],
                      &quot;startIndex&quot;: &quot;A String&quot;, # Index indicates the start of the segment, measured in bytes/unicode.
                    },
                  ],
                },
                &quot;references&quot;: [ # Document References.
                  { # Document reference.
                    &quot;chunkContents&quot;: [ # List of cited chunk contents derived from document content.
                      { # Chunk content.
                        &quot;content&quot;: &quot;A String&quot;, # Chunk textual content.
                        &quot;pageIdentifier&quot;: &quot;A String&quot;, # Page identifier.
                      },
                    ],
                    &quot;document&quot;: &quot;A String&quot;, # Required. Document.name of the document. Full resource name of the referenced document, in the format `projects/*/locations/*/collections/*/dataStores/*/branches/*/documents/*`.
                    &quot;title&quot;: &quot;A String&quot;, # Title of the document.
                    &quot;uri&quot;: &quot;A String&quot;, # Cloud Storage or HTTP uri for the document.
                  },
                ],
                &quot;summary&quot;: &quot;A String&quot;, # Summary text with no citation information.
              },
            },
          },
          &quot;userInput&quot;: { # Defines text input. # User text input.
            &quot;context&quot;: { # Defines context of the conversation # Conversation context of the input.
              &quot;activeDocument&quot;: &quot;A String&quot;, # The current active document the user opened. It contains the document resource reference.
              &quot;contextDocuments&quot;: [ # The current list of documents the user is seeing. It contains the document resource references.
                &quot;A String&quot;,
              ],
            },
            &quot;input&quot;: &quot;A String&quot;, # Text input.
          },
        },
      ],
      &quot;name&quot;: &quot;A String&quot;, # Immutable. Fully qualified name `projects/{project}/locations/global/collections/{collection}/dataStore/*/conversations/*` or `projects/{project}/locations/global/collections/{collection}/engines/*/conversations/*`.
      &quot;startTime&quot;: &quot;A String&quot;, # Output only. The time the conversation started.
      &quot;state&quot;: &quot;A String&quot;, # The state of the Conversation.
      &quot;userPseudoId&quot;: &quot;A String&quot;, # A unique identifier for tracking users.
    },
    &quot;filter&quot;: &quot;A String&quot;, # The filter syntax consists of an expression language for constructing a predicate from one or more fields of the documents being filtered. Filter expression is case-sensitive. This will be used to filter search results which may affect the summary response. If this field is unrecognizable, an `INVALID_ARGUMENT` is returned. Filtering in Vertex AI Search is done by mapping the LHS filter key to a key property defined in the Vertex AI Search backend -- this mapping is defined by the customer in their schema. For example a media customer might have a field &#x27;name&#x27; in their schema. In this case the filter would look like this: filter --&gt; name:&#x27;ANY(&quot;king kong&quot;)&#x27; For more information about filtering including syntax and filter operators, see [Filter](https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata)
    &quot;name&quot;: &quot;A String&quot;, # Required. The resource name of the Conversation to get. Format: `projects/{project_number}/locations/{location_id}/collections/{collection}/dataStores/{data_store_id}/conversations/{conversation_id}`. Use `projects/{project_number}/locations/{location_id}/collections/{collection}/dataStores/{data_store_id}/conversations/-` to activate auto session mode, which automatically creates a new conversation inside a ConverseConversation session.
    &quot;query&quot;: { # Defines text input. # Required. Current user input.
      &quot;context&quot;: { # Defines context of the conversation # Conversation context of the input.
        &quot;activeDocument&quot;: &quot;A String&quot;, # The current active document the user opened. It contains the document resource reference.
        &quot;contextDocuments&quot;: [ # The current list of documents the user is seeing. It contains the document resource references.
          &quot;A String&quot;,
        ],
      },
      &quot;input&quot;: &quot;A String&quot;, # Text input.
    },
    &quot;safeSearch&quot;: True or False, # Whether to turn on safe search.
    &quot;servingConfig&quot;: &quot;A String&quot;, # The resource name of the Serving Config to use. Format: `projects/{project_number}/locations/{location_id}/collections/{collection}/dataStores/{data_store_id}/servingConfigs/{serving_config_id}` If this is not set, the default serving config will be used.
    &quot;summarySpec&quot;: { # A specification for configuring a summary returned in a search response. # A specification for configuring the summary returned in the response.
      &quot;ignoreAdversarialQuery&quot;: True or False, # Specifies whether to filter out adversarial queries. The default value is `false`. Google employs search-query classification to detect adversarial queries. No summary is returned if the search query is classified as an adversarial query. For example, a user might ask a question regarding negative comments about the company or submit a query designed to generate unsafe, policy-violating output. If this field is set to `true`, we skip generating summaries for adversarial queries and return fallback messages instead.
      &quot;ignoreNonSummarySeekingQuery&quot;: True or False, # Specifies whether to filter out queries that are not summary-seeking. The default value is `false`. Google employs search-query classification to detect summary-seeking queries. No summary is returned if the search query is classified as a non-summary seeking query. For example, `why is the sky blue` and `Who is the best soccer player in the world?` are summary-seeking queries, but `SFO airport` and `world cup 2026` are not. They are most likely navigational queries. If this field is set to `true`, we skip generating summaries for non-summary seeking queries and return fallback messages instead.
      &quot;includeCitations&quot;: True or False, # Specifies whether to include citations in the summary. The default value is `false`. When this field is set to `true`, summaries include in-line citation numbers. Example summary including citations: BigQuery is Google Cloud&#x27;s fully managed and completely serverless enterprise data warehouse [1]. BigQuery supports all data types, works across clouds, and has built-in machine learning and business intelligence, all within a unified platform [2, 3]. The citation numbers refer to the returned search results and are 1-indexed. For example, [1] means that the sentence is attributed to the first search result. [2, 3] means that the sentence is attributed to both the second and third search results.
      &quot;languageCode&quot;: &quot;A String&quot;, # Language code for Summary. Use language tags defined by [BCP47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). Note: This is an experimental feature.
      &quot;modelPromptSpec&quot;: { # Specification of the prompt to use with the model. # If specified, the spec will be used to modify the prompt provided to the LLM.
        &quot;preamble&quot;: &quot;A String&quot;, # Text at the beginning of the prompt that instructs the assistant. Examples are available in the user guide.
      },
      &quot;modelSpec&quot;: { # Specification of the model. # If specified, the spec will be used to modify the model specification provided to the LLM.
        &quot;version&quot;: &quot;A String&quot;, # The model version used to generate the summary. Supported values are: * `stable`: string. Default value when no value is specified. Uses a generally available, fine-tuned model. For more information, see [Answer generation model versions and lifecycle](https://cloud.google.com/generative-ai-app-builder/docs/answer-generation-models). * `preview`: string. (Public preview) Uses a preview model. For more information, see [Answer generation model versions and lifecycle](https://cloud.google.com/generative-ai-app-builder/docs/answer-generation-models).
      },
      &quot;summaryResultCount&quot;: 42, # The number of top results to generate the summary from. If the number of results returned is less than `summaryResultCount`, the summary is generated from all of the results. At most 10 results for documents mode, or 50 for chunks mode, can be used to generate a summary. The chunks mode is used when SearchRequest.ContentSearchSpec.search_result_mode is set to CHUNKS.
      &quot;useSemanticChunks&quot;: True or False, # If true, answer will be generated from most relevant chunks from top search results. This feature will improve summary quality. Note that with this feature enabled, not all top search results will be referenced and included in the reference list, so the citation source index only points to the search results listed in the reference list.
    },
    &quot;userLabels&quot;: { # The user labels applied to a resource must meet the following requirements: * Each resource can have multiple labels, up to a maximum of 64. * Each label must be a key-value pair. * Keys have a minimum length of 1 character and a maximum length of 63 characters and cannot be empty. Values can be empty and have a maximum length of 63 characters. * Keys and values can contain only lowercase letters, numeric characters, underscores, and dashes. All characters must use UTF-8 encoding, and international characters are allowed. * The key portion of a label must be unique. However, you can use the same key with multiple resources. * Keys must start with a lowercase letter or international character. See [Google Cloud Document](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements) for more details.
      &quot;a_key&quot;: &quot;A String&quot;,
    },
  },
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response message for WidgetService.WidgetConverseConversation method.
  &quot;conversationId&quot;: &quot;A String&quot;, # The id of the Conversation returned.
  &quot;converseConversationResponse&quot;: { # Response message for ConversationalSearchService.ConverseConversation method. # ConverseConversationResponse returned from ConversationalSearchService.ConverseConversation.
    &quot;conversation&quot;: { # External conversation proto definition. # Updated conversation including the answer.
      &quot;endTime&quot;: &quot;A String&quot;, # Output only. The time the conversation finished.
      &quot;messages&quot;: [ # Conversation messages.
        { # Defines a conversation message.
          &quot;createTime&quot;: &quot;A String&quot;, # Output only. Message creation timestamp.
          &quot;reply&quot;: { # Defines a reply message to user. # Search reply.
            &quot;references&quot;: [ # References in the reply.
              { # Defines reference in reply.
                &quot;anchorText&quot;: &quot;A String&quot;, # Anchor text.
                &quot;end&quot;: 42, # Anchor text end index.
                &quot;start&quot;: 42, # Anchor text start index.
                &quot;uri&quot;: &quot;A String&quot;, # URI link reference.
              },
            ],
            &quot;reply&quot;: &quot;A String&quot;, # DEPRECATED: use `summary` instead. Text reply.
            &quot;summary&quot;: { # Summary of the top N search result specified by the summary spec. # Summary based on search results.
              &quot;safetyAttributes&quot;: { # Safety Attribute categories and their associated confidence scores. # A collection of Safety Attribute categories and their associated confidence scores.
                &quot;categories&quot;: [ # The display names of Safety Attribute categories associated with the generated content. Order matches the Scores.
                  &quot;A String&quot;,
                ],
                &quot;scores&quot;: [ # The confidence scores of the each category, higher value means higher confidence. Order matches the Categories.
                  3.14,
                ],
              },
              &quot;summarySkippedReasons&quot;: [ # Additional summary-skipped reasons. This provides the reason for ignored cases. If nothing is skipped, this field is not set.
                &quot;A String&quot;,
              ],
              &quot;summaryText&quot;: &quot;A String&quot;, # The summary content.
              &quot;summaryWithMetadata&quot;: { # Summary with metadata information. # Summary with metadata information.
                &quot;citationMetadata&quot;: { # Citation metadata. # Citation metadata for given summary.
                  &quot;citations&quot;: [ # Citations for segments.
                    { # Citation info for a segment.
                      &quot;endIndex&quot;: &quot;A String&quot;, # End of the attributed segment, exclusive.
                      &quot;sources&quot;: [ # Citation sources for the attributed segment.
                        { # Citation source.
                          &quot;referenceIndex&quot;: &quot;A String&quot;, # Document reference index from SummaryWithMetadata.references. It is 0-indexed and the value will be zero if the reference_index is not set explicitly.
                        },
                      ],
                      &quot;startIndex&quot;: &quot;A String&quot;, # Index indicates the start of the segment, measured in bytes/unicode.
                    },
                  ],
                },
                &quot;references&quot;: [ # Document References.
                  { # Document reference.
                    &quot;chunkContents&quot;: [ # List of cited chunk contents derived from document content.
                      { # Chunk content.
                        &quot;content&quot;: &quot;A String&quot;, # Chunk textual content.
                        &quot;pageIdentifier&quot;: &quot;A String&quot;, # Page identifier.
                      },
                    ],
                    &quot;document&quot;: &quot;A String&quot;, # Required. Document.name of the document. Full resource name of the referenced document, in the format `projects/*/locations/*/collections/*/dataStores/*/branches/*/documents/*`.
                    &quot;title&quot;: &quot;A String&quot;, # Title of the document.
                    &quot;uri&quot;: &quot;A String&quot;, # Cloud Storage or HTTP uri for the document.
                  },
                ],
                &quot;summary&quot;: &quot;A String&quot;, # Summary text with no citation information.
              },
            },
          },
          &quot;userInput&quot;: { # Defines text input. # User text input.
            &quot;context&quot;: { # Defines context of the conversation # Conversation context of the input.
              &quot;activeDocument&quot;: &quot;A String&quot;, # The current active document the user opened. It contains the document resource reference.
              &quot;contextDocuments&quot;: [ # The current list of documents the user is seeing. It contains the document resource references.
                &quot;A String&quot;,
              ],
            },
            &quot;input&quot;: &quot;A String&quot;, # Text input.
          },
        },
      ],
      &quot;name&quot;: &quot;A String&quot;, # Immutable. Fully qualified name `projects/{project}/locations/global/collections/{collection}/dataStore/*/conversations/*` or `projects/{project}/locations/global/collections/{collection}/engines/*/conversations/*`.
      &quot;startTime&quot;: &quot;A String&quot;, # Output only. The time the conversation started.
      &quot;state&quot;: &quot;A String&quot;, # The state of the Conversation.
      &quot;userPseudoId&quot;: &quot;A String&quot;, # A unique identifier for tracking users.
    },
    &quot;relatedQuestions&quot;: [ # Suggested related questions.
      &quot;A String&quot;,
    ],
    &quot;reply&quot;: { # Defines a reply message to user. # Answer to the current query.
      &quot;references&quot;: [ # References in the reply.
        { # Defines reference in reply.
          &quot;anchorText&quot;: &quot;A String&quot;, # Anchor text.
          &quot;end&quot;: 42, # Anchor text end index.
          &quot;start&quot;: 42, # Anchor text start index.
          &quot;uri&quot;: &quot;A String&quot;, # URI link reference.
        },
      ],
      &quot;reply&quot;: &quot;A String&quot;, # DEPRECATED: use `summary` instead. Text reply.
      &quot;summary&quot;: { # Summary of the top N search result specified by the summary spec. # Summary based on search results.
        &quot;safetyAttributes&quot;: { # Safety Attribute categories and their associated confidence scores. # A collection of Safety Attribute categories and their associated confidence scores.
          &quot;categories&quot;: [ # The display names of Safety Attribute categories associated with the generated content. Order matches the Scores.
            &quot;A String&quot;,
          ],
          &quot;scores&quot;: [ # The confidence scores of the each category, higher value means higher confidence. Order matches the Categories.
            3.14,
          ],
        },
        &quot;summarySkippedReasons&quot;: [ # Additional summary-skipped reasons. This provides the reason for ignored cases. If nothing is skipped, this field is not set.
          &quot;A String&quot;,
        ],
        &quot;summaryText&quot;: &quot;A String&quot;, # The summary content.
        &quot;summaryWithMetadata&quot;: { # Summary with metadata information. # Summary with metadata information.
          &quot;citationMetadata&quot;: { # Citation metadata. # Citation metadata for given summary.
            &quot;citations&quot;: [ # Citations for segments.
              { # Citation info for a segment.
                &quot;endIndex&quot;: &quot;A String&quot;, # End of the attributed segment, exclusive.
                &quot;sources&quot;: [ # Citation sources for the attributed segment.
                  { # Citation source.
                    &quot;referenceIndex&quot;: &quot;A String&quot;, # Document reference index from SummaryWithMetadata.references. It is 0-indexed and the value will be zero if the reference_index is not set explicitly.
                  },
                ],
                &quot;startIndex&quot;: &quot;A String&quot;, # Index indicates the start of the segment, measured in bytes/unicode.
              },
            ],
          },
          &quot;references&quot;: [ # Document References.
            { # Document reference.
              &quot;chunkContents&quot;: [ # List of cited chunk contents derived from document content.
                { # Chunk content.
                  &quot;content&quot;: &quot;A String&quot;, # Chunk textual content.
                  &quot;pageIdentifier&quot;: &quot;A String&quot;, # Page identifier.
                },
              ],
              &quot;document&quot;: &quot;A String&quot;, # Required. Document.name of the document. Full resource name of the referenced document, in the format `projects/*/locations/*/collections/*/dataStores/*/branches/*/documents/*`.
              &quot;title&quot;: &quot;A String&quot;, # Title of the document.
              &quot;uri&quot;: &quot;A String&quot;, # Cloud Storage or HTTP uri for the document.
            },
          ],
          &quot;summary&quot;: &quot;A String&quot;, # Summary text with no citation information.
        },
      },
    },
    &quot;searchResults&quot;: [ # Search Results.
      { # Represents the search results.
        &quot;chunk&quot;: { # Chunk captures all raw metadata information of items to be recommended or searched in the chunk mode. # The chunk data in the search response if the SearchRequest.ContentSearchSpec.search_result_mode is set to CHUNKS.
          &quot;chunkMetadata&quot;: { # Metadata of the current chunk. This field is only populated on SearchService.Search API. # Output only. Metadata of the current chunk.
            &quot;nextChunks&quot;: [ # The next chunks of the current chunk. The number is controlled by SearchRequest.ContentSearchSpec.ChunkSpec.num_next_chunks. This field is only populated on SearchService.Search API.
              # Object with schema name: GoogleCloudDiscoveryengineV1alphaChunk
            ],
            &quot;previousChunks&quot;: [ # The previous chunks of the current chunk. The number is controlled by SearchRequest.ContentSearchSpec.ChunkSpec.num_previous_chunks. This field is only populated on SearchService.Search API.
              # Object with schema name: GoogleCloudDiscoveryengineV1alphaChunk
            ],
          },
          &quot;content&quot;: &quot;A String&quot;, # Content is a string from a document (parsed content).
          &quot;derivedStructData&quot;: { # Output only. This field is OUTPUT_ONLY. It contains derived data that are not in the original input document.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;documentMetadata&quot;: { # Document metadata contains the information of the document of the current chunk. # Metadata of the document from the current chunk.
            &quot;structData&quot;: { # Data representation. The structured JSON data for the document. It should conform to the registered Schema or an `INVALID_ARGUMENT` error is thrown.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;title&quot;: &quot;A String&quot;, # Title of the document.
            &quot;uri&quot;: &quot;A String&quot;, # Uri of the document.
          },
          &quot;id&quot;: &quot;A String&quot;, # Unique chunk ID of the current chunk.
          &quot;name&quot;: &quot;A String&quot;, # The full resource name of the chunk. Format: `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}/documents/{document_id}/chunks/{chunk_id}`. This field must be a UTF-8 encoded string with a length limit of 1024 characters.
          &quot;pageSpan&quot;: { # Page span of the chunk. # Page span of the chunk.
            &quot;pageEnd&quot;: 42, # The end page of the chunk.
            &quot;pageStart&quot;: 42, # The start page of the chunk.
          },
        },
        &quot;document&quot;: { # Document captures all raw metadata information of items to be recommended or searched. # The document data snippet in the search response. Only fields that are marked as retrievable are populated.
          &quot;aclInfo&quot;: { # ACL Information of the Document. # Access control information for the document.
            &quot;readers&quot;: [ # Readers of the document.
              { # AclRestriction to model complex inheritance restrictions. Example: Modeling a &quot;Both Permit&quot; inheritance, where to access a child document, user needs to have access to parent document. Document Hierarchy - Space_S --&gt; Page_P. Readers: Space_S: group_1, user_1 Page_P: group_2, group_3, user_2 Space_S ACL Restriction - { &quot;acl_info&quot;: { &quot;readers&quot;: [ { &quot;principals&quot;: [ { &quot;group_id&quot;: &quot;group_1&quot; }, { &quot;user_id&quot;: &quot;user_1&quot; } ] } ] } } Page_P ACL Restriction. { &quot;acl_info&quot;: { &quot;readers&quot;: [ { &quot;principals&quot;: [ { &quot;group_id&quot;: &quot;group_2&quot; }, { &quot;group_id&quot;: &quot;group_3&quot; }, { &quot;user_id&quot;: &quot;user_2&quot; } ], }, { &quot;principals&quot;: [ { &quot;group_id&quot;: &quot;group_1&quot; }, { &quot;user_id&quot;: &quot;user_1&quot; } ], } ] } }
                &quot;principals&quot;: [ # List of principals.
                  { # Principal identifier of a user or a group.
                    &quot;groupId&quot;: &quot;A String&quot;, # Group identifier. For Google Workspace user account, group_id should be the google workspace group email. For non-google identity provider user account, group_id is the mapped group identifier configured during the workforcepool config.
                    &quot;userId&quot;: &quot;A String&quot;, # User identifier. For Google Workspace user account, user_id should be the google workspace user email. For non-google identity provider user account, user_id is the mapped user identifier configured during the workforcepool config.
                  },
                ],
              },
            ],
          },
          &quot;content&quot;: { # Unstructured data linked to this document. # The unstructured data linked to this document. Content must be set if this document is under a `CONTENT_REQUIRED` data store.
            &quot;mimeType&quot;: &quot;A String&quot;, # The MIME type of the content. Supported types: * `application/pdf` (PDF, only native PDFs are supported for now) * `text/html` (HTML) * `application/vnd.openxmlformats-officedocument.wordprocessingml.document` (DOCX) * `application/vnd.openxmlformats-officedocument.presentationml.presentation` (PPTX) * `text/plain` (TXT) See https://www.iana.org/assignments/media-types/media-types.xhtml.
            &quot;rawBytes&quot;: &quot;A String&quot;, # The content represented as a stream of bytes. The maximum length is 1,000,000 bytes (1 MB / ~0.95 MiB). Note: As with all `bytes` fields, this field is represented as pure binary in Protocol Buffers and base64-encoded string in JSON. For example, `abc123!?$*&amp;()&#x27;-=@~` should be represented as `YWJjMTIzIT8kKiYoKSctPUB+` in JSON. See https://developers.google.com/protocol-buffers/docs/proto3#json.
            &quot;uri&quot;: &quot;A String&quot;, # The URI of the content. Only Cloud Storage URIs (e.g. `gs://bucket-name/path/to/file`) are supported. The maximum file size is 2.5 MB for text-based formats, 100 MB for other formats.
          },
          &quot;derivedStructData&quot;: { # Output only. This field is OUTPUT_ONLY. It contains derived data that are not in the original input document.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;id&quot;: &quot;A String&quot;, # Immutable. The identifier of the document. Id should conform to [RFC-1034](https://tools.ietf.org/html/rfc1034) standard with a length limit of 63 characters.
          &quot;indexTime&quot;: &quot;A String&quot;, # Output only. The last time the document was indexed. If this field is set, the document could be returned in search results. This field is OUTPUT_ONLY. If this field is not populated, it means the document has never been indexed.
          &quot;jsonData&quot;: &quot;A String&quot;, # The JSON string representation of the document. It should conform to the registered Schema or an `INVALID_ARGUMENT` error is thrown.
          &quot;name&quot;: &quot;A String&quot;, # Immutable. The full resource name of the document. Format: `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}/documents/{document_id}`. This field must be a UTF-8 encoded string with a length limit of 1024 characters.
          &quot;parentDocumentId&quot;: &quot;A String&quot;, # The identifier of the parent document. Currently supports at most two level document hierarchy. Id should conform to [RFC-1034](https://tools.ietf.org/html/rfc1034) standard with a length limit of 63 characters.
          &quot;schemaId&quot;: &quot;A String&quot;, # The identifier of the schema located in the same data store.
          &quot;structData&quot;: { # The structured JSON data for the document. It should conform to the registered Schema or an `INVALID_ARGUMENT` error is thrown.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
        },
        &quot;id&quot;: &quot;A String&quot;, # Document.id of the searched Document.
        &quot;modelScores&quot;: { # Google provided available scores.
          &quot;a_key&quot;: { # Double list.
            &quot;values&quot;: [ # Double values.
              3.14,
            ],
          },
        },
      },
    ],
  },
  &quot;uToken&quot;: &quot;A String&quot;, # The token in response.
}</pre>
</div>

<div class="method">
    <code class="details" id="widgetSearch">widgetSearch(location, body=None, x__xgafv=None)</code>
  <pre>Performs a search. Similar to the SearchService.Search method, but a widget version that allows search without API Key. It supports search with or without JWT token.

Args:
  location: string, Required. The location resource where widget search will be performed. Format: `locations/{location}` (required)
  body: object, The request body.
    The object takes the form of:

{ # Request message for WidgetService.WidgetSearch method.
  &quot;additionalParams&quot;: { # AdditionalParams message for WidgetService methods for security and privacy enhancement. # Additional params for security and privacy enhancement.
    &quot;token&quot;: &quot;A String&quot;, # Token that used for non-human user check.
  },
  &quot;configId&quot;: &quot;A String&quot;, # Required. The UUID of the Search WidgetConfig. This field is used to identify the search widget configuration, set of models used to make the search.
  &quot;searchRequest&quot;: { # Request message for SearchService.Search method. # Required. The search request to perform search.
    &quot;boostSpec&quot;: { # Boost specification to boost certain documents. # Boost specification to boost certain documents. For more information on boosting, see [Boosting](https://cloud.google.com/retail/docs/boosting#boost)
      &quot;conditionBoostSpecs&quot;: [ # Condition boost specifications. If a document matches multiple conditions in the specifictions, boost scores from these specifications are all applied and combined in a non-linear way. Maximum number of specifications is 20.
        { # Boost applies to documents which match a condition.
          &quot;boost&quot;: 3.14, # Strength of the condition boost, which should be in [-1, 1]. Negative boost means demotion. Default is 0.0. Setting to 1.0 gives the document a big promotion. However, it does not necessarily mean that the boosted document will be the top result at all times, nor that other documents will be excluded. Results could still be shown even when none of them matches the condition. And results that are significantly more relevant to the search query can still trump your heavily favored but irrelevant documents. Setting to -1.0 gives the document a big demotion. However, results that are deeply relevant might still be shown. The document will have an upstream battle to get a fairly high ranking, but it is not blocked out completely. Setting to 0.0 means no boost applied. The boosting condition is ignored. Only one of the (condition, boost) combination or the boost_control_spec below are set. If both are set then the global boost is ignored and the more fine-grained boost_control_spec is applied.
          &quot;boostControlSpec&quot;: { # Specification for custom ranking based on customer specified attribute value. It provides more controls for customized ranking than the simple (condition, boost) combination above. # Complex specification for custom ranking based on customer defined attribute value.
            &quot;attributeType&quot;: &quot;A String&quot;, # The attribute type to be used to determine the boost amount. The attribute value can be derived from the field value of the specified field_name. In the case of numerical it is straightforward i.e. attribute_value = numerical_field_value. In the case of freshness however, attribute_value = (time.now() - datetime_field_value).
            &quot;controlPoints&quot;: [ # The control points used to define the curve. The monotonic function (defined through the interpolation_type above) passes through the control points listed here.
              { # The control points used to define the curve. The curve defined through these control points can only be monotonically increasing or decreasing(constant values are acceptable).
                &quot;attributeValue&quot;: &quot;A String&quot;, # Can be one of: 1. The numerical field value. 2. The duration spec for freshness: The value must be formatted as an XSD `dayTimeDuration` value (a restricted subset of an ISO 8601 duration value). The pattern for this is: `nDnM]`.
                &quot;boostAmount&quot;: 3.14, # The value between -1 to 1 by which to boost the score if the attribute_value evaluates to the value specified above.
              },
            ],
            &quot;fieldName&quot;: &quot;A String&quot;, # The name of the field whose value will be used to determine the boost amount.
            &quot;interpolationType&quot;: &quot;A String&quot;, # The interpolation type to be applied to connect the control points listed below.
          },
          &quot;condition&quot;: &quot;A String&quot;, # An expression which specifies a boost condition. The syntax and supported fields are the same as a filter expression. See SearchRequest.filter for detail syntax and limitations. Examples: * To boost documents with document ID &quot;doc_1&quot; or &quot;doc_2&quot;, and color &quot;Red&quot; or &quot;Blue&quot;: `(document_id: ANY(&quot;doc_1&quot;, &quot;doc_2&quot;)) AND (color: ANY(&quot;Red&quot;, &quot;Blue&quot;))`
        },
      ],
    },
    &quot;branch&quot;: &quot;A String&quot;, # The branch resource name, such as `projects/*/locations/global/collections/default_collection/dataStores/default_data_store/branches/0`. Use `default_branch` as the branch ID or leave this field empty, to search documents under the default branch.
    &quot;canonicalFilter&quot;: &quot;A String&quot;, # The default filter that is applied when a user performs a search without checking any filters on the search page. The filter applied to every search request when quality improvement such as query expansion is needed. In the case a query does not have a sufficient amount of results this filter will be used to determine whether or not to enable the query expansion flow. The original filter will still be used for the query expanded search. This field is strongly recommended to achieve high search quality. For more information about filter syntax, see SearchRequest.filter.
    &quot;contentSearchSpec&quot;: { # A specification for configuring the behavior of content search. # A specification for configuring the behavior of content search.
      &quot;chunkSpec&quot;: { # Specifies the chunk spec to be returned from the search response. Only available if the SearchRequest.ContentSearchSpec.search_result_mode is set to CHUNKS # Specifies the chunk spec to be returned from the search response. Only available if the SearchRequest.ContentSearchSpec.search_result_mode is set to CHUNKS
        &quot;numNextChunks&quot;: 42, # The number of next chunks to be returned of the current chunk. The maximum allowed value is 3. If not specified, no next chunks will be returned.
        &quot;numPreviousChunks&quot;: 42, # The number of previous chunks to be returned of the current chunk. The maximum allowed value is 3. If not specified, no previous chunks will be returned.
      },
      &quot;extractiveContentSpec&quot;: { # A specification for configuring the extractive content in a search response. # If there is no extractive_content_spec provided, there will be no extractive answer in the search response.
        &quot;maxExtractiveAnswerCount&quot;: 42, # The maximum number of extractive answers returned in each search result. An extractive answer is a verbatim answer extracted from the original document, which provides a precise and contextually relevant answer to the search query. If the number of matching answers is less than the `max_extractive_answer_count`, return all of the answers. Otherwise, return the `max_extractive_answer_count`. At most five answers are returned for each SearchResult.
        &quot;maxExtractiveSegmentCount&quot;: 42, # The max number of extractive segments returned in each search result. Only applied if the DataStore is set to DataStore.ContentConfig.CONTENT_REQUIRED or DataStore.solution_types is SOLUTION_TYPE_CHAT. An extractive segment is a text segment extracted from the original document that is relevant to the search query, and, in general, more verbose than an extractive answer. The segment could then be used as input for LLMs to generate summaries and answers. If the number of matching segments is less than `max_extractive_segment_count`, return all of the segments. Otherwise, return the `max_extractive_segment_count`.
        &quot;numNextSegments&quot;: 42, # Return at most `num_next_segments` segments after each selected segments.
        &quot;numPreviousSegments&quot;: 42, # Specifies whether to also include the adjacent from each selected segments. Return at most `num_previous_segments` segments before each selected segments.
        &quot;returnExtractiveSegmentScore&quot;: True or False, # Specifies whether to return the confidence score from the extractive segments in each search result. This feature is available only for new or allowlisted data stores. To allowlist your data store, contact your Customer Engineer. The default value is `false`.
      },
      &quot;searchResultMode&quot;: &quot;A String&quot;, # Specifies the search result mode. If unspecified, the search result mode is based on DataStore.DocumentProcessingConfig.chunking_config: * If DataStore.DocumentProcessingConfig.chunking_config is specified, it defaults to `CHUNKS`. * Otherwise, it defaults to `DOCUMENTS`.
      &quot;snippetSpec&quot;: { # A specification for configuring snippets in a search response. # If `snippetSpec` is not specified, snippets are not included in the search response.
        &quot;maxSnippetCount&quot;: 42, # [DEPRECATED] This field is deprecated. To control snippet return, use `return_snippet` field. For backwards compatibility, we will return snippet if max_snippet_count &gt; 0.
        &quot;referenceOnly&quot;: True or False, # [DEPRECATED] This field is deprecated and will have no affect on the snippet.
        &quot;returnSnippet&quot;: True or False, # If `true`, then return snippet. If no snippet can be generated, we return &quot;No snippet is available for this page.&quot; A `snippet_status` with `SUCCESS` or `NO_SNIPPET_AVAILABLE` will also be returned.
      },
      &quot;summarySpec&quot;: { # A specification for configuring a summary returned in a search response. # If `summarySpec` is not specified, summaries are not included in the search response.
        &quot;ignoreAdversarialQuery&quot;: True or False, # Specifies whether to filter out adversarial queries. The default value is `false`. Google employs search-query classification to detect adversarial queries. No summary is returned if the search query is classified as an adversarial query. For example, a user might ask a question regarding negative comments about the company or submit a query designed to generate unsafe, policy-violating output. If this field is set to `true`, we skip generating summaries for adversarial queries and return fallback messages instead.
        &quot;ignoreNonSummarySeekingQuery&quot;: True or False, # Specifies whether to filter out queries that are not summary-seeking. The default value is `false`. Google employs search-query classification to detect summary-seeking queries. No summary is returned if the search query is classified as a non-summary seeking query. For example, `why is the sky blue` and `Who is the best soccer player in the world?` are summary-seeking queries, but `SFO airport` and `world cup 2026` are not. They are most likely navigational queries. If this field is set to `true`, we skip generating summaries for non-summary seeking queries and return fallback messages instead.
        &quot;includeCitations&quot;: True or False, # Specifies whether to include citations in the summary. The default value is `false`. When this field is set to `true`, summaries include in-line citation numbers. Example summary including citations: BigQuery is Google Cloud&#x27;s fully managed and completely serverless enterprise data warehouse [1]. BigQuery supports all data types, works across clouds, and has built-in machine learning and business intelligence, all within a unified platform [2, 3]. The citation numbers refer to the returned search results and are 1-indexed. For example, [1] means that the sentence is attributed to the first search result. [2, 3] means that the sentence is attributed to both the second and third search results.
        &quot;languageCode&quot;: &quot;A String&quot;, # Language code for Summary. Use language tags defined by [BCP47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). Note: This is an experimental feature.
        &quot;modelPromptSpec&quot;: { # Specification of the prompt to use with the model. # If specified, the spec will be used to modify the prompt provided to the LLM.
          &quot;preamble&quot;: &quot;A String&quot;, # Text at the beginning of the prompt that instructs the assistant. Examples are available in the user guide.
        },
        &quot;modelSpec&quot;: { # Specification of the model. # If specified, the spec will be used to modify the model specification provided to the LLM.
          &quot;version&quot;: &quot;A String&quot;, # The model version used to generate the summary. Supported values are: * `stable`: string. Default value when no value is specified. Uses a generally available, fine-tuned model. For more information, see [Answer generation model versions and lifecycle](https://cloud.google.com/generative-ai-app-builder/docs/answer-generation-models). * `preview`: string. (Public preview) Uses a preview model. For more information, see [Answer generation model versions and lifecycle](https://cloud.google.com/generative-ai-app-builder/docs/answer-generation-models).
        },
        &quot;summaryResultCount&quot;: 42, # The number of top results to generate the summary from. If the number of results returned is less than `summaryResultCount`, the summary is generated from all of the results. At most 10 results for documents mode, or 50 for chunks mode, can be used to generate a summary. The chunks mode is used when SearchRequest.ContentSearchSpec.search_result_mode is set to CHUNKS.
        &quot;useSemanticChunks&quot;: True or False, # If true, answer will be generated from most relevant chunks from top search results. This feature will improve summary quality. Note that with this feature enabled, not all top search results will be referenced and included in the reference list, so the citation source index only points to the search results listed in the reference list.
      },
    },
    &quot;customFineTuningSpec&quot;: { # Defines custom fine tuning spec. # Custom fine tuning configs.
      &quot;enableSearchAdaptor&quot;: True or False, # Whether or not to enable and include custom fine tuned search adaptor model.
    },
    &quot;dataStoreSpecs&quot;: [ # A list of data store specs to apply on a search call.
      { # A struct to define data stores to filter on in a search call.
        &quot;dataStore&quot;: &quot;A String&quot;, # Required. Full resource name of DataStore, such as `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`.
      },
    ],
    &quot;embeddingSpec&quot;: { # The specification that uses customized query embedding vector to do semantic document retrieval. # Uses the provided embedding to do additional semantic document retrieval. The retrieval is based on the dot product of SearchRequest.EmbeddingSpec.EmbeddingVector.vector and the document embedding that is provided in SearchRequest.EmbeddingSpec.EmbeddingVector.field_path. If SearchRequest.EmbeddingSpec.EmbeddingVector.field_path is not provided, it will use ServingConfig.EmbeddingConfig.field_path.
      &quot;embeddingVectors&quot;: [ # The embedding vector used for retrieval. Limit to 1.
        { # Embedding vector.
          &quot;fieldPath&quot;: &quot;A String&quot;, # Embedding field path in schema.
          &quot;vector&quot;: [ # Query embedding vector.
            3.14,
          ],
        },
      ],
    },
    &quot;facetSpecs&quot;: [ # Facet specifications for faceted search. If empty, no facets are returned. A maximum of 100 values are allowed. Otherwise, an `INVALID_ARGUMENT` error is returned.
      { # A facet specification to perform faceted search.
        &quot;enableDynamicPosition&quot;: True or False, # Enables dynamic position for this facet. If set to true, the position of this facet among all facets in the response is determined automatically. If dynamic facets are enabled, it is ordered together. If set to false, the position of this facet in the response is the same as in the request, and it is ranked before the facets with dynamic position enable and all dynamic facets. For example, you may always want to have rating facet returned in the response, but it&#x27;s not necessarily to always display the rating facet at the top. In that case, you can set enable_dynamic_position to true so that the position of rating facet in response is determined automatically. Another example, assuming you have the following facets in the request: * &quot;rating&quot;, enable_dynamic_position = true * &quot;price&quot;, enable_dynamic_position = false * &quot;brands&quot;, enable_dynamic_position = false And also you have a dynamic facets enabled, which generates a facet `gender`. Then the final order of the facets in the response can be (&quot;price&quot;, &quot;brands&quot;, &quot;rating&quot;, &quot;gender&quot;) or (&quot;price&quot;, &quot;brands&quot;, &quot;gender&quot;, &quot;rating&quot;) depends on how API orders &quot;gender&quot; and &quot;rating&quot; facets. However, notice that &quot;price&quot; and &quot;brands&quot; are always ranked at first and second position because their enable_dynamic_position is false.
        &quot;excludedFilterKeys&quot;: [ # List of keys to exclude when faceting. By default, FacetKey.key is not excluded from the filter unless it is listed in this field. Listing a facet key in this field allows its values to appear as facet results, even when they are filtered out of search results. Using this field does not affect what search results are returned. For example, suppose there are 100 documents with the color facet &quot;Red&quot; and 200 documents with the color facet &quot;Blue&quot;. A query containing the filter &quot;color:ANY(&quot;Red&quot;)&quot; and having &quot;color&quot; as FacetKey.key would by default return only &quot;Red&quot; documents in the search results, and also return &quot;Red&quot; with count 100 as the only color facet. Although there are also blue documents available, &quot;Blue&quot; would not be shown as an available facet value. If &quot;color&quot; is listed in &quot;excludedFilterKeys&quot;, then the query returns the facet values &quot;Red&quot; with count 100 and &quot;Blue&quot; with count 200, because the &quot;color&quot; key is now excluded from the filter. Because this field doesn&#x27;t affect search results, the search results are still correctly filtered to return only &quot;Red&quot; documents. A maximum of 100 values are allowed. Otherwise, an `INVALID_ARGUMENT` error is returned.
          &quot;A String&quot;,
        ],
        &quot;facetKey&quot;: { # Specifies how a facet is computed. # Required. The facet key specification.
          &quot;caseInsensitive&quot;: True or False, # True to make facet keys case insensitive when getting faceting values with prefixes or contains; false otherwise.
          &quot;contains&quot;: [ # Only get facet values that contains the given strings. For example, suppose &quot;category&quot; has three values &quot;Action &gt; 2022&quot;, &quot;Action &gt; 2021&quot; and &quot;Sci-Fi &gt; 2022&quot;. If set &quot;contains&quot; to &quot;2022&quot;, the &quot;category&quot; facet only contains &quot;Action &gt; 2022&quot; and &quot;Sci-Fi &gt; 2022&quot;. Only supported on textual fields. Maximum is 10.
            &quot;A String&quot;,
          ],
          &quot;intervals&quot;: [ # Set only if values should be bucketed into intervals. Must be set for facets with numerical values. Must not be set for facet with text values. Maximum number of intervals is 30.
            { # A floating point interval.
              &quot;exclusiveMaximum&quot;: 3.14, # Exclusive upper bound.
              &quot;exclusiveMinimum&quot;: 3.14, # Exclusive lower bound.
              &quot;maximum&quot;: 3.14, # Inclusive upper bound.
              &quot;minimum&quot;: 3.14, # Inclusive lower bound.
            },
          ],
          &quot;key&quot;: &quot;A String&quot;, # Required. Supported textual and numerical facet keys in Document object, over which the facet values are computed. Facet key is case-sensitive.
          &quot;orderBy&quot;: &quot;A String&quot;, # The order in which documents are returned. Allowed values are: * &quot;count desc&quot;, which means order by SearchResponse.Facet.values.count descending. * &quot;value desc&quot;, which means order by SearchResponse.Facet.values.value descending. Only applies to textual facets. If not set, textual values are sorted in [natural order](https://en.wikipedia.org/wiki/Natural_sort_order); numerical intervals are sorted in the order given by FacetSpec.FacetKey.intervals.
          &quot;prefixes&quot;: [ # Only get facet values that start with the given string prefix. For example, suppose &quot;category&quot; has three values &quot;Action &gt; 2022&quot;, &quot;Action &gt; 2021&quot; and &quot;Sci-Fi &gt; 2022&quot;. If set &quot;prefixes&quot; to &quot;Action&quot;, the &quot;category&quot; facet only contains &quot;Action &gt; 2022&quot; and &quot;Action &gt; 2021&quot;. Only supported on textual fields. Maximum is 10.
            &quot;A String&quot;,
          ],
          &quot;restrictedValues&quot;: [ # Only get facet for the given restricted values. Only supported on textual fields. For example, suppose &quot;category&quot; has three values &quot;Action &gt; 2022&quot;, &quot;Action &gt; 2021&quot; and &quot;Sci-Fi &gt; 2022&quot;. If set &quot;restricted_values&quot; to &quot;Action &gt; 2022&quot;, the &quot;category&quot; facet only contains &quot;Action &gt; 2022&quot;. Only supported on textual fields. Maximum is 10.
            &quot;A String&quot;,
          ],
        },
        &quot;limit&quot;: 42, # Maximum of facet values that should be returned for this facet. If unspecified, defaults to 20. The maximum allowed value is 300. Values above 300 are coerced to 300. If this field is negative, an `INVALID_ARGUMENT` is returned.
      },
    ],
    &quot;filter&quot;: &quot;A String&quot;, # The filter syntax consists of an expression language for constructing a predicate from one or more fields of the documents being filtered. Filter expression is case-sensitive. If this field is unrecognizable, an `INVALID_ARGUMENT` is returned. Filtering in Vertex AI Search is done by mapping the LHS filter key to a key property defined in the Vertex AI Search backend -- this mapping is defined by the customer in their schema. For example a media customer might have a field &#x27;name&#x27; in their schema. In this case the filter would look like this: filter --&gt; name:&#x27;ANY(&quot;king kong&quot;)&#x27; For more information about filtering including syntax and filter operators, see [Filter](https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata)
    &quot;imageQuery&quot;: { # Specifies the image query input. # Raw image query.
      &quot;imageBytes&quot;: &quot;A String&quot;, # Base64 encoded image bytes. Supported image formats: JPEG, PNG, and BMP.
    },
    &quot;offset&quot;: 42, # A 0-indexed integer that specifies the current offset (that is, starting result location, amongst the Documents deemed by the API as relevant) in search results. This field is only considered if page_token is unset. If this field is negative, an `INVALID_ARGUMENT` is returned.
    &quot;orderBy&quot;: &quot;A String&quot;, # The order in which documents are returned. Documents can be ordered by a field in an Document object. Leave it unset if ordered by relevance. `order_by` expression is case-sensitive. For more information on ordering, see [Ordering](https://cloud.google.com/retail/docs/filter-and-order#order) If this field is unrecognizable, an `INVALID_ARGUMENT` is returned.
    &quot;pageSize&quot;: 42, # Maximum number of Documents to return. The maximum allowed value depends on the data type. Values above the maximum value are coerced to the maximum value. * Websites with basic indexing: Default `10`, Maximum `25`. * Websites with advanced indexing: Default `25`, Maximum `50`. * Other: Default `50`, Maximum `100`. If this field is negative, an `INVALID_ARGUMENT` is returned.
    &quot;pageToken&quot;: &quot;A String&quot;, # A page token received from a previous SearchService.Search call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to SearchService.Search must match the call that provided the page token. Otherwise, an `INVALID_ARGUMENT` error is returned.
    &quot;params&quot;: { # Additional search parameters. For public website search only, supported values are: * `user_country_code`: string. Default empty. If set to non-empty, results are restricted or boosted based on the location provided. Example: user_country_code: &quot;au&quot; For available codes see [Country Codes](https://developers.google.com/custom-search/docs/json_api_reference#countryCodes) * `search_type`: double. Default empty. Enables non-webpage searching depending on the value. The only valid non-default value is 1, which enables image searching. Example: search_type: 1
      &quot;a_key&quot;: &quot;&quot;,
    },
    &quot;query&quot;: &quot;A String&quot;, # Raw search query.
    &quot;queryExpansionSpec&quot;: { # Specification to determine under which conditions query expansion should occur. # The query expansion specification that specifies the conditions under which query expansion occurs.
      &quot;condition&quot;: &quot;A String&quot;, # The condition under which query expansion should occur. Default to Condition.DISABLED.
      &quot;pinUnexpandedResults&quot;: True or False, # Whether to pin unexpanded results. If this field is set to true, unexpanded products are always at the top of the search results, followed by the expanded results.
    },
    &quot;rankingExpression&quot;: &quot;A String&quot;, # The ranking expression controls the customized ranking on retrieval documents. This overrides ServingConfig.ranking_expression. The ranking expression is a single function or multiple functions that are joint by &quot;+&quot;. * ranking_expression = function, { &quot; + &quot;, function }; Supported functions: * double * relevance_score * double * dotProduct(embedding_field_path) Function variables: `relevance_score`: pre-defined keywords, used for measure relevance between query and document. `embedding_field_path`: the document embedding field used with query embedding vector. `dotProduct`: embedding function between embedding_field_path and query embedding vector. Example ranking expression: If document has an embedding field doc_embedding, the ranking expression could be `0.5 * relevance_score + 0.3 * dotProduct(doc_embedding)`.
    &quot;safeSearch&quot;: True or False, # Whether to turn on safe search. This is only supported for website search.
    &quot;servingConfig&quot;: &quot;A String&quot;, # Required. The resource name of the Search serving config, such as `projects/*/locations/global/collections/default_collection/engines/*/servingConfigs/default_serving_config`, or `projects/*/locations/global/collections/default_collection/dataStores/default_data_store/servingConfigs/default_serving_config`. This field is used to identify the serving configuration name, set of models used to make the search.
    &quot;spellCorrectionSpec&quot;: { # The specification for query spell correction. # The spell correction specification that specifies the mode under which spell correction takes effect.
      &quot;mode&quot;: &quot;A String&quot;, # The mode under which spell correction should take effect to replace the original search query. Default to Mode.AUTO.
    },
    &quot;userInfo&quot;: { # Information of an end user. # Information about the end user. Highly recommended for analytics. UserInfo.user_agent is used to deduce `device_type` for analytics.
      &quot;userAgent&quot;: &quot;A String&quot;, # User agent as included in the HTTP header. The field must be a UTF-8 encoded string with a length limit of 1,000 characters. Otherwise, an `INVALID_ARGUMENT` error is returned. This should not be set when using the client side event reporting with GTM or JavaScript tag in UserEventService.CollectUserEvent or if UserEvent.direct_user_request is set.
      &quot;userId&quot;: &quot;A String&quot;, # Highly recommended for logged-in users. Unique identifier for logged-in user, such as a user name. Don&#x27;t set for anonymous users. Always use a hashed value for this ID. Don&#x27;t set the field to the same fixed ID for different users. This mixes the event history of those users together, which results in degraded model quality. The field must be a UTF-8 encoded string with a length limit of 128 characters. Otherwise, an `INVALID_ARGUMENT` error is returned.
    },
    &quot;userLabels&quot;: { # The user labels applied to a resource must meet the following requirements: * Each resource can have multiple labels, up to a maximum of 64. * Each label must be a key-value pair. * Keys have a minimum length of 1 character and a maximum length of 63 characters and cannot be empty. Values can be empty and have a maximum length of 63 characters. * Keys and values can contain only lowercase letters, numeric characters, underscores, and dashes. All characters must use UTF-8 encoding, and international characters are allowed. * The key portion of a label must be unique. However, you can use the same key with multiple resources. * Keys must start with a lowercase letter or international character. See [Google Cloud Document](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements) for more details.
      &quot;a_key&quot;: &quot;A String&quot;,
    },
    &quot;userPseudoId&quot;: &quot;A String&quot;, # A unique identifier for tracking visitors. For example, this could be implemented with an HTTP cookie, which should be able to uniquely identify a visitor on a single device. This unique identifier should not change if the visitor logs in or out of the website. This field should NOT have a fixed value such as `unknown_visitor`. This should be the same identifier as UserEvent.user_pseudo_id and CompleteQueryRequest.user_pseudo_id The field must be a UTF-8 encoded string with a length limit of 128 characters. Otherwise, an `INVALID_ARGUMENT` error is returned.
  },
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response message for WidgetService.WidgetSearch method.
  &quot;searchResponse&quot;: { # Response message for SearchService.Search method. # The search response after performing search.
    &quot;appliedControls&quot;: [ # Controls applied as part of the Control service.
      &quot;A String&quot;,
    ],
    &quot;attributionToken&quot;: &quot;A String&quot;, # A unique search token. This should be included in the UserEvent logs resulting from this search, which enables accurate attribution of search model performance.
    &quot;correctedQuery&quot;: &quot;A String&quot;, # Contains the spell corrected query, if found. If the spell correction type is AUTOMATIC, then the search results are based on corrected_query. Otherwise the original query is used for search.
    &quot;facets&quot;: [ # Results of facets requested by user.
      { # A facet result.
        &quot;dynamicFacet&quot;: True or False, # Whether the facet is dynamically generated.
        &quot;key&quot;: &quot;A String&quot;, # The key for this facet. E.g., &quot;colors&quot; or &quot;price&quot;. It matches SearchRequest.FacetSpec.FacetKey.key.
        &quot;values&quot;: [ # The facet values for this field.
          { # A facet value which contains value names and their count.
            &quot;count&quot;: &quot;A String&quot;, # Number of items that have this facet value.
            &quot;interval&quot;: { # A floating point interval. # Interval value for a facet, such as 10, 20) for facet &quot;price&quot;. It matches [SearchRequest.FacetSpec.FacetKey.intervals.
              &quot;exclusiveMaximum&quot;: 3.14, # Exclusive upper bound.
              &quot;exclusiveMinimum&quot;: 3.14, # Exclusive lower bound.
              &quot;maximum&quot;: 3.14, # Inclusive upper bound.
              &quot;minimum&quot;: 3.14, # Inclusive lower bound.
            },
            &quot;value&quot;: &quot;A String&quot;, # Text value of a facet, such as &quot;Black&quot; for facet &quot;colors&quot;.
          },
        ],
      },
    ],
    &quot;geoSearchDebugInfo&quot;: [
      { # Debug information specifically related to forward geocoding issues arising from Geolocation Search.
        &quot;errorMessage&quot;: &quot;A String&quot;, # The error produced.
        &quot;originalAddressQuery&quot;: &quot;A String&quot;, # The address from which forward geocoding ingestion produced issues.
      },
    ],
    &quot;guidedSearchResult&quot;: { # Guided search result. The guided search helps user to refine the search results and narrow down to the real needs from a broaded search results. # Guided search result.
      &quot;followUpQuestions&quot;: [ # Suggested follow-up questions.
        &quot;A String&quot;,
      ],
      &quot;refinementAttributes&quot;: [ # A list of ranked refinement attributes.
        { # Useful attribute for search result refinements.
          &quot;attributeKey&quot;: &quot;A String&quot;, # Attribute key used to refine the results e.g. &#x27;movie_type&#x27;.
          &quot;attributeValue&quot;: &quot;A String&quot;, # Attribute value used to refine the results e.g. &#x27;drama&#x27;.
        },
      ],
    },
    &quot;nextPageToken&quot;: &quot;A String&quot;, # A token that can be sent as SearchRequest.page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.
    &quot;queryExpansionInfo&quot;: { # Information describing query expansion including whether expansion has occurred. # Query expansion information for the returned results.
      &quot;expandedQuery&quot;: True or False, # Bool describing whether query expansion has occurred.
      &quot;pinnedResultCount&quot;: &quot;A String&quot;, # Number of pinned results. This field will only be set when expansion happens and SearchRequest.QueryExpansionSpec.pin_unexpanded_results is set to true.
    },
    &quot;redirectUri&quot;: &quot;A String&quot;, # The URI of a customer-defined redirect page. If redirect action is triggered, no search is performed, and only redirect_uri and attribution_token are set in the response.
    &quot;results&quot;: [ # A list of matched documents. The order represents the ranking.
      { # Represents the search results.
        &quot;chunk&quot;: { # Chunk captures all raw metadata information of items to be recommended or searched in the chunk mode. # The chunk data in the search response if the SearchRequest.ContentSearchSpec.search_result_mode is set to CHUNKS.
          &quot;chunkMetadata&quot;: { # Metadata of the current chunk. This field is only populated on SearchService.Search API. # Output only. Metadata of the current chunk.
            &quot;nextChunks&quot;: [ # The next chunks of the current chunk. The number is controlled by SearchRequest.ContentSearchSpec.ChunkSpec.num_next_chunks. This field is only populated on SearchService.Search API.
              # Object with schema name: GoogleCloudDiscoveryengineV1alphaChunk
            ],
            &quot;previousChunks&quot;: [ # The previous chunks of the current chunk. The number is controlled by SearchRequest.ContentSearchSpec.ChunkSpec.num_previous_chunks. This field is only populated on SearchService.Search API.
              # Object with schema name: GoogleCloudDiscoveryengineV1alphaChunk
            ],
          },
          &quot;content&quot;: &quot;A String&quot;, # Content is a string from a document (parsed content).
          &quot;derivedStructData&quot;: { # Output only. This field is OUTPUT_ONLY. It contains derived data that are not in the original input document.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;documentMetadata&quot;: { # Document metadata contains the information of the document of the current chunk. # Metadata of the document from the current chunk.
            &quot;structData&quot;: { # Data representation. The structured JSON data for the document. It should conform to the registered Schema or an `INVALID_ARGUMENT` error is thrown.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;title&quot;: &quot;A String&quot;, # Title of the document.
            &quot;uri&quot;: &quot;A String&quot;, # Uri of the document.
          },
          &quot;id&quot;: &quot;A String&quot;, # Unique chunk ID of the current chunk.
          &quot;name&quot;: &quot;A String&quot;, # The full resource name of the chunk. Format: `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}/documents/{document_id}/chunks/{chunk_id}`. This field must be a UTF-8 encoded string with a length limit of 1024 characters.
          &quot;pageSpan&quot;: { # Page span of the chunk. # Page span of the chunk.
            &quot;pageEnd&quot;: 42, # The end page of the chunk.
            &quot;pageStart&quot;: 42, # The start page of the chunk.
          },
        },
        &quot;document&quot;: { # Document captures all raw metadata information of items to be recommended or searched. # The document data snippet in the search response. Only fields that are marked as retrievable are populated.
          &quot;aclInfo&quot;: { # ACL Information of the Document. # Access control information for the document.
            &quot;readers&quot;: [ # Readers of the document.
              { # AclRestriction to model complex inheritance restrictions. Example: Modeling a &quot;Both Permit&quot; inheritance, where to access a child document, user needs to have access to parent document. Document Hierarchy - Space_S --&gt; Page_P. Readers: Space_S: group_1, user_1 Page_P: group_2, group_3, user_2 Space_S ACL Restriction - { &quot;acl_info&quot;: { &quot;readers&quot;: [ { &quot;principals&quot;: [ { &quot;group_id&quot;: &quot;group_1&quot; }, { &quot;user_id&quot;: &quot;user_1&quot; } ] } ] } } Page_P ACL Restriction. { &quot;acl_info&quot;: { &quot;readers&quot;: [ { &quot;principals&quot;: [ { &quot;group_id&quot;: &quot;group_2&quot; }, { &quot;group_id&quot;: &quot;group_3&quot; }, { &quot;user_id&quot;: &quot;user_2&quot; } ], }, { &quot;principals&quot;: [ { &quot;group_id&quot;: &quot;group_1&quot; }, { &quot;user_id&quot;: &quot;user_1&quot; } ], } ] } }
                &quot;principals&quot;: [ # List of principals.
                  { # Principal identifier of a user or a group.
                    &quot;groupId&quot;: &quot;A String&quot;, # Group identifier. For Google Workspace user account, group_id should be the google workspace group email. For non-google identity provider user account, group_id is the mapped group identifier configured during the workforcepool config.
                    &quot;userId&quot;: &quot;A String&quot;, # User identifier. For Google Workspace user account, user_id should be the google workspace user email. For non-google identity provider user account, user_id is the mapped user identifier configured during the workforcepool config.
                  },
                ],
              },
            ],
          },
          &quot;content&quot;: { # Unstructured data linked to this document. # The unstructured data linked to this document. Content must be set if this document is under a `CONTENT_REQUIRED` data store.
            &quot;mimeType&quot;: &quot;A String&quot;, # The MIME type of the content. Supported types: * `application/pdf` (PDF, only native PDFs are supported for now) * `text/html` (HTML) * `application/vnd.openxmlformats-officedocument.wordprocessingml.document` (DOCX) * `application/vnd.openxmlformats-officedocument.presentationml.presentation` (PPTX) * `text/plain` (TXT) See https://www.iana.org/assignments/media-types/media-types.xhtml.
            &quot;rawBytes&quot;: &quot;A String&quot;, # The content represented as a stream of bytes. The maximum length is 1,000,000 bytes (1 MB / ~0.95 MiB). Note: As with all `bytes` fields, this field is represented as pure binary in Protocol Buffers and base64-encoded string in JSON. For example, `abc123!?$*&amp;()&#x27;-=@~` should be represented as `YWJjMTIzIT8kKiYoKSctPUB+` in JSON. See https://developers.google.com/protocol-buffers/docs/proto3#json.
            &quot;uri&quot;: &quot;A String&quot;, # The URI of the content. Only Cloud Storage URIs (e.g. `gs://bucket-name/path/to/file`) are supported. The maximum file size is 2.5 MB for text-based formats, 100 MB for other formats.
          },
          &quot;derivedStructData&quot;: { # Output only. This field is OUTPUT_ONLY. It contains derived data that are not in the original input document.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;id&quot;: &quot;A String&quot;, # Immutable. The identifier of the document. Id should conform to [RFC-1034](https://tools.ietf.org/html/rfc1034) standard with a length limit of 63 characters.
          &quot;indexTime&quot;: &quot;A String&quot;, # Output only. The last time the document was indexed. If this field is set, the document could be returned in search results. This field is OUTPUT_ONLY. If this field is not populated, it means the document has never been indexed.
          &quot;jsonData&quot;: &quot;A String&quot;, # The JSON string representation of the document. It should conform to the registered Schema or an `INVALID_ARGUMENT` error is thrown.
          &quot;name&quot;: &quot;A String&quot;, # Immutable. The full resource name of the document. Format: `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}/documents/{document_id}`. This field must be a UTF-8 encoded string with a length limit of 1024 characters.
          &quot;parentDocumentId&quot;: &quot;A String&quot;, # The identifier of the parent document. Currently supports at most two level document hierarchy. Id should conform to [RFC-1034](https://tools.ietf.org/html/rfc1034) standard with a length limit of 63 characters.
          &quot;schemaId&quot;: &quot;A String&quot;, # The identifier of the schema located in the same data store.
          &quot;structData&quot;: { # The structured JSON data for the document. It should conform to the registered Schema or an `INVALID_ARGUMENT` error is thrown.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
        },
        &quot;id&quot;: &quot;A String&quot;, # Document.id of the searched Document.
        &quot;modelScores&quot;: { # Google provided available scores.
          &quot;a_key&quot;: { # Double list.
            &quot;values&quot;: [ # Double values.
              3.14,
            ],
          },
        },
      },
    ],
    &quot;summary&quot;: { # Summary of the top N search result specified by the summary spec. # A summary as part of the search results. This field is only returned if SearchRequest.ContentSearchSpec.summary_spec is set.
      &quot;safetyAttributes&quot;: { # Safety Attribute categories and their associated confidence scores. # A collection of Safety Attribute categories and their associated confidence scores.
        &quot;categories&quot;: [ # The display names of Safety Attribute categories associated with the generated content. Order matches the Scores.
          &quot;A String&quot;,
        ],
        &quot;scores&quot;: [ # The confidence scores of the each category, higher value means higher confidence. Order matches the Categories.
          3.14,
        ],
      },
      &quot;summarySkippedReasons&quot;: [ # Additional summary-skipped reasons. This provides the reason for ignored cases. If nothing is skipped, this field is not set.
        &quot;A String&quot;,
      ],
      &quot;summaryText&quot;: &quot;A String&quot;, # The summary content.
      &quot;summaryWithMetadata&quot;: { # Summary with metadata information. # Summary with metadata information.
        &quot;citationMetadata&quot;: { # Citation metadata. # Citation metadata for given summary.
          &quot;citations&quot;: [ # Citations for segments.
            { # Citation info for a segment.
              &quot;endIndex&quot;: &quot;A String&quot;, # End of the attributed segment, exclusive.
              &quot;sources&quot;: [ # Citation sources for the attributed segment.
                { # Citation source.
                  &quot;referenceIndex&quot;: &quot;A String&quot;, # Document reference index from SummaryWithMetadata.references. It is 0-indexed and the value will be zero if the reference_index is not set explicitly.
                },
              ],
              &quot;startIndex&quot;: &quot;A String&quot;, # Index indicates the start of the segment, measured in bytes/unicode.
            },
          ],
        },
        &quot;references&quot;: [ # Document References.
          { # Document reference.
            &quot;chunkContents&quot;: [ # List of cited chunk contents derived from document content.
              { # Chunk content.
                &quot;content&quot;: &quot;A String&quot;, # Chunk textual content.
                &quot;pageIdentifier&quot;: &quot;A String&quot;, # Page identifier.
              },
            ],
            &quot;document&quot;: &quot;A String&quot;, # Required. Document.name of the document. Full resource name of the referenced document, in the format `projects/*/locations/*/collections/*/dataStores/*/branches/*/documents/*`.
            &quot;title&quot;: &quot;A String&quot;, # Title of the document.
            &quot;uri&quot;: &quot;A String&quot;, # Cloud Storage or HTTP uri for the document.
          },
        ],
        &quot;summary&quot;: &quot;A String&quot;, # Summary text with no citation information.
      },
    },
    &quot;totalSize&quot;: 42, # The estimated total count of matched items irrespective of pagination. The count of results returned by pagination may be less than the total_size that matches.
  },
  &quot;uToken&quot;: &quot;A String&quot;, # The token in response.
}</pre>
</div>

</body></html>