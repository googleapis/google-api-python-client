<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="ces_v1beta.html">Gemini Enterprise for Customer Experience API</a> . <a href="ces_v1beta.projects.html">projects</a> . <a href="ces_v1beta.projects.locations.html">locations</a> . <a href="ces_v1beta.projects.locations.apps.html">apps</a> . <a href="ces_v1beta.projects.locations.apps.guardrails.html">guardrails</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#create">create(parent, body=None, guardrailId=None, x__xgafv=None)</a></code></p>
<p class="firstline">Creates a new guardrail in the given app.</p>
<p class="toc_element">
  <code><a href="#delete">delete(name, etag=None, force=None, x__xgafv=None)</a></code></p>
<p class="firstline">Deletes the specified guardrail.</p>
<p class="toc_element">
  <code><a href="#get">get(name, x__xgafv=None)</a></code></p>
<p class="firstline">Gets details of the specified guardrail.</p>
<p class="toc_element">
  <code><a href="#list">list(parent, filter=None, orderBy=None, pageSize=None, pageToken=None, x__xgafv=None)</a></code></p>
<p class="firstline">Lists guardrails in the given app.</p>
<p class="toc_element">
  <code><a href="#list_next">list_next()</a></code></p>
<p class="firstline">Retrieves the next page of results.</p>
<p class="toc_element">
  <code><a href="#patch">patch(name, body=None, updateMask=None, x__xgafv=None)</a></code></p>
<p class="firstline">Updates the specified guardrail.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="create">create(parent, body=None, guardrailId=None, x__xgafv=None)</code>
  <pre>Creates a new guardrail in the given app.

Args:
  parent: string, Required. The resource name of the app to create a guardrail in. (required)
  body: object, The request body.
    The object takes the form of:

{ # Guardrail contains a list of checks and balances to keep the agents safe and secure.
  &quot;action&quot;: { # Action that is taken when a certain precondition is met. # Optional. Action to take when the guardrail is triggered.
    &quot;generativeAnswer&quot;: { # The agent will immediately respond with a generative answer. # Optional. Respond with a generative answer.
      &quot;prompt&quot;: &quot;A String&quot;, # Required. The prompt to use for the generative answer.
    },
    &quot;respondImmediately&quot;: { # The agent will immediately respond with a preconfigured response. # Optional. Immediately respond with a preconfigured response.
      &quot;responses&quot;: [ # Required. The canned responses for the agent to choose from. The response is chosen randomly.
        { # Represents a response from the agent.
          &quot;disabled&quot;: True or False, # Optional. Whether the response is disabled. Disabled responses are not used by the agent.
          &quot;text&quot;: &quot;A String&quot;, # Required. Text for the agent to respond with.
        },
      ],
    },
    &quot;transferAgent&quot;: { # The agent will transfer the conversation to a different agent. # Optional. Transfer the conversation to a different agent.
      &quot;agent&quot;: &quot;A String&quot;, # Required. The name of the agent to transfer the conversation to. The agent must be in the same app as the current agent. Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
    },
  },
  &quot;codeCallback&quot;: { # Guardrail that blocks the conversation based on the code callbacks provided. # Optional. Guardrail that potentially blocks the conversation based on the result of the callback execution.
    &quot;afterAgentCallback&quot;: { # A callback defines the custom logic to be executed at various stages of agent interaction. # Optional. The callback to execute after the agent is called. Each callback function is expected to return a structure (e.g., a dict or object) containing at least: - &#x27;decision&#x27;: Either &#x27;OK&#x27; or &#x27;TRIGGER&#x27;. - &#x27;reason&#x27;: A string explaining the decision. A &#x27;TRIGGER&#x27; decision may halt further processing.
      &quot;description&quot;: &quot;A String&quot;, # Optional. Human-readable description of the callback.
      &quot;disabled&quot;: True or False, # Optional. Whether the callback is disabled. Disabled callbacks are ignored by the agent.
      &quot;proactiveExecutionEnabled&quot;: True or False, # Optional. If enabled, the callback will also be executed on intermediate model outputs. This setting only affects after model callback. **ENABLE WITH CAUTION**. Typically after model callback only needs to be executed after receiving all model responses. Enabling proactive execution may have negative implication on the execution cost and latency, and should only be enabled in rare situations.
      &quot;pythonCode&quot;: &quot;A String&quot;, # Required. The python code to execute for the callback.
    },
    &quot;afterModelCallback&quot;: { # A callback defines the custom logic to be executed at various stages of agent interaction. # Optional. The callback to execute after the model is called. If there are multiple calls to the model, the callback will be executed multiple times. Each callback function is expected to return a structure (e.g., a dict or object) containing at least: - &#x27;decision&#x27;: Either &#x27;OK&#x27; or &#x27;TRIGGER&#x27;. - &#x27;reason&#x27;: A string explaining the decision. A &#x27;TRIGGER&#x27; decision may halt further processing.
      &quot;description&quot;: &quot;A String&quot;, # Optional. Human-readable description of the callback.
      &quot;disabled&quot;: True or False, # Optional. Whether the callback is disabled. Disabled callbacks are ignored by the agent.
      &quot;proactiveExecutionEnabled&quot;: True or False, # Optional. If enabled, the callback will also be executed on intermediate model outputs. This setting only affects after model callback. **ENABLE WITH CAUTION**. Typically after model callback only needs to be executed after receiving all model responses. Enabling proactive execution may have negative implication on the execution cost and latency, and should only be enabled in rare situations.
      &quot;pythonCode&quot;: &quot;A String&quot;, # Required. The python code to execute for the callback.
    },
    &quot;beforeAgentCallback&quot;: { # A callback defines the custom logic to be executed at various stages of agent interaction. # Optional. The callback to execute before the agent is called. Each callback function is expected to return a structure (e.g., a dict or object) containing at least: - &#x27;decision&#x27;: Either &#x27;OK&#x27; or &#x27;TRIGGER&#x27;. - &#x27;reason&#x27;: A string explaining the decision. A &#x27;TRIGGER&#x27; decision may halt further processing.
      &quot;description&quot;: &quot;A String&quot;, # Optional. Human-readable description of the callback.
      &quot;disabled&quot;: True or False, # Optional. Whether the callback is disabled. Disabled callbacks are ignored by the agent.
      &quot;proactiveExecutionEnabled&quot;: True or False, # Optional. If enabled, the callback will also be executed on intermediate model outputs. This setting only affects after model callback. **ENABLE WITH CAUTION**. Typically after model callback only needs to be executed after receiving all model responses. Enabling proactive execution may have negative implication on the execution cost and latency, and should only be enabled in rare situations.
      &quot;pythonCode&quot;: &quot;A String&quot;, # Required. The python code to execute for the callback.
    },
    &quot;beforeModelCallback&quot;: { # A callback defines the custom logic to be executed at various stages of agent interaction. # Optional. The callback to execute before the model is called. If there are multiple calls to the model, the callback will be executed multiple times. Each callback function is expected to return a structure (e.g., a dict or object) containing at least: - &#x27;decision&#x27;: Either &#x27;OK&#x27; or &#x27;TRIGGER&#x27;. - &#x27;reason&#x27;: A string explaining the decision. A &#x27;TRIGGER&#x27; decision may halt further processing.
      &quot;description&quot;: &quot;A String&quot;, # Optional. Human-readable description of the callback.
      &quot;disabled&quot;: True or False, # Optional. Whether the callback is disabled. Disabled callbacks are ignored by the agent.
      &quot;proactiveExecutionEnabled&quot;: True or False, # Optional. If enabled, the callback will also be executed on intermediate model outputs. This setting only affects after model callback. **ENABLE WITH CAUTION**. Typically after model callback only needs to be executed after receiving all model responses. Enabling proactive execution may have negative implication on the execution cost and latency, and should only be enabled in rare situations.
      &quot;pythonCode&quot;: &quot;A String&quot;, # Required. The python code to execute for the callback.
    },
  },
  &quot;contentFilter&quot;: { # Guardrail that bans certain content from being used in the conversation. # Optional. Guardrail that bans certain content from being used in the conversation.
    &quot;bannedContents&quot;: [ # Optional. List of banned phrases. Applies to both user inputs and agent responses.
      &quot;A String&quot;,
    ],
    &quot;bannedContentsInAgentResponse&quot;: [ # Optional. List of banned phrases. Applies only to agent responses.
      &quot;A String&quot;,
    ],
    &quot;bannedContentsInUserInput&quot;: [ # Optional. List of banned phrases. Applies only to user inputs.
      &quot;A String&quot;,
    ],
    &quot;disregardDiacritics&quot;: True or False, # Optional. If true, diacritics are ignored during matching.
    &quot;matchType&quot;: &quot;A String&quot;, # Required. Match type for the content filter.
  },
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when the guardrail was created.
  &quot;description&quot;: &quot;A String&quot;, # Optional. Description of the guardrail.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. Display name of the guardrail.
  &quot;enabled&quot;: True or False, # Optional. Whether the guardrail is enabled.
  &quot;etag&quot;: &quot;A String&quot;, # Etag used to ensure the object hasn&#x27;t changed during a read-modify-write operation. If the etag is empty, the update will overwrite any concurrent changes.
  &quot;llmPolicy&quot;: { # Guardrail that blocks the conversation if the LLM response is considered violating the policy based on the LLM classification. # Optional. Guardrail that blocks the conversation if the LLM response is considered violating the policy based on the LLM classification.
    &quot;allowShortUtterance&quot;: True or False, # Optional. By default, the LLM policy check is bypassed for short utterances. Enabling this setting applies the policy check to all utterances, including those that would normally be skipped.
    &quot;failOpen&quot;: True or False, # Optional. If an error occurs during the policy check, fail open and do not trigger the guardrail.
    &quot;maxConversationMessages&quot;: 42, # Optional. When checking this policy, consider the last &#x27;n&#x27; messages in the conversation. When not set a default value of 10 will be used.
    &quot;modelSettings&quot;: { # Model settings contains various configurations for the LLM model. # Optional. Model settings.
      &quot;model&quot;: &quot;A String&quot;, # Optional. The LLM model that the agent should use. If not set, the agent will inherit the model from its parent agent.
      &quot;temperature&quot;: 3.14, # Optional. If set, this temperature will be used for the LLM model. Temperature controls the randomness of the model&#x27;s responses. Lower temperatures produce responses that are more predictable. Higher temperatures produce responses that are more creative.
    },
    &quot;policyScope&quot;: &quot;A String&quot;, # Required. Defines when to apply the policy check during the conversation. If set to `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input. When applying the policy to the agent response, additional latency will be introduced before the agent can respond.
    &quot;prompt&quot;: &quot;A String&quot;, # Required. Policy prompt.
  },
  &quot;llmPromptSecurity&quot;: { # Guardrail that blocks the conversation if the input is considered unsafe based on the LLM classification. # Optional. Guardrail that blocks the conversation if the prompt is considered unsafe based on the LLM classification.
    &quot;customPolicy&quot;: { # Guardrail that blocks the conversation if the LLM response is considered violating the policy based on the LLM classification. # Optional. Use a user-defined LlmPolicy to configure the security guardrail.
      &quot;allowShortUtterance&quot;: True or False, # Optional. By default, the LLM policy check is bypassed for short utterances. Enabling this setting applies the policy check to all utterances, including those that would normally be skipped.
      &quot;failOpen&quot;: True or False, # Optional. If an error occurs during the policy check, fail open and do not trigger the guardrail.
      &quot;maxConversationMessages&quot;: 42, # Optional. When checking this policy, consider the last &#x27;n&#x27; messages in the conversation. When not set a default value of 10 will be used.
      &quot;modelSettings&quot;: { # Model settings contains various configurations for the LLM model. # Optional. Model settings.
        &quot;model&quot;: &quot;A String&quot;, # Optional. The LLM model that the agent should use. If not set, the agent will inherit the model from its parent agent.
        &quot;temperature&quot;: 3.14, # Optional. If set, this temperature will be used for the LLM model. Temperature controls the randomness of the model&#x27;s responses. Lower temperatures produce responses that are more predictable. Higher temperatures produce responses that are more creative.
      },
      &quot;policyScope&quot;: &quot;A String&quot;, # Required. Defines when to apply the policy check during the conversation. If set to `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input. When applying the policy to the agent response, additional latency will be introduced before the agent can respond.
      &quot;prompt&quot;: &quot;A String&quot;, # Required. Policy prompt.
    },
    &quot;defaultSettings&quot;: { # Configuration for default system security settings. # Optional. Use the system&#x27;s predefined default security settings. To select this mode, include an empty &#x27;default_settings&#x27; message in the request. The &#x27;default_prompt_template&#x27; field within will be populated by the server in the response.
      &quot;defaultPromptTemplate&quot;: &quot;A String&quot;, # Output only. The default prompt template used by the system. This field is for display purposes to show the user what prompt the system uses by default. It is OUTPUT_ONLY.
    },
    &quot;failOpen&quot;: True or False, # Optional. Determines the behavior when the guardrail encounters an LLM error. - If true: the guardrail is bypassed. - If false (default): the guardrail triggers/blocks. Note: If a custom policy is provided, this field is ignored in favor of the policy&#x27;s &#x27;fail_open&#x27; configuration.
  },
  &quot;modelSafety&quot;: { # Model safety settings overrides. When this is set, it will override the default settings and trigger the guardrail if the response is considered unsafe. # Optional. Guardrail that blocks the conversation if the LLM response is considered unsafe based on the model safety settings.
    &quot;safetySettings&quot;: [ # Required. List of safety settings.
      { # Safety setting.
        &quot;category&quot;: &quot;A String&quot;, # Required. The harm category.
        &quot;threshold&quot;: &quot;A String&quot;, # Required. The harm block threshold.
      },
    ],
  },
  &quot;name&quot;: &quot;A String&quot;, # Identifier. The unique identifier of the guardrail. Format: `projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}`
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when the guardrail was last updated.
}

  guardrailId: string, Optional. The ID to use for the guardrail, which will become the final component of the guardrail&#x27;s resource name. If not provided, a unique ID will be automatically assigned for the guardrail.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Guardrail contains a list of checks and balances to keep the agents safe and secure.
  &quot;action&quot;: { # Action that is taken when a certain precondition is met. # Optional. Action to take when the guardrail is triggered.
    &quot;generativeAnswer&quot;: { # The agent will immediately respond with a generative answer. # Optional. Respond with a generative answer.
      &quot;prompt&quot;: &quot;A String&quot;, # Required. The prompt to use for the generative answer.
    },
    &quot;respondImmediately&quot;: { # The agent will immediately respond with a preconfigured response. # Optional. Immediately respond with a preconfigured response.
      &quot;responses&quot;: [ # Required. The canned responses for the agent to choose from. The response is chosen randomly.
        { # Represents a response from the agent.
          &quot;disabled&quot;: True or False, # Optional. Whether the response is disabled. Disabled responses are not used by the agent.
          &quot;text&quot;: &quot;A String&quot;, # Required. Text for the agent to respond with.
        },
      ],
    },
    &quot;transferAgent&quot;: { # The agent will transfer the conversation to a different agent. # Optional. Transfer the conversation to a different agent.
      &quot;agent&quot;: &quot;A String&quot;, # Required. The name of the agent to transfer the conversation to. The agent must be in the same app as the current agent. Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
    },
  },
  &quot;codeCallback&quot;: { # Guardrail that blocks the conversation based on the code callbacks provided. # Optional. Guardrail that potentially blocks the conversation based on the result of the callback execution.
    &quot;afterAgentCallback&quot;: { # A callback defines the custom logic to be executed at various stages of agent interaction. # Optional. The callback to execute after the agent is called. Each callback function is expected to return a structure (e.g., a dict or object) containing at least: - &#x27;decision&#x27;: Either &#x27;OK&#x27; or &#x27;TRIGGER&#x27;. - &#x27;reason&#x27;: A string explaining the decision. A &#x27;TRIGGER&#x27; decision may halt further processing.
      &quot;description&quot;: &quot;A String&quot;, # Optional. Human-readable description of the callback.
      &quot;disabled&quot;: True or False, # Optional. Whether the callback is disabled. Disabled callbacks are ignored by the agent.
      &quot;proactiveExecutionEnabled&quot;: True or False, # Optional. If enabled, the callback will also be executed on intermediate model outputs. This setting only affects after model callback. **ENABLE WITH CAUTION**. Typically after model callback only needs to be executed after receiving all model responses. Enabling proactive execution may have negative implication on the execution cost and latency, and should only be enabled in rare situations.
      &quot;pythonCode&quot;: &quot;A String&quot;, # Required. The python code to execute for the callback.
    },
    &quot;afterModelCallback&quot;: { # A callback defines the custom logic to be executed at various stages of agent interaction. # Optional. The callback to execute after the model is called. If there are multiple calls to the model, the callback will be executed multiple times. Each callback function is expected to return a structure (e.g., a dict or object) containing at least: - &#x27;decision&#x27;: Either &#x27;OK&#x27; or &#x27;TRIGGER&#x27;. - &#x27;reason&#x27;: A string explaining the decision. A &#x27;TRIGGER&#x27; decision may halt further processing.
      &quot;description&quot;: &quot;A String&quot;, # Optional. Human-readable description of the callback.
      &quot;disabled&quot;: True or False, # Optional. Whether the callback is disabled. Disabled callbacks are ignored by the agent.
      &quot;proactiveExecutionEnabled&quot;: True or False, # Optional. If enabled, the callback will also be executed on intermediate model outputs. This setting only affects after model callback. **ENABLE WITH CAUTION**. Typically after model callback only needs to be executed after receiving all model responses. Enabling proactive execution may have negative implication on the execution cost and latency, and should only be enabled in rare situations.
      &quot;pythonCode&quot;: &quot;A String&quot;, # Required. The python code to execute for the callback.
    },
    &quot;beforeAgentCallback&quot;: { # A callback defines the custom logic to be executed at various stages of agent interaction. # Optional. The callback to execute before the agent is called. Each callback function is expected to return a structure (e.g., a dict or object) containing at least: - &#x27;decision&#x27;: Either &#x27;OK&#x27; or &#x27;TRIGGER&#x27;. - &#x27;reason&#x27;: A string explaining the decision. A &#x27;TRIGGER&#x27; decision may halt further processing.
      &quot;description&quot;: &quot;A String&quot;, # Optional. Human-readable description of the callback.
      &quot;disabled&quot;: True or False, # Optional. Whether the callback is disabled. Disabled callbacks are ignored by the agent.
      &quot;proactiveExecutionEnabled&quot;: True or False, # Optional. If enabled, the callback will also be executed on intermediate model outputs. This setting only affects after model callback. **ENABLE WITH CAUTION**. Typically after model callback only needs to be executed after receiving all model responses. Enabling proactive execution may have negative implication on the execution cost and latency, and should only be enabled in rare situations.
      &quot;pythonCode&quot;: &quot;A String&quot;, # Required. The python code to execute for the callback.
    },
    &quot;beforeModelCallback&quot;: { # A callback defines the custom logic to be executed at various stages of agent interaction. # Optional. The callback to execute before the model is called. If there are multiple calls to the model, the callback will be executed multiple times. Each callback function is expected to return a structure (e.g., a dict or object) containing at least: - &#x27;decision&#x27;: Either &#x27;OK&#x27; or &#x27;TRIGGER&#x27;. - &#x27;reason&#x27;: A string explaining the decision. A &#x27;TRIGGER&#x27; decision may halt further processing.
      &quot;description&quot;: &quot;A String&quot;, # Optional. Human-readable description of the callback.
      &quot;disabled&quot;: True or False, # Optional. Whether the callback is disabled. Disabled callbacks are ignored by the agent.
      &quot;proactiveExecutionEnabled&quot;: True or False, # Optional. If enabled, the callback will also be executed on intermediate model outputs. This setting only affects after model callback. **ENABLE WITH CAUTION**. Typically after model callback only needs to be executed after receiving all model responses. Enabling proactive execution may have negative implication on the execution cost and latency, and should only be enabled in rare situations.
      &quot;pythonCode&quot;: &quot;A String&quot;, # Required. The python code to execute for the callback.
    },
  },
  &quot;contentFilter&quot;: { # Guardrail that bans certain content from being used in the conversation. # Optional. Guardrail that bans certain content from being used in the conversation.
    &quot;bannedContents&quot;: [ # Optional. List of banned phrases. Applies to both user inputs and agent responses.
      &quot;A String&quot;,
    ],
    &quot;bannedContentsInAgentResponse&quot;: [ # Optional. List of banned phrases. Applies only to agent responses.
      &quot;A String&quot;,
    ],
    &quot;bannedContentsInUserInput&quot;: [ # Optional. List of banned phrases. Applies only to user inputs.
      &quot;A String&quot;,
    ],
    &quot;disregardDiacritics&quot;: True or False, # Optional. If true, diacritics are ignored during matching.
    &quot;matchType&quot;: &quot;A String&quot;, # Required. Match type for the content filter.
  },
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when the guardrail was created.
  &quot;description&quot;: &quot;A String&quot;, # Optional. Description of the guardrail.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. Display name of the guardrail.
  &quot;enabled&quot;: True or False, # Optional. Whether the guardrail is enabled.
  &quot;etag&quot;: &quot;A String&quot;, # Etag used to ensure the object hasn&#x27;t changed during a read-modify-write operation. If the etag is empty, the update will overwrite any concurrent changes.
  &quot;llmPolicy&quot;: { # Guardrail that blocks the conversation if the LLM response is considered violating the policy based on the LLM classification. # Optional. Guardrail that blocks the conversation if the LLM response is considered violating the policy based on the LLM classification.
    &quot;allowShortUtterance&quot;: True or False, # Optional. By default, the LLM policy check is bypassed for short utterances. Enabling this setting applies the policy check to all utterances, including those that would normally be skipped.
    &quot;failOpen&quot;: True or False, # Optional. If an error occurs during the policy check, fail open and do not trigger the guardrail.
    &quot;maxConversationMessages&quot;: 42, # Optional. When checking this policy, consider the last &#x27;n&#x27; messages in the conversation. When not set a default value of 10 will be used.
    &quot;modelSettings&quot;: { # Model settings contains various configurations for the LLM model. # Optional. Model settings.
      &quot;model&quot;: &quot;A String&quot;, # Optional. The LLM model that the agent should use. If not set, the agent will inherit the model from its parent agent.
      &quot;temperature&quot;: 3.14, # Optional. If set, this temperature will be used for the LLM model. Temperature controls the randomness of the model&#x27;s responses. Lower temperatures produce responses that are more predictable. Higher temperatures produce responses that are more creative.
    },
    &quot;policyScope&quot;: &quot;A String&quot;, # Required. Defines when to apply the policy check during the conversation. If set to `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input. When applying the policy to the agent response, additional latency will be introduced before the agent can respond.
    &quot;prompt&quot;: &quot;A String&quot;, # Required. Policy prompt.
  },
  &quot;llmPromptSecurity&quot;: { # Guardrail that blocks the conversation if the input is considered unsafe based on the LLM classification. # Optional. Guardrail that blocks the conversation if the prompt is considered unsafe based on the LLM classification.
    &quot;customPolicy&quot;: { # Guardrail that blocks the conversation if the LLM response is considered violating the policy based on the LLM classification. # Optional. Use a user-defined LlmPolicy to configure the security guardrail.
      &quot;allowShortUtterance&quot;: True or False, # Optional. By default, the LLM policy check is bypassed for short utterances. Enabling this setting applies the policy check to all utterances, including those that would normally be skipped.
      &quot;failOpen&quot;: True or False, # Optional. If an error occurs during the policy check, fail open and do not trigger the guardrail.
      &quot;maxConversationMessages&quot;: 42, # Optional. When checking this policy, consider the last &#x27;n&#x27; messages in the conversation. When not set a default value of 10 will be used.
      &quot;modelSettings&quot;: { # Model settings contains various configurations for the LLM model. # Optional. Model settings.
        &quot;model&quot;: &quot;A String&quot;, # Optional. The LLM model that the agent should use. If not set, the agent will inherit the model from its parent agent.
        &quot;temperature&quot;: 3.14, # Optional. If set, this temperature will be used for the LLM model. Temperature controls the randomness of the model&#x27;s responses. Lower temperatures produce responses that are more predictable. Higher temperatures produce responses that are more creative.
      },
      &quot;policyScope&quot;: &quot;A String&quot;, # Required. Defines when to apply the policy check during the conversation. If set to `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input. When applying the policy to the agent response, additional latency will be introduced before the agent can respond.
      &quot;prompt&quot;: &quot;A String&quot;, # Required. Policy prompt.
    },
    &quot;defaultSettings&quot;: { # Configuration for default system security settings. # Optional. Use the system&#x27;s predefined default security settings. To select this mode, include an empty &#x27;default_settings&#x27; message in the request. The &#x27;default_prompt_template&#x27; field within will be populated by the server in the response.
      &quot;defaultPromptTemplate&quot;: &quot;A String&quot;, # Output only. The default prompt template used by the system. This field is for display purposes to show the user what prompt the system uses by default. It is OUTPUT_ONLY.
    },
    &quot;failOpen&quot;: True or False, # Optional. Determines the behavior when the guardrail encounters an LLM error. - If true: the guardrail is bypassed. - If false (default): the guardrail triggers/blocks. Note: If a custom policy is provided, this field is ignored in favor of the policy&#x27;s &#x27;fail_open&#x27; configuration.
  },
  &quot;modelSafety&quot;: { # Model safety settings overrides. When this is set, it will override the default settings and trigger the guardrail if the response is considered unsafe. # Optional. Guardrail that blocks the conversation if the LLM response is considered unsafe based on the model safety settings.
    &quot;safetySettings&quot;: [ # Required. List of safety settings.
      { # Safety setting.
        &quot;category&quot;: &quot;A String&quot;, # Required. The harm category.
        &quot;threshold&quot;: &quot;A String&quot;, # Required. The harm block threshold.
      },
    ],
  },
  &quot;name&quot;: &quot;A String&quot;, # Identifier. The unique identifier of the guardrail. Format: `projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}`
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when the guardrail was last updated.
}</pre>
</div>

<div class="method">
    <code class="details" id="delete">delete(name, etag=None, force=None, x__xgafv=None)</code>
  <pre>Deletes the specified guardrail.

Args:
  name: string, Required. The resource name of the guardrail to delete. (required)
  etag: string, Optional. The current etag of the guardrail. If an etag is not provided, the deletion will overwrite any concurrent changes. If an etag is provided and does not match the current etag of the guardrail, deletion will be blocked and an ABORTED error will be returned.
  force: boolean, Optional. Indicates whether to forcefully delete the guardrail, even if it is still referenced by app/agents. * If `force = false`, the deletion fails if any apps/agents still reference the guardrail. * If `force = true`, all existing references from apps/agents will be removed and the guardrail will be deleted.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
}</pre>
</div>

<div class="method">
    <code class="details" id="get">get(name, x__xgafv=None)</code>
  <pre>Gets details of the specified guardrail.

Args:
  name: string, Required. The resource name of the guardrail to retrieve. (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Guardrail contains a list of checks and balances to keep the agents safe and secure.
  &quot;action&quot;: { # Action that is taken when a certain precondition is met. # Optional. Action to take when the guardrail is triggered.
    &quot;generativeAnswer&quot;: { # The agent will immediately respond with a generative answer. # Optional. Respond with a generative answer.
      &quot;prompt&quot;: &quot;A String&quot;, # Required. The prompt to use for the generative answer.
    },
    &quot;respondImmediately&quot;: { # The agent will immediately respond with a preconfigured response. # Optional. Immediately respond with a preconfigured response.
      &quot;responses&quot;: [ # Required. The canned responses for the agent to choose from. The response is chosen randomly.
        { # Represents a response from the agent.
          &quot;disabled&quot;: True or False, # Optional. Whether the response is disabled. Disabled responses are not used by the agent.
          &quot;text&quot;: &quot;A String&quot;, # Required. Text for the agent to respond with.
        },
      ],
    },
    &quot;transferAgent&quot;: { # The agent will transfer the conversation to a different agent. # Optional. Transfer the conversation to a different agent.
      &quot;agent&quot;: &quot;A String&quot;, # Required. The name of the agent to transfer the conversation to. The agent must be in the same app as the current agent. Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
    },
  },
  &quot;codeCallback&quot;: { # Guardrail that blocks the conversation based on the code callbacks provided. # Optional. Guardrail that potentially blocks the conversation based on the result of the callback execution.
    &quot;afterAgentCallback&quot;: { # A callback defines the custom logic to be executed at various stages of agent interaction. # Optional. The callback to execute after the agent is called. Each callback function is expected to return a structure (e.g., a dict or object) containing at least: - &#x27;decision&#x27;: Either &#x27;OK&#x27; or &#x27;TRIGGER&#x27;. - &#x27;reason&#x27;: A string explaining the decision. A &#x27;TRIGGER&#x27; decision may halt further processing.
      &quot;description&quot;: &quot;A String&quot;, # Optional. Human-readable description of the callback.
      &quot;disabled&quot;: True or False, # Optional. Whether the callback is disabled. Disabled callbacks are ignored by the agent.
      &quot;proactiveExecutionEnabled&quot;: True or False, # Optional. If enabled, the callback will also be executed on intermediate model outputs. This setting only affects after model callback. **ENABLE WITH CAUTION**. Typically after model callback only needs to be executed after receiving all model responses. Enabling proactive execution may have negative implication on the execution cost and latency, and should only be enabled in rare situations.
      &quot;pythonCode&quot;: &quot;A String&quot;, # Required. The python code to execute for the callback.
    },
    &quot;afterModelCallback&quot;: { # A callback defines the custom logic to be executed at various stages of agent interaction. # Optional. The callback to execute after the model is called. If there are multiple calls to the model, the callback will be executed multiple times. Each callback function is expected to return a structure (e.g., a dict or object) containing at least: - &#x27;decision&#x27;: Either &#x27;OK&#x27; or &#x27;TRIGGER&#x27;. - &#x27;reason&#x27;: A string explaining the decision. A &#x27;TRIGGER&#x27; decision may halt further processing.
      &quot;description&quot;: &quot;A String&quot;, # Optional. Human-readable description of the callback.
      &quot;disabled&quot;: True or False, # Optional. Whether the callback is disabled. Disabled callbacks are ignored by the agent.
      &quot;proactiveExecutionEnabled&quot;: True or False, # Optional. If enabled, the callback will also be executed on intermediate model outputs. This setting only affects after model callback. **ENABLE WITH CAUTION**. Typically after model callback only needs to be executed after receiving all model responses. Enabling proactive execution may have negative implication on the execution cost and latency, and should only be enabled in rare situations.
      &quot;pythonCode&quot;: &quot;A String&quot;, # Required. The python code to execute for the callback.
    },
    &quot;beforeAgentCallback&quot;: { # A callback defines the custom logic to be executed at various stages of agent interaction. # Optional. The callback to execute before the agent is called. Each callback function is expected to return a structure (e.g., a dict or object) containing at least: - &#x27;decision&#x27;: Either &#x27;OK&#x27; or &#x27;TRIGGER&#x27;. - &#x27;reason&#x27;: A string explaining the decision. A &#x27;TRIGGER&#x27; decision may halt further processing.
      &quot;description&quot;: &quot;A String&quot;, # Optional. Human-readable description of the callback.
      &quot;disabled&quot;: True or False, # Optional. Whether the callback is disabled. Disabled callbacks are ignored by the agent.
      &quot;proactiveExecutionEnabled&quot;: True or False, # Optional. If enabled, the callback will also be executed on intermediate model outputs. This setting only affects after model callback. **ENABLE WITH CAUTION**. Typically after model callback only needs to be executed after receiving all model responses. Enabling proactive execution may have negative implication on the execution cost and latency, and should only be enabled in rare situations.
      &quot;pythonCode&quot;: &quot;A String&quot;, # Required. The python code to execute for the callback.
    },
    &quot;beforeModelCallback&quot;: { # A callback defines the custom logic to be executed at various stages of agent interaction. # Optional. The callback to execute before the model is called. If there are multiple calls to the model, the callback will be executed multiple times. Each callback function is expected to return a structure (e.g., a dict or object) containing at least: - &#x27;decision&#x27;: Either &#x27;OK&#x27; or &#x27;TRIGGER&#x27;. - &#x27;reason&#x27;: A string explaining the decision. A &#x27;TRIGGER&#x27; decision may halt further processing.
      &quot;description&quot;: &quot;A String&quot;, # Optional. Human-readable description of the callback.
      &quot;disabled&quot;: True or False, # Optional. Whether the callback is disabled. Disabled callbacks are ignored by the agent.
      &quot;proactiveExecutionEnabled&quot;: True or False, # Optional. If enabled, the callback will also be executed on intermediate model outputs. This setting only affects after model callback. **ENABLE WITH CAUTION**. Typically after model callback only needs to be executed after receiving all model responses. Enabling proactive execution may have negative implication on the execution cost and latency, and should only be enabled in rare situations.
      &quot;pythonCode&quot;: &quot;A String&quot;, # Required. The python code to execute for the callback.
    },
  },
  &quot;contentFilter&quot;: { # Guardrail that bans certain content from being used in the conversation. # Optional. Guardrail that bans certain content from being used in the conversation.
    &quot;bannedContents&quot;: [ # Optional. List of banned phrases. Applies to both user inputs and agent responses.
      &quot;A String&quot;,
    ],
    &quot;bannedContentsInAgentResponse&quot;: [ # Optional. List of banned phrases. Applies only to agent responses.
      &quot;A String&quot;,
    ],
    &quot;bannedContentsInUserInput&quot;: [ # Optional. List of banned phrases. Applies only to user inputs.
      &quot;A String&quot;,
    ],
    &quot;disregardDiacritics&quot;: True or False, # Optional. If true, diacritics are ignored during matching.
    &quot;matchType&quot;: &quot;A String&quot;, # Required. Match type for the content filter.
  },
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when the guardrail was created.
  &quot;description&quot;: &quot;A String&quot;, # Optional. Description of the guardrail.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. Display name of the guardrail.
  &quot;enabled&quot;: True or False, # Optional. Whether the guardrail is enabled.
  &quot;etag&quot;: &quot;A String&quot;, # Etag used to ensure the object hasn&#x27;t changed during a read-modify-write operation. If the etag is empty, the update will overwrite any concurrent changes.
  &quot;llmPolicy&quot;: { # Guardrail that blocks the conversation if the LLM response is considered violating the policy based on the LLM classification. # Optional. Guardrail that blocks the conversation if the LLM response is considered violating the policy based on the LLM classification.
    &quot;allowShortUtterance&quot;: True or False, # Optional. By default, the LLM policy check is bypassed for short utterances. Enabling this setting applies the policy check to all utterances, including those that would normally be skipped.
    &quot;failOpen&quot;: True or False, # Optional. If an error occurs during the policy check, fail open and do not trigger the guardrail.
    &quot;maxConversationMessages&quot;: 42, # Optional. When checking this policy, consider the last &#x27;n&#x27; messages in the conversation. When not set a default value of 10 will be used.
    &quot;modelSettings&quot;: { # Model settings contains various configurations for the LLM model. # Optional. Model settings.
      &quot;model&quot;: &quot;A String&quot;, # Optional. The LLM model that the agent should use. If not set, the agent will inherit the model from its parent agent.
      &quot;temperature&quot;: 3.14, # Optional. If set, this temperature will be used for the LLM model. Temperature controls the randomness of the model&#x27;s responses. Lower temperatures produce responses that are more predictable. Higher temperatures produce responses that are more creative.
    },
    &quot;policyScope&quot;: &quot;A String&quot;, # Required. Defines when to apply the policy check during the conversation. If set to `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input. When applying the policy to the agent response, additional latency will be introduced before the agent can respond.
    &quot;prompt&quot;: &quot;A String&quot;, # Required. Policy prompt.
  },
  &quot;llmPromptSecurity&quot;: { # Guardrail that blocks the conversation if the input is considered unsafe based on the LLM classification. # Optional. Guardrail that blocks the conversation if the prompt is considered unsafe based on the LLM classification.
    &quot;customPolicy&quot;: { # Guardrail that blocks the conversation if the LLM response is considered violating the policy based on the LLM classification. # Optional. Use a user-defined LlmPolicy to configure the security guardrail.
      &quot;allowShortUtterance&quot;: True or False, # Optional. By default, the LLM policy check is bypassed for short utterances. Enabling this setting applies the policy check to all utterances, including those that would normally be skipped.
      &quot;failOpen&quot;: True or False, # Optional. If an error occurs during the policy check, fail open and do not trigger the guardrail.
      &quot;maxConversationMessages&quot;: 42, # Optional. When checking this policy, consider the last &#x27;n&#x27; messages in the conversation. When not set a default value of 10 will be used.
      &quot;modelSettings&quot;: { # Model settings contains various configurations for the LLM model. # Optional. Model settings.
        &quot;model&quot;: &quot;A String&quot;, # Optional. The LLM model that the agent should use. If not set, the agent will inherit the model from its parent agent.
        &quot;temperature&quot;: 3.14, # Optional. If set, this temperature will be used for the LLM model. Temperature controls the randomness of the model&#x27;s responses. Lower temperatures produce responses that are more predictable. Higher temperatures produce responses that are more creative.
      },
      &quot;policyScope&quot;: &quot;A String&quot;, # Required. Defines when to apply the policy check during the conversation. If set to `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input. When applying the policy to the agent response, additional latency will be introduced before the agent can respond.
      &quot;prompt&quot;: &quot;A String&quot;, # Required. Policy prompt.
    },
    &quot;defaultSettings&quot;: { # Configuration for default system security settings. # Optional. Use the system&#x27;s predefined default security settings. To select this mode, include an empty &#x27;default_settings&#x27; message in the request. The &#x27;default_prompt_template&#x27; field within will be populated by the server in the response.
      &quot;defaultPromptTemplate&quot;: &quot;A String&quot;, # Output only. The default prompt template used by the system. This field is for display purposes to show the user what prompt the system uses by default. It is OUTPUT_ONLY.
    },
    &quot;failOpen&quot;: True or False, # Optional. Determines the behavior when the guardrail encounters an LLM error. - If true: the guardrail is bypassed. - If false (default): the guardrail triggers/blocks. Note: If a custom policy is provided, this field is ignored in favor of the policy&#x27;s &#x27;fail_open&#x27; configuration.
  },
  &quot;modelSafety&quot;: { # Model safety settings overrides. When this is set, it will override the default settings and trigger the guardrail if the response is considered unsafe. # Optional. Guardrail that blocks the conversation if the LLM response is considered unsafe based on the model safety settings.
    &quot;safetySettings&quot;: [ # Required. List of safety settings.
      { # Safety setting.
        &quot;category&quot;: &quot;A String&quot;, # Required. The harm category.
        &quot;threshold&quot;: &quot;A String&quot;, # Required. The harm block threshold.
      },
    ],
  },
  &quot;name&quot;: &quot;A String&quot;, # Identifier. The unique identifier of the guardrail. Format: `projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}`
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when the guardrail was last updated.
}</pre>
</div>

<div class="method">
    <code class="details" id="list">list(parent, filter=None, orderBy=None, pageSize=None, pageToken=None, x__xgafv=None)</code>
  <pre>Lists guardrails in the given app.

Args:
  parent: string, Required. The resource name of the app to list guardrails from. (required)
  filter: string, Optional. Filter to be applied when listing the guardrails. See https://google.aip.dev/160 for more details.
  orderBy: string, Optional. Field to sort by. Only &quot;name&quot; and &quot;create_time&quot; is supported. See https://google.aip.dev/132#ordering for more details.
  pageSize: integer, Optional. Requested page size. Server may return fewer items than requested. If unspecified, server will pick an appropriate default.
  pageToken: string, Optional. The next_page_token value returned from a previous list AgentService.ListGuardrails call.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response message for AgentService.ListGuardrails.
  &quot;guardrails&quot;: [ # The list of guardrails.
    { # Guardrail contains a list of checks and balances to keep the agents safe and secure.
      &quot;action&quot;: { # Action that is taken when a certain precondition is met. # Optional. Action to take when the guardrail is triggered.
        &quot;generativeAnswer&quot;: { # The agent will immediately respond with a generative answer. # Optional. Respond with a generative answer.
          &quot;prompt&quot;: &quot;A String&quot;, # Required. The prompt to use for the generative answer.
        },
        &quot;respondImmediately&quot;: { # The agent will immediately respond with a preconfigured response. # Optional. Immediately respond with a preconfigured response.
          &quot;responses&quot;: [ # Required. The canned responses for the agent to choose from. The response is chosen randomly.
            { # Represents a response from the agent.
              &quot;disabled&quot;: True or False, # Optional. Whether the response is disabled. Disabled responses are not used by the agent.
              &quot;text&quot;: &quot;A String&quot;, # Required. Text for the agent to respond with.
            },
          ],
        },
        &quot;transferAgent&quot;: { # The agent will transfer the conversation to a different agent. # Optional. Transfer the conversation to a different agent.
          &quot;agent&quot;: &quot;A String&quot;, # Required. The name of the agent to transfer the conversation to. The agent must be in the same app as the current agent. Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        },
      },
      &quot;codeCallback&quot;: { # Guardrail that blocks the conversation based on the code callbacks provided. # Optional. Guardrail that potentially blocks the conversation based on the result of the callback execution.
        &quot;afterAgentCallback&quot;: { # A callback defines the custom logic to be executed at various stages of agent interaction. # Optional. The callback to execute after the agent is called. Each callback function is expected to return a structure (e.g., a dict or object) containing at least: - &#x27;decision&#x27;: Either &#x27;OK&#x27; or &#x27;TRIGGER&#x27;. - &#x27;reason&#x27;: A string explaining the decision. A &#x27;TRIGGER&#x27; decision may halt further processing.
          &quot;description&quot;: &quot;A String&quot;, # Optional. Human-readable description of the callback.
          &quot;disabled&quot;: True or False, # Optional. Whether the callback is disabled. Disabled callbacks are ignored by the agent.
          &quot;proactiveExecutionEnabled&quot;: True or False, # Optional. If enabled, the callback will also be executed on intermediate model outputs. This setting only affects after model callback. **ENABLE WITH CAUTION**. Typically after model callback only needs to be executed after receiving all model responses. Enabling proactive execution may have negative implication on the execution cost and latency, and should only be enabled in rare situations.
          &quot;pythonCode&quot;: &quot;A String&quot;, # Required. The python code to execute for the callback.
        },
        &quot;afterModelCallback&quot;: { # A callback defines the custom logic to be executed at various stages of agent interaction. # Optional. The callback to execute after the model is called. If there are multiple calls to the model, the callback will be executed multiple times. Each callback function is expected to return a structure (e.g., a dict or object) containing at least: - &#x27;decision&#x27;: Either &#x27;OK&#x27; or &#x27;TRIGGER&#x27;. - &#x27;reason&#x27;: A string explaining the decision. A &#x27;TRIGGER&#x27; decision may halt further processing.
          &quot;description&quot;: &quot;A String&quot;, # Optional. Human-readable description of the callback.
          &quot;disabled&quot;: True or False, # Optional. Whether the callback is disabled. Disabled callbacks are ignored by the agent.
          &quot;proactiveExecutionEnabled&quot;: True or False, # Optional. If enabled, the callback will also be executed on intermediate model outputs. This setting only affects after model callback. **ENABLE WITH CAUTION**. Typically after model callback only needs to be executed after receiving all model responses. Enabling proactive execution may have negative implication on the execution cost and latency, and should only be enabled in rare situations.
          &quot;pythonCode&quot;: &quot;A String&quot;, # Required. The python code to execute for the callback.
        },
        &quot;beforeAgentCallback&quot;: { # A callback defines the custom logic to be executed at various stages of agent interaction. # Optional. The callback to execute before the agent is called. Each callback function is expected to return a structure (e.g., a dict or object) containing at least: - &#x27;decision&#x27;: Either &#x27;OK&#x27; or &#x27;TRIGGER&#x27;. - &#x27;reason&#x27;: A string explaining the decision. A &#x27;TRIGGER&#x27; decision may halt further processing.
          &quot;description&quot;: &quot;A String&quot;, # Optional. Human-readable description of the callback.
          &quot;disabled&quot;: True or False, # Optional. Whether the callback is disabled. Disabled callbacks are ignored by the agent.
          &quot;proactiveExecutionEnabled&quot;: True or False, # Optional. If enabled, the callback will also be executed on intermediate model outputs. This setting only affects after model callback. **ENABLE WITH CAUTION**. Typically after model callback only needs to be executed after receiving all model responses. Enabling proactive execution may have negative implication on the execution cost and latency, and should only be enabled in rare situations.
          &quot;pythonCode&quot;: &quot;A String&quot;, # Required. The python code to execute for the callback.
        },
        &quot;beforeModelCallback&quot;: { # A callback defines the custom logic to be executed at various stages of agent interaction. # Optional. The callback to execute before the model is called. If there are multiple calls to the model, the callback will be executed multiple times. Each callback function is expected to return a structure (e.g., a dict or object) containing at least: - &#x27;decision&#x27;: Either &#x27;OK&#x27; or &#x27;TRIGGER&#x27;. - &#x27;reason&#x27;: A string explaining the decision. A &#x27;TRIGGER&#x27; decision may halt further processing.
          &quot;description&quot;: &quot;A String&quot;, # Optional. Human-readable description of the callback.
          &quot;disabled&quot;: True or False, # Optional. Whether the callback is disabled. Disabled callbacks are ignored by the agent.
          &quot;proactiveExecutionEnabled&quot;: True or False, # Optional. If enabled, the callback will also be executed on intermediate model outputs. This setting only affects after model callback. **ENABLE WITH CAUTION**. Typically after model callback only needs to be executed after receiving all model responses. Enabling proactive execution may have negative implication on the execution cost and latency, and should only be enabled in rare situations.
          &quot;pythonCode&quot;: &quot;A String&quot;, # Required. The python code to execute for the callback.
        },
      },
      &quot;contentFilter&quot;: { # Guardrail that bans certain content from being used in the conversation. # Optional. Guardrail that bans certain content from being used in the conversation.
        &quot;bannedContents&quot;: [ # Optional. List of banned phrases. Applies to both user inputs and agent responses.
          &quot;A String&quot;,
        ],
        &quot;bannedContentsInAgentResponse&quot;: [ # Optional. List of banned phrases. Applies only to agent responses.
          &quot;A String&quot;,
        ],
        &quot;bannedContentsInUserInput&quot;: [ # Optional. List of banned phrases. Applies only to user inputs.
          &quot;A String&quot;,
        ],
        &quot;disregardDiacritics&quot;: True or False, # Optional. If true, diacritics are ignored during matching.
        &quot;matchType&quot;: &quot;A String&quot;, # Required. Match type for the content filter.
      },
      &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when the guardrail was created.
      &quot;description&quot;: &quot;A String&quot;, # Optional. Description of the guardrail.
      &quot;displayName&quot;: &quot;A String&quot;, # Required. Display name of the guardrail.
      &quot;enabled&quot;: True or False, # Optional. Whether the guardrail is enabled.
      &quot;etag&quot;: &quot;A String&quot;, # Etag used to ensure the object hasn&#x27;t changed during a read-modify-write operation. If the etag is empty, the update will overwrite any concurrent changes.
      &quot;llmPolicy&quot;: { # Guardrail that blocks the conversation if the LLM response is considered violating the policy based on the LLM classification. # Optional. Guardrail that blocks the conversation if the LLM response is considered violating the policy based on the LLM classification.
        &quot;allowShortUtterance&quot;: True or False, # Optional. By default, the LLM policy check is bypassed for short utterances. Enabling this setting applies the policy check to all utterances, including those that would normally be skipped.
        &quot;failOpen&quot;: True or False, # Optional. If an error occurs during the policy check, fail open and do not trigger the guardrail.
        &quot;maxConversationMessages&quot;: 42, # Optional. When checking this policy, consider the last &#x27;n&#x27; messages in the conversation. When not set a default value of 10 will be used.
        &quot;modelSettings&quot;: { # Model settings contains various configurations for the LLM model. # Optional. Model settings.
          &quot;model&quot;: &quot;A String&quot;, # Optional. The LLM model that the agent should use. If not set, the agent will inherit the model from its parent agent.
          &quot;temperature&quot;: 3.14, # Optional. If set, this temperature will be used for the LLM model. Temperature controls the randomness of the model&#x27;s responses. Lower temperatures produce responses that are more predictable. Higher temperatures produce responses that are more creative.
        },
        &quot;policyScope&quot;: &quot;A String&quot;, # Required. Defines when to apply the policy check during the conversation. If set to `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input. When applying the policy to the agent response, additional latency will be introduced before the agent can respond.
        &quot;prompt&quot;: &quot;A String&quot;, # Required. Policy prompt.
      },
      &quot;llmPromptSecurity&quot;: { # Guardrail that blocks the conversation if the input is considered unsafe based on the LLM classification. # Optional. Guardrail that blocks the conversation if the prompt is considered unsafe based on the LLM classification.
        &quot;customPolicy&quot;: { # Guardrail that blocks the conversation if the LLM response is considered violating the policy based on the LLM classification. # Optional. Use a user-defined LlmPolicy to configure the security guardrail.
          &quot;allowShortUtterance&quot;: True or False, # Optional. By default, the LLM policy check is bypassed for short utterances. Enabling this setting applies the policy check to all utterances, including those that would normally be skipped.
          &quot;failOpen&quot;: True or False, # Optional. If an error occurs during the policy check, fail open and do not trigger the guardrail.
          &quot;maxConversationMessages&quot;: 42, # Optional. When checking this policy, consider the last &#x27;n&#x27; messages in the conversation. When not set a default value of 10 will be used.
          &quot;modelSettings&quot;: { # Model settings contains various configurations for the LLM model. # Optional. Model settings.
            &quot;model&quot;: &quot;A String&quot;, # Optional. The LLM model that the agent should use. If not set, the agent will inherit the model from its parent agent.
            &quot;temperature&quot;: 3.14, # Optional. If set, this temperature will be used for the LLM model. Temperature controls the randomness of the model&#x27;s responses. Lower temperatures produce responses that are more predictable. Higher temperatures produce responses that are more creative.
          },
          &quot;policyScope&quot;: &quot;A String&quot;, # Required. Defines when to apply the policy check during the conversation. If set to `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input. When applying the policy to the agent response, additional latency will be introduced before the agent can respond.
          &quot;prompt&quot;: &quot;A String&quot;, # Required. Policy prompt.
        },
        &quot;defaultSettings&quot;: { # Configuration for default system security settings. # Optional. Use the system&#x27;s predefined default security settings. To select this mode, include an empty &#x27;default_settings&#x27; message in the request. The &#x27;default_prompt_template&#x27; field within will be populated by the server in the response.
          &quot;defaultPromptTemplate&quot;: &quot;A String&quot;, # Output only. The default prompt template used by the system. This field is for display purposes to show the user what prompt the system uses by default. It is OUTPUT_ONLY.
        },
        &quot;failOpen&quot;: True or False, # Optional. Determines the behavior when the guardrail encounters an LLM error. - If true: the guardrail is bypassed. - If false (default): the guardrail triggers/blocks. Note: If a custom policy is provided, this field is ignored in favor of the policy&#x27;s &#x27;fail_open&#x27; configuration.
      },
      &quot;modelSafety&quot;: { # Model safety settings overrides. When this is set, it will override the default settings and trigger the guardrail if the response is considered unsafe. # Optional. Guardrail that blocks the conversation if the LLM response is considered unsafe based on the model safety settings.
        &quot;safetySettings&quot;: [ # Required. List of safety settings.
          { # Safety setting.
            &quot;category&quot;: &quot;A String&quot;, # Required. The harm category.
            &quot;threshold&quot;: &quot;A String&quot;, # Required. The harm block threshold.
          },
        ],
      },
      &quot;name&quot;: &quot;A String&quot;, # Identifier. The unique identifier of the guardrail. Format: `projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}`
      &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when the guardrail was last updated.
    },
  ],
  &quot;nextPageToken&quot;: &quot;A String&quot;, # A token that can be sent as ListGuardrailsRequest.page_token to retrieve the next page. Absence of this field indicates there are no subsequent pages.
}</pre>
</div>

<div class="method">
    <code class="details" id="list_next">list_next()</code>
  <pre>Retrieves the next page of results.

        Args:
          previous_request: The request for the previous page. (required)
          previous_response: The response from the request for the previous page. (required)

        Returns:
          A request object that you can call &#x27;execute()&#x27; on to request the next
          page. Returns None if there are no more items in the collection.
        </pre>
</div>

<div class="method">
    <code class="details" id="patch">patch(name, body=None, updateMask=None, x__xgafv=None)</code>
  <pre>Updates the specified guardrail.

Args:
  name: string, Identifier. The unique identifier of the guardrail. Format: `projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}` (required)
  body: object, The request body.
    The object takes the form of:

{ # Guardrail contains a list of checks and balances to keep the agents safe and secure.
  &quot;action&quot;: { # Action that is taken when a certain precondition is met. # Optional. Action to take when the guardrail is triggered.
    &quot;generativeAnswer&quot;: { # The agent will immediately respond with a generative answer. # Optional. Respond with a generative answer.
      &quot;prompt&quot;: &quot;A String&quot;, # Required. The prompt to use for the generative answer.
    },
    &quot;respondImmediately&quot;: { # The agent will immediately respond with a preconfigured response. # Optional. Immediately respond with a preconfigured response.
      &quot;responses&quot;: [ # Required. The canned responses for the agent to choose from. The response is chosen randomly.
        { # Represents a response from the agent.
          &quot;disabled&quot;: True or False, # Optional. Whether the response is disabled. Disabled responses are not used by the agent.
          &quot;text&quot;: &quot;A String&quot;, # Required. Text for the agent to respond with.
        },
      ],
    },
    &quot;transferAgent&quot;: { # The agent will transfer the conversation to a different agent. # Optional. Transfer the conversation to a different agent.
      &quot;agent&quot;: &quot;A String&quot;, # Required. The name of the agent to transfer the conversation to. The agent must be in the same app as the current agent. Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
    },
  },
  &quot;codeCallback&quot;: { # Guardrail that blocks the conversation based on the code callbacks provided. # Optional. Guardrail that potentially blocks the conversation based on the result of the callback execution.
    &quot;afterAgentCallback&quot;: { # A callback defines the custom logic to be executed at various stages of agent interaction. # Optional. The callback to execute after the agent is called. Each callback function is expected to return a structure (e.g., a dict or object) containing at least: - &#x27;decision&#x27;: Either &#x27;OK&#x27; or &#x27;TRIGGER&#x27;. - &#x27;reason&#x27;: A string explaining the decision. A &#x27;TRIGGER&#x27; decision may halt further processing.
      &quot;description&quot;: &quot;A String&quot;, # Optional. Human-readable description of the callback.
      &quot;disabled&quot;: True or False, # Optional. Whether the callback is disabled. Disabled callbacks are ignored by the agent.
      &quot;proactiveExecutionEnabled&quot;: True or False, # Optional. If enabled, the callback will also be executed on intermediate model outputs. This setting only affects after model callback. **ENABLE WITH CAUTION**. Typically after model callback only needs to be executed after receiving all model responses. Enabling proactive execution may have negative implication on the execution cost and latency, and should only be enabled in rare situations.
      &quot;pythonCode&quot;: &quot;A String&quot;, # Required. The python code to execute for the callback.
    },
    &quot;afterModelCallback&quot;: { # A callback defines the custom logic to be executed at various stages of agent interaction. # Optional. The callback to execute after the model is called. If there are multiple calls to the model, the callback will be executed multiple times. Each callback function is expected to return a structure (e.g., a dict or object) containing at least: - &#x27;decision&#x27;: Either &#x27;OK&#x27; or &#x27;TRIGGER&#x27;. - &#x27;reason&#x27;: A string explaining the decision. A &#x27;TRIGGER&#x27; decision may halt further processing.
      &quot;description&quot;: &quot;A String&quot;, # Optional. Human-readable description of the callback.
      &quot;disabled&quot;: True or False, # Optional. Whether the callback is disabled. Disabled callbacks are ignored by the agent.
      &quot;proactiveExecutionEnabled&quot;: True or False, # Optional. If enabled, the callback will also be executed on intermediate model outputs. This setting only affects after model callback. **ENABLE WITH CAUTION**. Typically after model callback only needs to be executed after receiving all model responses. Enabling proactive execution may have negative implication on the execution cost and latency, and should only be enabled in rare situations.
      &quot;pythonCode&quot;: &quot;A String&quot;, # Required. The python code to execute for the callback.
    },
    &quot;beforeAgentCallback&quot;: { # A callback defines the custom logic to be executed at various stages of agent interaction. # Optional. The callback to execute before the agent is called. Each callback function is expected to return a structure (e.g., a dict or object) containing at least: - &#x27;decision&#x27;: Either &#x27;OK&#x27; or &#x27;TRIGGER&#x27;. - &#x27;reason&#x27;: A string explaining the decision. A &#x27;TRIGGER&#x27; decision may halt further processing.
      &quot;description&quot;: &quot;A String&quot;, # Optional. Human-readable description of the callback.
      &quot;disabled&quot;: True or False, # Optional. Whether the callback is disabled. Disabled callbacks are ignored by the agent.
      &quot;proactiveExecutionEnabled&quot;: True or False, # Optional. If enabled, the callback will also be executed on intermediate model outputs. This setting only affects after model callback. **ENABLE WITH CAUTION**. Typically after model callback only needs to be executed after receiving all model responses. Enabling proactive execution may have negative implication on the execution cost and latency, and should only be enabled in rare situations.
      &quot;pythonCode&quot;: &quot;A String&quot;, # Required. The python code to execute for the callback.
    },
    &quot;beforeModelCallback&quot;: { # A callback defines the custom logic to be executed at various stages of agent interaction. # Optional. The callback to execute before the model is called. If there are multiple calls to the model, the callback will be executed multiple times. Each callback function is expected to return a structure (e.g., a dict or object) containing at least: - &#x27;decision&#x27;: Either &#x27;OK&#x27; or &#x27;TRIGGER&#x27;. - &#x27;reason&#x27;: A string explaining the decision. A &#x27;TRIGGER&#x27; decision may halt further processing.
      &quot;description&quot;: &quot;A String&quot;, # Optional. Human-readable description of the callback.
      &quot;disabled&quot;: True or False, # Optional. Whether the callback is disabled. Disabled callbacks are ignored by the agent.
      &quot;proactiveExecutionEnabled&quot;: True or False, # Optional. If enabled, the callback will also be executed on intermediate model outputs. This setting only affects after model callback. **ENABLE WITH CAUTION**. Typically after model callback only needs to be executed after receiving all model responses. Enabling proactive execution may have negative implication on the execution cost and latency, and should only be enabled in rare situations.
      &quot;pythonCode&quot;: &quot;A String&quot;, # Required. The python code to execute for the callback.
    },
  },
  &quot;contentFilter&quot;: { # Guardrail that bans certain content from being used in the conversation. # Optional. Guardrail that bans certain content from being used in the conversation.
    &quot;bannedContents&quot;: [ # Optional. List of banned phrases. Applies to both user inputs and agent responses.
      &quot;A String&quot;,
    ],
    &quot;bannedContentsInAgentResponse&quot;: [ # Optional. List of banned phrases. Applies only to agent responses.
      &quot;A String&quot;,
    ],
    &quot;bannedContentsInUserInput&quot;: [ # Optional. List of banned phrases. Applies only to user inputs.
      &quot;A String&quot;,
    ],
    &quot;disregardDiacritics&quot;: True or False, # Optional. If true, diacritics are ignored during matching.
    &quot;matchType&quot;: &quot;A String&quot;, # Required. Match type for the content filter.
  },
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when the guardrail was created.
  &quot;description&quot;: &quot;A String&quot;, # Optional. Description of the guardrail.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. Display name of the guardrail.
  &quot;enabled&quot;: True or False, # Optional. Whether the guardrail is enabled.
  &quot;etag&quot;: &quot;A String&quot;, # Etag used to ensure the object hasn&#x27;t changed during a read-modify-write operation. If the etag is empty, the update will overwrite any concurrent changes.
  &quot;llmPolicy&quot;: { # Guardrail that blocks the conversation if the LLM response is considered violating the policy based on the LLM classification. # Optional. Guardrail that blocks the conversation if the LLM response is considered violating the policy based on the LLM classification.
    &quot;allowShortUtterance&quot;: True or False, # Optional. By default, the LLM policy check is bypassed for short utterances. Enabling this setting applies the policy check to all utterances, including those that would normally be skipped.
    &quot;failOpen&quot;: True or False, # Optional. If an error occurs during the policy check, fail open and do not trigger the guardrail.
    &quot;maxConversationMessages&quot;: 42, # Optional. When checking this policy, consider the last &#x27;n&#x27; messages in the conversation. When not set a default value of 10 will be used.
    &quot;modelSettings&quot;: { # Model settings contains various configurations for the LLM model. # Optional. Model settings.
      &quot;model&quot;: &quot;A String&quot;, # Optional. The LLM model that the agent should use. If not set, the agent will inherit the model from its parent agent.
      &quot;temperature&quot;: 3.14, # Optional. If set, this temperature will be used for the LLM model. Temperature controls the randomness of the model&#x27;s responses. Lower temperatures produce responses that are more predictable. Higher temperatures produce responses that are more creative.
    },
    &quot;policyScope&quot;: &quot;A String&quot;, # Required. Defines when to apply the policy check during the conversation. If set to `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input. When applying the policy to the agent response, additional latency will be introduced before the agent can respond.
    &quot;prompt&quot;: &quot;A String&quot;, # Required. Policy prompt.
  },
  &quot;llmPromptSecurity&quot;: { # Guardrail that blocks the conversation if the input is considered unsafe based on the LLM classification. # Optional. Guardrail that blocks the conversation if the prompt is considered unsafe based on the LLM classification.
    &quot;customPolicy&quot;: { # Guardrail that blocks the conversation if the LLM response is considered violating the policy based on the LLM classification. # Optional. Use a user-defined LlmPolicy to configure the security guardrail.
      &quot;allowShortUtterance&quot;: True or False, # Optional. By default, the LLM policy check is bypassed for short utterances. Enabling this setting applies the policy check to all utterances, including those that would normally be skipped.
      &quot;failOpen&quot;: True or False, # Optional. If an error occurs during the policy check, fail open and do not trigger the guardrail.
      &quot;maxConversationMessages&quot;: 42, # Optional. When checking this policy, consider the last &#x27;n&#x27; messages in the conversation. When not set a default value of 10 will be used.
      &quot;modelSettings&quot;: { # Model settings contains various configurations for the LLM model. # Optional. Model settings.
        &quot;model&quot;: &quot;A String&quot;, # Optional. The LLM model that the agent should use. If not set, the agent will inherit the model from its parent agent.
        &quot;temperature&quot;: 3.14, # Optional. If set, this temperature will be used for the LLM model. Temperature controls the randomness of the model&#x27;s responses. Lower temperatures produce responses that are more predictable. Higher temperatures produce responses that are more creative.
      },
      &quot;policyScope&quot;: &quot;A String&quot;, # Required. Defines when to apply the policy check during the conversation. If set to `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input. When applying the policy to the agent response, additional latency will be introduced before the agent can respond.
      &quot;prompt&quot;: &quot;A String&quot;, # Required. Policy prompt.
    },
    &quot;defaultSettings&quot;: { # Configuration for default system security settings. # Optional. Use the system&#x27;s predefined default security settings. To select this mode, include an empty &#x27;default_settings&#x27; message in the request. The &#x27;default_prompt_template&#x27; field within will be populated by the server in the response.
      &quot;defaultPromptTemplate&quot;: &quot;A String&quot;, # Output only. The default prompt template used by the system. This field is for display purposes to show the user what prompt the system uses by default. It is OUTPUT_ONLY.
    },
    &quot;failOpen&quot;: True or False, # Optional. Determines the behavior when the guardrail encounters an LLM error. - If true: the guardrail is bypassed. - If false (default): the guardrail triggers/blocks. Note: If a custom policy is provided, this field is ignored in favor of the policy&#x27;s &#x27;fail_open&#x27; configuration.
  },
  &quot;modelSafety&quot;: { # Model safety settings overrides. When this is set, it will override the default settings and trigger the guardrail if the response is considered unsafe. # Optional. Guardrail that blocks the conversation if the LLM response is considered unsafe based on the model safety settings.
    &quot;safetySettings&quot;: [ # Required. List of safety settings.
      { # Safety setting.
        &quot;category&quot;: &quot;A String&quot;, # Required. The harm category.
        &quot;threshold&quot;: &quot;A String&quot;, # Required. The harm block threshold.
      },
    ],
  },
  &quot;name&quot;: &quot;A String&quot;, # Identifier. The unique identifier of the guardrail. Format: `projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}`
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when the guardrail was last updated.
}

  updateMask: string, Optional. Field mask is used to control which fields get updated. If the mask is not present, all fields will be updated.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Guardrail contains a list of checks and balances to keep the agents safe and secure.
  &quot;action&quot;: { # Action that is taken when a certain precondition is met. # Optional. Action to take when the guardrail is triggered.
    &quot;generativeAnswer&quot;: { # The agent will immediately respond with a generative answer. # Optional. Respond with a generative answer.
      &quot;prompt&quot;: &quot;A String&quot;, # Required. The prompt to use for the generative answer.
    },
    &quot;respondImmediately&quot;: { # The agent will immediately respond with a preconfigured response. # Optional. Immediately respond with a preconfigured response.
      &quot;responses&quot;: [ # Required. The canned responses for the agent to choose from. The response is chosen randomly.
        { # Represents a response from the agent.
          &quot;disabled&quot;: True or False, # Optional. Whether the response is disabled. Disabled responses are not used by the agent.
          &quot;text&quot;: &quot;A String&quot;, # Required. Text for the agent to respond with.
        },
      ],
    },
    &quot;transferAgent&quot;: { # The agent will transfer the conversation to a different agent. # Optional. Transfer the conversation to a different agent.
      &quot;agent&quot;: &quot;A String&quot;, # Required. The name of the agent to transfer the conversation to. The agent must be in the same app as the current agent. Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
    },
  },
  &quot;codeCallback&quot;: { # Guardrail that blocks the conversation based on the code callbacks provided. # Optional. Guardrail that potentially blocks the conversation based on the result of the callback execution.
    &quot;afterAgentCallback&quot;: { # A callback defines the custom logic to be executed at various stages of agent interaction. # Optional. The callback to execute after the agent is called. Each callback function is expected to return a structure (e.g., a dict or object) containing at least: - &#x27;decision&#x27;: Either &#x27;OK&#x27; or &#x27;TRIGGER&#x27;. - &#x27;reason&#x27;: A string explaining the decision. A &#x27;TRIGGER&#x27; decision may halt further processing.
      &quot;description&quot;: &quot;A String&quot;, # Optional. Human-readable description of the callback.
      &quot;disabled&quot;: True or False, # Optional. Whether the callback is disabled. Disabled callbacks are ignored by the agent.
      &quot;proactiveExecutionEnabled&quot;: True or False, # Optional. If enabled, the callback will also be executed on intermediate model outputs. This setting only affects after model callback. **ENABLE WITH CAUTION**. Typically after model callback only needs to be executed after receiving all model responses. Enabling proactive execution may have negative implication on the execution cost and latency, and should only be enabled in rare situations.
      &quot;pythonCode&quot;: &quot;A String&quot;, # Required. The python code to execute for the callback.
    },
    &quot;afterModelCallback&quot;: { # A callback defines the custom logic to be executed at various stages of agent interaction. # Optional. The callback to execute after the model is called. If there are multiple calls to the model, the callback will be executed multiple times. Each callback function is expected to return a structure (e.g., a dict or object) containing at least: - &#x27;decision&#x27;: Either &#x27;OK&#x27; or &#x27;TRIGGER&#x27;. - &#x27;reason&#x27;: A string explaining the decision. A &#x27;TRIGGER&#x27; decision may halt further processing.
      &quot;description&quot;: &quot;A String&quot;, # Optional. Human-readable description of the callback.
      &quot;disabled&quot;: True or False, # Optional. Whether the callback is disabled. Disabled callbacks are ignored by the agent.
      &quot;proactiveExecutionEnabled&quot;: True or False, # Optional. If enabled, the callback will also be executed on intermediate model outputs. This setting only affects after model callback. **ENABLE WITH CAUTION**. Typically after model callback only needs to be executed after receiving all model responses. Enabling proactive execution may have negative implication on the execution cost and latency, and should only be enabled in rare situations.
      &quot;pythonCode&quot;: &quot;A String&quot;, # Required. The python code to execute for the callback.
    },
    &quot;beforeAgentCallback&quot;: { # A callback defines the custom logic to be executed at various stages of agent interaction. # Optional. The callback to execute before the agent is called. Each callback function is expected to return a structure (e.g., a dict or object) containing at least: - &#x27;decision&#x27;: Either &#x27;OK&#x27; or &#x27;TRIGGER&#x27;. - &#x27;reason&#x27;: A string explaining the decision. A &#x27;TRIGGER&#x27; decision may halt further processing.
      &quot;description&quot;: &quot;A String&quot;, # Optional. Human-readable description of the callback.
      &quot;disabled&quot;: True or False, # Optional. Whether the callback is disabled. Disabled callbacks are ignored by the agent.
      &quot;proactiveExecutionEnabled&quot;: True or False, # Optional. If enabled, the callback will also be executed on intermediate model outputs. This setting only affects after model callback. **ENABLE WITH CAUTION**. Typically after model callback only needs to be executed after receiving all model responses. Enabling proactive execution may have negative implication on the execution cost and latency, and should only be enabled in rare situations.
      &quot;pythonCode&quot;: &quot;A String&quot;, # Required. The python code to execute for the callback.
    },
    &quot;beforeModelCallback&quot;: { # A callback defines the custom logic to be executed at various stages of agent interaction. # Optional. The callback to execute before the model is called. If there are multiple calls to the model, the callback will be executed multiple times. Each callback function is expected to return a structure (e.g., a dict or object) containing at least: - &#x27;decision&#x27;: Either &#x27;OK&#x27; or &#x27;TRIGGER&#x27;. - &#x27;reason&#x27;: A string explaining the decision. A &#x27;TRIGGER&#x27; decision may halt further processing.
      &quot;description&quot;: &quot;A String&quot;, # Optional. Human-readable description of the callback.
      &quot;disabled&quot;: True or False, # Optional. Whether the callback is disabled. Disabled callbacks are ignored by the agent.
      &quot;proactiveExecutionEnabled&quot;: True or False, # Optional. If enabled, the callback will also be executed on intermediate model outputs. This setting only affects after model callback. **ENABLE WITH CAUTION**. Typically after model callback only needs to be executed after receiving all model responses. Enabling proactive execution may have negative implication on the execution cost and latency, and should only be enabled in rare situations.
      &quot;pythonCode&quot;: &quot;A String&quot;, # Required. The python code to execute for the callback.
    },
  },
  &quot;contentFilter&quot;: { # Guardrail that bans certain content from being used in the conversation. # Optional. Guardrail that bans certain content from being used in the conversation.
    &quot;bannedContents&quot;: [ # Optional. List of banned phrases. Applies to both user inputs and agent responses.
      &quot;A String&quot;,
    ],
    &quot;bannedContentsInAgentResponse&quot;: [ # Optional. List of banned phrases. Applies only to agent responses.
      &quot;A String&quot;,
    ],
    &quot;bannedContentsInUserInput&quot;: [ # Optional. List of banned phrases. Applies only to user inputs.
      &quot;A String&quot;,
    ],
    &quot;disregardDiacritics&quot;: True or False, # Optional. If true, diacritics are ignored during matching.
    &quot;matchType&quot;: &quot;A String&quot;, # Required. Match type for the content filter.
  },
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when the guardrail was created.
  &quot;description&quot;: &quot;A String&quot;, # Optional. Description of the guardrail.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. Display name of the guardrail.
  &quot;enabled&quot;: True or False, # Optional. Whether the guardrail is enabled.
  &quot;etag&quot;: &quot;A String&quot;, # Etag used to ensure the object hasn&#x27;t changed during a read-modify-write operation. If the etag is empty, the update will overwrite any concurrent changes.
  &quot;llmPolicy&quot;: { # Guardrail that blocks the conversation if the LLM response is considered violating the policy based on the LLM classification. # Optional. Guardrail that blocks the conversation if the LLM response is considered violating the policy based on the LLM classification.
    &quot;allowShortUtterance&quot;: True or False, # Optional. By default, the LLM policy check is bypassed for short utterances. Enabling this setting applies the policy check to all utterances, including those that would normally be skipped.
    &quot;failOpen&quot;: True or False, # Optional. If an error occurs during the policy check, fail open and do not trigger the guardrail.
    &quot;maxConversationMessages&quot;: 42, # Optional. When checking this policy, consider the last &#x27;n&#x27; messages in the conversation. When not set a default value of 10 will be used.
    &quot;modelSettings&quot;: { # Model settings contains various configurations for the LLM model. # Optional. Model settings.
      &quot;model&quot;: &quot;A String&quot;, # Optional. The LLM model that the agent should use. If not set, the agent will inherit the model from its parent agent.
      &quot;temperature&quot;: 3.14, # Optional. If set, this temperature will be used for the LLM model. Temperature controls the randomness of the model&#x27;s responses. Lower temperatures produce responses that are more predictable. Higher temperatures produce responses that are more creative.
    },
    &quot;policyScope&quot;: &quot;A String&quot;, # Required. Defines when to apply the policy check during the conversation. If set to `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input. When applying the policy to the agent response, additional latency will be introduced before the agent can respond.
    &quot;prompt&quot;: &quot;A String&quot;, # Required. Policy prompt.
  },
  &quot;llmPromptSecurity&quot;: { # Guardrail that blocks the conversation if the input is considered unsafe based on the LLM classification. # Optional. Guardrail that blocks the conversation if the prompt is considered unsafe based on the LLM classification.
    &quot;customPolicy&quot;: { # Guardrail that blocks the conversation if the LLM response is considered violating the policy based on the LLM classification. # Optional. Use a user-defined LlmPolicy to configure the security guardrail.
      &quot;allowShortUtterance&quot;: True or False, # Optional. By default, the LLM policy check is bypassed for short utterances. Enabling this setting applies the policy check to all utterances, including those that would normally be skipped.
      &quot;failOpen&quot;: True or False, # Optional. If an error occurs during the policy check, fail open and do not trigger the guardrail.
      &quot;maxConversationMessages&quot;: 42, # Optional. When checking this policy, consider the last &#x27;n&#x27; messages in the conversation. When not set a default value of 10 will be used.
      &quot;modelSettings&quot;: { # Model settings contains various configurations for the LLM model. # Optional. Model settings.
        &quot;model&quot;: &quot;A String&quot;, # Optional. The LLM model that the agent should use. If not set, the agent will inherit the model from its parent agent.
        &quot;temperature&quot;: 3.14, # Optional. If set, this temperature will be used for the LLM model. Temperature controls the randomness of the model&#x27;s responses. Lower temperatures produce responses that are more predictable. Higher temperatures produce responses that are more creative.
      },
      &quot;policyScope&quot;: &quot;A String&quot;, # Required. Defines when to apply the policy check during the conversation. If set to `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input. When applying the policy to the agent response, additional latency will be introduced before the agent can respond.
      &quot;prompt&quot;: &quot;A String&quot;, # Required. Policy prompt.
    },
    &quot;defaultSettings&quot;: { # Configuration for default system security settings. # Optional. Use the system&#x27;s predefined default security settings. To select this mode, include an empty &#x27;default_settings&#x27; message in the request. The &#x27;default_prompt_template&#x27; field within will be populated by the server in the response.
      &quot;defaultPromptTemplate&quot;: &quot;A String&quot;, # Output only. The default prompt template used by the system. This field is for display purposes to show the user what prompt the system uses by default. It is OUTPUT_ONLY.
    },
    &quot;failOpen&quot;: True or False, # Optional. Determines the behavior when the guardrail encounters an LLM error. - If true: the guardrail is bypassed. - If false (default): the guardrail triggers/blocks. Note: If a custom policy is provided, this field is ignored in favor of the policy&#x27;s &#x27;fail_open&#x27; configuration.
  },
  &quot;modelSafety&quot;: { # Model safety settings overrides. When this is set, it will override the default settings and trigger the guardrail if the response is considered unsafe. # Optional. Guardrail that blocks the conversation if the LLM response is considered unsafe based on the model safety settings.
    &quot;safetySettings&quot;: [ # Required. List of safety settings.
      { # Safety setting.
        &quot;category&quot;: &quot;A String&quot;, # Required. The harm category.
        &quot;threshold&quot;: &quot;A String&quot;, # Required. The harm block threshold.
      },
    ],
  },
  &quot;name&quot;: &quot;A String&quot;, # Identifier. The unique identifier of the guardrail. Format: `projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}`
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when the guardrail was last updated.
}</pre>
</div>

</body></html>