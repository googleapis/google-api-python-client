<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="dataplex_v1.html">Cloud Dataplex API</a> . <a href="dataplex_v1.projects.html">projects</a> . <a href="dataplex_v1.projects.locations.html">locations</a> . <a href="dataplex_v1.projects.locations.dataScans.html">dataScans</a> . <a href="dataplex_v1.projects.locations.dataScans.jobs.html">jobs</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#get">get(name, view=None, x__xgafv=None)</a></code></p>
<p class="firstline">Get DataScanJob resource.</p>
<p class="toc_element">
  <code><a href="#list">list(parent, pageSize=None, pageToken=None, x__xgafv=None)</a></code></p>
<p class="firstline">Lists DataScanJobs under the given dataScan.</p>
<p class="toc_element">
  <code><a href="#list_next">list_next()</a></code></p>
<p class="firstline">Retrieves the next page of results.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="get">get(name, view=None, x__xgafv=None)</code>
  <pre>Get DataScanJob resource.

Args:
  name: string, Required. The resource name of the DataScanJob: projects/{project}/locations/{location_id}/dataScans/{data_scan_id}/dataScanJobs/{data_scan_job_id} where {project} refers to a project_id or project_number and location_id refers to a GCP region. (required)
  view: string, Optional. Used to select the subset of DataScan information to return. Defaults to BASIC.
    Allowed values
      DATA_SCAN_JOB_VIEW_UNSPECIFIED - The API will default to the BASIC view.
      BASIC - Basic view that does not include spec and result.
      FULL - Include everything.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A DataScanJob represents an instance of a data scan.
  &quot;dataProfileResult&quot;: { # DataProfileResult defines the output of DataProfileScan. Each field of the table will have field type specific profile result. # Output only. The result of the data profile scan.
    &quot;profile&quot;: { # Profile information describing the structure and layout of the data and contains the profile info. # This represents the profile information per field.
      &quot;fields&quot;: [ # The sequence of fields describing data in table entities.
        { # Represents a column field within a table schema.
          &quot;mode&quot;: &quot;A String&quot;, # The mode of the field. Its value will be: REQUIRED, if it is a required field. NULLABLE, if it is an optional field. REPEATED, if it is a repeated field.
          &quot;name&quot;: &quot;A String&quot;, # The name of the field.
          &quot;profile&quot;: { # ProfileInfo defines the profile information for each schema field type. # The profile information for the corresponding field.
            &quot;distinctRatio&quot;: 3.14, # The ratio of rows that are distinct against the rows in the sampled data.
            &quot;doubleProfile&quot;: { # DoubleFieldInfo defines output for any double type field. # The corresponding double field profile.
              &quot;average&quot;: 3.14, # The average of non-null values of double field in the sampled data. Return NaN, if the field has a NaN. Optional if zero non-null rows.
              &quot;max&quot;: 3.14, # The maximum value of a double field in the sampled data. Return NaN, if the field has a NaN. Optional if zero non-null rows.
              &quot;min&quot;: 3.14, # The minimum value of a double field in the sampled data. Return NaN, if the field has a NaN. Optional if zero non-null rows.
              &quot;quartiles&quot;: [ # A quartile divide the numebr of data points into four parts, or quarters, of more-or-less equal size. Three main quartiles used are: The first quartile (Q1) splits off the lowest 25% of data from the highest 75%. It is also known as the lower or 25th empirical quartile, as 25% of the data is below this point. The second quartile (Q2) is the median of a data set. So, 50% of the data lies below this point. The third quartile (Q3) splits off the highest 25% of data from the lowest 75%. It is known as the upper or 75th empirical quartile, as 75% of the data lies below this point. So, here the quartiles is provided as an ordered list of quartile values, occurring in order Q1, median, Q3.
                3.14,
              ],
              &quot;standardDeviation&quot;: 3.14, # The standard deviation of non-null of double field in the sampled data. Return NaN, if the field has a NaN. Optional if zero non-null rows.
            },
            &quot;integerProfile&quot;: { # IntegerFieldInfo defines output for any integer type field. # The corresponding integer field profile.
              &quot;average&quot;: 3.14, # The average of non-null values of integer field in the sampled data. Return NaN, if the field has a NaN. Optional if zero non-null rows.
              &quot;max&quot;: &quot;A String&quot;, # The maximum value of an integer field in the sampled data. Return NaN, if the field has a NaN. Optional if zero non-null rows.
              &quot;min&quot;: &quot;A String&quot;, # The minimum value of an integer field in the sampled data. Return NaN, if the field has a NaN. Optional if zero non-null rows.
              &quot;quartiles&quot;: [ # A quartile divide the number of data points into four parts, or quarters, of more-or-less equal size. Three main quartiles used are: The first quartile (Q1) splits off the lowest 25% of data from the highest 75%. It is also known as the lower or 25th empirical quartile, as 25% of the data is below this point. The second quartile (Q2) is the median of a data set. So, 50% of the data lies below this point. The third quartile (Q3) splits off the highest 25% of data from the lowest 75%. It is known as the upper or 75th empirical quartile, as 75% of the data lies below this point. So, here the quartiles is provided as an ordered list of quartile values, occurring in order Q1, median, Q3.
                &quot;A String&quot;,
              ],
              &quot;standardDeviation&quot;: 3.14, # The standard deviation of non-null of integer field in the sampled data. Return NaN, if the field has a NaN. Optional if zero non-null rows.
            },
            &quot;nullRatio&quot;: 3.14, # The ratio of null rows against the rows in the sampled data.
            &quot;stringProfile&quot;: { # StringFieldInfo defines output info for any string type field. # The corresponding string field profile.
              &quot;averageLength&quot;: 3.14, # The average length of a string field in the sampled data. Optional if zero non-null rows.
              &quot;maxLength&quot;: &quot;A String&quot;, # The maximum length of a string field in the sampled data. Optional if zero non-null rows.
              &quot;minLength&quot;: &quot;A String&quot;, # The minimum length of the string field in the sampled data. Optional if zero non-null rows.
            },
            &quot;topNValues&quot;: [ # The array of top N values of the field in the sampled data. Currently N is set as 10 or equal to distinct values in the field, whichever is smaller. This will be optional for complex non-groupable data-types such as JSON, ARRAY, JSON, STRUCT.
              { # The TopNValue defines the structure of output of top N values of a field.
                &quot;count&quot;: &quot;A String&quot;, # The frequency count of the corresponding value in the field.
                &quot;value&quot;: &quot;A String&quot;, # The value is the string value of the actual value from the field.
              },
            ],
          },
          &quot;type&quot;: &quot;A String&quot;, # The field data type. Possible values include: STRING BYTE INT64 INT32 INT16 DOUBLE FLOAT DECIMAL BOOLEAN BINARY TIMESTAMP DATE TIME NULL RECORD
        },
      ],
    },
    &quot;rowCount&quot;: &quot;A String&quot;, # The count of all rows in the sampled data. Return 0, if zero rows.
    &quot;scannedData&quot;: { # The data scanned during processing (e.g. in incremental DataScan) # The data scanned for this profile.
      &quot;incrementalField&quot;: { # A data range denoted by a pair of start/end values of a field. # The range denoted by values of an incremental field
        &quot;end&quot;: &quot;A String&quot;, # Value that marks the end of the range
        &quot;field&quot;: &quot;A String&quot;, # The field that contains values which monotonically increases over time (e.g. timestamp).
        &quot;start&quot;: &quot;A String&quot;, # Value that marks the start of the range
      },
    },
  },
  &quot;dataProfileSpec&quot;: { # DataProfileScan related setting. # Output only. DataProfileScan related setting.
  },
  &quot;dataQualityResult&quot;: { # The output of a DataQualityScan. # Output only. The result of the data quality scan.
    &quot;dimensions&quot;: [ # A list of results at the dimension-level.
      { # DataQualityDimensionResult provides a more detailed, per-dimension level view of the results.
        &quot;passed&quot;: True or False, # Whether the dimension passed or failed.
      },
    ],
    &quot;passed&quot;: True or False, # Overall data quality result -- true if all rules passed.
    &quot;rowCount&quot;: &quot;A String&quot;, # The count of rows processed.
    &quot;rules&quot;: [ # A list of all the rules in a job, and their results.
      { # DataQualityRuleResult provides a more detailed, per-rule level view of the results.
        &quot;evaluatedCount&quot;: &quot;A String&quot;, # The number of rows a rule was evaluated against. This field is only valid for ColumnMap type rules. Evaluated count can be configured to either (1) include all rows (default) - with null rows automatically failing rule evaluation OR (2) exclude null rows from the evaluated_count, by setting ignore_nulls = true
        &quot;failingRowsQuery&quot;: &quot;A String&quot;, # The query to find rows that did not pass this rule. Only applies to ColumnMap and RowCondition rules.
        &quot;nullCount&quot;: &quot;A String&quot;, # The number of rows with null values in the specified column.
        &quot;passRatio&quot;: 3.14, # The ratio of passed_count / evaluated_count. This field is only valid for ColumnMap type rules.
        &quot;passed&quot;: True or False, # Whether the rule passed or failed.
        &quot;passedCount&quot;: &quot;A String&quot;, # The number of rows which passed a rule evaluation. This field is only valid for ColumnMap type rules.
        &quot;rule&quot;: { # A rule captures data quality intent about a data source. # The rule specified in the DataQualitySpec, as is.
          &quot;column&quot;: &quot;A String&quot;, # Optional. The unnested column which this rule is evaluated against.
          &quot;dimension&quot;: &quot;A String&quot;, # Required. The dimension a rule belongs to. Results are also aggregated at the dimension-level. Supported dimensions are &quot;COMPLETENESS&quot;, &quot;ACCURACY&quot;, &quot;CONSISTENCY&quot;, &quot;VALIDITY&quot;, &quot;UNIQUENESS&quot;, &quot;INTEGRITY&quot;
          &quot;ignoreNull&quot;: True or False, # Optional. Rows with null values will automatically fail a rule, unless ignore_null is true. In that case, such null rows are trivially considered passing. Only applicable to ColumnMap rules.
          &quot;nonNullExpectation&quot;: { # Evaluates whether each column value is null. # ColumnMap rule which evaluates whether each column value is null.
          },
          &quot;rangeExpectation&quot;: { # Evaluates whether each column value lies between a specified range. # ColumnMap rule which evaluates whether each column value lies between a specified range.
            &quot;maxValue&quot;: &quot;A String&quot;, # Optional. The maximum column value allowed for a row to pass this validation. At least one of min_value and max_value need to be provided.
            &quot;minValue&quot;: &quot;A String&quot;, # Optional. The minimum column value allowed for a row to pass this validation. At least one of min_value and max_value need to be provided.
            &quot;strictMaxEnabled&quot;: True or False, # Optional. Whether each value needs to be strictly lesser than (&#x27;&lt;&#x27;) the maximum, or if equality is allowed. Only relevant if a max_value has been defined. Default = false.
            &quot;strictMinEnabled&quot;: True or False, # Optional. Whether each value needs to be strictly greater than (&#x27;&gt;&#x27;) the minimum, or if equality is allowed. Only relevant if a min_value has been defined. Default = false.
          },
          &quot;regexExpectation&quot;: { # Evaluates whether each column value matches a specified regex. # ColumnMap rule which evaluates whether each column value matches a specified regex.
            &quot;regex&quot;: &quot;A String&quot;,
          },
          &quot;rowConditionExpectation&quot;: { # Evaluates whether each row passes the specified condition. The SQL expression needs to use BigQuery standard SQL syntax and should produce a boolean per row as the result. Example: col1 &gt;= 0 AND col2 &lt; 10 # Table rule which evaluates whether each row passes the specified condition.
            &quot;sqlExpression&quot;: &quot;A String&quot;,
          },
          &quot;setExpectation&quot;: { # Evaluates whether each column value is contained by a specified set. # ColumnMap rule which evaluates whether each column value is contained by a specified set.
            &quot;values&quot;: [
              &quot;A String&quot;,
            ],
          },
          &quot;statisticRangeExpectation&quot;: { # Evaluates whether the column aggregate statistic lies between a specified range. # ColumnAggregate rule which evaluates whether the column aggregate statistic lies between a specified range.
            &quot;maxValue&quot;: &quot;A String&quot;, # The maximum column statistic value allowed for a row to pass this validation. At least one of min_value and max_value need to be provided.
            &quot;minValue&quot;: &quot;A String&quot;, # The minimum column statistic value allowed for a row to pass this validation. At least one of min_value and max_value need to be provided.
            &quot;statistic&quot;: &quot;A String&quot;,
            &quot;strictMaxEnabled&quot;: True or False, # Whether column statistic needs to be strictly lesser than (&#x27;&lt;&#x27;) the maximum, or if equality is allowed. Only relevant if a max_value has been defined. Default = false.
            &quot;strictMinEnabled&quot;: True or False, # Whether column statistic needs to be strictly greater than (&#x27;&gt;&#x27;) the minimum, or if equality is allowed. Only relevant if a min_value has been defined. Default = false.
          },
          &quot;tableConditionExpectation&quot;: { # Evaluates whether the provided expression is true. The SQL expression needs to use BigQuery standard SQL syntax and should produce a scalar boolean result. Example: MIN(col1) &gt;= 0 # Table rule which evaluates whether the provided expression is true.
            &quot;sqlExpression&quot;: &quot;A String&quot;,
          },
          &quot;threshold&quot;: 3.14, # Optional. The minimum ratio of passing_rows / total_rows required to pass this rule. Default = 1.0
          &quot;uniquenessExpectation&quot;: { # Evaluates whether the column has duplicates. # ColumnAggregate rule which evaluates whether the column has duplicates.
          },
        },
      },
    ],
    &quot;scannedData&quot;: { # The data scanned during processing (e.g. in incremental DataScan) # The data scanned for this result.
      &quot;incrementalField&quot;: { # A data range denoted by a pair of start/end values of a field. # The range denoted by values of an incremental field
        &quot;end&quot;: &quot;A String&quot;, # Value that marks the end of the range
        &quot;field&quot;: &quot;A String&quot;, # The field that contains values which monotonically increases over time (e.g. timestamp).
        &quot;start&quot;: &quot;A String&quot;, # Value that marks the start of the range
      },
    },
  },
  &quot;dataQualitySpec&quot;: { # DataQualityScan related setting. # Output only. DataQualityScan related setting.
    &quot;rules&quot;: [ # The list of rules to evaluate against a data source. At least one rule is required.
      { # A rule captures data quality intent about a data source.
        &quot;column&quot;: &quot;A String&quot;, # Optional. The unnested column which this rule is evaluated against.
        &quot;dimension&quot;: &quot;A String&quot;, # Required. The dimension a rule belongs to. Results are also aggregated at the dimension-level. Supported dimensions are &quot;COMPLETENESS&quot;, &quot;ACCURACY&quot;, &quot;CONSISTENCY&quot;, &quot;VALIDITY&quot;, &quot;UNIQUENESS&quot;, &quot;INTEGRITY&quot;
        &quot;ignoreNull&quot;: True or False, # Optional. Rows with null values will automatically fail a rule, unless ignore_null is true. In that case, such null rows are trivially considered passing. Only applicable to ColumnMap rules.
        &quot;nonNullExpectation&quot;: { # Evaluates whether each column value is null. # ColumnMap rule which evaluates whether each column value is null.
        },
        &quot;rangeExpectation&quot;: { # Evaluates whether each column value lies between a specified range. # ColumnMap rule which evaluates whether each column value lies between a specified range.
          &quot;maxValue&quot;: &quot;A String&quot;, # Optional. The maximum column value allowed for a row to pass this validation. At least one of min_value and max_value need to be provided.
          &quot;minValue&quot;: &quot;A String&quot;, # Optional. The minimum column value allowed for a row to pass this validation. At least one of min_value and max_value need to be provided.
          &quot;strictMaxEnabled&quot;: True or False, # Optional. Whether each value needs to be strictly lesser than (&#x27;&lt;&#x27;) the maximum, or if equality is allowed. Only relevant if a max_value has been defined. Default = false.
          &quot;strictMinEnabled&quot;: True or False, # Optional. Whether each value needs to be strictly greater than (&#x27;&gt;&#x27;) the minimum, or if equality is allowed. Only relevant if a min_value has been defined. Default = false.
        },
        &quot;regexExpectation&quot;: { # Evaluates whether each column value matches a specified regex. # ColumnMap rule which evaluates whether each column value matches a specified regex.
          &quot;regex&quot;: &quot;A String&quot;,
        },
        &quot;rowConditionExpectation&quot;: { # Evaluates whether each row passes the specified condition. The SQL expression needs to use BigQuery standard SQL syntax and should produce a boolean per row as the result. Example: col1 &gt;= 0 AND col2 &lt; 10 # Table rule which evaluates whether each row passes the specified condition.
          &quot;sqlExpression&quot;: &quot;A String&quot;,
        },
        &quot;setExpectation&quot;: { # Evaluates whether each column value is contained by a specified set. # ColumnMap rule which evaluates whether each column value is contained by a specified set.
          &quot;values&quot;: [
            &quot;A String&quot;,
          ],
        },
        &quot;statisticRangeExpectation&quot;: { # Evaluates whether the column aggregate statistic lies between a specified range. # ColumnAggregate rule which evaluates whether the column aggregate statistic lies between a specified range.
          &quot;maxValue&quot;: &quot;A String&quot;, # The maximum column statistic value allowed for a row to pass this validation. At least one of min_value and max_value need to be provided.
          &quot;minValue&quot;: &quot;A String&quot;, # The minimum column statistic value allowed for a row to pass this validation. At least one of min_value and max_value need to be provided.
          &quot;statistic&quot;: &quot;A String&quot;,
          &quot;strictMaxEnabled&quot;: True or False, # Whether column statistic needs to be strictly lesser than (&#x27;&lt;&#x27;) the maximum, or if equality is allowed. Only relevant if a max_value has been defined. Default = false.
          &quot;strictMinEnabled&quot;: True or False, # Whether column statistic needs to be strictly greater than (&#x27;&gt;&#x27;) the minimum, or if equality is allowed. Only relevant if a min_value has been defined. Default = false.
        },
        &quot;tableConditionExpectation&quot;: { # Evaluates whether the provided expression is true. The SQL expression needs to use BigQuery standard SQL syntax and should produce a scalar boolean result. Example: MIN(col1) &gt;= 0 # Table rule which evaluates whether the provided expression is true.
          &quot;sqlExpression&quot;: &quot;A String&quot;,
        },
        &quot;threshold&quot;: 3.14, # Optional. The minimum ratio of passing_rows / total_rows required to pass this rule. Default = 1.0
        &quot;uniquenessExpectation&quot;: { # Evaluates whether the column has duplicates. # ColumnAggregate rule which evaluates whether the column has duplicates.
        },
      },
    ],
  },
  &quot;endTime&quot;: &quot;A String&quot;, # Output only. The time when the DataScanJob ended.
  &quot;message&quot;: &quot;A String&quot;, # Output only. Additional information about the current state.
  &quot;name&quot;: &quot;A String&quot;, # Output only. The relative resource name of the DataScanJob, of the form: projects/{project}/locations/{location_id}/dataScans/{datascan_id}/jobs/{job_id}. where {project} refers to a project_id or project_number and location_id refers to a GCP region.
  &quot;startTime&quot;: &quot;A String&quot;, # Output only. The time when the DataScanJob was started.
  &quot;state&quot;: &quot;A String&quot;, # Output only. Execution state for the DataScanJob.
  &quot;type&quot;: &quot;A String&quot;, # Output only. The type of the parent DataScan.
  &quot;uid&quot;: &quot;A String&quot;, # Output only. System generated globally unique ID for the DataScanJob.
}</pre>
</div>

<div class="method">
    <code class="details" id="list">list(parent, pageSize=None, pageToken=None, x__xgafv=None)</code>
  <pre>Lists DataScanJobs under the given dataScan.

Args:
  parent: string, Required. The resource name of the parent environment: projects/{project}/locations/{location_id}/dataScans/{data_scan_id} where {project} refers to a project_id or project_number and location_id refers to a GCP region. (required)
  pageSize: integer, Optional. Maximum number of DataScanJobs to return. The service may return fewer than this value. If unspecified, at most 10 DataScanJobs will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
  pageToken: string, Optional. Page token received from a previous ListDataScanJobs call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to ListDataScanJobs must match the call that provided the page token.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # List DataScanJobs response.
  &quot;dataScanJobs&quot;: [ # DataScanJobs (metadata only) under a given dataScan.
    { # A DataScanJob represents an instance of a data scan.
      &quot;dataProfileResult&quot;: { # DataProfileResult defines the output of DataProfileScan. Each field of the table will have field type specific profile result. # Output only. The result of the data profile scan.
        &quot;profile&quot;: { # Profile information describing the structure and layout of the data and contains the profile info. # This represents the profile information per field.
          &quot;fields&quot;: [ # The sequence of fields describing data in table entities.
            { # Represents a column field within a table schema.
              &quot;mode&quot;: &quot;A String&quot;, # The mode of the field. Its value will be: REQUIRED, if it is a required field. NULLABLE, if it is an optional field. REPEATED, if it is a repeated field.
              &quot;name&quot;: &quot;A String&quot;, # The name of the field.
              &quot;profile&quot;: { # ProfileInfo defines the profile information for each schema field type. # The profile information for the corresponding field.
                &quot;distinctRatio&quot;: 3.14, # The ratio of rows that are distinct against the rows in the sampled data.
                &quot;doubleProfile&quot;: { # DoubleFieldInfo defines output for any double type field. # The corresponding double field profile.
                  &quot;average&quot;: 3.14, # The average of non-null values of double field in the sampled data. Return NaN, if the field has a NaN. Optional if zero non-null rows.
                  &quot;max&quot;: 3.14, # The maximum value of a double field in the sampled data. Return NaN, if the field has a NaN. Optional if zero non-null rows.
                  &quot;min&quot;: 3.14, # The minimum value of a double field in the sampled data. Return NaN, if the field has a NaN. Optional if zero non-null rows.
                  &quot;quartiles&quot;: [ # A quartile divide the numebr of data points into four parts, or quarters, of more-or-less equal size. Three main quartiles used are: The first quartile (Q1) splits off the lowest 25% of data from the highest 75%. It is also known as the lower or 25th empirical quartile, as 25% of the data is below this point. The second quartile (Q2) is the median of a data set. So, 50% of the data lies below this point. The third quartile (Q3) splits off the highest 25% of data from the lowest 75%. It is known as the upper or 75th empirical quartile, as 75% of the data lies below this point. So, here the quartiles is provided as an ordered list of quartile values, occurring in order Q1, median, Q3.
                    3.14,
                  ],
                  &quot;standardDeviation&quot;: 3.14, # The standard deviation of non-null of double field in the sampled data. Return NaN, if the field has a NaN. Optional if zero non-null rows.
                },
                &quot;integerProfile&quot;: { # IntegerFieldInfo defines output for any integer type field. # The corresponding integer field profile.
                  &quot;average&quot;: 3.14, # The average of non-null values of integer field in the sampled data. Return NaN, if the field has a NaN. Optional if zero non-null rows.
                  &quot;max&quot;: &quot;A String&quot;, # The maximum value of an integer field in the sampled data. Return NaN, if the field has a NaN. Optional if zero non-null rows.
                  &quot;min&quot;: &quot;A String&quot;, # The minimum value of an integer field in the sampled data. Return NaN, if the field has a NaN. Optional if zero non-null rows.
                  &quot;quartiles&quot;: [ # A quartile divide the number of data points into four parts, or quarters, of more-or-less equal size. Three main quartiles used are: The first quartile (Q1) splits off the lowest 25% of data from the highest 75%. It is also known as the lower or 25th empirical quartile, as 25% of the data is below this point. The second quartile (Q2) is the median of a data set. So, 50% of the data lies below this point. The third quartile (Q3) splits off the highest 25% of data from the lowest 75%. It is known as the upper or 75th empirical quartile, as 75% of the data lies below this point. So, here the quartiles is provided as an ordered list of quartile values, occurring in order Q1, median, Q3.
                    &quot;A String&quot;,
                  ],
                  &quot;standardDeviation&quot;: 3.14, # The standard deviation of non-null of integer field in the sampled data. Return NaN, if the field has a NaN. Optional if zero non-null rows.
                },
                &quot;nullRatio&quot;: 3.14, # The ratio of null rows against the rows in the sampled data.
                &quot;stringProfile&quot;: { # StringFieldInfo defines output info for any string type field. # The corresponding string field profile.
                  &quot;averageLength&quot;: 3.14, # The average length of a string field in the sampled data. Optional if zero non-null rows.
                  &quot;maxLength&quot;: &quot;A String&quot;, # The maximum length of a string field in the sampled data. Optional if zero non-null rows.
                  &quot;minLength&quot;: &quot;A String&quot;, # The minimum length of the string field in the sampled data. Optional if zero non-null rows.
                },
                &quot;topNValues&quot;: [ # The array of top N values of the field in the sampled data. Currently N is set as 10 or equal to distinct values in the field, whichever is smaller. This will be optional for complex non-groupable data-types such as JSON, ARRAY, JSON, STRUCT.
                  { # The TopNValue defines the structure of output of top N values of a field.
                    &quot;count&quot;: &quot;A String&quot;, # The frequency count of the corresponding value in the field.
                    &quot;value&quot;: &quot;A String&quot;, # The value is the string value of the actual value from the field.
                  },
                ],
              },
              &quot;type&quot;: &quot;A String&quot;, # The field data type. Possible values include: STRING BYTE INT64 INT32 INT16 DOUBLE FLOAT DECIMAL BOOLEAN BINARY TIMESTAMP DATE TIME NULL RECORD
            },
          ],
        },
        &quot;rowCount&quot;: &quot;A String&quot;, # The count of all rows in the sampled data. Return 0, if zero rows.
        &quot;scannedData&quot;: { # The data scanned during processing (e.g. in incremental DataScan) # The data scanned for this profile.
          &quot;incrementalField&quot;: { # A data range denoted by a pair of start/end values of a field. # The range denoted by values of an incremental field
            &quot;end&quot;: &quot;A String&quot;, # Value that marks the end of the range
            &quot;field&quot;: &quot;A String&quot;, # The field that contains values which monotonically increases over time (e.g. timestamp).
            &quot;start&quot;: &quot;A String&quot;, # Value that marks the start of the range
          },
        },
      },
      &quot;dataProfileSpec&quot;: { # DataProfileScan related setting. # Output only. DataProfileScan related setting.
      },
      &quot;dataQualityResult&quot;: { # The output of a DataQualityScan. # Output only. The result of the data quality scan.
        &quot;dimensions&quot;: [ # A list of results at the dimension-level.
          { # DataQualityDimensionResult provides a more detailed, per-dimension level view of the results.
            &quot;passed&quot;: True or False, # Whether the dimension passed or failed.
          },
        ],
        &quot;passed&quot;: True or False, # Overall data quality result -- true if all rules passed.
        &quot;rowCount&quot;: &quot;A String&quot;, # The count of rows processed.
        &quot;rules&quot;: [ # A list of all the rules in a job, and their results.
          { # DataQualityRuleResult provides a more detailed, per-rule level view of the results.
            &quot;evaluatedCount&quot;: &quot;A String&quot;, # The number of rows a rule was evaluated against. This field is only valid for ColumnMap type rules. Evaluated count can be configured to either (1) include all rows (default) - with null rows automatically failing rule evaluation OR (2) exclude null rows from the evaluated_count, by setting ignore_nulls = true
            &quot;failingRowsQuery&quot;: &quot;A String&quot;, # The query to find rows that did not pass this rule. Only applies to ColumnMap and RowCondition rules.
            &quot;nullCount&quot;: &quot;A String&quot;, # The number of rows with null values in the specified column.
            &quot;passRatio&quot;: 3.14, # The ratio of passed_count / evaluated_count. This field is only valid for ColumnMap type rules.
            &quot;passed&quot;: True or False, # Whether the rule passed or failed.
            &quot;passedCount&quot;: &quot;A String&quot;, # The number of rows which passed a rule evaluation. This field is only valid for ColumnMap type rules.
            &quot;rule&quot;: { # A rule captures data quality intent about a data source. # The rule specified in the DataQualitySpec, as is.
              &quot;column&quot;: &quot;A String&quot;, # Optional. The unnested column which this rule is evaluated against.
              &quot;dimension&quot;: &quot;A String&quot;, # Required. The dimension a rule belongs to. Results are also aggregated at the dimension-level. Supported dimensions are &quot;COMPLETENESS&quot;, &quot;ACCURACY&quot;, &quot;CONSISTENCY&quot;, &quot;VALIDITY&quot;, &quot;UNIQUENESS&quot;, &quot;INTEGRITY&quot;
              &quot;ignoreNull&quot;: True or False, # Optional. Rows with null values will automatically fail a rule, unless ignore_null is true. In that case, such null rows are trivially considered passing. Only applicable to ColumnMap rules.
              &quot;nonNullExpectation&quot;: { # Evaluates whether each column value is null. # ColumnMap rule which evaluates whether each column value is null.
              },
              &quot;rangeExpectation&quot;: { # Evaluates whether each column value lies between a specified range. # ColumnMap rule which evaluates whether each column value lies between a specified range.
                &quot;maxValue&quot;: &quot;A String&quot;, # Optional. The maximum column value allowed for a row to pass this validation. At least one of min_value and max_value need to be provided.
                &quot;minValue&quot;: &quot;A String&quot;, # Optional. The minimum column value allowed for a row to pass this validation. At least one of min_value and max_value need to be provided.
                &quot;strictMaxEnabled&quot;: True or False, # Optional. Whether each value needs to be strictly lesser than (&#x27;&lt;&#x27;) the maximum, or if equality is allowed. Only relevant if a max_value has been defined. Default = false.
                &quot;strictMinEnabled&quot;: True or False, # Optional. Whether each value needs to be strictly greater than (&#x27;&gt;&#x27;) the minimum, or if equality is allowed. Only relevant if a min_value has been defined. Default = false.
              },
              &quot;regexExpectation&quot;: { # Evaluates whether each column value matches a specified regex. # ColumnMap rule which evaluates whether each column value matches a specified regex.
                &quot;regex&quot;: &quot;A String&quot;,
              },
              &quot;rowConditionExpectation&quot;: { # Evaluates whether each row passes the specified condition. The SQL expression needs to use BigQuery standard SQL syntax and should produce a boolean per row as the result. Example: col1 &gt;= 0 AND col2 &lt; 10 # Table rule which evaluates whether each row passes the specified condition.
                &quot;sqlExpression&quot;: &quot;A String&quot;,
              },
              &quot;setExpectation&quot;: { # Evaluates whether each column value is contained by a specified set. # ColumnMap rule which evaluates whether each column value is contained by a specified set.
                &quot;values&quot;: [
                  &quot;A String&quot;,
                ],
              },
              &quot;statisticRangeExpectation&quot;: { # Evaluates whether the column aggregate statistic lies between a specified range. # ColumnAggregate rule which evaluates whether the column aggregate statistic lies between a specified range.
                &quot;maxValue&quot;: &quot;A String&quot;, # The maximum column statistic value allowed for a row to pass this validation. At least one of min_value and max_value need to be provided.
                &quot;minValue&quot;: &quot;A String&quot;, # The minimum column statistic value allowed for a row to pass this validation. At least one of min_value and max_value need to be provided.
                &quot;statistic&quot;: &quot;A String&quot;,
                &quot;strictMaxEnabled&quot;: True or False, # Whether column statistic needs to be strictly lesser than (&#x27;&lt;&#x27;) the maximum, or if equality is allowed. Only relevant if a max_value has been defined. Default = false.
                &quot;strictMinEnabled&quot;: True or False, # Whether column statistic needs to be strictly greater than (&#x27;&gt;&#x27;) the minimum, or if equality is allowed. Only relevant if a min_value has been defined. Default = false.
              },
              &quot;tableConditionExpectation&quot;: { # Evaluates whether the provided expression is true. The SQL expression needs to use BigQuery standard SQL syntax and should produce a scalar boolean result. Example: MIN(col1) &gt;= 0 # Table rule which evaluates whether the provided expression is true.
                &quot;sqlExpression&quot;: &quot;A String&quot;,
              },
              &quot;threshold&quot;: 3.14, # Optional. The minimum ratio of passing_rows / total_rows required to pass this rule. Default = 1.0
              &quot;uniquenessExpectation&quot;: { # Evaluates whether the column has duplicates. # ColumnAggregate rule which evaluates whether the column has duplicates.
              },
            },
          },
        ],
        &quot;scannedData&quot;: { # The data scanned during processing (e.g. in incremental DataScan) # The data scanned for this result.
          &quot;incrementalField&quot;: { # A data range denoted by a pair of start/end values of a field. # The range denoted by values of an incremental field
            &quot;end&quot;: &quot;A String&quot;, # Value that marks the end of the range
            &quot;field&quot;: &quot;A String&quot;, # The field that contains values which monotonically increases over time (e.g. timestamp).
            &quot;start&quot;: &quot;A String&quot;, # Value that marks the start of the range
          },
        },
      },
      &quot;dataQualitySpec&quot;: { # DataQualityScan related setting. # Output only. DataQualityScan related setting.
        &quot;rules&quot;: [ # The list of rules to evaluate against a data source. At least one rule is required.
          { # A rule captures data quality intent about a data source.
            &quot;column&quot;: &quot;A String&quot;, # Optional. The unnested column which this rule is evaluated against.
            &quot;dimension&quot;: &quot;A String&quot;, # Required. The dimension a rule belongs to. Results are also aggregated at the dimension-level. Supported dimensions are &quot;COMPLETENESS&quot;, &quot;ACCURACY&quot;, &quot;CONSISTENCY&quot;, &quot;VALIDITY&quot;, &quot;UNIQUENESS&quot;, &quot;INTEGRITY&quot;
            &quot;ignoreNull&quot;: True or False, # Optional. Rows with null values will automatically fail a rule, unless ignore_null is true. In that case, such null rows are trivially considered passing. Only applicable to ColumnMap rules.
            &quot;nonNullExpectation&quot;: { # Evaluates whether each column value is null. # ColumnMap rule which evaluates whether each column value is null.
            },
            &quot;rangeExpectation&quot;: { # Evaluates whether each column value lies between a specified range. # ColumnMap rule which evaluates whether each column value lies between a specified range.
              &quot;maxValue&quot;: &quot;A String&quot;, # Optional. The maximum column value allowed for a row to pass this validation. At least one of min_value and max_value need to be provided.
              &quot;minValue&quot;: &quot;A String&quot;, # Optional. The minimum column value allowed for a row to pass this validation. At least one of min_value and max_value need to be provided.
              &quot;strictMaxEnabled&quot;: True or False, # Optional. Whether each value needs to be strictly lesser than (&#x27;&lt;&#x27;) the maximum, or if equality is allowed. Only relevant if a max_value has been defined. Default = false.
              &quot;strictMinEnabled&quot;: True or False, # Optional. Whether each value needs to be strictly greater than (&#x27;&gt;&#x27;) the minimum, or if equality is allowed. Only relevant if a min_value has been defined. Default = false.
            },
            &quot;regexExpectation&quot;: { # Evaluates whether each column value matches a specified regex. # ColumnMap rule which evaluates whether each column value matches a specified regex.
              &quot;regex&quot;: &quot;A String&quot;,
            },
            &quot;rowConditionExpectation&quot;: { # Evaluates whether each row passes the specified condition. The SQL expression needs to use BigQuery standard SQL syntax and should produce a boolean per row as the result. Example: col1 &gt;= 0 AND col2 &lt; 10 # Table rule which evaluates whether each row passes the specified condition.
              &quot;sqlExpression&quot;: &quot;A String&quot;,
            },
            &quot;setExpectation&quot;: { # Evaluates whether each column value is contained by a specified set. # ColumnMap rule which evaluates whether each column value is contained by a specified set.
              &quot;values&quot;: [
                &quot;A String&quot;,
              ],
            },
            &quot;statisticRangeExpectation&quot;: { # Evaluates whether the column aggregate statistic lies between a specified range. # ColumnAggregate rule which evaluates whether the column aggregate statistic lies between a specified range.
              &quot;maxValue&quot;: &quot;A String&quot;, # The maximum column statistic value allowed for a row to pass this validation. At least one of min_value and max_value need to be provided.
              &quot;minValue&quot;: &quot;A String&quot;, # The minimum column statistic value allowed for a row to pass this validation. At least one of min_value and max_value need to be provided.
              &quot;statistic&quot;: &quot;A String&quot;,
              &quot;strictMaxEnabled&quot;: True or False, # Whether column statistic needs to be strictly lesser than (&#x27;&lt;&#x27;) the maximum, or if equality is allowed. Only relevant if a max_value has been defined. Default = false.
              &quot;strictMinEnabled&quot;: True or False, # Whether column statistic needs to be strictly greater than (&#x27;&gt;&#x27;) the minimum, or if equality is allowed. Only relevant if a min_value has been defined. Default = false.
            },
            &quot;tableConditionExpectation&quot;: { # Evaluates whether the provided expression is true. The SQL expression needs to use BigQuery standard SQL syntax and should produce a scalar boolean result. Example: MIN(col1) &gt;= 0 # Table rule which evaluates whether the provided expression is true.
              &quot;sqlExpression&quot;: &quot;A String&quot;,
            },
            &quot;threshold&quot;: 3.14, # Optional. The minimum ratio of passing_rows / total_rows required to pass this rule. Default = 1.0
            &quot;uniquenessExpectation&quot;: { # Evaluates whether the column has duplicates. # ColumnAggregate rule which evaluates whether the column has duplicates.
            },
          },
        ],
      },
      &quot;endTime&quot;: &quot;A String&quot;, # Output only. The time when the DataScanJob ended.
      &quot;message&quot;: &quot;A String&quot;, # Output only. Additional information about the current state.
      &quot;name&quot;: &quot;A String&quot;, # Output only. The relative resource name of the DataScanJob, of the form: projects/{project}/locations/{location_id}/dataScans/{datascan_id}/jobs/{job_id}. where {project} refers to a project_id or project_number and location_id refers to a GCP region.
      &quot;startTime&quot;: &quot;A String&quot;, # Output only. The time when the DataScanJob was started.
      &quot;state&quot;: &quot;A String&quot;, # Output only. Execution state for the DataScanJob.
      &quot;type&quot;: &quot;A String&quot;, # Output only. The type of the parent DataScan.
      &quot;uid&quot;: &quot;A String&quot;, # Output only. System generated globally unique ID for the DataScanJob.
    },
  ],
  &quot;nextPageToken&quot;: &quot;A String&quot;, # Token to retrieve the next page of results, or empty if there are no more results in the list.
}</pre>
</div>

<div class="method">
    <code class="details" id="list_next">list_next()</code>
  <pre>Retrieves the next page of results.

        Args:
          previous_request: The request for the previous page. (required)
          previous_response: The response from the request for the previous page. (required)

        Returns:
          A request object that you can call &#x27;execute()&#x27; on to request the next
          page. Returns None if there are no more items in the collection.
        </pre>
</div>

</body></html>