<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="dlp_v2.html">Cloud Data Loss Prevention (DLP) API</a> . <a href="dlp_v2.projects.html">projects</a> . <a href="dlp_v2.projects.locations.html">locations</a> . <a href="dlp_v2.projects.locations.image.html">image</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#redact">redact(parent, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Redacts potentially sensitive info from an image. This method has limits on input size, processing time, and output size. See https://cloud.google.com/dlp/docs/redacting-sensitive-data-images to learn more. When no InfoTypes or CustomInfoTypes are specified in this request, the system will automatically choose what detectors to run. By default this may be all types, but may change over time as detectors are updated.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="redact">redact(parent, body=None, x__xgafv=None)</code>
  <pre>Redacts potentially sensitive info from an image. This method has limits on input size, processing time, and output size. See https://cloud.google.com/dlp/docs/redacting-sensitive-data-images to learn more. When no InfoTypes or CustomInfoTypes are specified in this request, the system will automatically choose what detectors to run. By default this may be all types, but may change over time as detectors are updated.

Args:
  parent: string, Parent resource name. The format of this value varies depending on whether you have [specified a processing location](https://cloud.google.com/dlp/docs/specifying-location): + Projects scope, location specified: `projects/`PROJECT_ID`/locations/`LOCATION_ID + Projects scope, no location specified (defaults to global): `projects/`PROJECT_ID The following example `parent` string specifies a parent project with the identifier `example-project`, and specifies the `europe-west3` location for processing data: parent=projects/example-project/locations/europe-west3 (required)
  body: object, The request body.
    The object takes the form of:

{ # Request to search for potentially sensitive info in an image and redact it by covering it with a colored rectangle.
  &quot;byteItem&quot;: { # Container for bytes to inspect or redact. # The content must be PNG, JPEG, SVG or BMP.
    &quot;data&quot;: &quot;A String&quot;, # Content data to inspect or redact.
    &quot;type&quot;: &quot;A String&quot;, # The type of data stored in the bytes string. Default will be TEXT_UTF8.
  },
  &quot;imageRedactionConfigs&quot;: [ # The configuration for specifying what content to redact from images.
    { # Configuration for determining how redaction of images should occur.
      &quot;infoType&quot;: { # Type of information detected by the API. # Only one per info_type should be provided per request. If not specified, and redact_all_text is false, the DLP API will redact all text that it matches against all info_types that are found, but not specified in another ImageRedactionConfig.
        &quot;name&quot;: &quot;A String&quot;, # Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
      },
      &quot;redactAllText&quot;: True or False, # If true, all text found in the image, regardless whether it matches an info_type, is redacted. Only one should be provided.
      &quot;redactionColor&quot;: { # Represents a color in the RGB color space. # The color to use when redacting content from an image. If not specified, the default is black.
        &quot;blue&quot;: 3.14, # The amount of blue in the color as a value in the interval [0, 1].
        &quot;green&quot;: 3.14, # The amount of green in the color as a value in the interval [0, 1].
        &quot;red&quot;: 3.14, # The amount of red in the color as a value in the interval [0, 1].
      },
    },
  ],
  &quot;includeFindings&quot;: True or False, # Whether the response should include findings along with the redacted image.
  &quot;inspectConfig&quot;: { # Configuration description of the scanning process. When used with redactContent only info_types and min_likelihood are currently used. # Configuration for the inspector.
    &quot;contentOptions&quot;: [ # List of options defining data content to scan. If empty, text, images, and other content will be included.
      &quot;A String&quot;,
    ],
    &quot;customInfoTypes&quot;: [ # CustomInfoTypes provided by the user. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more.
      { # Custom information type provided by the user. Used to find domain-specific sensitive information configurable to the data in question.
        &quot;detectionRules&quot;: [ # Set of detection rules to apply to all findings of this CustomInfoType. Rules are applied in order that they are specified. Not supported for the `surrogate_type` CustomInfoType.
          { # Deprecated; use `InspectionRuleSet` instead. Rule for modifying a `CustomInfoType` to alter behavior under certain circumstances, depending on the specific details of the rule. Not supported for the `surrogate_type` custom infoType.
            &quot;hotwordRule&quot;: { # The rule that adjusts the likelihood of findings within a certain proximity of hotwords. # Hotword-based detection rule.
              &quot;hotwordRegex&quot;: { # Message defining a custom regular expression. # Regular expression pattern defining what qualifies as a hotword.
                &quot;groupIndexes&quot;: [ # The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
                  42,
                ],
                &quot;pattern&quot;: &quot;A String&quot;, # Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
              },
              &quot;likelihoodAdjustment&quot;: { # Message for specifying an adjustment to the likelihood of a finding as part of a detection rule. # Likelihood adjustment to apply to all matching findings.
                &quot;fixedLikelihood&quot;: &quot;A String&quot;, # Set the likelihood of a finding to a fixed value.
                &quot;relativeLikelihood&quot;: 42, # Increase or decrease the likelihood by the specified number of levels. For example, if a finding would be `POSSIBLE` without the detection rule and `relative_likelihood` is 1, then it is upgraded to `LIKELY`, while a value of -1 would downgrade it to `UNLIKELY`. Likelihood may never drop below `VERY_UNLIKELY` or exceed `VERY_LIKELY`, so applying an adjustment of 1 followed by an adjustment of -1 when base likelihood is `VERY_LIKELY` will result in a final likelihood of `LIKELY`.
              },
              &quot;proximity&quot;: { # Message for specifying a window around a finding to apply a detection rule. # Proximity of the finding within which the entire hotword must reside. The total length of the window cannot exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be used to match substrings of the finding itself. For example, the certainty of a phone number regex &quot;\(\d{3}\) \d{3}-\d{4}&quot; could be adjusted upwards if the area code is known to be the local area code of a company office using the hotword regex &quot;\(xxx\)&quot;, where &quot;xxx&quot; is the area code in question.
                &quot;windowAfter&quot;: 42, # Number of characters after the finding to consider.
                &quot;windowBefore&quot;: 42, # Number of characters before the finding to consider.
              },
            },
          },
        ],
        &quot;dictionary&quot;: { # Custom information type based on a dictionary of words or phrases. This can be used to match sensitive information specific to the data, such as a list of employee IDs or job titles. Dictionary words are case-insensitive and all characters other than letters and digits in the unicode [Basic Multilingual Plane](https://en.wikipedia.org/wiki/Plane_%28Unicode%29#Basic_Multilingual_Plane) will be replaced with whitespace when scanning for matches, so the dictionary phrase &quot;Sam Johnson&quot; will match all three phrases &quot;sam johnson&quot;, &quot;Sam, Johnson&quot;, and &quot;Sam (Johnson)&quot;. Additionally, the characters surrounding any match must be of a different type than the adjacent characters within the word, so letters must be next to non-letters and digits next to non-digits. For example, the dictionary word &quot;jen&quot; will match the first three letters of the text &quot;jen123&quot; but will return no matches for &quot;jennifer&quot;. Dictionary words containing a large number of characters that are not letters or digits may result in unexpected findings because such characters are treated as whitespace. The [limits](https://cloud.google.com/dlp/limits) page contains details about the size limits of dictionaries. For dictionaries that do not fit within these constraints, consider using `LargeCustomDictionaryConfig` in the `StoredInfoType` API. # A list of phrases to detect as a CustomInfoType.
          &quot;cloudStoragePath&quot;: { # Message representing a single file or path in Cloud Storage. # Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
            &quot;path&quot;: &quot;A String&quot;, # A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
          },
          &quot;wordList&quot;: { # Message defining a list of words or phrases to search for in the data. # List of words or phrases to search for.
            &quot;words&quot;: [ # Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits. [required]
              &quot;A String&quot;,
            ],
          },
        },
        &quot;exclusionType&quot;: &quot;A String&quot;, # If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching.
        &quot;infoType&quot;: { # Type of information detected by the API. # CustomInfoType can either be a new infoType, or an extension of built-in infoType, when the name matches one of existing infoTypes and that infoType is specified in `InspectContent.info_types` field. Specifying the latter adds findings to the one detected by the system. If built-in info type is not specified in `InspectContent.info_types` list then the name is treated as a custom info type.
          &quot;name&quot;: &quot;A String&quot;, # Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
        },
        &quot;likelihood&quot;: &quot;A String&quot;, # Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria specified by the rule. Defaults to `VERY_LIKELY` if not specified.
        &quot;regex&quot;: { # Message defining a custom regular expression. # Regular expression based CustomInfoType.
          &quot;groupIndexes&quot;: [ # The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
            42,
          ],
          &quot;pattern&quot;: &quot;A String&quot;, # Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        },
        &quot;storedType&quot;: { # A reference to a StoredInfoType to use with scanning. # Load an existing `StoredInfoType` resource for use in `InspectDataSource`. Not currently supported in `InspectContent`.
          &quot;createTime&quot;: &quot;A String&quot;, # Timestamp indicating when the version of the `StoredInfoType` used for inspection was created. Output-only field, populated by the system.
          &quot;name&quot;: &quot;A String&quot;, # Resource name of the requested `StoredInfoType`, for example `organizations/433245324/storedInfoTypes/432452342` or `projects/project-id/storedInfoTypes/432452342`.
        },
        &quot;surrogateType&quot;: { # Message for detecting output from deidentification transformations such as [`CryptoReplaceFfxFpeConfig`](https://cloud.google.com/dlp/docs/reference/rest/v2/organizations.deidentifyTemplates#cryptoreplaceffxfpeconfig). These types of transformations are those that perform pseudonymization, thereby producing a &quot;surrogate&quot; as output. This should be used in conjunction with a field on the transformation such as `surrogate_info_type`. This CustomInfoType does not support the use of `detection_rules`. # Message for detecting output from deidentification transformations that support reversing.
        },
      },
    ],
    &quot;excludeInfoTypes&quot;: True or False, # When true, excludes type information of the findings.
    &quot;includeQuote&quot;: True or False, # When true, a contextual quote from the data that triggered a finding is included in the response; see Finding.quote.
    &quot;infoTypes&quot;: [ # Restricts what info_types to look for. The values must correspond to InfoType values returned by ListInfoTypes or listed at https://cloud.google.com/dlp/docs/infotypes-reference. When no InfoTypes or CustomInfoTypes are specified in a request, the system may automatically choose what detectors to run. By default this may be all types, but may change over time as detectors are updated. If you need precise control and predictability as to what detectors are run you should specify specific InfoTypes listed in the reference, otherwise a default list will be used, which may change over time.
      { # Type of information detected by the API.
        &quot;name&quot;: &quot;A String&quot;, # Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
      },
    ],
    &quot;limits&quot;: { # Configuration to control the number of findings returned. Cannot be set if de-identification is requested. # Configuration to control the number of findings returned.
      &quot;maxFindingsPerInfoType&quot;: [ # Configuration of findings limit given for specified infoTypes.
        { # Max findings configuration per infoType, per content item or long running DlpJob.
          &quot;infoType&quot;: { # Type of information detected by the API. # Type of information the findings limit applies to. Only one limit per info_type should be provided. If InfoTypeLimit does not have an info_type, the DLP API applies the limit against all info_types that are found but not specified in another InfoTypeLimit.
            &quot;name&quot;: &quot;A String&quot;, # Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
          },
          &quot;maxFindings&quot;: 42, # Max findings limit for the given infoType.
        },
      ],
      &quot;maxFindingsPerItem&quot;: 42, # Max number of findings that will be returned for each item scanned. When set within `InspectJobConfig`, the maximum returned is 2000 regardless if this is set higher. When set within `InspectContentRequest`, this field is ignored.
      &quot;maxFindingsPerRequest&quot;: 42, # Max number of findings that will be returned per request/job. When set within `InspectContentRequest`, the maximum returned is 2000 regardless if this is set higher.
    },
    &quot;minLikelihood&quot;: &quot;A String&quot;, # Only returns findings equal or above this threshold. The default is POSSIBLE. See https://cloud.google.com/dlp/docs/likelihood to learn more.
    &quot;ruleSet&quot;: [ # Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end, other rules are executed in the order they are specified for each info type.
      { # Rule set for modifying a set of infoTypes to alter behavior under certain circumstances, depending on the specific details of the rules within the set.
        &quot;infoTypes&quot;: [ # List of infoTypes this rule set is applied to.
          { # Type of information detected by the API.
            &quot;name&quot;: &quot;A String&quot;, # Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
          },
        ],
        &quot;rules&quot;: [ # Set of rules to be applied to infoTypes. The rules are applied in order.
          { # A single inspection rule to be applied to infoTypes, specified in `InspectionRuleSet`.
            &quot;exclusionRule&quot;: { # The rule that specifies conditions when findings of infoTypes specified in `InspectionRuleSet` are removed from results. # Exclusion rule.
              &quot;dictionary&quot;: { # Custom information type based on a dictionary of words or phrases. This can be used to match sensitive information specific to the data, such as a list of employee IDs or job titles. Dictionary words are case-insensitive and all characters other than letters and digits in the unicode [Basic Multilingual Plane](https://en.wikipedia.org/wiki/Plane_%28Unicode%29#Basic_Multilingual_Plane) will be replaced with whitespace when scanning for matches, so the dictionary phrase &quot;Sam Johnson&quot; will match all three phrases &quot;sam johnson&quot;, &quot;Sam, Johnson&quot;, and &quot;Sam (Johnson)&quot;. Additionally, the characters surrounding any match must be of a different type than the adjacent characters within the word, so letters must be next to non-letters and digits next to non-digits. For example, the dictionary word &quot;jen&quot; will match the first three letters of the text &quot;jen123&quot; but will return no matches for &quot;jennifer&quot;. Dictionary words containing a large number of characters that are not letters or digits may result in unexpected findings because such characters are treated as whitespace. The [limits](https://cloud.google.com/dlp/limits) page contains details about the size limits of dictionaries. For dictionaries that do not fit within these constraints, consider using `LargeCustomDictionaryConfig` in the `StoredInfoType` API. # Dictionary which defines the rule.
                &quot;cloudStoragePath&quot;: { # Message representing a single file or path in Cloud Storage. # Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
                  &quot;path&quot;: &quot;A String&quot;, # A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
                },
                &quot;wordList&quot;: { # Message defining a list of words or phrases to search for in the data. # List of words or phrases to search for.
                  &quot;words&quot;: [ # Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits. [required]
                    &quot;A String&quot;,
                  ],
                },
              },
              &quot;excludeInfoTypes&quot;: { # List of exclude infoTypes. # Set of infoTypes for which findings would affect this rule.
                &quot;infoTypes&quot;: [ # InfoType list in ExclusionRule rule drops a finding when it overlaps or contained within with a finding of an infoType from this list. For example, for `InspectionRuleSet.info_types` containing &quot;PHONE_NUMBER&quot;` and `exclusion_rule` containing `exclude_info_types.info_types` with &quot;EMAIL_ADDRESS&quot; the phone number findings are dropped if they overlap with EMAIL_ADDRESS finding. That leads to &quot;555-222-2222@example.org&quot; to generate only a single finding, namely email address.
                  { # Type of information detected by the API.
                    &quot;name&quot;: &quot;A String&quot;, # Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
                  },
                ],
              },
              &quot;matchingType&quot;: &quot;A String&quot;, # How the rule is applied, see MatchingType documentation for details.
              &quot;regex&quot;: { # Message defining a custom regular expression. # Regular expression which defines the rule.
                &quot;groupIndexes&quot;: [ # The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
                  42,
                ],
                &quot;pattern&quot;: &quot;A String&quot;, # Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
              },
            },
            &quot;hotwordRule&quot;: { # The rule that adjusts the likelihood of findings within a certain proximity of hotwords. # Hotword-based detection rule.
              &quot;hotwordRegex&quot;: { # Message defining a custom regular expression. # Regular expression pattern defining what qualifies as a hotword.
                &quot;groupIndexes&quot;: [ # The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
                  42,
                ],
                &quot;pattern&quot;: &quot;A String&quot;, # Pattern defining the regular expression. Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
              },
              &quot;likelihoodAdjustment&quot;: { # Message for specifying an adjustment to the likelihood of a finding as part of a detection rule. # Likelihood adjustment to apply to all matching findings.
                &quot;fixedLikelihood&quot;: &quot;A String&quot;, # Set the likelihood of a finding to a fixed value.
                &quot;relativeLikelihood&quot;: 42, # Increase or decrease the likelihood by the specified number of levels. For example, if a finding would be `POSSIBLE` without the detection rule and `relative_likelihood` is 1, then it is upgraded to `LIKELY`, while a value of -1 would downgrade it to `UNLIKELY`. Likelihood may never drop below `VERY_UNLIKELY` or exceed `VERY_LIKELY`, so applying an adjustment of 1 followed by an adjustment of -1 when base likelihood is `VERY_LIKELY` will result in a final likelihood of `LIKELY`.
              },
              &quot;proximity&quot;: { # Message for specifying a window around a finding to apply a detection rule. # Proximity of the finding within which the entire hotword must reside. The total length of the window cannot exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be used to match substrings of the finding itself. For example, the certainty of a phone number regex &quot;\(\d{3}\) \d{3}-\d{4}&quot; could be adjusted upwards if the area code is known to be the local area code of a company office using the hotword regex &quot;\(xxx\)&quot;, where &quot;xxx&quot; is the area code in question.
                &quot;windowAfter&quot;: 42, # Number of characters after the finding to consider.
                &quot;windowBefore&quot;: 42, # Number of characters before the finding to consider.
              },
            },
          },
        ],
      },
    ],
  },
  &quot;locationId&quot;: &quot;A String&quot;, # Deprecated. This field has no effect.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Results of redacting an image.
  &quot;extractedText&quot;: &quot;A String&quot;, # If an image was being inspected and the InspectConfig&#x27;s include_quote was set to true, then this field will include all text, if any, that was found in the image.
  &quot;inspectResult&quot;: { # All the findings for a single scanned item. # The findings. Populated when include_findings in the request is true.
    &quot;findings&quot;: [ # List of findings for an item.
      { # Represents a piece of potentially sensitive content.
        &quot;createTime&quot;: &quot;A String&quot;, # Timestamp when finding was detected.
        &quot;findingId&quot;: &quot;A String&quot;, # The unique finding id.
        &quot;infoType&quot;: { # Type of information detected by the API. # The type of content that might have been found. Provided if `excluded_types` is false.
          &quot;name&quot;: &quot;A String&quot;, # Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
        },
        &quot;jobCreateTime&quot;: &quot;A String&quot;, # Time the job started that produced this finding.
        &quot;jobName&quot;: &quot;A String&quot;, # The job that stored the finding.
        &quot;labels&quot;: { # The labels associated with this `Finding`. Label keys must be between 1 and 63 characters long and must conform to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`. Label values must be between 0 and 63 characters long and must conform to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`. No more than 10 labels can be associated with a given finding. Examples: * `&quot;environment&quot; : &quot;production&quot;` * `&quot;pipeline&quot; : &quot;etl&quot;`
          &quot;a_key&quot;: &quot;A String&quot;,
        },
        &quot;likelihood&quot;: &quot;A String&quot;, # Confidence of how likely it is that the `info_type` is correct.
        &quot;location&quot;: { # Specifies the location of the finding. # Where the content was found.
          &quot;byteRange&quot;: { # Generic half-open interval [start, end) # Zero-based byte offsets delimiting the finding. These are relative to the finding&#x27;s containing element. Note that when the content is not textual, this references the UTF-8 encoded textual representation of the content. Omitted if content is an image.
            &quot;end&quot;: &quot;A String&quot;, # Index of the last character of the range (exclusive).
            &quot;start&quot;: &quot;A String&quot;, # Index of the first character of the range (inclusive).
          },
          &quot;codepointRange&quot;: { # Generic half-open interval [start, end) # Unicode character offsets delimiting the finding. These are relative to the finding&#x27;s containing element. Provided when the content is text.
            &quot;end&quot;: &quot;A String&quot;, # Index of the last character of the range (exclusive).
            &quot;start&quot;: &quot;A String&quot;, # Index of the first character of the range (inclusive).
          },
          &quot;container&quot;: { # Represents a container that may contain DLP findings. Examples of a container include a file, table, or database record. # Information about the container where this finding occurred, if available.
            &quot;fullPath&quot;: &quot;A String&quot;, # A string representation of the full container name. Examples: - BigQuery: &#x27;Project:DataSetId.TableId&#x27; - Google Cloud Storage: &#x27;gs://Bucket/folders/filename.txt&#x27;
            &quot;projectId&quot;: &quot;A String&quot;, # Project where the finding was found. Can be different from the project that owns the finding.
            &quot;relativePath&quot;: &quot;A String&quot;, # The rest of the path after the root. Examples: - For BigQuery table `project_id:dataset_id.table_id`, the relative path is `table_id` - Google Cloud Storage file `gs://bucket/folder/filename.txt`, the relative path is `folder/filename.txt`
            &quot;rootPath&quot;: &quot;A String&quot;, # The root of the container. Examples: - For BigQuery table `project_id:dataset_id.table_id`, the root is `dataset_id` - For Google Cloud Storage file `gs://bucket/folder/filename.txt`, the root is `gs://bucket`
            &quot;type&quot;: &quot;A String&quot;, # Container type, for example BigQuery or Google Cloud Storage.
            &quot;updateTime&quot;: &quot;A String&quot;, # Findings container modification timestamp, if applicable. For Google Cloud Storage contains last file modification timestamp. For BigQuery table contains last_modified_time property. For Datastore - not populated.
            &quot;version&quot;: &quot;A String&quot;, # Findings container version, if available (&quot;generation&quot; for Google Cloud Storage).
          },
          &quot;contentLocations&quot;: [ # List of nested objects pointing to the precise location of the finding within the file or record.
            { # Precise location of the finding within a document, record, image, or metadata container.
              &quot;containerName&quot;: &quot;A String&quot;, # Name of the container where the finding is located. The top level name is the source file name or table name. Names of some common storage containers are formatted as follows: * BigQuery tables: `{project_id}:{dataset_id}.{table_id}` * Cloud Storage files: `gs://{bucket}/{path}` * Datastore namespace: {namespace} Nested names could be absent if the embedded object has no string identifier (for an example an image contained within a document).
              &quot;containerTimestamp&quot;: &quot;A String&quot;, # Findings container modification timestamp, if applicable. For Google Cloud Storage contains last file modification timestamp. For BigQuery table contains last_modified_time property. For Datastore - not populated.
              &quot;containerVersion&quot;: &quot;A String&quot;, # Findings container version, if available (&quot;generation&quot; for Google Cloud Storage).
              &quot;documentLocation&quot;: { # Location of a finding within a document. # Location data for document files.
                &quot;fileOffset&quot;: &quot;A String&quot;, # Offset of the line, from the beginning of the file, where the finding is located.
              },
              &quot;imageLocation&quot;: { # Location of the finding within an image. # Location within an image&#x27;s pixels.
                &quot;boundingBoxes&quot;: [ # Bounding boxes locating the pixels within the image containing the finding.
                  { # Bounding box encompassing detected text within an image.
                    &quot;height&quot;: 42, # Height of the bounding box in pixels.
                    &quot;left&quot;: 42, # Left coordinate of the bounding box. (0,0) is upper left.
                    &quot;top&quot;: 42, # Top coordinate of the bounding box. (0,0) is upper left.
                    &quot;width&quot;: 42, # Width of the bounding box in pixels.
                  },
                ],
              },
              &quot;metadataLocation&quot;: { # Metadata Location # Location within the metadata for inspected content.
                &quot;storageLabel&quot;: { # Storage metadata label to indicate which metadata entry contains findings. # Storage metadata.
                  &quot;key&quot;: &quot;A String&quot;,
                },
                &quot;type&quot;: &quot;A String&quot;, # Type of metadata containing the finding.
              },
              &quot;recordLocation&quot;: { # Location of a finding within a row or record. # Location within a row or record of a database table.
                &quot;fieldId&quot;: { # General identifier of a data field in a storage service. # Field id of the field containing the finding.
                  &quot;name&quot;: &quot;A String&quot;, # Name describing the field.
                },
                &quot;recordKey&quot;: { # Message for a unique key indicating a record that contains a finding. # Key of the finding.
                  &quot;bigQueryKey&quot;: { # Row key for identifying a record in BigQuery table.
                    &quot;rowNumber&quot;: &quot;A String&quot;, # Row number inferred at the time the table was scanned. This value is nondeterministic, cannot be queried, and may be null for inspection jobs. To locate findings within a table, specify `inspect_job.storage_config.big_query_options.identifying_fields` in `CreateDlpJobRequest`.
                    &quot;tableReference&quot;: { # Message defining the location of a BigQuery table. A table is uniquely identified by its project_id, dataset_id, and table_name. Within a query a table is often referenced with a string in the format of: `:.` or `..`. # Complete BigQuery table reference.
                      &quot;datasetId&quot;: &quot;A String&quot;, # Dataset ID of the table.
                      &quot;projectId&quot;: &quot;A String&quot;, # The Google Cloud Platform project ID of the project containing the table. If omitted, project ID is inferred from the API call.
                      &quot;tableId&quot;: &quot;A String&quot;, # Name of the table.
                    },
                  },
                  &quot;datastoreKey&quot;: { # Record key for a finding in Cloud Datastore.
                    &quot;entityKey&quot;: { # A unique identifier for a Datastore entity. If a key&#x27;s partition ID or any of its path kinds or names are reserved/read-only, the key is reserved/read-only. A reserved/read-only key is forbidden in certain documented contexts. # Datastore entity key.
                      &quot;partitionId&quot;: { # Datastore partition ID. A partition ID identifies a grouping of entities. The grouping is always by project and namespace, however the namespace ID may be empty. A partition ID contains several dimensions: project ID and namespace ID. # Entities are partitioned into subsets, currently identified by a project ID and namespace ID. Queries are scoped to a single partition.
                        &quot;namespaceId&quot;: &quot;A String&quot;, # If not empty, the ID of the namespace to which the entities belong.
                        &quot;projectId&quot;: &quot;A String&quot;, # The ID of the project to which the entities belong.
                      },
                      &quot;path&quot;: [ # The entity path. An entity path consists of one or more elements composed of a kind and a string or numerical identifier, which identify entities. The first element identifies a _root entity_, the second element identifies a _child_ of the root entity, the third element identifies a child of the second entity, and so forth. The entities identified by all prefixes of the path are called the element&#x27;s _ancestors_. A path can never be empty, and a path can have at most 100 elements.
                        { # A (kind, ID/name) pair used to construct a key path. If either name or ID is set, the element is complete. If neither is set, the element is incomplete.
                          &quot;id&quot;: &quot;A String&quot;, # The auto-allocated ID of the entity. Never equal to zero. Values less than zero are discouraged and may not be supported in the future.
                          &quot;kind&quot;: &quot;A String&quot;, # The kind of the entity. A kind matching regex `__.*__` is reserved/read-only. A kind must not contain more than 1500 bytes when UTF-8 encoded. Cannot be `&quot;&quot;`.
                          &quot;name&quot;: &quot;A String&quot;, # The name of the entity. A name matching regex `__.*__` is reserved/read-only. A name must not be more than 1500 bytes when UTF-8 encoded. Cannot be `&quot;&quot;`.
                        },
                      ],
                    },
                  },
                  &quot;idValues&quot;: [ # Values of identifying columns in the given row. Order of values matches the order of `identifying_fields` specified in the scanning request.
                    &quot;A String&quot;,
                  ],
                },
                &quot;tableLocation&quot;: { # Location of a finding within a table. # Location within a `ContentItem.Table`.
                  &quot;rowIndex&quot;: &quot;A String&quot;, # The zero-based index of the row where the finding is located. Only populated for resources that have a natural ordering, not BigQuery. In BigQuery, to identify the row a finding came from, populate BigQueryOptions.identifying_fields with your primary key column names and when you store the findings the value of those columns will be stored inside of Finding.
                },
              },
            },
          ],
        },
        &quot;name&quot;: &quot;A String&quot;, # Resource name in format projects/{project}/locations/{location}/findings/{finding} Populated only when viewing persisted findings.
        &quot;quote&quot;: &quot;A String&quot;, # The content that was found. Even if the content is not textual, it may be converted to a textual representation here. Provided if `include_quote` is true and the finding is less than or equal to 4096 bytes long. If the finding exceeds 4096 bytes in length, the quote may be omitted.
        &quot;quoteInfo&quot;: { # Message for infoType-dependent details parsed from quote. # Contains data parsed from quotes. Only populated if include_quote was set to true and a supported infoType was requested. Currently supported infoTypes: DATE, DATE_OF_BIRTH and TIME.
          &quot;dateTime&quot;: { # Message for a date time object. e.g. 2018-01-01, 5th August. # The date time indicated by the quote.
            &quot;date&quot;: { # Represents a whole or partial calendar date, such as a birthday. The time of day and time zone are either specified elsewhere or are insignificant. The date is relative to the Gregorian Calendar. This can represent one of the following: * A full date, with non-zero year, month, and day values * A month and day value, with a zero year, such as an anniversary * A year on its own, with zero month and day values * A year and month value, with a zero day, such as a credit card expiration date Related types are google.type.TimeOfDay and `google.protobuf.Timestamp`. # One or more of the following must be set. Must be a valid date or time value.
              &quot;day&quot;: 42, # Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn&#x27;t significant.
              &quot;month&quot;: 42, # Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
              &quot;year&quot;: 42, # Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
            },
            &quot;dayOfWeek&quot;: &quot;A String&quot;, # Day of week
            &quot;time&quot;: { # Represents a time of day. The date and time zone are either not significant or are specified elsewhere. An API may choose to allow leap seconds. Related types are google.type.Date and `google.protobuf.Timestamp`. # Time of day
              &quot;hours&quot;: 42, # Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value &quot;24:00:00&quot; for scenarios like business closing time.
              &quot;minutes&quot;: 42, # Minutes of hour of day. Must be from 0 to 59.
              &quot;nanos&quot;: 42, # Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
              &quot;seconds&quot;: 42, # Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
            },
            &quot;timeZone&quot;: { # Time zone of the date time object. # Time zone
              &quot;offsetMinutes&quot;: 42, # Set only if the offset can be determined. Positive for time ahead of UTC. E.g. For &quot;UTC-9&quot;, this value is -540.
            },
          },
        },
        &quot;resourceName&quot;: &quot;A String&quot;, # The job that stored the finding.
        &quot;triggerName&quot;: &quot;A String&quot;, # Job trigger name, if applicable, for this finding.
      },
    ],
    &quot;findingsTruncated&quot;: True or False, # If true, then this item might have more findings than were returned, and the findings returned are an arbitrary subset of all findings. The findings list might be truncated because the input items were too large, or because the server reached the maximum amount of resources allowed for a single API call. For best results, divide the input into smaller batches.
  },
  &quot;redactedImage&quot;: &quot;A String&quot;, # The redacted image. The type will be the same as the original image.
}</pre>
</div>

</body></html>