<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="discoveryengine_v1alpha.html">Discovery Engine API</a> . <a href="discoveryengine_v1alpha.projects.html">projects</a> . <a href="discoveryengine_v1alpha.projects.locations.html">locations</a> . <a href="discoveryengine_v1alpha.projects.locations.collections.html">collections</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="discoveryengine_v1alpha.projects.locations.collections.dataConnector.html">dataConnector()</a></code>
</p>
<p class="firstline">Returns the dataConnector Resource.</p>

<p class="toc_element">
  <code><a href="discoveryengine_v1alpha.projects.locations.collections.dataStores.html">dataStores()</a></code>
</p>
<p class="firstline">Returns the dataStores Resource.</p>

<p class="toc_element">
  <code><a href="discoveryengine_v1alpha.projects.locations.collections.engines.html">engines()</a></code>
</p>
<p class="firstline">Returns the engines Resource.</p>

<p class="toc_element">
  <code><a href="discoveryengine_v1alpha.projects.locations.collections.operations.html">operations()</a></code>
</p>
<p class="firstline">Returns the operations Resource.</p>

<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#delete">delete(name, x__xgafv=None)</a></code></p>
<p class="firstline">Deletes a Collection.</p>
<p class="toc_element">
  <code><a href="#get">get(name, x__xgafv=None)</a></code></p>
<p class="firstline">Gets a Collection.</p>
<p class="toc_element">
  <code><a href="#getDataConnector">getDataConnector(name, x__xgafv=None)</a></code></p>
<p class="firstline">Gets the DataConnector. DataConnector is a singleton resource for each Collection.</p>
<p class="toc_element">
  <code><a href="#list">list(parent, filter=None, pageSize=None, pageToken=None, x__xgafv=None)</a></code></p>
<p class="firstline">Gets a list of Collections.</p>
<p class="toc_element">
  <code><a href="#list_next">list_next()</a></code></p>
<p class="firstline">Retrieves the next page of results.</p>
<p class="toc_element">
  <code><a href="#patch">patch(name, body=None, updateMask=None, x__xgafv=None)</a></code></p>
<p class="firstline">Updates a Collection.</p>
<p class="toc_element">
  <code><a href="#updateDataConnector">updateDataConnector(name, body=None, updateMask=None, x__xgafv=None)</a></code></p>
<p class="firstline">Updates a DataConnector.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="delete">delete(name, x__xgafv=None)</code>
  <pre>Deletes a Collection.

Args:
  name: string, Required. The full resource name of the Collection, in the format of `projects/{project}/locations/{location}/collections/{collection}`. (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # This resource represents a long-running operation that is the result of a network API call.
  &quot;done&quot;: True or False, # If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The error result of the operation in case of failure or cancellation.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;metadata&quot;: { # Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
  &quot;name&quot;: &quot;A String&quot;, # The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
  &quot;response&quot;: { # The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="get">get(name, x__xgafv=None)</code>
  <pre>Gets a Collection.

Args:
  name: string, Required. The full resource name, in the format of `projects/{project}/locations/{location}/collections/{collection}`. (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Collection is a container for configuring resources and access to a set of DataStores.
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp the Collection was created at.
  &quot;dataConnector&quot;: { # Manages the connection to external data sources for all data stores grouped under a Collection. It&#x27;s a singleton resource of Collection. The initialization is only supported through DataConnectorService.SetUpDataConnector method, which will create a new Collection and initialize its DataConnector. # Output only. The data connector, if present, manages the connection for data stores in the Collection. To set up the connector, use DataConnectorService.SetUpDataConnector method, which creates a new Collection while setting up the DataConnector singleton resource. Setting up connector on an existing Collection is not supported. This output only field contains a subset of the DataConnector fields, including `name`, `data_source`, `entities.entity_name` and `entities.data_store`. To get more details about a data connector, use the DataConnectorService.GetDataConnector method.
    &quot;actionConfig&quot;: { # Informations to support actions on the connector. # Optional. Action configurations to make the connector support actions.
      &quot;actionParams&quot;: { # Required. Params needed to support actions in the format of (Key, Value) pairs. Required parameters for sources that support OAUTH, i.e. `gmail`, `google_calendar`, `jira`, `workday`, `salesforce`, `confluence`: * Key: `client_id` * Value: type STRING. The client id for the service provider to identify your application. * Key: `client_secret` * Value:type STRING. The client secret generated by the application&#x27;s authorization server.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;isActionConfigured&quot;: True or False, # Output only. The connector contains the necessary parameters and is configured to support actions.
    },
    &quot;autoRunDisabled&quot;: True or False, # Indicates whether the connector is disabled for auto run. It can be used to pause periodical and real time sync.
    &quot;blockingReasons&quot;: [ # Output only. User actions that must be completed before the connector can start syncing data.
      &quot;A String&quot;,
    ],
    &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp the DataConnector was created at.
    &quot;dataSource&quot;: &quot;A String&quot;, # Required. The name of the data source. Supported values: `salesforce`, `jira`, `confluence`, `bigquery`.
    &quot;destinationConfigs&quot;: [ # Optional. Any target destinations used to connect to third-party services.
      { # Defines target endpoints used to connect to third-party sources.
        &quot;destinations&quot;: [ # Optional. The destinations for the corresponding key.
          { # Defines a target endpoint
            &quot;host&quot;: &quot;A String&quot;, # Publicly routable host.
            &quot;port&quot;: 42, # Optional. Target port number accepted by the destination.
          },
        ],
        &quot;key&quot;: &quot;A String&quot;, # Optional. Unique destination identifier that is supported by the connector.
        &quot;params&quot;: { # Optional. Additional parameters for this destination config.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
      },
    ],
    &quot;entities&quot;: [ # List of entities from the connected data source to ingest.
      { # Represents an entity in the data source. For example, the `Account` object in Salesforce.
        &quot;dataStore&quot;: &quot;A String&quot;, # Output only. The full resource name of the associated data store for the source entity. Format: `projects/*/locations/*/collections/*/dataStores/*`. When the connector is initialized by the DataConnectorService.SetUpDataConnector method, a DataStore is automatically created for each source entity.
        &quot;entityName&quot;: &quot;A String&quot;, # The name of the entity. Supported values by data source: * Salesforce: `Lead`, `Opportunity`, `Contact`, `Account`, `Case`, `Contract`, `Campaign` * Jira: `Issue` * Confluence: `Content`, `Space`
        &quot;keyPropertyMappings&quot;: { # Attributes for indexing. Key: Field name. Value: The key property to map a field to, such as `title`, and `description`. Supported key properties: * `title`: The title for data record. This would be displayed on search results. * `description`: The description for data record. This would be displayed on search results.
          &quot;a_key&quot;: &quot;A String&quot;,
        },
        &quot;params&quot;: { # The parameters for the entity to facilitate data ingestion. E.g. for BQ connectors: * Key: `document_id_column` * Value: type STRING. The value of the column id.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
      },
    ],
    &quot;errors&quot;: [ # Output only. The errors from initialization or from the latest connector run.
      { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
        &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
        &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
          {
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
          },
        ],
        &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
      },
    ],
    &quot;identityRefreshInterval&quot;: &quot;A String&quot;, # The refresh interval to sync the Access Control List information for the documents ingested by this connector. If not set, the access control list will be refreshed at the default interval of 30 minutes. The identity refresh interval can be at least 30 minutes and at most 7 days.
    &quot;identityScheduleConfig&quot;: { # The configuration for the identity data synchronization runs. # The configuration for the identity data synchronization runs. This contains the refresh interval to sync the Access Control List information for the documents ingested by this connector.
      &quot;nextSyncTime&quot;: { # Represents civil time (or occasionally physical time). This type can represent a civil time in one of a few possible ways: * When utc_offset is set and time_zone is unset: a civil time on a calendar day with a particular offset from UTC. * When time_zone is set and utc_offset is unset: a civil time on a calendar day in a particular time zone. * When neither time_zone nor utc_offset is set: a civil time on a calendar day in local time. The date is relative to the Proleptic Gregorian Calendar. If year, month, or day are 0, the DateTime is considered not to have a specific year, month, or day respectively. This type may also be used to represent a physical time if all the date and time fields are set and either case of the `time_offset` oneof is set. Consider using `Timestamp` message for physical time instead. If your use case also would like to store the user&#x27;s timezone, that can be done in another field. This type is more flexible than some applications may want. Make sure to document and validate your application&#x27;s limitations. # Optional. The UTC time when the next data sync is expected to start for the Data Connector. Customers are only able to specify the hour and minute to schedule the data sync. This is utilized when the data connector has a refresh interval greater than 1 day.
        &quot;day&quot;: 42, # Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
        &quot;hours&quot;: 42, # Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value &quot;24:00:00&quot; for scenarios like business closing time.
        &quot;minutes&quot;: 42, # Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
        &quot;month&quot;: 42, # Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
        &quot;nanos&quot;: 42, # Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
        &quot;seconds&quot;: 42, # Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
        &quot;timeZone&quot;: { # Represents a time zone from the [IANA Time Zone Database](https://www.iana.org/time-zones). # Time zone.
          &quot;id&quot;: &quot;A String&quot;, # IANA Time Zone Database time zone. For example &quot;America/New_York&quot;.
          &quot;version&quot;: &quot;A String&quot;, # Optional. IANA Time Zone Database version number. For example &quot;2019a&quot;.
        },
        &quot;utcOffset&quot;: &quot;A String&quot;, # UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
        &quot;year&quot;: 42, # Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
      },
      &quot;refreshInterval&quot;: &quot;A String&quot;, # Optional. The refresh interval to sync the Access Control List information for the documents ingested by this connector. If not set, the access control list will be refreshed at the default interval of 30 minutes. The identity refresh interval can be at least 30 minutes and at most 7 days.
    },
    &quot;kmsKeyName&quot;: &quot;A String&quot;, # Input only. The KMS key to be used to protect the DataStores managed by this connector. Must be set for requests that need to comply with CMEK Org Policy protections. If this field is set and processed successfully, the DataStores created by this connector will be protected by the KMS key.
    &quot;lastSyncTime&quot;: &quot;A String&quot;, # Output only. For periodic connectors only, the last time a data sync was completed.
    &quot;latestPauseTime&quot;: &quot;A String&quot;, # Output only. The most recent timestamp when this DataConnector was paused, affecting all functionalities such as data synchronization. Pausing a connector has the following effects: - All functionalities, including data synchronization, are halted. - Any ongoing data synchronization job will be canceled. - No future data synchronization runs will be scheduled nor can be triggered.
    &quot;name&quot;: &quot;A String&quot;, # Output only. The full resource name of the Data Connector. Format: `projects/*/locations/*/collections/*/dataConnector`.
    &quot;nextSyncTime&quot;: { # Represents civil time (or occasionally physical time). This type can represent a civil time in one of a few possible ways: * When utc_offset is set and time_zone is unset: a civil time on a calendar day with a particular offset from UTC. * When time_zone is set and utc_offset is unset: a civil time on a calendar day in a particular time zone. * When neither time_zone nor utc_offset is set: a civil time on a calendar day in local time. The date is relative to the Proleptic Gregorian Calendar. If year, month, or day are 0, the DateTime is considered not to have a specific year, month, or day respectively. This type may also be used to represent a physical time if all the date and time fields are set and either case of the `time_offset` oneof is set. Consider using `Timestamp` message for physical time instead. If your use case also would like to store the user&#x27;s timezone, that can be done in another field. This type is more flexible than some applications may want. Make sure to document and validate your application&#x27;s limitations. # The UTC time when the next data sync is expected to start for the Data Connector. Customers are only able to specify the hour and minute to schedule the data sync. This is utilized when the data connector has a refresh interval greater than 1 day.
      &quot;day&quot;: 42, # Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
      &quot;hours&quot;: 42, # Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value &quot;24:00:00&quot; for scenarios like business closing time.
      &quot;minutes&quot;: 42, # Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
      &quot;month&quot;: 42, # Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
      &quot;nanos&quot;: 42, # Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
      &quot;seconds&quot;: 42, # Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
      &quot;timeZone&quot;: { # Represents a time zone from the [IANA Time Zone Database](https://www.iana.org/time-zones). # Time zone.
        &quot;id&quot;: &quot;A String&quot;, # IANA Time Zone Database time zone. For example &quot;America/New_York&quot;.
        &quot;version&quot;: &quot;A String&quot;, # Optional. IANA Time Zone Database version number. For example &quot;2019a&quot;.
      },
      &quot;utcOffset&quot;: &quot;A String&quot;, # UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
      &quot;year&quot;: 42, # Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
    },
    &quot;params&quot;: { # Required. Params needed to access the source in the format of (Key, Value) pairs. Required parameters for all data sources: * Key: `instance_uri` * Value: type STRING. The uri to access the data source. Required parameters for sources that support OAUTH, i.e. `salesforce`: * Key: `client_id` * Value: type STRING. The client id for the third party service provider to identify your application. * Key: `client_secret` * Value:type STRING. The client secret generated by the third party authorization server. * Key: `access_token` * Value: type STRING. OAuth token for UCS to access to the protected resource. * Key: `refresh_token` * Value: type STRING. OAuth refresh token for UCS to obtain a new access token without user interaction. Required parameters for sources that support basic API token auth, i.e. `jira`, `confluence`: * Key: `user_account` * Value: type STRING. The username or email with the source. * Key: `api_token` * Value: type STRING. The API token generated for the source account, that is used for authenticating anywhere where you would have used a password. Example: ```json { &quot;instance_uri&quot;: &quot;https://xxx.atlassian.net&quot;, &quot;user_account&quot;: &quot;xxxx.xxx@xxx.com&quot;, &quot;api_token&quot;: &quot;test-token&quot; } ``` Optional parameter to specify the authorization type to use for multiple authorization types support: * Key: `auth_type` * Value: type STRING. The authorization type for the data source. Supported values: `BASIC_AUTH`, `OAUTH`, `OAUTH_ACCESS_TOKEN`, `OAUTH_TWO_LEGGED`, `OAUTH_JWT_BEARER`, `OAUTH_PASSWORD_GRANT`, `JWT`, `API_TOKEN`, `FEDERATED_CREDENTIAL`.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;privateConnectivityProjectId&quot;: &quot;A String&quot;, # Output only. The tenant project ID associated with private connectivity connectors. This project must be allowlisted by in order for the connector to function.
    &quot;refreshInterval&quot;: &quot;A String&quot;, # Required. The refresh interval for data sync. If duration is set to 0, the data will be synced in real time. The streaming feature is not supported yet. The minimum is 30 minutes and maximum is 7 days.
    &quot;state&quot;: &quot;A String&quot;, # Output only. State of the connector.
    &quot;staticIpAddresses&quot;: [ # Output only. The static IP addresses used by this connector.
      &quot;A String&quot;,
    ],
    &quot;staticIpEnabled&quot;: True or False, # Optional. Whether customer has enabled static IP addresses for this connector.
    &quot;syncMode&quot;: &quot;A String&quot;, # The data synchronization mode supported by the data connector.
    &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp the DataConnector was last updated.
  },
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The Collection display name. This field must be a UTF-8 encoded string with a length limit of 128 characters. Otherwise, an INVALID_ARGUMENT error is returned.
  &quot;name&quot;: &quot;A String&quot;, # Immutable. The full resource name of the Collection. Format: `projects/{project}/locations/{location}/collections/{collection_id}`. This field must be a UTF-8 encoded string with a length limit of 1024 characters.
}</pre>
</div>

<div class="method">
    <code class="details" id="getDataConnector">getDataConnector(name, x__xgafv=None)</code>
  <pre>Gets the DataConnector. DataConnector is a singleton resource for each Collection.

Args:
  name: string, Required. Full resource name of DataConnector, such as `projects/{project}/locations/{location}/collections/{collection_id}/dataConnector`. If the caller does not have permission to access the DataConnector, regardless of whether or not it exists, a PERMISSION_DENIED error is returned. If the requested DataConnector does not exist, a NOT_FOUND error is returned. (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Manages the connection to external data sources for all data stores grouped under a Collection. It&#x27;s a singleton resource of Collection. The initialization is only supported through DataConnectorService.SetUpDataConnector method, which will create a new Collection and initialize its DataConnector.
  &quot;actionConfig&quot;: { # Informations to support actions on the connector. # Optional. Action configurations to make the connector support actions.
    &quot;actionParams&quot;: { # Required. Params needed to support actions in the format of (Key, Value) pairs. Required parameters for sources that support OAUTH, i.e. `gmail`, `google_calendar`, `jira`, `workday`, `salesforce`, `confluence`: * Key: `client_id` * Value: type STRING. The client id for the service provider to identify your application. * Key: `client_secret` * Value:type STRING. The client secret generated by the application&#x27;s authorization server.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;isActionConfigured&quot;: True or False, # Output only. The connector contains the necessary parameters and is configured to support actions.
  },
  &quot;autoRunDisabled&quot;: True or False, # Indicates whether the connector is disabled for auto run. It can be used to pause periodical and real time sync.
  &quot;blockingReasons&quot;: [ # Output only. User actions that must be completed before the connector can start syncing data.
    &quot;A String&quot;,
  ],
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp the DataConnector was created at.
  &quot;dataSource&quot;: &quot;A String&quot;, # Required. The name of the data source. Supported values: `salesforce`, `jira`, `confluence`, `bigquery`.
  &quot;destinationConfigs&quot;: [ # Optional. Any target destinations used to connect to third-party services.
    { # Defines target endpoints used to connect to third-party sources.
      &quot;destinations&quot;: [ # Optional. The destinations for the corresponding key.
        { # Defines a target endpoint
          &quot;host&quot;: &quot;A String&quot;, # Publicly routable host.
          &quot;port&quot;: 42, # Optional. Target port number accepted by the destination.
        },
      ],
      &quot;key&quot;: &quot;A String&quot;, # Optional. Unique destination identifier that is supported by the connector.
      &quot;params&quot;: { # Optional. Additional parameters for this destination config.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
    },
  ],
  &quot;entities&quot;: [ # List of entities from the connected data source to ingest.
    { # Represents an entity in the data source. For example, the `Account` object in Salesforce.
      &quot;dataStore&quot;: &quot;A String&quot;, # Output only. The full resource name of the associated data store for the source entity. Format: `projects/*/locations/*/collections/*/dataStores/*`. When the connector is initialized by the DataConnectorService.SetUpDataConnector method, a DataStore is automatically created for each source entity.
      &quot;entityName&quot;: &quot;A String&quot;, # The name of the entity. Supported values by data source: * Salesforce: `Lead`, `Opportunity`, `Contact`, `Account`, `Case`, `Contract`, `Campaign` * Jira: `Issue` * Confluence: `Content`, `Space`
      &quot;keyPropertyMappings&quot;: { # Attributes for indexing. Key: Field name. Value: The key property to map a field to, such as `title`, and `description`. Supported key properties: * `title`: The title for data record. This would be displayed on search results. * `description`: The description for data record. This would be displayed on search results.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
      &quot;params&quot;: { # The parameters for the entity to facilitate data ingestion. E.g. for BQ connectors: * Key: `document_id_column` * Value: type STRING. The value of the column id.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
    },
  ],
  &quot;errors&quot;: [ # Output only. The errors from initialization or from the latest connector run.
    { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
      &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
      &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
        {
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
        },
      ],
      &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
    },
  ],
  &quot;identityRefreshInterval&quot;: &quot;A String&quot;, # The refresh interval to sync the Access Control List information for the documents ingested by this connector. If not set, the access control list will be refreshed at the default interval of 30 minutes. The identity refresh interval can be at least 30 minutes and at most 7 days.
  &quot;identityScheduleConfig&quot;: { # The configuration for the identity data synchronization runs. # The configuration for the identity data synchronization runs. This contains the refresh interval to sync the Access Control List information for the documents ingested by this connector.
    &quot;nextSyncTime&quot;: { # Represents civil time (or occasionally physical time). This type can represent a civil time in one of a few possible ways: * When utc_offset is set and time_zone is unset: a civil time on a calendar day with a particular offset from UTC. * When time_zone is set and utc_offset is unset: a civil time on a calendar day in a particular time zone. * When neither time_zone nor utc_offset is set: a civil time on a calendar day in local time. The date is relative to the Proleptic Gregorian Calendar. If year, month, or day are 0, the DateTime is considered not to have a specific year, month, or day respectively. This type may also be used to represent a physical time if all the date and time fields are set and either case of the `time_offset` oneof is set. Consider using `Timestamp` message for physical time instead. If your use case also would like to store the user&#x27;s timezone, that can be done in another field. This type is more flexible than some applications may want. Make sure to document and validate your application&#x27;s limitations. # Optional. The UTC time when the next data sync is expected to start for the Data Connector. Customers are only able to specify the hour and minute to schedule the data sync. This is utilized when the data connector has a refresh interval greater than 1 day.
      &quot;day&quot;: 42, # Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
      &quot;hours&quot;: 42, # Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value &quot;24:00:00&quot; for scenarios like business closing time.
      &quot;minutes&quot;: 42, # Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
      &quot;month&quot;: 42, # Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
      &quot;nanos&quot;: 42, # Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
      &quot;seconds&quot;: 42, # Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
      &quot;timeZone&quot;: { # Represents a time zone from the [IANA Time Zone Database](https://www.iana.org/time-zones). # Time zone.
        &quot;id&quot;: &quot;A String&quot;, # IANA Time Zone Database time zone. For example &quot;America/New_York&quot;.
        &quot;version&quot;: &quot;A String&quot;, # Optional. IANA Time Zone Database version number. For example &quot;2019a&quot;.
      },
      &quot;utcOffset&quot;: &quot;A String&quot;, # UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
      &quot;year&quot;: 42, # Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
    },
    &quot;refreshInterval&quot;: &quot;A String&quot;, # Optional. The refresh interval to sync the Access Control List information for the documents ingested by this connector. If not set, the access control list will be refreshed at the default interval of 30 minutes. The identity refresh interval can be at least 30 minutes and at most 7 days.
  },
  &quot;kmsKeyName&quot;: &quot;A String&quot;, # Input only. The KMS key to be used to protect the DataStores managed by this connector. Must be set for requests that need to comply with CMEK Org Policy protections. If this field is set and processed successfully, the DataStores created by this connector will be protected by the KMS key.
  &quot;lastSyncTime&quot;: &quot;A String&quot;, # Output only. For periodic connectors only, the last time a data sync was completed.
  &quot;latestPauseTime&quot;: &quot;A String&quot;, # Output only. The most recent timestamp when this DataConnector was paused, affecting all functionalities such as data synchronization. Pausing a connector has the following effects: - All functionalities, including data synchronization, are halted. - Any ongoing data synchronization job will be canceled. - No future data synchronization runs will be scheduled nor can be triggered.
  &quot;name&quot;: &quot;A String&quot;, # Output only. The full resource name of the Data Connector. Format: `projects/*/locations/*/collections/*/dataConnector`.
  &quot;nextSyncTime&quot;: { # Represents civil time (or occasionally physical time). This type can represent a civil time in one of a few possible ways: * When utc_offset is set and time_zone is unset: a civil time on a calendar day with a particular offset from UTC. * When time_zone is set and utc_offset is unset: a civil time on a calendar day in a particular time zone. * When neither time_zone nor utc_offset is set: a civil time on a calendar day in local time. The date is relative to the Proleptic Gregorian Calendar. If year, month, or day are 0, the DateTime is considered not to have a specific year, month, or day respectively. This type may also be used to represent a physical time if all the date and time fields are set and either case of the `time_offset` oneof is set. Consider using `Timestamp` message for physical time instead. If your use case also would like to store the user&#x27;s timezone, that can be done in another field. This type is more flexible than some applications may want. Make sure to document and validate your application&#x27;s limitations. # The UTC time when the next data sync is expected to start for the Data Connector. Customers are only able to specify the hour and minute to schedule the data sync. This is utilized when the data connector has a refresh interval greater than 1 day.
    &quot;day&quot;: 42, # Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
    &quot;hours&quot;: 42, # Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value &quot;24:00:00&quot; for scenarios like business closing time.
    &quot;minutes&quot;: 42, # Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
    &quot;month&quot;: 42, # Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
    &quot;nanos&quot;: 42, # Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
    &quot;seconds&quot;: 42, # Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
    &quot;timeZone&quot;: { # Represents a time zone from the [IANA Time Zone Database](https://www.iana.org/time-zones). # Time zone.
      &quot;id&quot;: &quot;A String&quot;, # IANA Time Zone Database time zone. For example &quot;America/New_York&quot;.
      &quot;version&quot;: &quot;A String&quot;, # Optional. IANA Time Zone Database version number. For example &quot;2019a&quot;.
    },
    &quot;utcOffset&quot;: &quot;A String&quot;, # UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
    &quot;year&quot;: 42, # Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
  },
  &quot;params&quot;: { # Required. Params needed to access the source in the format of (Key, Value) pairs. Required parameters for all data sources: * Key: `instance_uri` * Value: type STRING. The uri to access the data source. Required parameters for sources that support OAUTH, i.e. `salesforce`: * Key: `client_id` * Value: type STRING. The client id for the third party service provider to identify your application. * Key: `client_secret` * Value:type STRING. The client secret generated by the third party authorization server. * Key: `access_token` * Value: type STRING. OAuth token for UCS to access to the protected resource. * Key: `refresh_token` * Value: type STRING. OAuth refresh token for UCS to obtain a new access token without user interaction. Required parameters for sources that support basic API token auth, i.e. `jira`, `confluence`: * Key: `user_account` * Value: type STRING. The username or email with the source. * Key: `api_token` * Value: type STRING. The API token generated for the source account, that is used for authenticating anywhere where you would have used a password. Example: ```json { &quot;instance_uri&quot;: &quot;https://xxx.atlassian.net&quot;, &quot;user_account&quot;: &quot;xxxx.xxx@xxx.com&quot;, &quot;api_token&quot;: &quot;test-token&quot; } ``` Optional parameter to specify the authorization type to use for multiple authorization types support: * Key: `auth_type` * Value: type STRING. The authorization type for the data source. Supported values: `BASIC_AUTH`, `OAUTH`, `OAUTH_ACCESS_TOKEN`, `OAUTH_TWO_LEGGED`, `OAUTH_JWT_BEARER`, `OAUTH_PASSWORD_GRANT`, `JWT`, `API_TOKEN`, `FEDERATED_CREDENTIAL`.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
  },
  &quot;privateConnectivityProjectId&quot;: &quot;A String&quot;, # Output only. The tenant project ID associated with private connectivity connectors. This project must be allowlisted by in order for the connector to function.
  &quot;refreshInterval&quot;: &quot;A String&quot;, # Required. The refresh interval for data sync. If duration is set to 0, the data will be synced in real time. The streaming feature is not supported yet. The minimum is 30 minutes and maximum is 7 days.
  &quot;state&quot;: &quot;A String&quot;, # Output only. State of the connector.
  &quot;staticIpAddresses&quot;: [ # Output only. The static IP addresses used by this connector.
    &quot;A String&quot;,
  ],
  &quot;staticIpEnabled&quot;: True or False, # Optional. Whether customer has enabled static IP addresses for this connector.
  &quot;syncMode&quot;: &quot;A String&quot;, # The data synchronization mode supported by the data connector.
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp the DataConnector was last updated.
}</pre>
</div>

<div class="method">
    <code class="details" id="list">list(parent, filter=None, pageSize=None, pageToken=None, x__xgafv=None)</code>
  <pre>Gets a list of Collections.

Args:
  parent: string, Required. The parent data store resource name, in the format of `projects/{project}/locations/{location}`. (required)
  filter: string, Filter returned collections by associated data connector data sources. For example: `filter = &#x27;data_source:jira confluence&#x27;`. If the filter is empty, we return all collections under a project and location.
  pageSize: integer, The maximum number of Collections to return. The service may return fewer than this value. If unspecified, at most 100 Collections will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
  pageToken: string, A page token, received from a previous CollectionService.ListCollections call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to CollectionService.ListCollections must match the call that provided the page token.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response message for CollectionService.ListCollections method.
  &quot;collections&quot;: [ # The Collections.
    { # Collection is a container for configuring resources and access to a set of DataStores.
      &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp the Collection was created at.
      &quot;dataConnector&quot;: { # Manages the connection to external data sources for all data stores grouped under a Collection. It&#x27;s a singleton resource of Collection. The initialization is only supported through DataConnectorService.SetUpDataConnector method, which will create a new Collection and initialize its DataConnector. # Output only. The data connector, if present, manages the connection for data stores in the Collection. To set up the connector, use DataConnectorService.SetUpDataConnector method, which creates a new Collection while setting up the DataConnector singleton resource. Setting up connector on an existing Collection is not supported. This output only field contains a subset of the DataConnector fields, including `name`, `data_source`, `entities.entity_name` and `entities.data_store`. To get more details about a data connector, use the DataConnectorService.GetDataConnector method.
        &quot;actionConfig&quot;: { # Informations to support actions on the connector. # Optional. Action configurations to make the connector support actions.
          &quot;actionParams&quot;: { # Required. Params needed to support actions in the format of (Key, Value) pairs. Required parameters for sources that support OAUTH, i.e. `gmail`, `google_calendar`, `jira`, `workday`, `salesforce`, `confluence`: * Key: `client_id` * Value: type STRING. The client id for the service provider to identify your application. * Key: `client_secret` * Value:type STRING. The client secret generated by the application&#x27;s authorization server.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;isActionConfigured&quot;: True or False, # Output only. The connector contains the necessary parameters and is configured to support actions.
        },
        &quot;autoRunDisabled&quot;: True or False, # Indicates whether the connector is disabled for auto run. It can be used to pause periodical and real time sync.
        &quot;blockingReasons&quot;: [ # Output only. User actions that must be completed before the connector can start syncing data.
          &quot;A String&quot;,
        ],
        &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp the DataConnector was created at.
        &quot;dataSource&quot;: &quot;A String&quot;, # Required. The name of the data source. Supported values: `salesforce`, `jira`, `confluence`, `bigquery`.
        &quot;destinationConfigs&quot;: [ # Optional. Any target destinations used to connect to third-party services.
          { # Defines target endpoints used to connect to third-party sources.
            &quot;destinations&quot;: [ # Optional. The destinations for the corresponding key.
              { # Defines a target endpoint
                &quot;host&quot;: &quot;A String&quot;, # Publicly routable host.
                &quot;port&quot;: 42, # Optional. Target port number accepted by the destination.
              },
            ],
            &quot;key&quot;: &quot;A String&quot;, # Optional. Unique destination identifier that is supported by the connector.
            &quot;params&quot;: { # Optional. Additional parameters for this destination config.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
          },
        ],
        &quot;entities&quot;: [ # List of entities from the connected data source to ingest.
          { # Represents an entity in the data source. For example, the `Account` object in Salesforce.
            &quot;dataStore&quot;: &quot;A String&quot;, # Output only. The full resource name of the associated data store for the source entity. Format: `projects/*/locations/*/collections/*/dataStores/*`. When the connector is initialized by the DataConnectorService.SetUpDataConnector method, a DataStore is automatically created for each source entity.
            &quot;entityName&quot;: &quot;A String&quot;, # The name of the entity. Supported values by data source: * Salesforce: `Lead`, `Opportunity`, `Contact`, `Account`, `Case`, `Contract`, `Campaign` * Jira: `Issue` * Confluence: `Content`, `Space`
            &quot;keyPropertyMappings&quot;: { # Attributes for indexing. Key: Field name. Value: The key property to map a field to, such as `title`, and `description`. Supported key properties: * `title`: The title for data record. This would be displayed on search results. * `description`: The description for data record. This would be displayed on search results.
              &quot;a_key&quot;: &quot;A String&quot;,
            },
            &quot;params&quot;: { # The parameters for the entity to facilitate data ingestion. E.g. for BQ connectors: * Key: `document_id_column` * Value: type STRING. The value of the column id.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
          },
        ],
        &quot;errors&quot;: [ # Output only. The errors from initialization or from the latest connector run.
          { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
            &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
            &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
              {
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
              },
            ],
            &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
          },
        ],
        &quot;identityRefreshInterval&quot;: &quot;A String&quot;, # The refresh interval to sync the Access Control List information for the documents ingested by this connector. If not set, the access control list will be refreshed at the default interval of 30 minutes. The identity refresh interval can be at least 30 minutes and at most 7 days.
        &quot;identityScheduleConfig&quot;: { # The configuration for the identity data synchronization runs. # The configuration for the identity data synchronization runs. This contains the refresh interval to sync the Access Control List information for the documents ingested by this connector.
          &quot;nextSyncTime&quot;: { # Represents civil time (or occasionally physical time). This type can represent a civil time in one of a few possible ways: * When utc_offset is set and time_zone is unset: a civil time on a calendar day with a particular offset from UTC. * When time_zone is set and utc_offset is unset: a civil time on a calendar day in a particular time zone. * When neither time_zone nor utc_offset is set: a civil time on a calendar day in local time. The date is relative to the Proleptic Gregorian Calendar. If year, month, or day are 0, the DateTime is considered not to have a specific year, month, or day respectively. This type may also be used to represent a physical time if all the date and time fields are set and either case of the `time_offset` oneof is set. Consider using `Timestamp` message for physical time instead. If your use case also would like to store the user&#x27;s timezone, that can be done in another field. This type is more flexible than some applications may want. Make sure to document and validate your application&#x27;s limitations. # Optional. The UTC time when the next data sync is expected to start for the Data Connector. Customers are only able to specify the hour and minute to schedule the data sync. This is utilized when the data connector has a refresh interval greater than 1 day.
            &quot;day&quot;: 42, # Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
            &quot;hours&quot;: 42, # Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value &quot;24:00:00&quot; for scenarios like business closing time.
            &quot;minutes&quot;: 42, # Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
            &quot;month&quot;: 42, # Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
            &quot;nanos&quot;: 42, # Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
            &quot;seconds&quot;: 42, # Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
            &quot;timeZone&quot;: { # Represents a time zone from the [IANA Time Zone Database](https://www.iana.org/time-zones). # Time zone.
              &quot;id&quot;: &quot;A String&quot;, # IANA Time Zone Database time zone. For example &quot;America/New_York&quot;.
              &quot;version&quot;: &quot;A String&quot;, # Optional. IANA Time Zone Database version number. For example &quot;2019a&quot;.
            },
            &quot;utcOffset&quot;: &quot;A String&quot;, # UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
            &quot;year&quot;: 42, # Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
          },
          &quot;refreshInterval&quot;: &quot;A String&quot;, # Optional. The refresh interval to sync the Access Control List information for the documents ingested by this connector. If not set, the access control list will be refreshed at the default interval of 30 minutes. The identity refresh interval can be at least 30 minutes and at most 7 days.
        },
        &quot;kmsKeyName&quot;: &quot;A String&quot;, # Input only. The KMS key to be used to protect the DataStores managed by this connector. Must be set for requests that need to comply with CMEK Org Policy protections. If this field is set and processed successfully, the DataStores created by this connector will be protected by the KMS key.
        &quot;lastSyncTime&quot;: &quot;A String&quot;, # Output only. For periodic connectors only, the last time a data sync was completed.
        &quot;latestPauseTime&quot;: &quot;A String&quot;, # Output only. The most recent timestamp when this DataConnector was paused, affecting all functionalities such as data synchronization. Pausing a connector has the following effects: - All functionalities, including data synchronization, are halted. - Any ongoing data synchronization job will be canceled. - No future data synchronization runs will be scheduled nor can be triggered.
        &quot;name&quot;: &quot;A String&quot;, # Output only. The full resource name of the Data Connector. Format: `projects/*/locations/*/collections/*/dataConnector`.
        &quot;nextSyncTime&quot;: { # Represents civil time (or occasionally physical time). This type can represent a civil time in one of a few possible ways: * When utc_offset is set and time_zone is unset: a civil time on a calendar day with a particular offset from UTC. * When time_zone is set and utc_offset is unset: a civil time on a calendar day in a particular time zone. * When neither time_zone nor utc_offset is set: a civil time on a calendar day in local time. The date is relative to the Proleptic Gregorian Calendar. If year, month, or day are 0, the DateTime is considered not to have a specific year, month, or day respectively. This type may also be used to represent a physical time if all the date and time fields are set and either case of the `time_offset` oneof is set. Consider using `Timestamp` message for physical time instead. If your use case also would like to store the user&#x27;s timezone, that can be done in another field. This type is more flexible than some applications may want. Make sure to document and validate your application&#x27;s limitations. # The UTC time when the next data sync is expected to start for the Data Connector. Customers are only able to specify the hour and minute to schedule the data sync. This is utilized when the data connector has a refresh interval greater than 1 day.
          &quot;day&quot;: 42, # Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
          &quot;hours&quot;: 42, # Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value &quot;24:00:00&quot; for scenarios like business closing time.
          &quot;minutes&quot;: 42, # Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
          &quot;month&quot;: 42, # Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
          &quot;nanos&quot;: 42, # Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
          &quot;seconds&quot;: 42, # Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
          &quot;timeZone&quot;: { # Represents a time zone from the [IANA Time Zone Database](https://www.iana.org/time-zones). # Time zone.
            &quot;id&quot;: &quot;A String&quot;, # IANA Time Zone Database time zone. For example &quot;America/New_York&quot;.
            &quot;version&quot;: &quot;A String&quot;, # Optional. IANA Time Zone Database version number. For example &quot;2019a&quot;.
          },
          &quot;utcOffset&quot;: &quot;A String&quot;, # UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
          &quot;year&quot;: 42, # Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
        },
        &quot;params&quot;: { # Required. Params needed to access the source in the format of (Key, Value) pairs. Required parameters for all data sources: * Key: `instance_uri` * Value: type STRING. The uri to access the data source. Required parameters for sources that support OAUTH, i.e. `salesforce`: * Key: `client_id` * Value: type STRING. The client id for the third party service provider to identify your application. * Key: `client_secret` * Value:type STRING. The client secret generated by the third party authorization server. * Key: `access_token` * Value: type STRING. OAuth token for UCS to access to the protected resource. * Key: `refresh_token` * Value: type STRING. OAuth refresh token for UCS to obtain a new access token without user interaction. Required parameters for sources that support basic API token auth, i.e. `jira`, `confluence`: * Key: `user_account` * Value: type STRING. The username or email with the source. * Key: `api_token` * Value: type STRING. The API token generated for the source account, that is used for authenticating anywhere where you would have used a password. Example: ```json { &quot;instance_uri&quot;: &quot;https://xxx.atlassian.net&quot;, &quot;user_account&quot;: &quot;xxxx.xxx@xxx.com&quot;, &quot;api_token&quot;: &quot;test-token&quot; } ``` Optional parameter to specify the authorization type to use for multiple authorization types support: * Key: `auth_type` * Value: type STRING. The authorization type for the data source. Supported values: `BASIC_AUTH`, `OAUTH`, `OAUTH_ACCESS_TOKEN`, `OAUTH_TWO_LEGGED`, `OAUTH_JWT_BEARER`, `OAUTH_PASSWORD_GRANT`, `JWT`, `API_TOKEN`, `FEDERATED_CREDENTIAL`.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;privateConnectivityProjectId&quot;: &quot;A String&quot;, # Output only. The tenant project ID associated with private connectivity connectors. This project must be allowlisted by in order for the connector to function.
        &quot;refreshInterval&quot;: &quot;A String&quot;, # Required. The refresh interval for data sync. If duration is set to 0, the data will be synced in real time. The streaming feature is not supported yet. The minimum is 30 minutes and maximum is 7 days.
        &quot;state&quot;: &quot;A String&quot;, # Output only. State of the connector.
        &quot;staticIpAddresses&quot;: [ # Output only. The static IP addresses used by this connector.
          &quot;A String&quot;,
        ],
        &quot;staticIpEnabled&quot;: True or False, # Optional. Whether customer has enabled static IP addresses for this connector.
        &quot;syncMode&quot;: &quot;A String&quot;, # The data synchronization mode supported by the data connector.
        &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp the DataConnector was last updated.
      },
      &quot;displayName&quot;: &quot;A String&quot;, # Required. The Collection display name. This field must be a UTF-8 encoded string with a length limit of 128 characters. Otherwise, an INVALID_ARGUMENT error is returned.
      &quot;name&quot;: &quot;A String&quot;, # Immutable. The full resource name of the Collection. Format: `projects/{project}/locations/{location}/collections/{collection_id}`. This field must be a UTF-8 encoded string with a length limit of 1024 characters.
    },
  ],
  &quot;nextPageToken&quot;: &quot;A String&quot;, # A token that can be sent as ListCollectionsRequest.page_token to retrieve the next page. If this field is omitted, there are no subsequent pages.
}</pre>
</div>

<div class="method">
    <code class="details" id="list_next">list_next()</code>
  <pre>Retrieves the next page of results.

        Args:
          previous_request: The request for the previous page. (required)
          previous_response: The response from the request for the previous page. (required)

        Returns:
          A request object that you can call &#x27;execute()&#x27; on to request the next
          page. Returns None if there are no more items in the collection.
        </pre>
</div>

<div class="method">
    <code class="details" id="patch">patch(name, body=None, updateMask=None, x__xgafv=None)</code>
  <pre>Updates a Collection.

Args:
  name: string, Immutable. The full resource name of the Collection. Format: `projects/{project}/locations/{location}/collections/{collection_id}`. This field must be a UTF-8 encoded string with a length limit of 1024 characters. (required)
  body: object, The request body.
    The object takes the form of:

{ # Collection is a container for configuring resources and access to a set of DataStores.
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp the Collection was created at.
  &quot;dataConnector&quot;: { # Manages the connection to external data sources for all data stores grouped under a Collection. It&#x27;s a singleton resource of Collection. The initialization is only supported through DataConnectorService.SetUpDataConnector method, which will create a new Collection and initialize its DataConnector. # Output only. The data connector, if present, manages the connection for data stores in the Collection. To set up the connector, use DataConnectorService.SetUpDataConnector method, which creates a new Collection while setting up the DataConnector singleton resource. Setting up connector on an existing Collection is not supported. This output only field contains a subset of the DataConnector fields, including `name`, `data_source`, `entities.entity_name` and `entities.data_store`. To get more details about a data connector, use the DataConnectorService.GetDataConnector method.
    &quot;actionConfig&quot;: { # Informations to support actions on the connector. # Optional. Action configurations to make the connector support actions.
      &quot;actionParams&quot;: { # Required. Params needed to support actions in the format of (Key, Value) pairs. Required parameters for sources that support OAUTH, i.e. `gmail`, `google_calendar`, `jira`, `workday`, `salesforce`, `confluence`: * Key: `client_id` * Value: type STRING. The client id for the service provider to identify your application. * Key: `client_secret` * Value:type STRING. The client secret generated by the application&#x27;s authorization server.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;isActionConfigured&quot;: True or False, # Output only. The connector contains the necessary parameters and is configured to support actions.
    },
    &quot;autoRunDisabled&quot;: True or False, # Indicates whether the connector is disabled for auto run. It can be used to pause periodical and real time sync.
    &quot;blockingReasons&quot;: [ # Output only. User actions that must be completed before the connector can start syncing data.
      &quot;A String&quot;,
    ],
    &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp the DataConnector was created at.
    &quot;dataSource&quot;: &quot;A String&quot;, # Required. The name of the data source. Supported values: `salesforce`, `jira`, `confluence`, `bigquery`.
    &quot;destinationConfigs&quot;: [ # Optional. Any target destinations used to connect to third-party services.
      { # Defines target endpoints used to connect to third-party sources.
        &quot;destinations&quot;: [ # Optional. The destinations for the corresponding key.
          { # Defines a target endpoint
            &quot;host&quot;: &quot;A String&quot;, # Publicly routable host.
            &quot;port&quot;: 42, # Optional. Target port number accepted by the destination.
          },
        ],
        &quot;key&quot;: &quot;A String&quot;, # Optional. Unique destination identifier that is supported by the connector.
        &quot;params&quot;: { # Optional. Additional parameters for this destination config.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
      },
    ],
    &quot;entities&quot;: [ # List of entities from the connected data source to ingest.
      { # Represents an entity in the data source. For example, the `Account` object in Salesforce.
        &quot;dataStore&quot;: &quot;A String&quot;, # Output only. The full resource name of the associated data store for the source entity. Format: `projects/*/locations/*/collections/*/dataStores/*`. When the connector is initialized by the DataConnectorService.SetUpDataConnector method, a DataStore is automatically created for each source entity.
        &quot;entityName&quot;: &quot;A String&quot;, # The name of the entity. Supported values by data source: * Salesforce: `Lead`, `Opportunity`, `Contact`, `Account`, `Case`, `Contract`, `Campaign` * Jira: `Issue` * Confluence: `Content`, `Space`
        &quot;keyPropertyMappings&quot;: { # Attributes for indexing. Key: Field name. Value: The key property to map a field to, such as `title`, and `description`. Supported key properties: * `title`: The title for data record. This would be displayed on search results. * `description`: The description for data record. This would be displayed on search results.
          &quot;a_key&quot;: &quot;A String&quot;,
        },
        &quot;params&quot;: { # The parameters for the entity to facilitate data ingestion. E.g. for BQ connectors: * Key: `document_id_column` * Value: type STRING. The value of the column id.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
      },
    ],
    &quot;errors&quot;: [ # Output only. The errors from initialization or from the latest connector run.
      { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
        &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
        &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
          {
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
          },
        ],
        &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
      },
    ],
    &quot;identityRefreshInterval&quot;: &quot;A String&quot;, # The refresh interval to sync the Access Control List information for the documents ingested by this connector. If not set, the access control list will be refreshed at the default interval of 30 minutes. The identity refresh interval can be at least 30 minutes and at most 7 days.
    &quot;identityScheduleConfig&quot;: { # The configuration for the identity data synchronization runs. # The configuration for the identity data synchronization runs. This contains the refresh interval to sync the Access Control List information for the documents ingested by this connector.
      &quot;nextSyncTime&quot;: { # Represents civil time (or occasionally physical time). This type can represent a civil time in one of a few possible ways: * When utc_offset is set and time_zone is unset: a civil time on a calendar day with a particular offset from UTC. * When time_zone is set and utc_offset is unset: a civil time on a calendar day in a particular time zone. * When neither time_zone nor utc_offset is set: a civil time on a calendar day in local time. The date is relative to the Proleptic Gregorian Calendar. If year, month, or day are 0, the DateTime is considered not to have a specific year, month, or day respectively. This type may also be used to represent a physical time if all the date and time fields are set and either case of the `time_offset` oneof is set. Consider using `Timestamp` message for physical time instead. If your use case also would like to store the user&#x27;s timezone, that can be done in another field. This type is more flexible than some applications may want. Make sure to document and validate your application&#x27;s limitations. # Optional. The UTC time when the next data sync is expected to start for the Data Connector. Customers are only able to specify the hour and minute to schedule the data sync. This is utilized when the data connector has a refresh interval greater than 1 day.
        &quot;day&quot;: 42, # Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
        &quot;hours&quot;: 42, # Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value &quot;24:00:00&quot; for scenarios like business closing time.
        &quot;minutes&quot;: 42, # Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
        &quot;month&quot;: 42, # Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
        &quot;nanos&quot;: 42, # Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
        &quot;seconds&quot;: 42, # Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
        &quot;timeZone&quot;: { # Represents a time zone from the [IANA Time Zone Database](https://www.iana.org/time-zones). # Time zone.
          &quot;id&quot;: &quot;A String&quot;, # IANA Time Zone Database time zone. For example &quot;America/New_York&quot;.
          &quot;version&quot;: &quot;A String&quot;, # Optional. IANA Time Zone Database version number. For example &quot;2019a&quot;.
        },
        &quot;utcOffset&quot;: &quot;A String&quot;, # UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
        &quot;year&quot;: 42, # Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
      },
      &quot;refreshInterval&quot;: &quot;A String&quot;, # Optional. The refresh interval to sync the Access Control List information for the documents ingested by this connector. If not set, the access control list will be refreshed at the default interval of 30 minutes. The identity refresh interval can be at least 30 minutes and at most 7 days.
    },
    &quot;kmsKeyName&quot;: &quot;A String&quot;, # Input only. The KMS key to be used to protect the DataStores managed by this connector. Must be set for requests that need to comply with CMEK Org Policy protections. If this field is set and processed successfully, the DataStores created by this connector will be protected by the KMS key.
    &quot;lastSyncTime&quot;: &quot;A String&quot;, # Output only. For periodic connectors only, the last time a data sync was completed.
    &quot;latestPauseTime&quot;: &quot;A String&quot;, # Output only. The most recent timestamp when this DataConnector was paused, affecting all functionalities such as data synchronization. Pausing a connector has the following effects: - All functionalities, including data synchronization, are halted. - Any ongoing data synchronization job will be canceled. - No future data synchronization runs will be scheduled nor can be triggered.
    &quot;name&quot;: &quot;A String&quot;, # Output only. The full resource name of the Data Connector. Format: `projects/*/locations/*/collections/*/dataConnector`.
    &quot;nextSyncTime&quot;: { # Represents civil time (or occasionally physical time). This type can represent a civil time in one of a few possible ways: * When utc_offset is set and time_zone is unset: a civil time on a calendar day with a particular offset from UTC. * When time_zone is set and utc_offset is unset: a civil time on a calendar day in a particular time zone. * When neither time_zone nor utc_offset is set: a civil time on a calendar day in local time. The date is relative to the Proleptic Gregorian Calendar. If year, month, or day are 0, the DateTime is considered not to have a specific year, month, or day respectively. This type may also be used to represent a physical time if all the date and time fields are set and either case of the `time_offset` oneof is set. Consider using `Timestamp` message for physical time instead. If your use case also would like to store the user&#x27;s timezone, that can be done in another field. This type is more flexible than some applications may want. Make sure to document and validate your application&#x27;s limitations. # The UTC time when the next data sync is expected to start for the Data Connector. Customers are only able to specify the hour and minute to schedule the data sync. This is utilized when the data connector has a refresh interval greater than 1 day.
      &quot;day&quot;: 42, # Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
      &quot;hours&quot;: 42, # Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value &quot;24:00:00&quot; for scenarios like business closing time.
      &quot;minutes&quot;: 42, # Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
      &quot;month&quot;: 42, # Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
      &quot;nanos&quot;: 42, # Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
      &quot;seconds&quot;: 42, # Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
      &quot;timeZone&quot;: { # Represents a time zone from the [IANA Time Zone Database](https://www.iana.org/time-zones). # Time zone.
        &quot;id&quot;: &quot;A String&quot;, # IANA Time Zone Database time zone. For example &quot;America/New_York&quot;.
        &quot;version&quot;: &quot;A String&quot;, # Optional. IANA Time Zone Database version number. For example &quot;2019a&quot;.
      },
      &quot;utcOffset&quot;: &quot;A String&quot;, # UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
      &quot;year&quot;: 42, # Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
    },
    &quot;params&quot;: { # Required. Params needed to access the source in the format of (Key, Value) pairs. Required parameters for all data sources: * Key: `instance_uri` * Value: type STRING. The uri to access the data source. Required parameters for sources that support OAUTH, i.e. `salesforce`: * Key: `client_id` * Value: type STRING. The client id for the third party service provider to identify your application. * Key: `client_secret` * Value:type STRING. The client secret generated by the third party authorization server. * Key: `access_token` * Value: type STRING. OAuth token for UCS to access to the protected resource. * Key: `refresh_token` * Value: type STRING. OAuth refresh token for UCS to obtain a new access token without user interaction. Required parameters for sources that support basic API token auth, i.e. `jira`, `confluence`: * Key: `user_account` * Value: type STRING. The username or email with the source. * Key: `api_token` * Value: type STRING. The API token generated for the source account, that is used for authenticating anywhere where you would have used a password. Example: ```json { &quot;instance_uri&quot;: &quot;https://xxx.atlassian.net&quot;, &quot;user_account&quot;: &quot;xxxx.xxx@xxx.com&quot;, &quot;api_token&quot;: &quot;test-token&quot; } ``` Optional parameter to specify the authorization type to use for multiple authorization types support: * Key: `auth_type` * Value: type STRING. The authorization type for the data source. Supported values: `BASIC_AUTH`, `OAUTH`, `OAUTH_ACCESS_TOKEN`, `OAUTH_TWO_LEGGED`, `OAUTH_JWT_BEARER`, `OAUTH_PASSWORD_GRANT`, `JWT`, `API_TOKEN`, `FEDERATED_CREDENTIAL`.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;privateConnectivityProjectId&quot;: &quot;A String&quot;, # Output only. The tenant project ID associated with private connectivity connectors. This project must be allowlisted by in order for the connector to function.
    &quot;refreshInterval&quot;: &quot;A String&quot;, # Required. The refresh interval for data sync. If duration is set to 0, the data will be synced in real time. The streaming feature is not supported yet. The minimum is 30 minutes and maximum is 7 days.
    &quot;state&quot;: &quot;A String&quot;, # Output only. State of the connector.
    &quot;staticIpAddresses&quot;: [ # Output only. The static IP addresses used by this connector.
      &quot;A String&quot;,
    ],
    &quot;staticIpEnabled&quot;: True or False, # Optional. Whether customer has enabled static IP addresses for this connector.
    &quot;syncMode&quot;: &quot;A String&quot;, # The data synchronization mode supported by the data connector.
    &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp the DataConnector was last updated.
  },
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The Collection display name. This field must be a UTF-8 encoded string with a length limit of 128 characters. Otherwise, an INVALID_ARGUMENT error is returned.
  &quot;name&quot;: &quot;A String&quot;, # Immutable. The full resource name of the Collection. Format: `projects/{project}/locations/{location}/collections/{collection_id}`. This field must be a UTF-8 encoded string with a length limit of 1024 characters.
}

  updateMask: string, Optional. The list of fields to be updated.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # This resource represents a long-running operation that is the result of a network API call.
  &quot;done&quot;: True or False, # If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The error result of the operation in case of failure or cancellation.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;metadata&quot;: { # Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
  &quot;name&quot;: &quot;A String&quot;, # The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
  &quot;response&quot;: { # The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="updateDataConnector">updateDataConnector(name, body=None, updateMask=None, x__xgafv=None)</code>
  <pre>Updates a DataConnector.

Args:
  name: string, Output only. The full resource name of the Data Connector. Format: `projects/*/locations/*/collections/*/dataConnector`. (required)
  body: object, The request body.
    The object takes the form of:

{ # Manages the connection to external data sources for all data stores grouped under a Collection. It&#x27;s a singleton resource of Collection. The initialization is only supported through DataConnectorService.SetUpDataConnector method, which will create a new Collection and initialize its DataConnector.
  &quot;actionConfig&quot;: { # Informations to support actions on the connector. # Optional. Action configurations to make the connector support actions.
    &quot;actionParams&quot;: { # Required. Params needed to support actions in the format of (Key, Value) pairs. Required parameters for sources that support OAUTH, i.e. `gmail`, `google_calendar`, `jira`, `workday`, `salesforce`, `confluence`: * Key: `client_id` * Value: type STRING. The client id for the service provider to identify your application. * Key: `client_secret` * Value:type STRING. The client secret generated by the application&#x27;s authorization server.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;isActionConfigured&quot;: True or False, # Output only. The connector contains the necessary parameters and is configured to support actions.
  },
  &quot;autoRunDisabled&quot;: True or False, # Indicates whether the connector is disabled for auto run. It can be used to pause periodical and real time sync.
  &quot;blockingReasons&quot;: [ # Output only. User actions that must be completed before the connector can start syncing data.
    &quot;A String&quot;,
  ],
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp the DataConnector was created at.
  &quot;dataSource&quot;: &quot;A String&quot;, # Required. The name of the data source. Supported values: `salesforce`, `jira`, `confluence`, `bigquery`.
  &quot;destinationConfigs&quot;: [ # Optional. Any target destinations used to connect to third-party services.
    { # Defines target endpoints used to connect to third-party sources.
      &quot;destinations&quot;: [ # Optional. The destinations for the corresponding key.
        { # Defines a target endpoint
          &quot;host&quot;: &quot;A String&quot;, # Publicly routable host.
          &quot;port&quot;: 42, # Optional. Target port number accepted by the destination.
        },
      ],
      &quot;key&quot;: &quot;A String&quot;, # Optional. Unique destination identifier that is supported by the connector.
      &quot;params&quot;: { # Optional. Additional parameters for this destination config.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
    },
  ],
  &quot;entities&quot;: [ # List of entities from the connected data source to ingest.
    { # Represents an entity in the data source. For example, the `Account` object in Salesforce.
      &quot;dataStore&quot;: &quot;A String&quot;, # Output only. The full resource name of the associated data store for the source entity. Format: `projects/*/locations/*/collections/*/dataStores/*`. When the connector is initialized by the DataConnectorService.SetUpDataConnector method, a DataStore is automatically created for each source entity.
      &quot;entityName&quot;: &quot;A String&quot;, # The name of the entity. Supported values by data source: * Salesforce: `Lead`, `Opportunity`, `Contact`, `Account`, `Case`, `Contract`, `Campaign` * Jira: `Issue` * Confluence: `Content`, `Space`
      &quot;keyPropertyMappings&quot;: { # Attributes for indexing. Key: Field name. Value: The key property to map a field to, such as `title`, and `description`. Supported key properties: * `title`: The title for data record. This would be displayed on search results. * `description`: The description for data record. This would be displayed on search results.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
      &quot;params&quot;: { # The parameters for the entity to facilitate data ingestion. E.g. for BQ connectors: * Key: `document_id_column` * Value: type STRING. The value of the column id.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
    },
  ],
  &quot;errors&quot;: [ # Output only. The errors from initialization or from the latest connector run.
    { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
      &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
      &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
        {
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
        },
      ],
      &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
    },
  ],
  &quot;identityRefreshInterval&quot;: &quot;A String&quot;, # The refresh interval to sync the Access Control List information for the documents ingested by this connector. If not set, the access control list will be refreshed at the default interval of 30 minutes. The identity refresh interval can be at least 30 minutes and at most 7 days.
  &quot;identityScheduleConfig&quot;: { # The configuration for the identity data synchronization runs. # The configuration for the identity data synchronization runs. This contains the refresh interval to sync the Access Control List information for the documents ingested by this connector.
    &quot;nextSyncTime&quot;: { # Represents civil time (or occasionally physical time). This type can represent a civil time in one of a few possible ways: * When utc_offset is set and time_zone is unset: a civil time on a calendar day with a particular offset from UTC. * When time_zone is set and utc_offset is unset: a civil time on a calendar day in a particular time zone. * When neither time_zone nor utc_offset is set: a civil time on a calendar day in local time. The date is relative to the Proleptic Gregorian Calendar. If year, month, or day are 0, the DateTime is considered not to have a specific year, month, or day respectively. This type may also be used to represent a physical time if all the date and time fields are set and either case of the `time_offset` oneof is set. Consider using `Timestamp` message for physical time instead. If your use case also would like to store the user&#x27;s timezone, that can be done in another field. This type is more flexible than some applications may want. Make sure to document and validate your application&#x27;s limitations. # Optional. The UTC time when the next data sync is expected to start for the Data Connector. Customers are only able to specify the hour and minute to schedule the data sync. This is utilized when the data connector has a refresh interval greater than 1 day.
      &quot;day&quot;: 42, # Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
      &quot;hours&quot;: 42, # Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value &quot;24:00:00&quot; for scenarios like business closing time.
      &quot;minutes&quot;: 42, # Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
      &quot;month&quot;: 42, # Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
      &quot;nanos&quot;: 42, # Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
      &quot;seconds&quot;: 42, # Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
      &quot;timeZone&quot;: { # Represents a time zone from the [IANA Time Zone Database](https://www.iana.org/time-zones). # Time zone.
        &quot;id&quot;: &quot;A String&quot;, # IANA Time Zone Database time zone. For example &quot;America/New_York&quot;.
        &quot;version&quot;: &quot;A String&quot;, # Optional. IANA Time Zone Database version number. For example &quot;2019a&quot;.
      },
      &quot;utcOffset&quot;: &quot;A String&quot;, # UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
      &quot;year&quot;: 42, # Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
    },
    &quot;refreshInterval&quot;: &quot;A String&quot;, # Optional. The refresh interval to sync the Access Control List information for the documents ingested by this connector. If not set, the access control list will be refreshed at the default interval of 30 minutes. The identity refresh interval can be at least 30 minutes and at most 7 days.
  },
  &quot;kmsKeyName&quot;: &quot;A String&quot;, # Input only. The KMS key to be used to protect the DataStores managed by this connector. Must be set for requests that need to comply with CMEK Org Policy protections. If this field is set and processed successfully, the DataStores created by this connector will be protected by the KMS key.
  &quot;lastSyncTime&quot;: &quot;A String&quot;, # Output only. For periodic connectors only, the last time a data sync was completed.
  &quot;latestPauseTime&quot;: &quot;A String&quot;, # Output only. The most recent timestamp when this DataConnector was paused, affecting all functionalities such as data synchronization. Pausing a connector has the following effects: - All functionalities, including data synchronization, are halted. - Any ongoing data synchronization job will be canceled. - No future data synchronization runs will be scheduled nor can be triggered.
  &quot;name&quot;: &quot;A String&quot;, # Output only. The full resource name of the Data Connector. Format: `projects/*/locations/*/collections/*/dataConnector`.
  &quot;nextSyncTime&quot;: { # Represents civil time (or occasionally physical time). This type can represent a civil time in one of a few possible ways: * When utc_offset is set and time_zone is unset: a civil time on a calendar day with a particular offset from UTC. * When time_zone is set and utc_offset is unset: a civil time on a calendar day in a particular time zone. * When neither time_zone nor utc_offset is set: a civil time on a calendar day in local time. The date is relative to the Proleptic Gregorian Calendar. If year, month, or day are 0, the DateTime is considered not to have a specific year, month, or day respectively. This type may also be used to represent a physical time if all the date and time fields are set and either case of the `time_offset` oneof is set. Consider using `Timestamp` message for physical time instead. If your use case also would like to store the user&#x27;s timezone, that can be done in another field. This type is more flexible than some applications may want. Make sure to document and validate your application&#x27;s limitations. # The UTC time when the next data sync is expected to start for the Data Connector. Customers are only able to specify the hour and minute to schedule the data sync. This is utilized when the data connector has a refresh interval greater than 1 day.
    &quot;day&quot;: 42, # Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
    &quot;hours&quot;: 42, # Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value &quot;24:00:00&quot; for scenarios like business closing time.
    &quot;minutes&quot;: 42, # Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
    &quot;month&quot;: 42, # Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
    &quot;nanos&quot;: 42, # Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
    &quot;seconds&quot;: 42, # Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
    &quot;timeZone&quot;: { # Represents a time zone from the [IANA Time Zone Database](https://www.iana.org/time-zones). # Time zone.
      &quot;id&quot;: &quot;A String&quot;, # IANA Time Zone Database time zone. For example &quot;America/New_York&quot;.
      &quot;version&quot;: &quot;A String&quot;, # Optional. IANA Time Zone Database version number. For example &quot;2019a&quot;.
    },
    &quot;utcOffset&quot;: &quot;A String&quot;, # UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
    &quot;year&quot;: 42, # Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
  },
  &quot;params&quot;: { # Required. Params needed to access the source in the format of (Key, Value) pairs. Required parameters for all data sources: * Key: `instance_uri` * Value: type STRING. The uri to access the data source. Required parameters for sources that support OAUTH, i.e. `salesforce`: * Key: `client_id` * Value: type STRING. The client id for the third party service provider to identify your application. * Key: `client_secret` * Value:type STRING. The client secret generated by the third party authorization server. * Key: `access_token` * Value: type STRING. OAuth token for UCS to access to the protected resource. * Key: `refresh_token` * Value: type STRING. OAuth refresh token for UCS to obtain a new access token without user interaction. Required parameters for sources that support basic API token auth, i.e. `jira`, `confluence`: * Key: `user_account` * Value: type STRING. The username or email with the source. * Key: `api_token` * Value: type STRING. The API token generated for the source account, that is used for authenticating anywhere where you would have used a password. Example: ```json { &quot;instance_uri&quot;: &quot;https://xxx.atlassian.net&quot;, &quot;user_account&quot;: &quot;xxxx.xxx@xxx.com&quot;, &quot;api_token&quot;: &quot;test-token&quot; } ``` Optional parameter to specify the authorization type to use for multiple authorization types support: * Key: `auth_type` * Value: type STRING. The authorization type for the data source. Supported values: `BASIC_AUTH`, `OAUTH`, `OAUTH_ACCESS_TOKEN`, `OAUTH_TWO_LEGGED`, `OAUTH_JWT_BEARER`, `OAUTH_PASSWORD_GRANT`, `JWT`, `API_TOKEN`, `FEDERATED_CREDENTIAL`.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
  },
  &quot;privateConnectivityProjectId&quot;: &quot;A String&quot;, # Output only. The tenant project ID associated with private connectivity connectors. This project must be allowlisted by in order for the connector to function.
  &quot;refreshInterval&quot;: &quot;A String&quot;, # Required. The refresh interval for data sync. If duration is set to 0, the data will be synced in real time. The streaming feature is not supported yet. The minimum is 30 minutes and maximum is 7 days.
  &quot;state&quot;: &quot;A String&quot;, # Output only. State of the connector.
  &quot;staticIpAddresses&quot;: [ # Output only. The static IP addresses used by this connector.
    &quot;A String&quot;,
  ],
  &quot;staticIpEnabled&quot;: True or False, # Optional. Whether customer has enabled static IP addresses for this connector.
  &quot;syncMode&quot;: &quot;A String&quot;, # The data synchronization mode supported by the data connector.
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp the DataConnector was last updated.
}

  updateMask: string, Indicates which fields in the provided DataConnector to update. Supported field paths include: - refresh_interval - params - auto_run_disabled - action_config - destination_configs - blocking_reasons Note: Support for these fields may vary depending on the connector type. For example, not all connectors support `destination_configs`. If an unsupported or unknown field path is provided, the request will return an INVALID_ARGUMENT error.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Manages the connection to external data sources for all data stores grouped under a Collection. It&#x27;s a singleton resource of Collection. The initialization is only supported through DataConnectorService.SetUpDataConnector method, which will create a new Collection and initialize its DataConnector.
  &quot;actionConfig&quot;: { # Informations to support actions on the connector. # Optional. Action configurations to make the connector support actions.
    &quot;actionParams&quot;: { # Required. Params needed to support actions in the format of (Key, Value) pairs. Required parameters for sources that support OAUTH, i.e. `gmail`, `google_calendar`, `jira`, `workday`, `salesforce`, `confluence`: * Key: `client_id` * Value: type STRING. The client id for the service provider to identify your application. * Key: `client_secret` * Value:type STRING. The client secret generated by the application&#x27;s authorization server.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;isActionConfigured&quot;: True or False, # Output only. The connector contains the necessary parameters and is configured to support actions.
  },
  &quot;autoRunDisabled&quot;: True or False, # Indicates whether the connector is disabled for auto run. It can be used to pause periodical and real time sync.
  &quot;blockingReasons&quot;: [ # Output only. User actions that must be completed before the connector can start syncing data.
    &quot;A String&quot;,
  ],
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp the DataConnector was created at.
  &quot;dataSource&quot;: &quot;A String&quot;, # Required. The name of the data source. Supported values: `salesforce`, `jira`, `confluence`, `bigquery`.
  &quot;destinationConfigs&quot;: [ # Optional. Any target destinations used to connect to third-party services.
    { # Defines target endpoints used to connect to third-party sources.
      &quot;destinations&quot;: [ # Optional. The destinations for the corresponding key.
        { # Defines a target endpoint
          &quot;host&quot;: &quot;A String&quot;, # Publicly routable host.
          &quot;port&quot;: 42, # Optional. Target port number accepted by the destination.
        },
      ],
      &quot;key&quot;: &quot;A String&quot;, # Optional. Unique destination identifier that is supported by the connector.
      &quot;params&quot;: { # Optional. Additional parameters for this destination config.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
    },
  ],
  &quot;entities&quot;: [ # List of entities from the connected data source to ingest.
    { # Represents an entity in the data source. For example, the `Account` object in Salesforce.
      &quot;dataStore&quot;: &quot;A String&quot;, # Output only. The full resource name of the associated data store for the source entity. Format: `projects/*/locations/*/collections/*/dataStores/*`. When the connector is initialized by the DataConnectorService.SetUpDataConnector method, a DataStore is automatically created for each source entity.
      &quot;entityName&quot;: &quot;A String&quot;, # The name of the entity. Supported values by data source: * Salesforce: `Lead`, `Opportunity`, `Contact`, `Account`, `Case`, `Contract`, `Campaign` * Jira: `Issue` * Confluence: `Content`, `Space`
      &quot;keyPropertyMappings&quot;: { # Attributes for indexing. Key: Field name. Value: The key property to map a field to, such as `title`, and `description`. Supported key properties: * `title`: The title for data record. This would be displayed on search results. * `description`: The description for data record. This would be displayed on search results.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
      &quot;params&quot;: { # The parameters for the entity to facilitate data ingestion. E.g. for BQ connectors: * Key: `document_id_column` * Value: type STRING. The value of the column id.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
    },
  ],
  &quot;errors&quot;: [ # Output only. The errors from initialization or from the latest connector run.
    { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
      &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
      &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
        {
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
        },
      ],
      &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
    },
  ],
  &quot;identityRefreshInterval&quot;: &quot;A String&quot;, # The refresh interval to sync the Access Control List information for the documents ingested by this connector. If not set, the access control list will be refreshed at the default interval of 30 minutes. The identity refresh interval can be at least 30 minutes and at most 7 days.
  &quot;identityScheduleConfig&quot;: { # The configuration for the identity data synchronization runs. # The configuration for the identity data synchronization runs. This contains the refresh interval to sync the Access Control List information for the documents ingested by this connector.
    &quot;nextSyncTime&quot;: { # Represents civil time (or occasionally physical time). This type can represent a civil time in one of a few possible ways: * When utc_offset is set and time_zone is unset: a civil time on a calendar day with a particular offset from UTC. * When time_zone is set and utc_offset is unset: a civil time on a calendar day in a particular time zone. * When neither time_zone nor utc_offset is set: a civil time on a calendar day in local time. The date is relative to the Proleptic Gregorian Calendar. If year, month, or day are 0, the DateTime is considered not to have a specific year, month, or day respectively. This type may also be used to represent a physical time if all the date and time fields are set and either case of the `time_offset` oneof is set. Consider using `Timestamp` message for physical time instead. If your use case also would like to store the user&#x27;s timezone, that can be done in another field. This type is more flexible than some applications may want. Make sure to document and validate your application&#x27;s limitations. # Optional. The UTC time when the next data sync is expected to start for the Data Connector. Customers are only able to specify the hour and minute to schedule the data sync. This is utilized when the data connector has a refresh interval greater than 1 day.
      &quot;day&quot;: 42, # Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
      &quot;hours&quot;: 42, # Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value &quot;24:00:00&quot; for scenarios like business closing time.
      &quot;minutes&quot;: 42, # Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
      &quot;month&quot;: 42, # Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
      &quot;nanos&quot;: 42, # Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
      &quot;seconds&quot;: 42, # Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
      &quot;timeZone&quot;: { # Represents a time zone from the [IANA Time Zone Database](https://www.iana.org/time-zones). # Time zone.
        &quot;id&quot;: &quot;A String&quot;, # IANA Time Zone Database time zone. For example &quot;America/New_York&quot;.
        &quot;version&quot;: &quot;A String&quot;, # Optional. IANA Time Zone Database version number. For example &quot;2019a&quot;.
      },
      &quot;utcOffset&quot;: &quot;A String&quot;, # UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
      &quot;year&quot;: 42, # Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
    },
    &quot;refreshInterval&quot;: &quot;A String&quot;, # Optional. The refresh interval to sync the Access Control List information for the documents ingested by this connector. If not set, the access control list will be refreshed at the default interval of 30 minutes. The identity refresh interval can be at least 30 minutes and at most 7 days.
  },
  &quot;kmsKeyName&quot;: &quot;A String&quot;, # Input only. The KMS key to be used to protect the DataStores managed by this connector. Must be set for requests that need to comply with CMEK Org Policy protections. If this field is set and processed successfully, the DataStores created by this connector will be protected by the KMS key.
  &quot;lastSyncTime&quot;: &quot;A String&quot;, # Output only. For periodic connectors only, the last time a data sync was completed.
  &quot;latestPauseTime&quot;: &quot;A String&quot;, # Output only. The most recent timestamp when this DataConnector was paused, affecting all functionalities such as data synchronization. Pausing a connector has the following effects: - All functionalities, including data synchronization, are halted. - Any ongoing data synchronization job will be canceled. - No future data synchronization runs will be scheduled nor can be triggered.
  &quot;name&quot;: &quot;A String&quot;, # Output only. The full resource name of the Data Connector. Format: `projects/*/locations/*/collections/*/dataConnector`.
  &quot;nextSyncTime&quot;: { # Represents civil time (or occasionally physical time). This type can represent a civil time in one of a few possible ways: * When utc_offset is set and time_zone is unset: a civil time on a calendar day with a particular offset from UTC. * When time_zone is set and utc_offset is unset: a civil time on a calendar day in a particular time zone. * When neither time_zone nor utc_offset is set: a civil time on a calendar day in local time. The date is relative to the Proleptic Gregorian Calendar. If year, month, or day are 0, the DateTime is considered not to have a specific year, month, or day respectively. This type may also be used to represent a physical time if all the date and time fields are set and either case of the `time_offset` oneof is set. Consider using `Timestamp` message for physical time instead. If your use case also would like to store the user&#x27;s timezone, that can be done in another field. This type is more flexible than some applications may want. Make sure to document and validate your application&#x27;s limitations. # The UTC time when the next data sync is expected to start for the Data Connector. Customers are only able to specify the hour and minute to schedule the data sync. This is utilized when the data connector has a refresh interval greater than 1 day.
    &quot;day&quot;: 42, # Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
    &quot;hours&quot;: 42, # Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value &quot;24:00:00&quot; for scenarios like business closing time.
    &quot;minutes&quot;: 42, # Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
    &quot;month&quot;: 42, # Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
    &quot;nanos&quot;: 42, # Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
    &quot;seconds&quot;: 42, # Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
    &quot;timeZone&quot;: { # Represents a time zone from the [IANA Time Zone Database](https://www.iana.org/time-zones). # Time zone.
      &quot;id&quot;: &quot;A String&quot;, # IANA Time Zone Database time zone. For example &quot;America/New_York&quot;.
      &quot;version&quot;: &quot;A String&quot;, # Optional. IANA Time Zone Database version number. For example &quot;2019a&quot;.
    },
    &quot;utcOffset&quot;: &quot;A String&quot;, # UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
    &quot;year&quot;: 42, # Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
  },
  &quot;params&quot;: { # Required. Params needed to access the source in the format of (Key, Value) pairs. Required parameters for all data sources: * Key: `instance_uri` * Value: type STRING. The uri to access the data source. Required parameters for sources that support OAUTH, i.e. `salesforce`: * Key: `client_id` * Value: type STRING. The client id for the third party service provider to identify your application. * Key: `client_secret` * Value:type STRING. The client secret generated by the third party authorization server. * Key: `access_token` * Value: type STRING. OAuth token for UCS to access to the protected resource. * Key: `refresh_token` * Value: type STRING. OAuth refresh token for UCS to obtain a new access token without user interaction. Required parameters for sources that support basic API token auth, i.e. `jira`, `confluence`: * Key: `user_account` * Value: type STRING. The username or email with the source. * Key: `api_token` * Value: type STRING. The API token generated for the source account, that is used for authenticating anywhere where you would have used a password. Example: ```json { &quot;instance_uri&quot;: &quot;https://xxx.atlassian.net&quot;, &quot;user_account&quot;: &quot;xxxx.xxx@xxx.com&quot;, &quot;api_token&quot;: &quot;test-token&quot; } ``` Optional parameter to specify the authorization type to use for multiple authorization types support: * Key: `auth_type` * Value: type STRING. The authorization type for the data source. Supported values: `BASIC_AUTH`, `OAUTH`, `OAUTH_ACCESS_TOKEN`, `OAUTH_TWO_LEGGED`, `OAUTH_JWT_BEARER`, `OAUTH_PASSWORD_GRANT`, `JWT`, `API_TOKEN`, `FEDERATED_CREDENTIAL`.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
  },
  &quot;privateConnectivityProjectId&quot;: &quot;A String&quot;, # Output only. The tenant project ID associated with private connectivity connectors. This project must be allowlisted by in order for the connector to function.
  &quot;refreshInterval&quot;: &quot;A String&quot;, # Required. The refresh interval for data sync. If duration is set to 0, the data will be synced in real time. The streaming feature is not supported yet. The minimum is 30 minutes and maximum is 7 days.
  &quot;state&quot;: &quot;A String&quot;, # Output only. State of the connector.
  &quot;staticIpAddresses&quot;: [ # Output only. The static IP addresses used by this connector.
    &quot;A String&quot;,
  ],
  &quot;staticIpEnabled&quot;: True or False, # Optional. Whether customer has enabled static IP addresses for this connector.
  &quot;syncMode&quot;: &quot;A String&quot;, # The data synchronization mode supported by the data connector.
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp the DataConnector was last updated.
}</pre>
</div>

</body></html>