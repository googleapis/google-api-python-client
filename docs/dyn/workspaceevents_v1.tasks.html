<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="workspaceevents_v1.html">Google Workspace Events API</a> . <a href="workspaceevents_v1.tasks.html">tasks</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="workspaceevents_v1.tasks.pushNotificationConfigs.html">pushNotificationConfigs()</a></code>
</p>
<p class="firstline">Returns the pushNotificationConfigs Resource.</p>

<p class="toc_element">
  <code><a href="#cancel">cancel(name, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Cancel a task from the agent. If supported one should expect no more task updates for the task.</p>
<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#get">get(name, historyLength=None, tenant=None, x__xgafv=None)</a></code></p>
<p class="firstline">Get the current state of a task from the agent.</p>
<p class="toc_element">
  <code><a href="#subscribe">subscribe(name, tenant=None, x__xgafv=None)</a></code></p>
<p class="firstline">TaskSubscription is a streaming call that will return a stream of task update events. This attaches the stream to an existing in process task. If the task is complete the stream will return the completed task (like GetTask) and close the stream.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="cancel">cancel(name, body=None, x__xgafv=None)</code>
  <pre>Cancel a task from the agent. If supported one should expect no more task updates for the task.

Args:
  name: string, The resource name of the task to cancel. Format: tasks/{task_id} (required)
  body: object, The request body.
    The object takes the form of:

{
  &quot;tenant&quot;: &quot;A String&quot;, # Optional tenant, provided as a path parameter. Experimental, might still change for 1.0 release.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Task is the core unit of action for A2A. It has a current status and when results are created for the task they are stored in the artifact. If there are multiple turns for a task, these are stored in history.
  &quot;artifacts&quot;: [ # A set of output artifacts for a Task.
    { # Artifacts are the container for task completed results. These are similar to Messages but are intended to be the product of a task, as opposed to point-to-point communication.
      &quot;artifactId&quot;: &quot;A String&quot;, # Unique identifier (e.g. UUID) for the artifact. It must be at least unique within a task.
      &quot;description&quot;: &quot;A String&quot;, # A human readable description of the artifact, optional.
      &quot;extensions&quot;: [ # The URIs of extensions that are present or contributed to this Artifact.
        &quot;A String&quot;,
      ],
      &quot;metadata&quot;: { # Optional metadata included with the artifact.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;name&quot;: &quot;A String&quot;, # A human readable name for the artifact.
      &quot;parts&quot;: [ # The content of the artifact.
        { # Part represents a container for a section of communication content. Parts can be purely textual, some sort of file (image, video, etc) or a structured data blob (i.e. JSON).
          &quot;data&quot;: { # DataPart represents a structured blob. This is most commonly a JSON payload.
            &quot;data&quot;: {
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
          },
          &quot;file&quot;: { # FilePart represents the different ways files can be provided. If files are small, directly feeding the bytes is supported via file_with_bytes. If the file is large, the agent should read the content as appropriate directly from the file_with_uri source.
            &quot;fileWithBytes&quot;: &quot;A String&quot;,
            &quot;fileWithUri&quot;: &quot;A String&quot;,
            &quot;mimeType&quot;: &quot;A String&quot;,
            &quot;name&quot;: &quot;A String&quot;,
          },
          &quot;metadata&quot;: { # Optional metadata associated with this part.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;text&quot;: &quot;A String&quot;,
        },
      ],
    },
  ],
  &quot;contextId&quot;: &quot;A String&quot;, # Unique identifier (e.g. UUID) for the contextual collection of interactions (tasks and messages). Created by the A2A server.
  &quot;history&quot;: [ # protolint:disable REPEATED_FIELD_NAMES_PLURALIZED The history of interactions from a task.
    { # Message is one unit of communication between client and server. It is associated with a context and optionally a task. Since the server is responsible for the context definition, it must always provide a context_id in its messages. The client can optionally provide the context_id if it knows the context to associate the message to. Similarly for task_id, except the server decides if a task is created and whether to include the task_id.
      &quot;content&quot;: [ # protolint:disable REPEATED_FIELD_NAMES_PLURALIZED Content is the container of the message content.
        { # Part represents a container for a section of communication content. Parts can be purely textual, some sort of file (image, video, etc) or a structured data blob (i.e. JSON).
          &quot;data&quot;: { # DataPart represents a structured blob. This is most commonly a JSON payload.
            &quot;data&quot;: {
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
          },
          &quot;file&quot;: { # FilePart represents the different ways files can be provided. If files are small, directly feeding the bytes is supported via file_with_bytes. If the file is large, the agent should read the content as appropriate directly from the file_with_uri source.
            &quot;fileWithBytes&quot;: &quot;A String&quot;,
            &quot;fileWithUri&quot;: &quot;A String&quot;,
            &quot;mimeType&quot;: &quot;A String&quot;,
            &quot;name&quot;: &quot;A String&quot;,
          },
          &quot;metadata&quot;: { # Optional metadata associated with this part.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;text&quot;: &quot;A String&quot;,
        },
      ],
      &quot;contextId&quot;: &quot;A String&quot;, # The context id of the message. This is optional and if set, the message will be associated with the given context.
      &quot;extensions&quot;: [ # The URIs of extensions that are present or contributed to this Message.
        &quot;A String&quot;,
      ],
      &quot;messageId&quot;: &quot;A String&quot;, # The unique identifier (e.g. UUID)of the message. This is required and created by the message creator.
      &quot;metadata&quot;: { # protolint:enable REPEATED_FIELD_NAMES_PLURALIZED Any optional metadata to provide along with the message.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;role&quot;: &quot;A String&quot;, # A role for the message.
      &quot;taskId&quot;: &quot;A String&quot;, # The task id of the message. This is optional and if set, the message will be associated with the given task.
    },
  ],
  &quot;id&quot;: &quot;A String&quot;, # Unique identifier (e.g. UUID) for the task, generated by the server for a new task.
  &quot;metadata&quot;: { # protolint:enable REPEATED_FIELD_NAMES_PLURALIZED A key/value object to store custom metadata about a task.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
  },
  &quot;status&quot;: { # A container for the status of a task # The current status of a Task, including state and a message.
    &quot;message&quot;: { # Message is one unit of communication between client and server. It is associated with a context and optionally a task. Since the server is responsible for the context definition, it must always provide a context_id in its messages. The client can optionally provide the context_id if it knows the context to associate the message to. Similarly for task_id, except the server decides if a task is created and whether to include the task_id. # A message associated with the status.
      &quot;content&quot;: [ # protolint:disable REPEATED_FIELD_NAMES_PLURALIZED Content is the container of the message content.
        { # Part represents a container for a section of communication content. Parts can be purely textual, some sort of file (image, video, etc) or a structured data blob (i.e. JSON).
          &quot;data&quot;: { # DataPart represents a structured blob. This is most commonly a JSON payload.
            &quot;data&quot;: {
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
          },
          &quot;file&quot;: { # FilePart represents the different ways files can be provided. If files are small, directly feeding the bytes is supported via file_with_bytes. If the file is large, the agent should read the content as appropriate directly from the file_with_uri source.
            &quot;fileWithBytes&quot;: &quot;A String&quot;,
            &quot;fileWithUri&quot;: &quot;A String&quot;,
            &quot;mimeType&quot;: &quot;A String&quot;,
            &quot;name&quot;: &quot;A String&quot;,
          },
          &quot;metadata&quot;: { # Optional metadata associated with this part.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;text&quot;: &quot;A String&quot;,
        },
      ],
      &quot;contextId&quot;: &quot;A String&quot;, # The context id of the message. This is optional and if set, the message will be associated with the given context.
      &quot;extensions&quot;: [ # The URIs of extensions that are present or contributed to this Message.
        &quot;A String&quot;,
      ],
      &quot;messageId&quot;: &quot;A String&quot;, # The unique identifier (e.g. UUID)of the message. This is required and created by the message creator.
      &quot;metadata&quot;: { # protolint:enable REPEATED_FIELD_NAMES_PLURALIZED Any optional metadata to provide along with the message.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;role&quot;: &quot;A String&quot;, # A role for the message.
      &quot;taskId&quot;: &quot;A String&quot;, # The task id of the message. This is optional and if set, the message will be associated with the given task.
    },
    &quot;state&quot;: &quot;A String&quot;, # The current state of this task
    &quot;timestamp&quot;: &quot;A String&quot;, # Timestamp when the status was recorded. Example: &quot;2023-10-27T10:00:00Z&quot;
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="get">get(name, historyLength=None, tenant=None, x__xgafv=None)</code>
  <pre>Get the current state of a task from the agent.

Args:
  name: string, Required. The resource name of the task. Format: tasks/{task_id} (required)
  historyLength: integer, The number of most recent messages from the task&#x27;s history to retrieve.
  tenant: string, Optional tenant, provided as a path parameter. Experimental, might still change for 1.0 release.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Task is the core unit of action for A2A. It has a current status and when results are created for the task they are stored in the artifact. If there are multiple turns for a task, these are stored in history.
  &quot;artifacts&quot;: [ # A set of output artifacts for a Task.
    { # Artifacts are the container for task completed results. These are similar to Messages but are intended to be the product of a task, as opposed to point-to-point communication.
      &quot;artifactId&quot;: &quot;A String&quot;, # Unique identifier (e.g. UUID) for the artifact. It must be at least unique within a task.
      &quot;description&quot;: &quot;A String&quot;, # A human readable description of the artifact, optional.
      &quot;extensions&quot;: [ # The URIs of extensions that are present or contributed to this Artifact.
        &quot;A String&quot;,
      ],
      &quot;metadata&quot;: { # Optional metadata included with the artifact.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;name&quot;: &quot;A String&quot;, # A human readable name for the artifact.
      &quot;parts&quot;: [ # The content of the artifact.
        { # Part represents a container for a section of communication content. Parts can be purely textual, some sort of file (image, video, etc) or a structured data blob (i.e. JSON).
          &quot;data&quot;: { # DataPart represents a structured blob. This is most commonly a JSON payload.
            &quot;data&quot;: {
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
          },
          &quot;file&quot;: { # FilePart represents the different ways files can be provided. If files are small, directly feeding the bytes is supported via file_with_bytes. If the file is large, the agent should read the content as appropriate directly from the file_with_uri source.
            &quot;fileWithBytes&quot;: &quot;A String&quot;,
            &quot;fileWithUri&quot;: &quot;A String&quot;,
            &quot;mimeType&quot;: &quot;A String&quot;,
            &quot;name&quot;: &quot;A String&quot;,
          },
          &quot;metadata&quot;: { # Optional metadata associated with this part.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;text&quot;: &quot;A String&quot;,
        },
      ],
    },
  ],
  &quot;contextId&quot;: &quot;A String&quot;, # Unique identifier (e.g. UUID) for the contextual collection of interactions (tasks and messages). Created by the A2A server.
  &quot;history&quot;: [ # protolint:disable REPEATED_FIELD_NAMES_PLURALIZED The history of interactions from a task.
    { # Message is one unit of communication between client and server. It is associated with a context and optionally a task. Since the server is responsible for the context definition, it must always provide a context_id in its messages. The client can optionally provide the context_id if it knows the context to associate the message to. Similarly for task_id, except the server decides if a task is created and whether to include the task_id.
      &quot;content&quot;: [ # protolint:disable REPEATED_FIELD_NAMES_PLURALIZED Content is the container of the message content.
        { # Part represents a container for a section of communication content. Parts can be purely textual, some sort of file (image, video, etc) or a structured data blob (i.e. JSON).
          &quot;data&quot;: { # DataPart represents a structured blob. This is most commonly a JSON payload.
            &quot;data&quot;: {
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
          },
          &quot;file&quot;: { # FilePart represents the different ways files can be provided. If files are small, directly feeding the bytes is supported via file_with_bytes. If the file is large, the agent should read the content as appropriate directly from the file_with_uri source.
            &quot;fileWithBytes&quot;: &quot;A String&quot;,
            &quot;fileWithUri&quot;: &quot;A String&quot;,
            &quot;mimeType&quot;: &quot;A String&quot;,
            &quot;name&quot;: &quot;A String&quot;,
          },
          &quot;metadata&quot;: { # Optional metadata associated with this part.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;text&quot;: &quot;A String&quot;,
        },
      ],
      &quot;contextId&quot;: &quot;A String&quot;, # The context id of the message. This is optional and if set, the message will be associated with the given context.
      &quot;extensions&quot;: [ # The URIs of extensions that are present or contributed to this Message.
        &quot;A String&quot;,
      ],
      &quot;messageId&quot;: &quot;A String&quot;, # The unique identifier (e.g. UUID)of the message. This is required and created by the message creator.
      &quot;metadata&quot;: { # protolint:enable REPEATED_FIELD_NAMES_PLURALIZED Any optional metadata to provide along with the message.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;role&quot;: &quot;A String&quot;, # A role for the message.
      &quot;taskId&quot;: &quot;A String&quot;, # The task id of the message. This is optional and if set, the message will be associated with the given task.
    },
  ],
  &quot;id&quot;: &quot;A String&quot;, # Unique identifier (e.g. UUID) for the task, generated by the server for a new task.
  &quot;metadata&quot;: { # protolint:enable REPEATED_FIELD_NAMES_PLURALIZED A key/value object to store custom metadata about a task.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
  },
  &quot;status&quot;: { # A container for the status of a task # The current status of a Task, including state and a message.
    &quot;message&quot;: { # Message is one unit of communication between client and server. It is associated with a context and optionally a task. Since the server is responsible for the context definition, it must always provide a context_id in its messages. The client can optionally provide the context_id if it knows the context to associate the message to. Similarly for task_id, except the server decides if a task is created and whether to include the task_id. # A message associated with the status.
      &quot;content&quot;: [ # protolint:disable REPEATED_FIELD_NAMES_PLURALIZED Content is the container of the message content.
        { # Part represents a container for a section of communication content. Parts can be purely textual, some sort of file (image, video, etc) or a structured data blob (i.e. JSON).
          &quot;data&quot;: { # DataPart represents a structured blob. This is most commonly a JSON payload.
            &quot;data&quot;: {
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
          },
          &quot;file&quot;: { # FilePart represents the different ways files can be provided. If files are small, directly feeding the bytes is supported via file_with_bytes. If the file is large, the agent should read the content as appropriate directly from the file_with_uri source.
            &quot;fileWithBytes&quot;: &quot;A String&quot;,
            &quot;fileWithUri&quot;: &quot;A String&quot;,
            &quot;mimeType&quot;: &quot;A String&quot;,
            &quot;name&quot;: &quot;A String&quot;,
          },
          &quot;metadata&quot;: { # Optional metadata associated with this part.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;text&quot;: &quot;A String&quot;,
        },
      ],
      &quot;contextId&quot;: &quot;A String&quot;, # The context id of the message. This is optional and if set, the message will be associated with the given context.
      &quot;extensions&quot;: [ # The URIs of extensions that are present or contributed to this Message.
        &quot;A String&quot;,
      ],
      &quot;messageId&quot;: &quot;A String&quot;, # The unique identifier (e.g. UUID)of the message. This is required and created by the message creator.
      &quot;metadata&quot;: { # protolint:enable REPEATED_FIELD_NAMES_PLURALIZED Any optional metadata to provide along with the message.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;role&quot;: &quot;A String&quot;, # A role for the message.
      &quot;taskId&quot;: &quot;A String&quot;, # The task id of the message. This is optional and if set, the message will be associated with the given task.
    },
    &quot;state&quot;: &quot;A String&quot;, # The current state of this task
    &quot;timestamp&quot;: &quot;A String&quot;, # Timestamp when the status was recorded. Example: &quot;2023-10-27T10:00:00Z&quot;
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="subscribe">subscribe(name, tenant=None, x__xgafv=None)</code>
  <pre>TaskSubscription is a streaming call that will return a stream of task update events. This attaches the stream to an existing in process task. If the task is complete the stream will return the completed task (like GetTask) and close the stream.

Args:
  name: string, The resource name of the task to subscribe to. Format: tasks/{task_id} (required)
  tenant: string, Optional tenant, provided as a path parameter. Experimental, might still change for 1.0 release.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The stream response for a message. The stream should be one of the following sequences: If the response is a message, the stream should contain one, and only one, message and then close If the response is a task lifecycle, the first response should be a Task object followed by zero or more TaskStatusUpdateEvents and TaskArtifactUpdateEvents. The stream should complete when the Task if in an interrupted or terminal state. A stream that ends before these conditions are met are
  &quot;artifactUpdate&quot;: { # TaskArtifactUpdateEvent represents a task delta where an artifact has been generated.
    &quot;append&quot;: True or False, # Whether this should be appended to a prior one produced
    &quot;artifact&quot;: { # Artifacts are the container for task completed results. These are similar to Messages but are intended to be the product of a task, as opposed to point-to-point communication. # The artifact itself
      &quot;artifactId&quot;: &quot;A String&quot;, # Unique identifier (e.g. UUID) for the artifact. It must be at least unique within a task.
      &quot;description&quot;: &quot;A String&quot;, # A human readable description of the artifact, optional.
      &quot;extensions&quot;: [ # The URIs of extensions that are present or contributed to this Artifact.
        &quot;A String&quot;,
      ],
      &quot;metadata&quot;: { # Optional metadata included with the artifact.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;name&quot;: &quot;A String&quot;, # A human readable name for the artifact.
      &quot;parts&quot;: [ # The content of the artifact.
        { # Part represents a container for a section of communication content. Parts can be purely textual, some sort of file (image, video, etc) or a structured data blob (i.e. JSON).
          &quot;data&quot;: { # DataPart represents a structured blob. This is most commonly a JSON payload.
            &quot;data&quot;: {
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
          },
          &quot;file&quot;: { # FilePart represents the different ways files can be provided. If files are small, directly feeding the bytes is supported via file_with_bytes. If the file is large, the agent should read the content as appropriate directly from the file_with_uri source.
            &quot;fileWithBytes&quot;: &quot;A String&quot;,
            &quot;fileWithUri&quot;: &quot;A String&quot;,
            &quot;mimeType&quot;: &quot;A String&quot;,
            &quot;name&quot;: &quot;A String&quot;,
          },
          &quot;metadata&quot;: { # Optional metadata associated with this part.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;text&quot;: &quot;A String&quot;,
        },
      ],
    },
    &quot;contextId&quot;: &quot;A String&quot;, # The id of the context that this task belongs too
    &quot;lastChunk&quot;: True or False, # Whether this represents the last part of an artifact
    &quot;metadata&quot;: { # Optional metadata associated with the artifact update.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;taskId&quot;: &quot;A String&quot;, # The id of the task for this artifact
  },
  &quot;message&quot;: { # Message is one unit of communication between client and server. It is associated with a context and optionally a task. Since the server is responsible for the context definition, it must always provide a context_id in its messages. The client can optionally provide the context_id if it knows the context to associate the message to. Similarly for task_id, except the server decides if a task is created and whether to include the task_id.
    &quot;content&quot;: [ # protolint:disable REPEATED_FIELD_NAMES_PLURALIZED Content is the container of the message content.
      { # Part represents a container for a section of communication content. Parts can be purely textual, some sort of file (image, video, etc) or a structured data blob (i.e. JSON).
        &quot;data&quot;: { # DataPart represents a structured blob. This is most commonly a JSON payload.
          &quot;data&quot;: {
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
        },
        &quot;file&quot;: { # FilePart represents the different ways files can be provided. If files are small, directly feeding the bytes is supported via file_with_bytes. If the file is large, the agent should read the content as appropriate directly from the file_with_uri source.
          &quot;fileWithBytes&quot;: &quot;A String&quot;,
          &quot;fileWithUri&quot;: &quot;A String&quot;,
          &quot;mimeType&quot;: &quot;A String&quot;,
          &quot;name&quot;: &quot;A String&quot;,
        },
        &quot;metadata&quot;: { # Optional metadata associated with this part.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;text&quot;: &quot;A String&quot;,
      },
    ],
    &quot;contextId&quot;: &quot;A String&quot;, # The context id of the message. This is optional and if set, the message will be associated with the given context.
    &quot;extensions&quot;: [ # The URIs of extensions that are present or contributed to this Message.
      &quot;A String&quot;,
    ],
    &quot;messageId&quot;: &quot;A String&quot;, # The unique identifier (e.g. UUID)of the message. This is required and created by the message creator.
    &quot;metadata&quot;: { # protolint:enable REPEATED_FIELD_NAMES_PLURALIZED Any optional metadata to provide along with the message.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;role&quot;: &quot;A String&quot;, # A role for the message.
    &quot;taskId&quot;: &quot;A String&quot;, # The task id of the message. This is optional and if set, the message will be associated with the given task.
  },
  &quot;statusUpdate&quot;: { # TaskStatusUpdateEvent is a delta even on a task indicating that a task has changed.
    &quot;contextId&quot;: &quot;A String&quot;, # The id of the context that the task belongs to
    &quot;final&quot;: True or False, # Whether this is the last status update expected for this task.
    &quot;metadata&quot;: { # Optional metadata to associate with the task update.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;status&quot;: { # A container for the status of a task # The new status of the task.
      &quot;message&quot;: { # Message is one unit of communication between client and server. It is associated with a context and optionally a task. Since the server is responsible for the context definition, it must always provide a context_id in its messages. The client can optionally provide the context_id if it knows the context to associate the message to. Similarly for task_id, except the server decides if a task is created and whether to include the task_id. # A message associated with the status.
        &quot;content&quot;: [ # protolint:disable REPEATED_FIELD_NAMES_PLURALIZED Content is the container of the message content.
          { # Part represents a container for a section of communication content. Parts can be purely textual, some sort of file (image, video, etc) or a structured data blob (i.e. JSON).
            &quot;data&quot;: { # DataPart represents a structured blob. This is most commonly a JSON payload.
              &quot;data&quot;: {
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;file&quot;: { # FilePart represents the different ways files can be provided. If files are small, directly feeding the bytes is supported via file_with_bytes. If the file is large, the agent should read the content as appropriate directly from the file_with_uri source.
              &quot;fileWithBytes&quot;: &quot;A String&quot;,
              &quot;fileWithUri&quot;: &quot;A String&quot;,
              &quot;mimeType&quot;: &quot;A String&quot;,
              &quot;name&quot;: &quot;A String&quot;,
            },
            &quot;metadata&quot;: { # Optional metadata associated with this part.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;text&quot;: &quot;A String&quot;,
          },
        ],
        &quot;contextId&quot;: &quot;A String&quot;, # The context id of the message. This is optional and if set, the message will be associated with the given context.
        &quot;extensions&quot;: [ # The URIs of extensions that are present or contributed to this Message.
          &quot;A String&quot;,
        ],
        &quot;messageId&quot;: &quot;A String&quot;, # The unique identifier (e.g. UUID)of the message. This is required and created by the message creator.
        &quot;metadata&quot;: { # protolint:enable REPEATED_FIELD_NAMES_PLURALIZED Any optional metadata to provide along with the message.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;role&quot;: &quot;A String&quot;, # A role for the message.
        &quot;taskId&quot;: &quot;A String&quot;, # The task id of the message. This is optional and if set, the message will be associated with the given task.
      },
      &quot;state&quot;: &quot;A String&quot;, # The current state of this task
      &quot;timestamp&quot;: &quot;A String&quot;, # Timestamp when the status was recorded. Example: &quot;2023-10-27T10:00:00Z&quot;
    },
    &quot;taskId&quot;: &quot;A String&quot;, # The id of the task that is changed
  },
  &quot;task&quot;: { # Task is the core unit of action for A2A. It has a current status and when results are created for the task they are stored in the artifact. If there are multiple turns for a task, these are stored in history.
    &quot;artifacts&quot;: [ # A set of output artifacts for a Task.
      { # Artifacts are the container for task completed results. These are similar to Messages but are intended to be the product of a task, as opposed to point-to-point communication.
        &quot;artifactId&quot;: &quot;A String&quot;, # Unique identifier (e.g. UUID) for the artifact. It must be at least unique within a task.
        &quot;description&quot;: &quot;A String&quot;, # A human readable description of the artifact, optional.
        &quot;extensions&quot;: [ # The URIs of extensions that are present or contributed to this Artifact.
          &quot;A String&quot;,
        ],
        &quot;metadata&quot;: { # Optional metadata included with the artifact.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;name&quot;: &quot;A String&quot;, # A human readable name for the artifact.
        &quot;parts&quot;: [ # The content of the artifact.
          { # Part represents a container for a section of communication content. Parts can be purely textual, some sort of file (image, video, etc) or a structured data blob (i.e. JSON).
            &quot;data&quot;: { # DataPart represents a structured blob. This is most commonly a JSON payload.
              &quot;data&quot;: {
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;file&quot;: { # FilePart represents the different ways files can be provided. If files are small, directly feeding the bytes is supported via file_with_bytes. If the file is large, the agent should read the content as appropriate directly from the file_with_uri source.
              &quot;fileWithBytes&quot;: &quot;A String&quot;,
              &quot;fileWithUri&quot;: &quot;A String&quot;,
              &quot;mimeType&quot;: &quot;A String&quot;,
              &quot;name&quot;: &quot;A String&quot;,
            },
            &quot;metadata&quot;: { # Optional metadata associated with this part.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;text&quot;: &quot;A String&quot;,
          },
        ],
      },
    ],
    &quot;contextId&quot;: &quot;A String&quot;, # Unique identifier (e.g. UUID) for the contextual collection of interactions (tasks and messages). Created by the A2A server.
    &quot;history&quot;: [ # protolint:disable REPEATED_FIELD_NAMES_PLURALIZED The history of interactions from a task.
      { # Message is one unit of communication between client and server. It is associated with a context and optionally a task. Since the server is responsible for the context definition, it must always provide a context_id in its messages. The client can optionally provide the context_id if it knows the context to associate the message to. Similarly for task_id, except the server decides if a task is created and whether to include the task_id.
        &quot;content&quot;: [ # protolint:disable REPEATED_FIELD_NAMES_PLURALIZED Content is the container of the message content.
          { # Part represents a container for a section of communication content. Parts can be purely textual, some sort of file (image, video, etc) or a structured data blob (i.e. JSON).
            &quot;data&quot;: { # DataPart represents a structured blob. This is most commonly a JSON payload.
              &quot;data&quot;: {
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;file&quot;: { # FilePart represents the different ways files can be provided. If files are small, directly feeding the bytes is supported via file_with_bytes. If the file is large, the agent should read the content as appropriate directly from the file_with_uri source.
              &quot;fileWithBytes&quot;: &quot;A String&quot;,
              &quot;fileWithUri&quot;: &quot;A String&quot;,
              &quot;mimeType&quot;: &quot;A String&quot;,
              &quot;name&quot;: &quot;A String&quot;,
            },
            &quot;metadata&quot;: { # Optional metadata associated with this part.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;text&quot;: &quot;A String&quot;,
          },
        ],
        &quot;contextId&quot;: &quot;A String&quot;, # The context id of the message. This is optional and if set, the message will be associated with the given context.
        &quot;extensions&quot;: [ # The URIs of extensions that are present or contributed to this Message.
          &quot;A String&quot;,
        ],
        &quot;messageId&quot;: &quot;A String&quot;, # The unique identifier (e.g. UUID)of the message. This is required and created by the message creator.
        &quot;metadata&quot;: { # protolint:enable REPEATED_FIELD_NAMES_PLURALIZED Any optional metadata to provide along with the message.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;role&quot;: &quot;A String&quot;, # A role for the message.
        &quot;taskId&quot;: &quot;A String&quot;, # The task id of the message. This is optional and if set, the message will be associated with the given task.
      },
    ],
    &quot;id&quot;: &quot;A String&quot;, # Unique identifier (e.g. UUID) for the task, generated by the server for a new task.
    &quot;metadata&quot;: { # protolint:enable REPEATED_FIELD_NAMES_PLURALIZED A key/value object to store custom metadata about a task.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;status&quot;: { # A container for the status of a task # The current status of a Task, including state and a message.
      &quot;message&quot;: { # Message is one unit of communication between client and server. It is associated with a context and optionally a task. Since the server is responsible for the context definition, it must always provide a context_id in its messages. The client can optionally provide the context_id if it knows the context to associate the message to. Similarly for task_id, except the server decides if a task is created and whether to include the task_id. # A message associated with the status.
        &quot;content&quot;: [ # protolint:disable REPEATED_FIELD_NAMES_PLURALIZED Content is the container of the message content.
          { # Part represents a container for a section of communication content. Parts can be purely textual, some sort of file (image, video, etc) or a structured data blob (i.e. JSON).
            &quot;data&quot;: { # DataPart represents a structured blob. This is most commonly a JSON payload.
              &quot;data&quot;: {
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;file&quot;: { # FilePart represents the different ways files can be provided. If files are small, directly feeding the bytes is supported via file_with_bytes. If the file is large, the agent should read the content as appropriate directly from the file_with_uri source.
              &quot;fileWithBytes&quot;: &quot;A String&quot;,
              &quot;fileWithUri&quot;: &quot;A String&quot;,
              &quot;mimeType&quot;: &quot;A String&quot;,
              &quot;name&quot;: &quot;A String&quot;,
            },
            &quot;metadata&quot;: { # Optional metadata associated with this part.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;text&quot;: &quot;A String&quot;,
          },
        ],
        &quot;contextId&quot;: &quot;A String&quot;, # The context id of the message. This is optional and if set, the message will be associated with the given context.
        &quot;extensions&quot;: [ # The URIs of extensions that are present or contributed to this Message.
          &quot;A String&quot;,
        ],
        &quot;messageId&quot;: &quot;A String&quot;, # The unique identifier (e.g. UUID)of the message. This is required and created by the message creator.
        &quot;metadata&quot;: { # protolint:enable REPEATED_FIELD_NAMES_PLURALIZED Any optional metadata to provide along with the message.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;role&quot;: &quot;A String&quot;, # A role for the message.
        &quot;taskId&quot;: &quot;A String&quot;, # The task id of the message. This is optional and if set, the message will be associated with the given task.
      },
      &quot;state&quot;: &quot;A String&quot;, # The current state of this task
      &quot;timestamp&quot;: &quot;A String&quot;, # Timestamp when the status was recorded. Example: &quot;2023-10-27T10:00:00Z&quot;
    },
  },
}</pre>
</div>

</body></html>