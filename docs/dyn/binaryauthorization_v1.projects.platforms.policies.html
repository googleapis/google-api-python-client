<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="binaryauthorization_v1.html">Binary Authorization API</a> . <a href="binaryauthorization_v1.projects.html">projects</a> . <a href="binaryauthorization_v1.projects.platforms.html">platforms</a> . <a href="binaryauthorization_v1.projects.platforms.policies.html">policies</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#create">create(parent, body=None, policyId=None, x__xgafv=None)</a></code></p>
<p class="firstline">Creates a platform policy, and returns a copy of it. Returns `NOT_FOUND` if the project or platform doesn't exist, `INVALID_ARGUMENT` if the request is malformed, `ALREADY_EXISTS` if the policy already exists, and `INVALID_ARGUMENT` if the policy contains a platform-specific policy that does not match the platform value specified in the URL.</p>
<p class="toc_element">
  <code><a href="#delete">delete(name, etag=None, x__xgafv=None)</a></code></p>
<p class="firstline">Deletes a platform policy. Returns `NOT_FOUND` if the policy doesn't exist.</p>
<p class="toc_element">
  <code><a href="#get">get(name, x__xgafv=None)</a></code></p>
<p class="firstline">Gets a platform policy. Returns `NOT_FOUND` if the policy doesn't exist.</p>
<p class="toc_element">
  <code><a href="#list">list(parent, pageSize=None, pageToken=None, x__xgafv=None)</a></code></p>
<p class="firstline">Lists platform policies owned by a project in the specified platform. Returns `INVALID_ARGUMENT` if the project or the platform doesn't exist.</p>
<p class="toc_element">
  <code><a href="#list_next">list_next()</a></code></p>
<p class="firstline">Retrieves the next page of results.</p>
<p class="toc_element">
  <code><a href="#replacePlatformPolicy">replacePlatformPolicy(name, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Replaces a platform policy. Returns `NOT_FOUND` if the policy doesn't exist.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="create">create(parent, body=None, policyId=None, x__xgafv=None)</code>
  <pre>Creates a platform policy, and returns a copy of it. Returns `NOT_FOUND` if the project or platform doesn&#x27;t exist, `INVALID_ARGUMENT` if the request is malformed, `ALREADY_EXISTS` if the policy already exists, and `INVALID_ARGUMENT` if the policy contains a platform-specific policy that does not match the platform value specified in the URL.

Args:
  parent: string, Required. The parent of this platform policy. (required)
  body: object, The request body.
    The object takes the form of:

{ # A Binary Authorization platform policy for deployments on various platforms.
  &quot;description&quot;: &quot;A String&quot;, # Optional. A description comment about the policy.
  &quot;etag&quot;: &quot;A String&quot;, # Optional. Used to prevent updating the policy when another request has updated it since it was retrieved.
  &quot;gkePolicy&quot;: { # A Binary Authorization policy for a GKE cluster. This is one type of policy that can occur as a `PlatformPolicy`. # Optional. GKE platform-specific policy.
    &quot;checkSets&quot;: [ # Optional. The `CheckSet` objects to apply, scoped by namespace or namespace and service account. Exactly one `CheckSet` will be evaluated for a given Pod (unless the list is empty, in which case the behavior is &quot;always allow&quot;). If multiple `CheckSet` objects have scopes that match the namespace and service account of the Pod being evaluated, only the `CheckSet` with the MOST SPECIFIC scope will match. `CheckSet` objects must be listed in order of decreasing specificity, i.e. if a scope matches a given service account (which must include the namespace), it must come before a `CheckSet` with a scope matching just that namespace. This property is enforced by server-side validation. The purpose of this restriction is to ensure that if more than one `CheckSet` matches a given Pod, the `CheckSet` that will be evaluated will always be the first in the list to match (because if any other matches, it must be less specific). If `check_sets` is empty, the default behavior is to allow all images. If `check_sets` is non-empty, the last `check_sets` entry must always be a `CheckSet` with no scope set, i.e. a catchall to handle any situation not caught by the preceding `CheckSet` objects.
      { # A conjunction of policy checks, scoped to a particular namespace or Kubernetes service account. In order for evaluation of a `CheckSet` to return &quot;allowed&quot; for a given image in a given Pod, one of the following conditions must be satisfied: * The image is explicitly exempted by an entry in `image_allowlist`, OR * ALL of the `checks` evaluate to &quot;allowed&quot;.
        &quot;checks&quot;: [ # Optional. The checks to apply. The ultimate result of evaluating the check set will be &quot;allow&quot; if and only if every check in `checks` evaluates to &quot;allow&quot;. If `checks` is empty, the default behavior is &quot;always allow&quot;.
          { # A single check to perform against a Pod. Checks are grouped into `CheckSet` objects, which are defined by the top-level policy.
            &quot;alwaysDeny&quot;: True or False, # Optional. A special-case check that always denies. Note that this still only applies when the scope of the `CheckSet` applies and the image isn&#x27;t exempted by an image allowlist. This check is primarily useful for testing, or to set the default behavior for all unmatched scopes to &quot;deny&quot;.
            &quot;displayName&quot;: &quot;A String&quot;, # Optional. A user-provided name for this check. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
            &quot;imageAllowlist&quot;: { # Images that are exempted from normal checks based on name pattern only. # Optional. Images exempted from this check. If any of the patterns match the image url, the check will not be evaluated.
              &quot;allowPattern&quot;: [ # Required. A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
                &quot;A String&quot;,
              ],
            },
            &quot;imageFreshnessCheck&quot;: { # An image freshness check, which rejects images that were uploaded before the set number of days ago to the supported repositories. # Optional. Require that an image is no older than a configured expiration time. Image age is determined by its upload time.
              &quot;maxUploadAgeDays&quot;: 42, # Required. The max number of days that is allowed since the image was uploaded. Must be greater than zero.
            },
            &quot;sigstoreSignatureCheck&quot;: { # A Sigstore signature check, which verifies the Sigstore signature associated with an image. # Optional. Require that an image was signed by Cosign with a trusted key. This check requires that both the image and signature are stored in Artifact Registry.
              &quot;sigstoreAuthorities&quot;: [ # Required. The authorities required by this check to verify the signature. A signature only needs to be verified by one authority to pass the check.
                { # A Sigstore authority, used to verify signatures that are created by Sigstore. An authority is analogous to an attestation authenticator, verifying that a signature is valid or invalid.
                  &quot;displayName&quot;: &quot;A String&quot;, # Optional. A user-provided name for this `SigstoreAuthority`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
                  &quot;publicKeySet&quot;: { # A bundle of Sigstore public keys, used to verify Sigstore signatures. A signature is authenticated by a `SigstorePublicKeySet` if any of the keys verify it. # Required. A simple set of public keys. A signature is considered valid if any keys in the set validate the signature.
                    &quot;publicKeys&quot;: [ # Required. `public_keys` must have at least one entry.
                      { # A Sigstore public key. `SigstorePublicKey` is the public key material used to authenticate Sigstore signatures.
                        &quot;publicKeyPem&quot;: &quot;A String&quot;, # The public key material in PEM format.
                      },
                    ],
                  },
                },
              ],
            },
            &quot;simpleSigningAttestationCheck&quot;: { # Require a signed [DSSE](https://github.com/secure-systems-lab/dsse) attestation with type SimpleSigning. # Optional. Require a SimpleSigning-type attestation for every image in the deployment.
              &quot;attestationAuthenticators&quot;: [ # Required. The authenticators required by this check to verify an attestation. Typically this is one or more PKIX public keys for signature verification. Only one authenticator needs to consider an attestation verified in order for an attestation to be considered fully authenticated. In otherwords, this list of authenticators is an &quot;OR&quot; of the authenticator results. At least one authenticator is required.
                { # An attestation authenticator that will be used to verify attestations. Typically this is just a set of public keys. Conceptually, an authenticator can be treated as always returning either &quot;authenticated&quot; or &quot;not authenticated&quot; when presented with a signed attestation (almost always assumed to be a [DSSE](https://github.com/secure-systems-lab/dsse) attestation). The details of how an authenticator makes this decision are specific to the type of &#x27;authenticator&#x27; that this message wraps.
                  &quot;displayName&quot;: &quot;A String&quot;, # Optional. A user-provided name for this `AttestationAuthenticator`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
                  &quot;pkixPublicKeySet&quot;: { # A bundle of PKIX public keys, used to authenticate attestation signatures. Generally, a signature is considered to be authenticated by a `PkixPublicKeySet` if any of the public keys verify it (i.e. it is an &quot;OR&quot; of the keys). # Optional. A set of raw PKIX SubjectPublicKeyInfo format public keys. If any public key in the set validates the attestation signature, then the signature is considered authenticated (i.e. any one key is sufficient to authenticate).
                    &quot;pkixPublicKeys&quot;: [ # Required. `pkix_public_keys` must have at least one entry.
                      { # A public key in the PkixPublicKey [format](https://tools.ietf.org/html/rfc5280#section-4.1.2.7). Public keys of this type are typically textually encoded using the PEM format.
                        &quot;keyId&quot;: &quot;A String&quot;, # Optional. The ID of this public key. Signatures verified by Binary Authorization must include the ID of the public key that can be used to verify them. The ID must match exactly contents of the `key_id` field exactly. The ID may be explicitly provided by the caller, but it MUST be a valid RFC3986 URI. If `key_id` is left blank and this `PkixPublicKey` is not used in the context of a wrapper (see next paragraph), a default key ID will be computed based on the digest of the DER encoding of the public key. If this `PkixPublicKey` is used in the context of a wrapper that has its own notion of key ID (e.g. `AttestorPublicKey`), then this field can either match that value exactly, or be left blank, in which case it behaves exactly as though it is equal to that wrapper value.
                        &quot;publicKeyPem&quot;: &quot;A String&quot;, # A PEM-encoded public key, as described in https://tools.ietf.org/html/rfc7468#section-13
                        &quot;signatureAlgorithm&quot;: &quot;A String&quot;, # The signature algorithm used to verify a message against a signature using this key. These signature algorithm must match the structure and any object identifiers encoded in `public_key_pem` (i.e. this algorithm must match that of the public key).
                      },
                    ],
                  },
                },
              ],
              &quot;containerAnalysisAttestationProjects&quot;: [ # Optional. The projects where attestations are stored as Container Analysis Occurrences, in the format `projects/[PROJECT_ID]`. Only one attestation needs to successfully verify an image for this check to pass, so a single verified attestation found in any of `container_analysis_attestation_projects` is sufficient for the check to pass. A project ID must be used, not a project number. When fetching Occurrences from Container Analysis, only `AttestationOccurrence` kinds are considered. In the future, additional Occurrence kinds may be added to the query. Maximum number of `container_analysis_attestation_projects` allowed in each `SimpleSigningAttestationCheck` is 10.
                &quot;A String&quot;,
              ],
            },
            &quot;slsaCheck&quot;: { # A SLSA provenance attestation check, which ensures that images are built by a trusted builder using source code from its trusted repositories only. # Optional. Require that an image was built by a trusted builder (such as Google Cloud Build), meets requirements for Supply chain Levels for Software Artifacts (SLSA), and was built from a trusted source code repostitory.
              &quot;rules&quot;: [ # Specifies a list of verification rules for the SLSA attestations. An image is considered compliant with the SlsaCheck if any of the rules are satisfied.
                { # Specifies verification rules for evaluating the SLSA attestations including: which builders to trust, where to fetch the SLSA attestations generated by those builders, and other builder-specific evaluation rules such as which source repositories are trusted. An image is considered verified by the rule if any of the fetched SLSA attestations is verified.
                  &quot;attestationSource&quot;: { # Specifies the locations for fetching the provenance attestations. # Specifies where to fetch the provenances attestations generated by the builder (group).
                    &quot;containerAnalysisAttestationProjects&quot;: [ # The IDs of the Google Cloud projects that store the SLSA attestations as Container Analysis Occurrences, in the format `projects/[PROJECT_ID]`. Maximum number of `container_analysis_attestation_projects` allowed in each `AttestationSource` is 10.
                      &quot;A String&quot;,
                    ],
                  },
                  &quot;configBasedBuildRequired&quot;: True or False, # If true, require the image to be built from a top-level configuration. `trusted_source_repo_patterns` specifies the repositories containing this configuration.
                  &quot;trustedBuilder&quot;: &quot;A String&quot;, # Each verification rule is used for evaluation against provenances generated by a specific builder (group). For some of the builders, such as the Google Cloud Build, users don&#x27;t need to explicitly specify their roots of trust in the policy since the evaluation service can automatically fetch them based on the builder (group).
                  &quot;trustedSourceRepoPatterns&quot;: [ # List of trusted source code repository URL patterns. These patterns match the full repository URL without its scheme (e.g. `https://`). The patterns must not include schemes. For example, the pattern `source.cloud.google.com/my-project/my-repo-name` matches the following URLs: - `source.cloud.google.com/my-project/my-repo-name` - `git+ssh://source.cloud.google.com/my-project/my-repo-name` - `https://source.cloud.google.com/my-project/my-repo-name` A pattern matches a URL either exactly or with `*` wildcards. `*` can be used in only two ways: 1. trailing `*` after hosturi/ to match varying endings; 2. trailing `**` after hosturi/ to match `/` as well. `*` and `**` can only be used as wildcards and can only occur at the end of the pattern after a `/`. (So it&#x27;s not possible to match a URL that contains literal `*`.) For example: - `github.com/my-project/my-repo` is valid to match a single repo - `github.com/my-project/*` will match all direct repos in `my-project` - `github.com/**` matches all repos in GitHub
                    &quot;A String&quot;,
                  ],
                },
              ],
            },
            &quot;trustedDirectoryCheck&quot;: { # A trusted directory check, which rejects images that do not come from the set of user-configured trusted directories. # Optional. Require that an image lives in a trusted directory.
              &quot;trustedDirPatterns&quot;: [ # Required. List of trusted directory patterns. A pattern is in the form &quot;registry/path/to/directory&quot;. The registry domain part is defined as two or more dot-separated words, e.g., `us.pkg.dev`, or `gcr.io`. Additionally, `*` can be used in three ways as wildcards: 1. leading `*` to match varying prefixes in registry subdomain (useful for location prefixes); 2. trailing `*` after registry/ to match varying endings; 3. trailing `**` after registry/ to match &quot;/&quot; as well. For example: -- `gcr.io/my-project/my-repo` is valid to match a single directory -- `*-docker.pkg.dev/my-project/my-repo` or `*.gcr.io/my-project` are valid to match varying prefixes -- `gcr.io/my-project/*` will match all direct directories in `my-project` -- `gcr.io/my-project/**` would match all directories in `my-project` -- `gcr.i*` is not allowed since the registry is not completely specified -- `sub*domain.gcr.io/nginx` is not valid because only leading `*` or trailing `*` are allowed. -- `*pkg.dev/my-project/my-repo` is not valid because leading `*` can only match subdomain -- `**-docker.pkg.dev` is not valid because one leading `*` is allowed, and that it cannot match `/`
                &quot;A String&quot;,
              ],
            },
            &quot;vulnerabilityCheck&quot;: { # An image vulnerability check, which rejects images that violate the configured vulnerability rules. # Optional. Require that an image does not contain vulnerabilities that violate the configured rules, such as based on severity levels.
              &quot;allowedCves&quot;: [ # Optional. A list of specific CVEs to ignore even if the vulnerability level violates `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will allow vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
                &quot;A String&quot;,
              ],
              &quot;blockedCves&quot;: [ # Optional. A list of specific CVEs to always raise warnings about even if the vulnerability level meets `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will block vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
                &quot;A String&quot;,
              ],
              &quot;containerAnalysisVulnerabilityProjects&quot;: [ # Optional. The projects where vulnerabilities are stored as Container Analysis Occurrences. Each project is expressed in the resource format of `projects/[PROJECT_ID]`, e.g., `projects/my-gcp-project`. An attempt will be made for each project to fetch vulnerabilities, and all valid vulnerabilities will be used to check against the vulnerability policy. If no valid scan is found in all projects configured here, an error will be returned for the check. Maximum number of `container_analysis_vulnerability_projects` allowed in each `VulnerabilityCheck` is 10.
                &quot;A String&quot;,
              ],
              &quot;maximumFixableSeverity&quot;: &quot;A String&quot;, # Required. The threshold for severity for which a fix is currently available. This field is required and must be set.
              &quot;maximumUnfixableSeverity&quot;: &quot;A String&quot;, # Required. The threshold for severity for which a fix isn&#x27;t currently available. This field is required and must be set.
            },
          },
        ],
        &quot;displayName&quot;: &quot;A String&quot;, # Optional. A user-provided name for this `CheckSet`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
        &quot;imageAllowlist&quot;: { # Images that are exempted from normal checks based on name pattern only. # Optional. Images exempted from this `CheckSet`. If any of the patterns match the image being evaluated, no checks in the `CheckSet` will be evaluated.
          &quot;allowPattern&quot;: [ # Required. A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
            &quot;A String&quot;,
          ],
        },
        &quot;scope&quot;: { # A scope specifier for `CheckSet` objects. # Optional. The scope to which this `CheckSet` applies. If unset or an empty string (the default), applies to all namespaces and service accounts. See the `Scope` message documentation for details on scoping rules.
          &quot;kubernetesNamespace&quot;: &quot;A String&quot;, # Optional. Matches all Kubernetes service accounts in the provided namespace, unless a more specific `kubernetes_service_account` scope already matched.
          &quot;kubernetesServiceAccount&quot;: &quot;A String&quot;, # Optional. Matches a single Kubernetes service account, e.g. `my-namespace:my-service-account`. `kubernetes_service_account` scope is always more specific than `kubernetes_namespace` scope for the same namespace.
        },
      },
    ],
    &quot;imageAllowlist&quot;: { # Images that are exempted from normal checks based on name pattern only. # Optional. Images exempted from this policy. If any of the patterns match the image being evaluated, the rest of the policy will not be evaluated.
      &quot;allowPattern&quot;: [ # Required. A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
        &quot;A String&quot;,
      ],
    },
  },
  &quot;name&quot;: &quot;A String&quot;, # Output only. The relative resource name of the Binary Authorization platform policy, in the form of `projects/*/platforms/*/policies/*`.
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Time when the policy was last updated.
}

  policyId: string, Required. The platform policy ID.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A Binary Authorization platform policy for deployments on various platforms.
  &quot;description&quot;: &quot;A String&quot;, # Optional. A description comment about the policy.
  &quot;etag&quot;: &quot;A String&quot;, # Optional. Used to prevent updating the policy when another request has updated it since it was retrieved.
  &quot;gkePolicy&quot;: { # A Binary Authorization policy for a GKE cluster. This is one type of policy that can occur as a `PlatformPolicy`. # Optional. GKE platform-specific policy.
    &quot;checkSets&quot;: [ # Optional. The `CheckSet` objects to apply, scoped by namespace or namespace and service account. Exactly one `CheckSet` will be evaluated for a given Pod (unless the list is empty, in which case the behavior is &quot;always allow&quot;). If multiple `CheckSet` objects have scopes that match the namespace and service account of the Pod being evaluated, only the `CheckSet` with the MOST SPECIFIC scope will match. `CheckSet` objects must be listed in order of decreasing specificity, i.e. if a scope matches a given service account (which must include the namespace), it must come before a `CheckSet` with a scope matching just that namespace. This property is enforced by server-side validation. The purpose of this restriction is to ensure that if more than one `CheckSet` matches a given Pod, the `CheckSet` that will be evaluated will always be the first in the list to match (because if any other matches, it must be less specific). If `check_sets` is empty, the default behavior is to allow all images. If `check_sets` is non-empty, the last `check_sets` entry must always be a `CheckSet` with no scope set, i.e. a catchall to handle any situation not caught by the preceding `CheckSet` objects.
      { # A conjunction of policy checks, scoped to a particular namespace or Kubernetes service account. In order for evaluation of a `CheckSet` to return &quot;allowed&quot; for a given image in a given Pod, one of the following conditions must be satisfied: * The image is explicitly exempted by an entry in `image_allowlist`, OR * ALL of the `checks` evaluate to &quot;allowed&quot;.
        &quot;checks&quot;: [ # Optional. The checks to apply. The ultimate result of evaluating the check set will be &quot;allow&quot; if and only if every check in `checks` evaluates to &quot;allow&quot;. If `checks` is empty, the default behavior is &quot;always allow&quot;.
          { # A single check to perform against a Pod. Checks are grouped into `CheckSet` objects, which are defined by the top-level policy.
            &quot;alwaysDeny&quot;: True or False, # Optional. A special-case check that always denies. Note that this still only applies when the scope of the `CheckSet` applies and the image isn&#x27;t exempted by an image allowlist. This check is primarily useful for testing, or to set the default behavior for all unmatched scopes to &quot;deny&quot;.
            &quot;displayName&quot;: &quot;A String&quot;, # Optional. A user-provided name for this check. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
            &quot;imageAllowlist&quot;: { # Images that are exempted from normal checks based on name pattern only. # Optional. Images exempted from this check. If any of the patterns match the image url, the check will not be evaluated.
              &quot;allowPattern&quot;: [ # Required. A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
                &quot;A String&quot;,
              ],
            },
            &quot;imageFreshnessCheck&quot;: { # An image freshness check, which rejects images that were uploaded before the set number of days ago to the supported repositories. # Optional. Require that an image is no older than a configured expiration time. Image age is determined by its upload time.
              &quot;maxUploadAgeDays&quot;: 42, # Required. The max number of days that is allowed since the image was uploaded. Must be greater than zero.
            },
            &quot;sigstoreSignatureCheck&quot;: { # A Sigstore signature check, which verifies the Sigstore signature associated with an image. # Optional. Require that an image was signed by Cosign with a trusted key. This check requires that both the image and signature are stored in Artifact Registry.
              &quot;sigstoreAuthorities&quot;: [ # Required. The authorities required by this check to verify the signature. A signature only needs to be verified by one authority to pass the check.
                { # A Sigstore authority, used to verify signatures that are created by Sigstore. An authority is analogous to an attestation authenticator, verifying that a signature is valid or invalid.
                  &quot;displayName&quot;: &quot;A String&quot;, # Optional. A user-provided name for this `SigstoreAuthority`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
                  &quot;publicKeySet&quot;: { # A bundle of Sigstore public keys, used to verify Sigstore signatures. A signature is authenticated by a `SigstorePublicKeySet` if any of the keys verify it. # Required. A simple set of public keys. A signature is considered valid if any keys in the set validate the signature.
                    &quot;publicKeys&quot;: [ # Required. `public_keys` must have at least one entry.
                      { # A Sigstore public key. `SigstorePublicKey` is the public key material used to authenticate Sigstore signatures.
                        &quot;publicKeyPem&quot;: &quot;A String&quot;, # The public key material in PEM format.
                      },
                    ],
                  },
                },
              ],
            },
            &quot;simpleSigningAttestationCheck&quot;: { # Require a signed [DSSE](https://github.com/secure-systems-lab/dsse) attestation with type SimpleSigning. # Optional. Require a SimpleSigning-type attestation for every image in the deployment.
              &quot;attestationAuthenticators&quot;: [ # Required. The authenticators required by this check to verify an attestation. Typically this is one or more PKIX public keys for signature verification. Only one authenticator needs to consider an attestation verified in order for an attestation to be considered fully authenticated. In otherwords, this list of authenticators is an &quot;OR&quot; of the authenticator results. At least one authenticator is required.
                { # An attestation authenticator that will be used to verify attestations. Typically this is just a set of public keys. Conceptually, an authenticator can be treated as always returning either &quot;authenticated&quot; or &quot;not authenticated&quot; when presented with a signed attestation (almost always assumed to be a [DSSE](https://github.com/secure-systems-lab/dsse) attestation). The details of how an authenticator makes this decision are specific to the type of &#x27;authenticator&#x27; that this message wraps.
                  &quot;displayName&quot;: &quot;A String&quot;, # Optional. A user-provided name for this `AttestationAuthenticator`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
                  &quot;pkixPublicKeySet&quot;: { # A bundle of PKIX public keys, used to authenticate attestation signatures. Generally, a signature is considered to be authenticated by a `PkixPublicKeySet` if any of the public keys verify it (i.e. it is an &quot;OR&quot; of the keys). # Optional. A set of raw PKIX SubjectPublicKeyInfo format public keys. If any public key in the set validates the attestation signature, then the signature is considered authenticated (i.e. any one key is sufficient to authenticate).
                    &quot;pkixPublicKeys&quot;: [ # Required. `pkix_public_keys` must have at least one entry.
                      { # A public key in the PkixPublicKey [format](https://tools.ietf.org/html/rfc5280#section-4.1.2.7). Public keys of this type are typically textually encoded using the PEM format.
                        &quot;keyId&quot;: &quot;A String&quot;, # Optional. The ID of this public key. Signatures verified by Binary Authorization must include the ID of the public key that can be used to verify them. The ID must match exactly contents of the `key_id` field exactly. The ID may be explicitly provided by the caller, but it MUST be a valid RFC3986 URI. If `key_id` is left blank and this `PkixPublicKey` is not used in the context of a wrapper (see next paragraph), a default key ID will be computed based on the digest of the DER encoding of the public key. If this `PkixPublicKey` is used in the context of a wrapper that has its own notion of key ID (e.g. `AttestorPublicKey`), then this field can either match that value exactly, or be left blank, in which case it behaves exactly as though it is equal to that wrapper value.
                        &quot;publicKeyPem&quot;: &quot;A String&quot;, # A PEM-encoded public key, as described in https://tools.ietf.org/html/rfc7468#section-13
                        &quot;signatureAlgorithm&quot;: &quot;A String&quot;, # The signature algorithm used to verify a message against a signature using this key. These signature algorithm must match the structure and any object identifiers encoded in `public_key_pem` (i.e. this algorithm must match that of the public key).
                      },
                    ],
                  },
                },
              ],
              &quot;containerAnalysisAttestationProjects&quot;: [ # Optional. The projects where attestations are stored as Container Analysis Occurrences, in the format `projects/[PROJECT_ID]`. Only one attestation needs to successfully verify an image for this check to pass, so a single verified attestation found in any of `container_analysis_attestation_projects` is sufficient for the check to pass. A project ID must be used, not a project number. When fetching Occurrences from Container Analysis, only `AttestationOccurrence` kinds are considered. In the future, additional Occurrence kinds may be added to the query. Maximum number of `container_analysis_attestation_projects` allowed in each `SimpleSigningAttestationCheck` is 10.
                &quot;A String&quot;,
              ],
            },
            &quot;slsaCheck&quot;: { # A SLSA provenance attestation check, which ensures that images are built by a trusted builder using source code from its trusted repositories only. # Optional. Require that an image was built by a trusted builder (such as Google Cloud Build), meets requirements for Supply chain Levels for Software Artifacts (SLSA), and was built from a trusted source code repostitory.
              &quot;rules&quot;: [ # Specifies a list of verification rules for the SLSA attestations. An image is considered compliant with the SlsaCheck if any of the rules are satisfied.
                { # Specifies verification rules for evaluating the SLSA attestations including: which builders to trust, where to fetch the SLSA attestations generated by those builders, and other builder-specific evaluation rules such as which source repositories are trusted. An image is considered verified by the rule if any of the fetched SLSA attestations is verified.
                  &quot;attestationSource&quot;: { # Specifies the locations for fetching the provenance attestations. # Specifies where to fetch the provenances attestations generated by the builder (group).
                    &quot;containerAnalysisAttestationProjects&quot;: [ # The IDs of the Google Cloud projects that store the SLSA attestations as Container Analysis Occurrences, in the format `projects/[PROJECT_ID]`. Maximum number of `container_analysis_attestation_projects` allowed in each `AttestationSource` is 10.
                      &quot;A String&quot;,
                    ],
                  },
                  &quot;configBasedBuildRequired&quot;: True or False, # If true, require the image to be built from a top-level configuration. `trusted_source_repo_patterns` specifies the repositories containing this configuration.
                  &quot;trustedBuilder&quot;: &quot;A String&quot;, # Each verification rule is used for evaluation against provenances generated by a specific builder (group). For some of the builders, such as the Google Cloud Build, users don&#x27;t need to explicitly specify their roots of trust in the policy since the evaluation service can automatically fetch them based on the builder (group).
                  &quot;trustedSourceRepoPatterns&quot;: [ # List of trusted source code repository URL patterns. These patterns match the full repository URL without its scheme (e.g. `https://`). The patterns must not include schemes. For example, the pattern `source.cloud.google.com/my-project/my-repo-name` matches the following URLs: - `source.cloud.google.com/my-project/my-repo-name` - `git+ssh://source.cloud.google.com/my-project/my-repo-name` - `https://source.cloud.google.com/my-project/my-repo-name` A pattern matches a URL either exactly or with `*` wildcards. `*` can be used in only two ways: 1. trailing `*` after hosturi/ to match varying endings; 2. trailing `**` after hosturi/ to match `/` as well. `*` and `**` can only be used as wildcards and can only occur at the end of the pattern after a `/`. (So it&#x27;s not possible to match a URL that contains literal `*`.) For example: - `github.com/my-project/my-repo` is valid to match a single repo - `github.com/my-project/*` will match all direct repos in `my-project` - `github.com/**` matches all repos in GitHub
                    &quot;A String&quot;,
                  ],
                },
              ],
            },
            &quot;trustedDirectoryCheck&quot;: { # A trusted directory check, which rejects images that do not come from the set of user-configured trusted directories. # Optional. Require that an image lives in a trusted directory.
              &quot;trustedDirPatterns&quot;: [ # Required. List of trusted directory patterns. A pattern is in the form &quot;registry/path/to/directory&quot;. The registry domain part is defined as two or more dot-separated words, e.g., `us.pkg.dev`, or `gcr.io`. Additionally, `*` can be used in three ways as wildcards: 1. leading `*` to match varying prefixes in registry subdomain (useful for location prefixes); 2. trailing `*` after registry/ to match varying endings; 3. trailing `**` after registry/ to match &quot;/&quot; as well. For example: -- `gcr.io/my-project/my-repo` is valid to match a single directory -- `*-docker.pkg.dev/my-project/my-repo` or `*.gcr.io/my-project` are valid to match varying prefixes -- `gcr.io/my-project/*` will match all direct directories in `my-project` -- `gcr.io/my-project/**` would match all directories in `my-project` -- `gcr.i*` is not allowed since the registry is not completely specified -- `sub*domain.gcr.io/nginx` is not valid because only leading `*` or trailing `*` are allowed. -- `*pkg.dev/my-project/my-repo` is not valid because leading `*` can only match subdomain -- `**-docker.pkg.dev` is not valid because one leading `*` is allowed, and that it cannot match `/`
                &quot;A String&quot;,
              ],
            },
            &quot;vulnerabilityCheck&quot;: { # An image vulnerability check, which rejects images that violate the configured vulnerability rules. # Optional. Require that an image does not contain vulnerabilities that violate the configured rules, such as based on severity levels.
              &quot;allowedCves&quot;: [ # Optional. A list of specific CVEs to ignore even if the vulnerability level violates `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will allow vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
                &quot;A String&quot;,
              ],
              &quot;blockedCves&quot;: [ # Optional. A list of specific CVEs to always raise warnings about even if the vulnerability level meets `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will block vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
                &quot;A String&quot;,
              ],
              &quot;containerAnalysisVulnerabilityProjects&quot;: [ # Optional. The projects where vulnerabilities are stored as Container Analysis Occurrences. Each project is expressed in the resource format of `projects/[PROJECT_ID]`, e.g., `projects/my-gcp-project`. An attempt will be made for each project to fetch vulnerabilities, and all valid vulnerabilities will be used to check against the vulnerability policy. If no valid scan is found in all projects configured here, an error will be returned for the check. Maximum number of `container_analysis_vulnerability_projects` allowed in each `VulnerabilityCheck` is 10.
                &quot;A String&quot;,
              ],
              &quot;maximumFixableSeverity&quot;: &quot;A String&quot;, # Required. The threshold for severity for which a fix is currently available. This field is required and must be set.
              &quot;maximumUnfixableSeverity&quot;: &quot;A String&quot;, # Required. The threshold for severity for which a fix isn&#x27;t currently available. This field is required and must be set.
            },
          },
        ],
        &quot;displayName&quot;: &quot;A String&quot;, # Optional. A user-provided name for this `CheckSet`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
        &quot;imageAllowlist&quot;: { # Images that are exempted from normal checks based on name pattern only. # Optional. Images exempted from this `CheckSet`. If any of the patterns match the image being evaluated, no checks in the `CheckSet` will be evaluated.
          &quot;allowPattern&quot;: [ # Required. A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
            &quot;A String&quot;,
          ],
        },
        &quot;scope&quot;: { # A scope specifier for `CheckSet` objects. # Optional. The scope to which this `CheckSet` applies. If unset or an empty string (the default), applies to all namespaces and service accounts. See the `Scope` message documentation for details on scoping rules.
          &quot;kubernetesNamespace&quot;: &quot;A String&quot;, # Optional. Matches all Kubernetes service accounts in the provided namespace, unless a more specific `kubernetes_service_account` scope already matched.
          &quot;kubernetesServiceAccount&quot;: &quot;A String&quot;, # Optional. Matches a single Kubernetes service account, e.g. `my-namespace:my-service-account`. `kubernetes_service_account` scope is always more specific than `kubernetes_namespace` scope for the same namespace.
        },
      },
    ],
    &quot;imageAllowlist&quot;: { # Images that are exempted from normal checks based on name pattern only. # Optional. Images exempted from this policy. If any of the patterns match the image being evaluated, the rest of the policy will not be evaluated.
      &quot;allowPattern&quot;: [ # Required. A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
        &quot;A String&quot;,
      ],
    },
  },
  &quot;name&quot;: &quot;A String&quot;, # Output only. The relative resource name of the Binary Authorization platform policy, in the form of `projects/*/platforms/*/policies/*`.
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Time when the policy was last updated.
}</pre>
</div>

<div class="method">
    <code class="details" id="delete">delete(name, etag=None, x__xgafv=None)</code>
  <pre>Deletes a platform policy. Returns `NOT_FOUND` if the policy doesn&#x27;t exist.

Args:
  name: string, Required. The name of the platform policy to delete, in the format `projects/*/platforms/*/policies/*`. (required)
  etag: string, Optional. Used to prevent deleting the policy when another request has updated it since it was retrieved.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
}</pre>
</div>

<div class="method">
    <code class="details" id="get">get(name, x__xgafv=None)</code>
  <pre>Gets a platform policy. Returns `NOT_FOUND` if the policy doesn&#x27;t exist.

Args:
  name: string, Required. The name of the platform policy to retrieve in the format `projects/*/platforms/*/policies/*`. (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A Binary Authorization platform policy for deployments on various platforms.
  &quot;description&quot;: &quot;A String&quot;, # Optional. A description comment about the policy.
  &quot;etag&quot;: &quot;A String&quot;, # Optional. Used to prevent updating the policy when another request has updated it since it was retrieved.
  &quot;gkePolicy&quot;: { # A Binary Authorization policy for a GKE cluster. This is one type of policy that can occur as a `PlatformPolicy`. # Optional. GKE platform-specific policy.
    &quot;checkSets&quot;: [ # Optional. The `CheckSet` objects to apply, scoped by namespace or namespace and service account. Exactly one `CheckSet` will be evaluated for a given Pod (unless the list is empty, in which case the behavior is &quot;always allow&quot;). If multiple `CheckSet` objects have scopes that match the namespace and service account of the Pod being evaluated, only the `CheckSet` with the MOST SPECIFIC scope will match. `CheckSet` objects must be listed in order of decreasing specificity, i.e. if a scope matches a given service account (which must include the namespace), it must come before a `CheckSet` with a scope matching just that namespace. This property is enforced by server-side validation. The purpose of this restriction is to ensure that if more than one `CheckSet` matches a given Pod, the `CheckSet` that will be evaluated will always be the first in the list to match (because if any other matches, it must be less specific). If `check_sets` is empty, the default behavior is to allow all images. If `check_sets` is non-empty, the last `check_sets` entry must always be a `CheckSet` with no scope set, i.e. a catchall to handle any situation not caught by the preceding `CheckSet` objects.
      { # A conjunction of policy checks, scoped to a particular namespace or Kubernetes service account. In order for evaluation of a `CheckSet` to return &quot;allowed&quot; for a given image in a given Pod, one of the following conditions must be satisfied: * The image is explicitly exempted by an entry in `image_allowlist`, OR * ALL of the `checks` evaluate to &quot;allowed&quot;.
        &quot;checks&quot;: [ # Optional. The checks to apply. The ultimate result of evaluating the check set will be &quot;allow&quot; if and only if every check in `checks` evaluates to &quot;allow&quot;. If `checks` is empty, the default behavior is &quot;always allow&quot;.
          { # A single check to perform against a Pod. Checks are grouped into `CheckSet` objects, which are defined by the top-level policy.
            &quot;alwaysDeny&quot;: True or False, # Optional. A special-case check that always denies. Note that this still only applies when the scope of the `CheckSet` applies and the image isn&#x27;t exempted by an image allowlist. This check is primarily useful for testing, or to set the default behavior for all unmatched scopes to &quot;deny&quot;.
            &quot;displayName&quot;: &quot;A String&quot;, # Optional. A user-provided name for this check. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
            &quot;imageAllowlist&quot;: { # Images that are exempted from normal checks based on name pattern only. # Optional. Images exempted from this check. If any of the patterns match the image url, the check will not be evaluated.
              &quot;allowPattern&quot;: [ # Required. A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
                &quot;A String&quot;,
              ],
            },
            &quot;imageFreshnessCheck&quot;: { # An image freshness check, which rejects images that were uploaded before the set number of days ago to the supported repositories. # Optional. Require that an image is no older than a configured expiration time. Image age is determined by its upload time.
              &quot;maxUploadAgeDays&quot;: 42, # Required. The max number of days that is allowed since the image was uploaded. Must be greater than zero.
            },
            &quot;sigstoreSignatureCheck&quot;: { # A Sigstore signature check, which verifies the Sigstore signature associated with an image. # Optional. Require that an image was signed by Cosign with a trusted key. This check requires that both the image and signature are stored in Artifact Registry.
              &quot;sigstoreAuthorities&quot;: [ # Required. The authorities required by this check to verify the signature. A signature only needs to be verified by one authority to pass the check.
                { # A Sigstore authority, used to verify signatures that are created by Sigstore. An authority is analogous to an attestation authenticator, verifying that a signature is valid or invalid.
                  &quot;displayName&quot;: &quot;A String&quot;, # Optional. A user-provided name for this `SigstoreAuthority`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
                  &quot;publicKeySet&quot;: { # A bundle of Sigstore public keys, used to verify Sigstore signatures. A signature is authenticated by a `SigstorePublicKeySet` if any of the keys verify it. # Required. A simple set of public keys. A signature is considered valid if any keys in the set validate the signature.
                    &quot;publicKeys&quot;: [ # Required. `public_keys` must have at least one entry.
                      { # A Sigstore public key. `SigstorePublicKey` is the public key material used to authenticate Sigstore signatures.
                        &quot;publicKeyPem&quot;: &quot;A String&quot;, # The public key material in PEM format.
                      },
                    ],
                  },
                },
              ],
            },
            &quot;simpleSigningAttestationCheck&quot;: { # Require a signed [DSSE](https://github.com/secure-systems-lab/dsse) attestation with type SimpleSigning. # Optional. Require a SimpleSigning-type attestation for every image in the deployment.
              &quot;attestationAuthenticators&quot;: [ # Required. The authenticators required by this check to verify an attestation. Typically this is one or more PKIX public keys for signature verification. Only one authenticator needs to consider an attestation verified in order for an attestation to be considered fully authenticated. In otherwords, this list of authenticators is an &quot;OR&quot; of the authenticator results. At least one authenticator is required.
                { # An attestation authenticator that will be used to verify attestations. Typically this is just a set of public keys. Conceptually, an authenticator can be treated as always returning either &quot;authenticated&quot; or &quot;not authenticated&quot; when presented with a signed attestation (almost always assumed to be a [DSSE](https://github.com/secure-systems-lab/dsse) attestation). The details of how an authenticator makes this decision are specific to the type of &#x27;authenticator&#x27; that this message wraps.
                  &quot;displayName&quot;: &quot;A String&quot;, # Optional. A user-provided name for this `AttestationAuthenticator`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
                  &quot;pkixPublicKeySet&quot;: { # A bundle of PKIX public keys, used to authenticate attestation signatures. Generally, a signature is considered to be authenticated by a `PkixPublicKeySet` if any of the public keys verify it (i.e. it is an &quot;OR&quot; of the keys). # Optional. A set of raw PKIX SubjectPublicKeyInfo format public keys. If any public key in the set validates the attestation signature, then the signature is considered authenticated (i.e. any one key is sufficient to authenticate).
                    &quot;pkixPublicKeys&quot;: [ # Required. `pkix_public_keys` must have at least one entry.
                      { # A public key in the PkixPublicKey [format](https://tools.ietf.org/html/rfc5280#section-4.1.2.7). Public keys of this type are typically textually encoded using the PEM format.
                        &quot;keyId&quot;: &quot;A String&quot;, # Optional. The ID of this public key. Signatures verified by Binary Authorization must include the ID of the public key that can be used to verify them. The ID must match exactly contents of the `key_id` field exactly. The ID may be explicitly provided by the caller, but it MUST be a valid RFC3986 URI. If `key_id` is left blank and this `PkixPublicKey` is not used in the context of a wrapper (see next paragraph), a default key ID will be computed based on the digest of the DER encoding of the public key. If this `PkixPublicKey` is used in the context of a wrapper that has its own notion of key ID (e.g. `AttestorPublicKey`), then this field can either match that value exactly, or be left blank, in which case it behaves exactly as though it is equal to that wrapper value.
                        &quot;publicKeyPem&quot;: &quot;A String&quot;, # A PEM-encoded public key, as described in https://tools.ietf.org/html/rfc7468#section-13
                        &quot;signatureAlgorithm&quot;: &quot;A String&quot;, # The signature algorithm used to verify a message against a signature using this key. These signature algorithm must match the structure and any object identifiers encoded in `public_key_pem` (i.e. this algorithm must match that of the public key).
                      },
                    ],
                  },
                },
              ],
              &quot;containerAnalysisAttestationProjects&quot;: [ # Optional. The projects where attestations are stored as Container Analysis Occurrences, in the format `projects/[PROJECT_ID]`. Only one attestation needs to successfully verify an image for this check to pass, so a single verified attestation found in any of `container_analysis_attestation_projects` is sufficient for the check to pass. A project ID must be used, not a project number. When fetching Occurrences from Container Analysis, only `AttestationOccurrence` kinds are considered. In the future, additional Occurrence kinds may be added to the query. Maximum number of `container_analysis_attestation_projects` allowed in each `SimpleSigningAttestationCheck` is 10.
                &quot;A String&quot;,
              ],
            },
            &quot;slsaCheck&quot;: { # A SLSA provenance attestation check, which ensures that images are built by a trusted builder using source code from its trusted repositories only. # Optional. Require that an image was built by a trusted builder (such as Google Cloud Build), meets requirements for Supply chain Levels for Software Artifacts (SLSA), and was built from a trusted source code repostitory.
              &quot;rules&quot;: [ # Specifies a list of verification rules for the SLSA attestations. An image is considered compliant with the SlsaCheck if any of the rules are satisfied.
                { # Specifies verification rules for evaluating the SLSA attestations including: which builders to trust, where to fetch the SLSA attestations generated by those builders, and other builder-specific evaluation rules such as which source repositories are trusted. An image is considered verified by the rule if any of the fetched SLSA attestations is verified.
                  &quot;attestationSource&quot;: { # Specifies the locations for fetching the provenance attestations. # Specifies where to fetch the provenances attestations generated by the builder (group).
                    &quot;containerAnalysisAttestationProjects&quot;: [ # The IDs of the Google Cloud projects that store the SLSA attestations as Container Analysis Occurrences, in the format `projects/[PROJECT_ID]`. Maximum number of `container_analysis_attestation_projects` allowed in each `AttestationSource` is 10.
                      &quot;A String&quot;,
                    ],
                  },
                  &quot;configBasedBuildRequired&quot;: True or False, # If true, require the image to be built from a top-level configuration. `trusted_source_repo_patterns` specifies the repositories containing this configuration.
                  &quot;trustedBuilder&quot;: &quot;A String&quot;, # Each verification rule is used for evaluation against provenances generated by a specific builder (group). For some of the builders, such as the Google Cloud Build, users don&#x27;t need to explicitly specify their roots of trust in the policy since the evaluation service can automatically fetch them based on the builder (group).
                  &quot;trustedSourceRepoPatterns&quot;: [ # List of trusted source code repository URL patterns. These patterns match the full repository URL without its scheme (e.g. `https://`). The patterns must not include schemes. For example, the pattern `source.cloud.google.com/my-project/my-repo-name` matches the following URLs: - `source.cloud.google.com/my-project/my-repo-name` - `git+ssh://source.cloud.google.com/my-project/my-repo-name` - `https://source.cloud.google.com/my-project/my-repo-name` A pattern matches a URL either exactly or with `*` wildcards. `*` can be used in only two ways: 1. trailing `*` after hosturi/ to match varying endings; 2. trailing `**` after hosturi/ to match `/` as well. `*` and `**` can only be used as wildcards and can only occur at the end of the pattern after a `/`. (So it&#x27;s not possible to match a URL that contains literal `*`.) For example: - `github.com/my-project/my-repo` is valid to match a single repo - `github.com/my-project/*` will match all direct repos in `my-project` - `github.com/**` matches all repos in GitHub
                    &quot;A String&quot;,
                  ],
                },
              ],
            },
            &quot;trustedDirectoryCheck&quot;: { # A trusted directory check, which rejects images that do not come from the set of user-configured trusted directories. # Optional. Require that an image lives in a trusted directory.
              &quot;trustedDirPatterns&quot;: [ # Required. List of trusted directory patterns. A pattern is in the form &quot;registry/path/to/directory&quot;. The registry domain part is defined as two or more dot-separated words, e.g., `us.pkg.dev`, or `gcr.io`. Additionally, `*` can be used in three ways as wildcards: 1. leading `*` to match varying prefixes in registry subdomain (useful for location prefixes); 2. trailing `*` after registry/ to match varying endings; 3. trailing `**` after registry/ to match &quot;/&quot; as well. For example: -- `gcr.io/my-project/my-repo` is valid to match a single directory -- `*-docker.pkg.dev/my-project/my-repo` or `*.gcr.io/my-project` are valid to match varying prefixes -- `gcr.io/my-project/*` will match all direct directories in `my-project` -- `gcr.io/my-project/**` would match all directories in `my-project` -- `gcr.i*` is not allowed since the registry is not completely specified -- `sub*domain.gcr.io/nginx` is not valid because only leading `*` or trailing `*` are allowed. -- `*pkg.dev/my-project/my-repo` is not valid because leading `*` can only match subdomain -- `**-docker.pkg.dev` is not valid because one leading `*` is allowed, and that it cannot match `/`
                &quot;A String&quot;,
              ],
            },
            &quot;vulnerabilityCheck&quot;: { # An image vulnerability check, which rejects images that violate the configured vulnerability rules. # Optional. Require that an image does not contain vulnerabilities that violate the configured rules, such as based on severity levels.
              &quot;allowedCves&quot;: [ # Optional. A list of specific CVEs to ignore even if the vulnerability level violates `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will allow vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
                &quot;A String&quot;,
              ],
              &quot;blockedCves&quot;: [ # Optional. A list of specific CVEs to always raise warnings about even if the vulnerability level meets `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will block vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
                &quot;A String&quot;,
              ],
              &quot;containerAnalysisVulnerabilityProjects&quot;: [ # Optional. The projects where vulnerabilities are stored as Container Analysis Occurrences. Each project is expressed in the resource format of `projects/[PROJECT_ID]`, e.g., `projects/my-gcp-project`. An attempt will be made for each project to fetch vulnerabilities, and all valid vulnerabilities will be used to check against the vulnerability policy. If no valid scan is found in all projects configured here, an error will be returned for the check. Maximum number of `container_analysis_vulnerability_projects` allowed in each `VulnerabilityCheck` is 10.
                &quot;A String&quot;,
              ],
              &quot;maximumFixableSeverity&quot;: &quot;A String&quot;, # Required. The threshold for severity for which a fix is currently available. This field is required and must be set.
              &quot;maximumUnfixableSeverity&quot;: &quot;A String&quot;, # Required. The threshold for severity for which a fix isn&#x27;t currently available. This field is required and must be set.
            },
          },
        ],
        &quot;displayName&quot;: &quot;A String&quot;, # Optional. A user-provided name for this `CheckSet`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
        &quot;imageAllowlist&quot;: { # Images that are exempted from normal checks based on name pattern only. # Optional. Images exempted from this `CheckSet`. If any of the patterns match the image being evaluated, no checks in the `CheckSet` will be evaluated.
          &quot;allowPattern&quot;: [ # Required. A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
            &quot;A String&quot;,
          ],
        },
        &quot;scope&quot;: { # A scope specifier for `CheckSet` objects. # Optional. The scope to which this `CheckSet` applies. If unset or an empty string (the default), applies to all namespaces and service accounts. See the `Scope` message documentation for details on scoping rules.
          &quot;kubernetesNamespace&quot;: &quot;A String&quot;, # Optional. Matches all Kubernetes service accounts in the provided namespace, unless a more specific `kubernetes_service_account` scope already matched.
          &quot;kubernetesServiceAccount&quot;: &quot;A String&quot;, # Optional. Matches a single Kubernetes service account, e.g. `my-namespace:my-service-account`. `kubernetes_service_account` scope is always more specific than `kubernetes_namespace` scope for the same namespace.
        },
      },
    ],
    &quot;imageAllowlist&quot;: { # Images that are exempted from normal checks based on name pattern only. # Optional. Images exempted from this policy. If any of the patterns match the image being evaluated, the rest of the policy will not be evaluated.
      &quot;allowPattern&quot;: [ # Required. A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
        &quot;A String&quot;,
      ],
    },
  },
  &quot;name&quot;: &quot;A String&quot;, # Output only. The relative resource name of the Binary Authorization platform policy, in the form of `projects/*/platforms/*/policies/*`.
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Time when the policy was last updated.
}</pre>
</div>

<div class="method">
    <code class="details" id="list">list(parent, pageSize=None, pageToken=None, x__xgafv=None)</code>
  <pre>Lists platform policies owned by a project in the specified platform. Returns `INVALID_ARGUMENT` if the project or the platform doesn&#x27;t exist.

Args:
  parent: string, Required. The resource name of the platform associated with the platform policies using the format `projects/*/platforms/*`. (required)
  pageSize: integer, Requested page size. The server may return fewer results than requested. If unspecified, the server picks an appropriate default.
  pageToken: string, A token identifying a page of results the server should return. Typically, this is the value of ListPlatformPoliciesResponse.next_page_token returned from the previous call to the `ListPlatformPolicies` method.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response message for PlatformPolicyManagementService.ListPlatformPolicies.
  &quot;nextPageToken&quot;: &quot;A String&quot;, # A token to retrieve the next page of results. Pass this value in the ListPlatformPoliciesRequest.page_token field in the subsequent call to the `ListPlatformPolicies` method to retrieve the next page of results.
  &quot;platformPolicies&quot;: [ # The list of platform policies.
    { # A Binary Authorization platform policy for deployments on various platforms.
      &quot;description&quot;: &quot;A String&quot;, # Optional. A description comment about the policy.
      &quot;etag&quot;: &quot;A String&quot;, # Optional. Used to prevent updating the policy when another request has updated it since it was retrieved.
      &quot;gkePolicy&quot;: { # A Binary Authorization policy for a GKE cluster. This is one type of policy that can occur as a `PlatformPolicy`. # Optional. GKE platform-specific policy.
        &quot;checkSets&quot;: [ # Optional. The `CheckSet` objects to apply, scoped by namespace or namespace and service account. Exactly one `CheckSet` will be evaluated for a given Pod (unless the list is empty, in which case the behavior is &quot;always allow&quot;). If multiple `CheckSet` objects have scopes that match the namespace and service account of the Pod being evaluated, only the `CheckSet` with the MOST SPECIFIC scope will match. `CheckSet` objects must be listed in order of decreasing specificity, i.e. if a scope matches a given service account (which must include the namespace), it must come before a `CheckSet` with a scope matching just that namespace. This property is enforced by server-side validation. The purpose of this restriction is to ensure that if more than one `CheckSet` matches a given Pod, the `CheckSet` that will be evaluated will always be the first in the list to match (because if any other matches, it must be less specific). If `check_sets` is empty, the default behavior is to allow all images. If `check_sets` is non-empty, the last `check_sets` entry must always be a `CheckSet` with no scope set, i.e. a catchall to handle any situation not caught by the preceding `CheckSet` objects.
          { # A conjunction of policy checks, scoped to a particular namespace or Kubernetes service account. In order for evaluation of a `CheckSet` to return &quot;allowed&quot; for a given image in a given Pod, one of the following conditions must be satisfied: * The image is explicitly exempted by an entry in `image_allowlist`, OR * ALL of the `checks` evaluate to &quot;allowed&quot;.
            &quot;checks&quot;: [ # Optional. The checks to apply. The ultimate result of evaluating the check set will be &quot;allow&quot; if and only if every check in `checks` evaluates to &quot;allow&quot;. If `checks` is empty, the default behavior is &quot;always allow&quot;.
              { # A single check to perform against a Pod. Checks are grouped into `CheckSet` objects, which are defined by the top-level policy.
                &quot;alwaysDeny&quot;: True or False, # Optional. A special-case check that always denies. Note that this still only applies when the scope of the `CheckSet` applies and the image isn&#x27;t exempted by an image allowlist. This check is primarily useful for testing, or to set the default behavior for all unmatched scopes to &quot;deny&quot;.
                &quot;displayName&quot;: &quot;A String&quot;, # Optional. A user-provided name for this check. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
                &quot;imageAllowlist&quot;: { # Images that are exempted from normal checks based on name pattern only. # Optional. Images exempted from this check. If any of the patterns match the image url, the check will not be evaluated.
                  &quot;allowPattern&quot;: [ # Required. A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
                    &quot;A String&quot;,
                  ],
                },
                &quot;imageFreshnessCheck&quot;: { # An image freshness check, which rejects images that were uploaded before the set number of days ago to the supported repositories. # Optional. Require that an image is no older than a configured expiration time. Image age is determined by its upload time.
                  &quot;maxUploadAgeDays&quot;: 42, # Required. The max number of days that is allowed since the image was uploaded. Must be greater than zero.
                },
                &quot;sigstoreSignatureCheck&quot;: { # A Sigstore signature check, which verifies the Sigstore signature associated with an image. # Optional. Require that an image was signed by Cosign with a trusted key. This check requires that both the image and signature are stored in Artifact Registry.
                  &quot;sigstoreAuthorities&quot;: [ # Required. The authorities required by this check to verify the signature. A signature only needs to be verified by one authority to pass the check.
                    { # A Sigstore authority, used to verify signatures that are created by Sigstore. An authority is analogous to an attestation authenticator, verifying that a signature is valid or invalid.
                      &quot;displayName&quot;: &quot;A String&quot;, # Optional. A user-provided name for this `SigstoreAuthority`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
                      &quot;publicKeySet&quot;: { # A bundle of Sigstore public keys, used to verify Sigstore signatures. A signature is authenticated by a `SigstorePublicKeySet` if any of the keys verify it. # Required. A simple set of public keys. A signature is considered valid if any keys in the set validate the signature.
                        &quot;publicKeys&quot;: [ # Required. `public_keys` must have at least one entry.
                          { # A Sigstore public key. `SigstorePublicKey` is the public key material used to authenticate Sigstore signatures.
                            &quot;publicKeyPem&quot;: &quot;A String&quot;, # The public key material in PEM format.
                          },
                        ],
                      },
                    },
                  ],
                },
                &quot;simpleSigningAttestationCheck&quot;: { # Require a signed [DSSE](https://github.com/secure-systems-lab/dsse) attestation with type SimpleSigning. # Optional. Require a SimpleSigning-type attestation for every image in the deployment.
                  &quot;attestationAuthenticators&quot;: [ # Required. The authenticators required by this check to verify an attestation. Typically this is one or more PKIX public keys for signature verification. Only one authenticator needs to consider an attestation verified in order for an attestation to be considered fully authenticated. In otherwords, this list of authenticators is an &quot;OR&quot; of the authenticator results. At least one authenticator is required.
                    { # An attestation authenticator that will be used to verify attestations. Typically this is just a set of public keys. Conceptually, an authenticator can be treated as always returning either &quot;authenticated&quot; or &quot;not authenticated&quot; when presented with a signed attestation (almost always assumed to be a [DSSE](https://github.com/secure-systems-lab/dsse) attestation). The details of how an authenticator makes this decision are specific to the type of &#x27;authenticator&#x27; that this message wraps.
                      &quot;displayName&quot;: &quot;A String&quot;, # Optional. A user-provided name for this `AttestationAuthenticator`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
                      &quot;pkixPublicKeySet&quot;: { # A bundle of PKIX public keys, used to authenticate attestation signatures. Generally, a signature is considered to be authenticated by a `PkixPublicKeySet` if any of the public keys verify it (i.e. it is an &quot;OR&quot; of the keys). # Optional. A set of raw PKIX SubjectPublicKeyInfo format public keys. If any public key in the set validates the attestation signature, then the signature is considered authenticated (i.e. any one key is sufficient to authenticate).
                        &quot;pkixPublicKeys&quot;: [ # Required. `pkix_public_keys` must have at least one entry.
                          { # A public key in the PkixPublicKey [format](https://tools.ietf.org/html/rfc5280#section-4.1.2.7). Public keys of this type are typically textually encoded using the PEM format.
                            &quot;keyId&quot;: &quot;A String&quot;, # Optional. The ID of this public key. Signatures verified by Binary Authorization must include the ID of the public key that can be used to verify them. The ID must match exactly contents of the `key_id` field exactly. The ID may be explicitly provided by the caller, but it MUST be a valid RFC3986 URI. If `key_id` is left blank and this `PkixPublicKey` is not used in the context of a wrapper (see next paragraph), a default key ID will be computed based on the digest of the DER encoding of the public key. If this `PkixPublicKey` is used in the context of a wrapper that has its own notion of key ID (e.g. `AttestorPublicKey`), then this field can either match that value exactly, or be left blank, in which case it behaves exactly as though it is equal to that wrapper value.
                            &quot;publicKeyPem&quot;: &quot;A String&quot;, # A PEM-encoded public key, as described in https://tools.ietf.org/html/rfc7468#section-13
                            &quot;signatureAlgorithm&quot;: &quot;A String&quot;, # The signature algorithm used to verify a message against a signature using this key. These signature algorithm must match the structure and any object identifiers encoded in `public_key_pem` (i.e. this algorithm must match that of the public key).
                          },
                        ],
                      },
                    },
                  ],
                  &quot;containerAnalysisAttestationProjects&quot;: [ # Optional. The projects where attestations are stored as Container Analysis Occurrences, in the format `projects/[PROJECT_ID]`. Only one attestation needs to successfully verify an image for this check to pass, so a single verified attestation found in any of `container_analysis_attestation_projects` is sufficient for the check to pass. A project ID must be used, not a project number. When fetching Occurrences from Container Analysis, only `AttestationOccurrence` kinds are considered. In the future, additional Occurrence kinds may be added to the query. Maximum number of `container_analysis_attestation_projects` allowed in each `SimpleSigningAttestationCheck` is 10.
                    &quot;A String&quot;,
                  ],
                },
                &quot;slsaCheck&quot;: { # A SLSA provenance attestation check, which ensures that images are built by a trusted builder using source code from its trusted repositories only. # Optional. Require that an image was built by a trusted builder (such as Google Cloud Build), meets requirements for Supply chain Levels for Software Artifacts (SLSA), and was built from a trusted source code repostitory.
                  &quot;rules&quot;: [ # Specifies a list of verification rules for the SLSA attestations. An image is considered compliant with the SlsaCheck if any of the rules are satisfied.
                    { # Specifies verification rules for evaluating the SLSA attestations including: which builders to trust, where to fetch the SLSA attestations generated by those builders, and other builder-specific evaluation rules such as which source repositories are trusted. An image is considered verified by the rule if any of the fetched SLSA attestations is verified.
                      &quot;attestationSource&quot;: { # Specifies the locations for fetching the provenance attestations. # Specifies where to fetch the provenances attestations generated by the builder (group).
                        &quot;containerAnalysisAttestationProjects&quot;: [ # The IDs of the Google Cloud projects that store the SLSA attestations as Container Analysis Occurrences, in the format `projects/[PROJECT_ID]`. Maximum number of `container_analysis_attestation_projects` allowed in each `AttestationSource` is 10.
                          &quot;A String&quot;,
                        ],
                      },
                      &quot;configBasedBuildRequired&quot;: True or False, # If true, require the image to be built from a top-level configuration. `trusted_source_repo_patterns` specifies the repositories containing this configuration.
                      &quot;trustedBuilder&quot;: &quot;A String&quot;, # Each verification rule is used for evaluation against provenances generated by a specific builder (group). For some of the builders, such as the Google Cloud Build, users don&#x27;t need to explicitly specify their roots of trust in the policy since the evaluation service can automatically fetch them based on the builder (group).
                      &quot;trustedSourceRepoPatterns&quot;: [ # List of trusted source code repository URL patterns. These patterns match the full repository URL without its scheme (e.g. `https://`). The patterns must not include schemes. For example, the pattern `source.cloud.google.com/my-project/my-repo-name` matches the following URLs: - `source.cloud.google.com/my-project/my-repo-name` - `git+ssh://source.cloud.google.com/my-project/my-repo-name` - `https://source.cloud.google.com/my-project/my-repo-name` A pattern matches a URL either exactly or with `*` wildcards. `*` can be used in only two ways: 1. trailing `*` after hosturi/ to match varying endings; 2. trailing `**` after hosturi/ to match `/` as well. `*` and `**` can only be used as wildcards and can only occur at the end of the pattern after a `/`. (So it&#x27;s not possible to match a URL that contains literal `*`.) For example: - `github.com/my-project/my-repo` is valid to match a single repo - `github.com/my-project/*` will match all direct repos in `my-project` - `github.com/**` matches all repos in GitHub
                        &quot;A String&quot;,
                      ],
                    },
                  ],
                },
                &quot;trustedDirectoryCheck&quot;: { # A trusted directory check, which rejects images that do not come from the set of user-configured trusted directories. # Optional. Require that an image lives in a trusted directory.
                  &quot;trustedDirPatterns&quot;: [ # Required. List of trusted directory patterns. A pattern is in the form &quot;registry/path/to/directory&quot;. The registry domain part is defined as two or more dot-separated words, e.g., `us.pkg.dev`, or `gcr.io`. Additionally, `*` can be used in three ways as wildcards: 1. leading `*` to match varying prefixes in registry subdomain (useful for location prefixes); 2. trailing `*` after registry/ to match varying endings; 3. trailing `**` after registry/ to match &quot;/&quot; as well. For example: -- `gcr.io/my-project/my-repo` is valid to match a single directory -- `*-docker.pkg.dev/my-project/my-repo` or `*.gcr.io/my-project` are valid to match varying prefixes -- `gcr.io/my-project/*` will match all direct directories in `my-project` -- `gcr.io/my-project/**` would match all directories in `my-project` -- `gcr.i*` is not allowed since the registry is not completely specified -- `sub*domain.gcr.io/nginx` is not valid because only leading `*` or trailing `*` are allowed. -- `*pkg.dev/my-project/my-repo` is not valid because leading `*` can only match subdomain -- `**-docker.pkg.dev` is not valid because one leading `*` is allowed, and that it cannot match `/`
                    &quot;A String&quot;,
                  ],
                },
                &quot;vulnerabilityCheck&quot;: { # An image vulnerability check, which rejects images that violate the configured vulnerability rules. # Optional. Require that an image does not contain vulnerabilities that violate the configured rules, such as based on severity levels.
                  &quot;allowedCves&quot;: [ # Optional. A list of specific CVEs to ignore even if the vulnerability level violates `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will allow vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
                    &quot;A String&quot;,
                  ],
                  &quot;blockedCves&quot;: [ # Optional. A list of specific CVEs to always raise warnings about even if the vulnerability level meets `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will block vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
                    &quot;A String&quot;,
                  ],
                  &quot;containerAnalysisVulnerabilityProjects&quot;: [ # Optional. The projects where vulnerabilities are stored as Container Analysis Occurrences. Each project is expressed in the resource format of `projects/[PROJECT_ID]`, e.g., `projects/my-gcp-project`. An attempt will be made for each project to fetch vulnerabilities, and all valid vulnerabilities will be used to check against the vulnerability policy. If no valid scan is found in all projects configured here, an error will be returned for the check. Maximum number of `container_analysis_vulnerability_projects` allowed in each `VulnerabilityCheck` is 10.
                    &quot;A String&quot;,
                  ],
                  &quot;maximumFixableSeverity&quot;: &quot;A String&quot;, # Required. The threshold for severity for which a fix is currently available. This field is required and must be set.
                  &quot;maximumUnfixableSeverity&quot;: &quot;A String&quot;, # Required. The threshold for severity for which a fix isn&#x27;t currently available. This field is required and must be set.
                },
              },
            ],
            &quot;displayName&quot;: &quot;A String&quot;, # Optional. A user-provided name for this `CheckSet`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
            &quot;imageAllowlist&quot;: { # Images that are exempted from normal checks based on name pattern only. # Optional. Images exempted from this `CheckSet`. If any of the patterns match the image being evaluated, no checks in the `CheckSet` will be evaluated.
              &quot;allowPattern&quot;: [ # Required. A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
                &quot;A String&quot;,
              ],
            },
            &quot;scope&quot;: { # A scope specifier for `CheckSet` objects. # Optional. The scope to which this `CheckSet` applies. If unset or an empty string (the default), applies to all namespaces and service accounts. See the `Scope` message documentation for details on scoping rules.
              &quot;kubernetesNamespace&quot;: &quot;A String&quot;, # Optional. Matches all Kubernetes service accounts in the provided namespace, unless a more specific `kubernetes_service_account` scope already matched.
              &quot;kubernetesServiceAccount&quot;: &quot;A String&quot;, # Optional. Matches a single Kubernetes service account, e.g. `my-namespace:my-service-account`. `kubernetes_service_account` scope is always more specific than `kubernetes_namespace` scope for the same namespace.
            },
          },
        ],
        &quot;imageAllowlist&quot;: { # Images that are exempted from normal checks based on name pattern only. # Optional. Images exempted from this policy. If any of the patterns match the image being evaluated, the rest of the policy will not be evaluated.
          &quot;allowPattern&quot;: [ # Required. A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
            &quot;A String&quot;,
          ],
        },
      },
      &quot;name&quot;: &quot;A String&quot;, # Output only. The relative resource name of the Binary Authorization platform policy, in the form of `projects/*/platforms/*/policies/*`.
      &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Time when the policy was last updated.
    },
  ],
}</pre>
</div>

<div class="method">
    <code class="details" id="list_next">list_next()</code>
  <pre>Retrieves the next page of results.

        Args:
          previous_request: The request for the previous page. (required)
          previous_response: The response from the request for the previous page. (required)

        Returns:
          A request object that you can call &#x27;execute()&#x27; on to request the next
          page. Returns None if there are no more items in the collection.
        </pre>
</div>

<div class="method">
    <code class="details" id="replacePlatformPolicy">replacePlatformPolicy(name, body=None, x__xgafv=None)</code>
  <pre>Replaces a platform policy. Returns `NOT_FOUND` if the policy doesn&#x27;t exist.

Args:
  name: string, Output only. The relative resource name of the Binary Authorization platform policy, in the form of `projects/*/platforms/*/policies/*`. (required)
  body: object, The request body.
    The object takes the form of:

{ # A Binary Authorization platform policy for deployments on various platforms.
  &quot;description&quot;: &quot;A String&quot;, # Optional. A description comment about the policy.
  &quot;etag&quot;: &quot;A String&quot;, # Optional. Used to prevent updating the policy when another request has updated it since it was retrieved.
  &quot;gkePolicy&quot;: { # A Binary Authorization policy for a GKE cluster. This is one type of policy that can occur as a `PlatformPolicy`. # Optional. GKE platform-specific policy.
    &quot;checkSets&quot;: [ # Optional. The `CheckSet` objects to apply, scoped by namespace or namespace and service account. Exactly one `CheckSet` will be evaluated for a given Pod (unless the list is empty, in which case the behavior is &quot;always allow&quot;). If multiple `CheckSet` objects have scopes that match the namespace and service account of the Pod being evaluated, only the `CheckSet` with the MOST SPECIFIC scope will match. `CheckSet` objects must be listed in order of decreasing specificity, i.e. if a scope matches a given service account (which must include the namespace), it must come before a `CheckSet` with a scope matching just that namespace. This property is enforced by server-side validation. The purpose of this restriction is to ensure that if more than one `CheckSet` matches a given Pod, the `CheckSet` that will be evaluated will always be the first in the list to match (because if any other matches, it must be less specific). If `check_sets` is empty, the default behavior is to allow all images. If `check_sets` is non-empty, the last `check_sets` entry must always be a `CheckSet` with no scope set, i.e. a catchall to handle any situation not caught by the preceding `CheckSet` objects.
      { # A conjunction of policy checks, scoped to a particular namespace or Kubernetes service account. In order for evaluation of a `CheckSet` to return &quot;allowed&quot; for a given image in a given Pod, one of the following conditions must be satisfied: * The image is explicitly exempted by an entry in `image_allowlist`, OR * ALL of the `checks` evaluate to &quot;allowed&quot;.
        &quot;checks&quot;: [ # Optional. The checks to apply. The ultimate result of evaluating the check set will be &quot;allow&quot; if and only if every check in `checks` evaluates to &quot;allow&quot;. If `checks` is empty, the default behavior is &quot;always allow&quot;.
          { # A single check to perform against a Pod. Checks are grouped into `CheckSet` objects, which are defined by the top-level policy.
            &quot;alwaysDeny&quot;: True or False, # Optional. A special-case check that always denies. Note that this still only applies when the scope of the `CheckSet` applies and the image isn&#x27;t exempted by an image allowlist. This check is primarily useful for testing, or to set the default behavior for all unmatched scopes to &quot;deny&quot;.
            &quot;displayName&quot;: &quot;A String&quot;, # Optional. A user-provided name for this check. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
            &quot;imageAllowlist&quot;: { # Images that are exempted from normal checks based on name pattern only. # Optional. Images exempted from this check. If any of the patterns match the image url, the check will not be evaluated.
              &quot;allowPattern&quot;: [ # Required. A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
                &quot;A String&quot;,
              ],
            },
            &quot;imageFreshnessCheck&quot;: { # An image freshness check, which rejects images that were uploaded before the set number of days ago to the supported repositories. # Optional. Require that an image is no older than a configured expiration time. Image age is determined by its upload time.
              &quot;maxUploadAgeDays&quot;: 42, # Required. The max number of days that is allowed since the image was uploaded. Must be greater than zero.
            },
            &quot;sigstoreSignatureCheck&quot;: { # A Sigstore signature check, which verifies the Sigstore signature associated with an image. # Optional. Require that an image was signed by Cosign with a trusted key. This check requires that both the image and signature are stored in Artifact Registry.
              &quot;sigstoreAuthorities&quot;: [ # Required. The authorities required by this check to verify the signature. A signature only needs to be verified by one authority to pass the check.
                { # A Sigstore authority, used to verify signatures that are created by Sigstore. An authority is analogous to an attestation authenticator, verifying that a signature is valid or invalid.
                  &quot;displayName&quot;: &quot;A String&quot;, # Optional. A user-provided name for this `SigstoreAuthority`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
                  &quot;publicKeySet&quot;: { # A bundle of Sigstore public keys, used to verify Sigstore signatures. A signature is authenticated by a `SigstorePublicKeySet` if any of the keys verify it. # Required. A simple set of public keys. A signature is considered valid if any keys in the set validate the signature.
                    &quot;publicKeys&quot;: [ # Required. `public_keys` must have at least one entry.
                      { # A Sigstore public key. `SigstorePublicKey` is the public key material used to authenticate Sigstore signatures.
                        &quot;publicKeyPem&quot;: &quot;A String&quot;, # The public key material in PEM format.
                      },
                    ],
                  },
                },
              ],
            },
            &quot;simpleSigningAttestationCheck&quot;: { # Require a signed [DSSE](https://github.com/secure-systems-lab/dsse) attestation with type SimpleSigning. # Optional. Require a SimpleSigning-type attestation for every image in the deployment.
              &quot;attestationAuthenticators&quot;: [ # Required. The authenticators required by this check to verify an attestation. Typically this is one or more PKIX public keys for signature verification. Only one authenticator needs to consider an attestation verified in order for an attestation to be considered fully authenticated. In otherwords, this list of authenticators is an &quot;OR&quot; of the authenticator results. At least one authenticator is required.
                { # An attestation authenticator that will be used to verify attestations. Typically this is just a set of public keys. Conceptually, an authenticator can be treated as always returning either &quot;authenticated&quot; or &quot;not authenticated&quot; when presented with a signed attestation (almost always assumed to be a [DSSE](https://github.com/secure-systems-lab/dsse) attestation). The details of how an authenticator makes this decision are specific to the type of &#x27;authenticator&#x27; that this message wraps.
                  &quot;displayName&quot;: &quot;A String&quot;, # Optional. A user-provided name for this `AttestationAuthenticator`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
                  &quot;pkixPublicKeySet&quot;: { # A bundle of PKIX public keys, used to authenticate attestation signatures. Generally, a signature is considered to be authenticated by a `PkixPublicKeySet` if any of the public keys verify it (i.e. it is an &quot;OR&quot; of the keys). # Optional. A set of raw PKIX SubjectPublicKeyInfo format public keys. If any public key in the set validates the attestation signature, then the signature is considered authenticated (i.e. any one key is sufficient to authenticate).
                    &quot;pkixPublicKeys&quot;: [ # Required. `pkix_public_keys` must have at least one entry.
                      { # A public key in the PkixPublicKey [format](https://tools.ietf.org/html/rfc5280#section-4.1.2.7). Public keys of this type are typically textually encoded using the PEM format.
                        &quot;keyId&quot;: &quot;A String&quot;, # Optional. The ID of this public key. Signatures verified by Binary Authorization must include the ID of the public key that can be used to verify them. The ID must match exactly contents of the `key_id` field exactly. The ID may be explicitly provided by the caller, but it MUST be a valid RFC3986 URI. If `key_id` is left blank and this `PkixPublicKey` is not used in the context of a wrapper (see next paragraph), a default key ID will be computed based on the digest of the DER encoding of the public key. If this `PkixPublicKey` is used in the context of a wrapper that has its own notion of key ID (e.g. `AttestorPublicKey`), then this field can either match that value exactly, or be left blank, in which case it behaves exactly as though it is equal to that wrapper value.
                        &quot;publicKeyPem&quot;: &quot;A String&quot;, # A PEM-encoded public key, as described in https://tools.ietf.org/html/rfc7468#section-13
                        &quot;signatureAlgorithm&quot;: &quot;A String&quot;, # The signature algorithm used to verify a message against a signature using this key. These signature algorithm must match the structure and any object identifiers encoded in `public_key_pem` (i.e. this algorithm must match that of the public key).
                      },
                    ],
                  },
                },
              ],
              &quot;containerAnalysisAttestationProjects&quot;: [ # Optional. The projects where attestations are stored as Container Analysis Occurrences, in the format `projects/[PROJECT_ID]`. Only one attestation needs to successfully verify an image for this check to pass, so a single verified attestation found in any of `container_analysis_attestation_projects` is sufficient for the check to pass. A project ID must be used, not a project number. When fetching Occurrences from Container Analysis, only `AttestationOccurrence` kinds are considered. In the future, additional Occurrence kinds may be added to the query. Maximum number of `container_analysis_attestation_projects` allowed in each `SimpleSigningAttestationCheck` is 10.
                &quot;A String&quot;,
              ],
            },
            &quot;slsaCheck&quot;: { # A SLSA provenance attestation check, which ensures that images are built by a trusted builder using source code from its trusted repositories only. # Optional. Require that an image was built by a trusted builder (such as Google Cloud Build), meets requirements for Supply chain Levels for Software Artifacts (SLSA), and was built from a trusted source code repostitory.
              &quot;rules&quot;: [ # Specifies a list of verification rules for the SLSA attestations. An image is considered compliant with the SlsaCheck if any of the rules are satisfied.
                { # Specifies verification rules for evaluating the SLSA attestations including: which builders to trust, where to fetch the SLSA attestations generated by those builders, and other builder-specific evaluation rules such as which source repositories are trusted. An image is considered verified by the rule if any of the fetched SLSA attestations is verified.
                  &quot;attestationSource&quot;: { # Specifies the locations for fetching the provenance attestations. # Specifies where to fetch the provenances attestations generated by the builder (group).
                    &quot;containerAnalysisAttestationProjects&quot;: [ # The IDs of the Google Cloud projects that store the SLSA attestations as Container Analysis Occurrences, in the format `projects/[PROJECT_ID]`. Maximum number of `container_analysis_attestation_projects` allowed in each `AttestationSource` is 10.
                      &quot;A String&quot;,
                    ],
                  },
                  &quot;configBasedBuildRequired&quot;: True or False, # If true, require the image to be built from a top-level configuration. `trusted_source_repo_patterns` specifies the repositories containing this configuration.
                  &quot;trustedBuilder&quot;: &quot;A String&quot;, # Each verification rule is used for evaluation against provenances generated by a specific builder (group). For some of the builders, such as the Google Cloud Build, users don&#x27;t need to explicitly specify their roots of trust in the policy since the evaluation service can automatically fetch them based on the builder (group).
                  &quot;trustedSourceRepoPatterns&quot;: [ # List of trusted source code repository URL patterns. These patterns match the full repository URL without its scheme (e.g. `https://`). The patterns must not include schemes. For example, the pattern `source.cloud.google.com/my-project/my-repo-name` matches the following URLs: - `source.cloud.google.com/my-project/my-repo-name` - `git+ssh://source.cloud.google.com/my-project/my-repo-name` - `https://source.cloud.google.com/my-project/my-repo-name` A pattern matches a URL either exactly or with `*` wildcards. `*` can be used in only two ways: 1. trailing `*` after hosturi/ to match varying endings; 2. trailing `**` after hosturi/ to match `/` as well. `*` and `**` can only be used as wildcards and can only occur at the end of the pattern after a `/`. (So it&#x27;s not possible to match a URL that contains literal `*`.) For example: - `github.com/my-project/my-repo` is valid to match a single repo - `github.com/my-project/*` will match all direct repos in `my-project` - `github.com/**` matches all repos in GitHub
                    &quot;A String&quot;,
                  ],
                },
              ],
            },
            &quot;trustedDirectoryCheck&quot;: { # A trusted directory check, which rejects images that do not come from the set of user-configured trusted directories. # Optional. Require that an image lives in a trusted directory.
              &quot;trustedDirPatterns&quot;: [ # Required. List of trusted directory patterns. A pattern is in the form &quot;registry/path/to/directory&quot;. The registry domain part is defined as two or more dot-separated words, e.g., `us.pkg.dev`, or `gcr.io`. Additionally, `*` can be used in three ways as wildcards: 1. leading `*` to match varying prefixes in registry subdomain (useful for location prefixes); 2. trailing `*` after registry/ to match varying endings; 3. trailing `**` after registry/ to match &quot;/&quot; as well. For example: -- `gcr.io/my-project/my-repo` is valid to match a single directory -- `*-docker.pkg.dev/my-project/my-repo` or `*.gcr.io/my-project` are valid to match varying prefixes -- `gcr.io/my-project/*` will match all direct directories in `my-project` -- `gcr.io/my-project/**` would match all directories in `my-project` -- `gcr.i*` is not allowed since the registry is not completely specified -- `sub*domain.gcr.io/nginx` is not valid because only leading `*` or trailing `*` are allowed. -- `*pkg.dev/my-project/my-repo` is not valid because leading `*` can only match subdomain -- `**-docker.pkg.dev` is not valid because one leading `*` is allowed, and that it cannot match `/`
                &quot;A String&quot;,
              ],
            },
            &quot;vulnerabilityCheck&quot;: { # An image vulnerability check, which rejects images that violate the configured vulnerability rules. # Optional. Require that an image does not contain vulnerabilities that violate the configured rules, such as based on severity levels.
              &quot;allowedCves&quot;: [ # Optional. A list of specific CVEs to ignore even if the vulnerability level violates `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will allow vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
                &quot;A String&quot;,
              ],
              &quot;blockedCves&quot;: [ # Optional. A list of specific CVEs to always raise warnings about even if the vulnerability level meets `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will block vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
                &quot;A String&quot;,
              ],
              &quot;containerAnalysisVulnerabilityProjects&quot;: [ # Optional. The projects where vulnerabilities are stored as Container Analysis Occurrences. Each project is expressed in the resource format of `projects/[PROJECT_ID]`, e.g., `projects/my-gcp-project`. An attempt will be made for each project to fetch vulnerabilities, and all valid vulnerabilities will be used to check against the vulnerability policy. If no valid scan is found in all projects configured here, an error will be returned for the check. Maximum number of `container_analysis_vulnerability_projects` allowed in each `VulnerabilityCheck` is 10.
                &quot;A String&quot;,
              ],
              &quot;maximumFixableSeverity&quot;: &quot;A String&quot;, # Required. The threshold for severity for which a fix is currently available. This field is required and must be set.
              &quot;maximumUnfixableSeverity&quot;: &quot;A String&quot;, # Required. The threshold for severity for which a fix isn&#x27;t currently available. This field is required and must be set.
            },
          },
        ],
        &quot;displayName&quot;: &quot;A String&quot;, # Optional. A user-provided name for this `CheckSet`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
        &quot;imageAllowlist&quot;: { # Images that are exempted from normal checks based on name pattern only. # Optional. Images exempted from this `CheckSet`. If any of the patterns match the image being evaluated, no checks in the `CheckSet` will be evaluated.
          &quot;allowPattern&quot;: [ # Required. A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
            &quot;A String&quot;,
          ],
        },
        &quot;scope&quot;: { # A scope specifier for `CheckSet` objects. # Optional. The scope to which this `CheckSet` applies. If unset or an empty string (the default), applies to all namespaces and service accounts. See the `Scope` message documentation for details on scoping rules.
          &quot;kubernetesNamespace&quot;: &quot;A String&quot;, # Optional. Matches all Kubernetes service accounts in the provided namespace, unless a more specific `kubernetes_service_account` scope already matched.
          &quot;kubernetesServiceAccount&quot;: &quot;A String&quot;, # Optional. Matches a single Kubernetes service account, e.g. `my-namespace:my-service-account`. `kubernetes_service_account` scope is always more specific than `kubernetes_namespace` scope for the same namespace.
        },
      },
    ],
    &quot;imageAllowlist&quot;: { # Images that are exempted from normal checks based on name pattern only. # Optional. Images exempted from this policy. If any of the patterns match the image being evaluated, the rest of the policy will not be evaluated.
      &quot;allowPattern&quot;: [ # Required. A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
        &quot;A String&quot;,
      ],
    },
  },
  &quot;name&quot;: &quot;A String&quot;, # Output only. The relative resource name of the Binary Authorization platform policy, in the form of `projects/*/platforms/*/policies/*`.
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Time when the policy was last updated.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A Binary Authorization platform policy for deployments on various platforms.
  &quot;description&quot;: &quot;A String&quot;, # Optional. A description comment about the policy.
  &quot;etag&quot;: &quot;A String&quot;, # Optional. Used to prevent updating the policy when another request has updated it since it was retrieved.
  &quot;gkePolicy&quot;: { # A Binary Authorization policy for a GKE cluster. This is one type of policy that can occur as a `PlatformPolicy`. # Optional. GKE platform-specific policy.
    &quot;checkSets&quot;: [ # Optional. The `CheckSet` objects to apply, scoped by namespace or namespace and service account. Exactly one `CheckSet` will be evaluated for a given Pod (unless the list is empty, in which case the behavior is &quot;always allow&quot;). If multiple `CheckSet` objects have scopes that match the namespace and service account of the Pod being evaluated, only the `CheckSet` with the MOST SPECIFIC scope will match. `CheckSet` objects must be listed in order of decreasing specificity, i.e. if a scope matches a given service account (which must include the namespace), it must come before a `CheckSet` with a scope matching just that namespace. This property is enforced by server-side validation. The purpose of this restriction is to ensure that if more than one `CheckSet` matches a given Pod, the `CheckSet` that will be evaluated will always be the first in the list to match (because if any other matches, it must be less specific). If `check_sets` is empty, the default behavior is to allow all images. If `check_sets` is non-empty, the last `check_sets` entry must always be a `CheckSet` with no scope set, i.e. a catchall to handle any situation not caught by the preceding `CheckSet` objects.
      { # A conjunction of policy checks, scoped to a particular namespace or Kubernetes service account. In order for evaluation of a `CheckSet` to return &quot;allowed&quot; for a given image in a given Pod, one of the following conditions must be satisfied: * The image is explicitly exempted by an entry in `image_allowlist`, OR * ALL of the `checks` evaluate to &quot;allowed&quot;.
        &quot;checks&quot;: [ # Optional. The checks to apply. The ultimate result of evaluating the check set will be &quot;allow&quot; if and only if every check in `checks` evaluates to &quot;allow&quot;. If `checks` is empty, the default behavior is &quot;always allow&quot;.
          { # A single check to perform against a Pod. Checks are grouped into `CheckSet` objects, which are defined by the top-level policy.
            &quot;alwaysDeny&quot;: True or False, # Optional. A special-case check that always denies. Note that this still only applies when the scope of the `CheckSet` applies and the image isn&#x27;t exempted by an image allowlist. This check is primarily useful for testing, or to set the default behavior for all unmatched scopes to &quot;deny&quot;.
            &quot;displayName&quot;: &quot;A String&quot;, # Optional. A user-provided name for this check. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
            &quot;imageAllowlist&quot;: { # Images that are exempted from normal checks based on name pattern only. # Optional. Images exempted from this check. If any of the patterns match the image url, the check will not be evaluated.
              &quot;allowPattern&quot;: [ # Required. A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
                &quot;A String&quot;,
              ],
            },
            &quot;imageFreshnessCheck&quot;: { # An image freshness check, which rejects images that were uploaded before the set number of days ago to the supported repositories. # Optional. Require that an image is no older than a configured expiration time. Image age is determined by its upload time.
              &quot;maxUploadAgeDays&quot;: 42, # Required. The max number of days that is allowed since the image was uploaded. Must be greater than zero.
            },
            &quot;sigstoreSignatureCheck&quot;: { # A Sigstore signature check, which verifies the Sigstore signature associated with an image. # Optional. Require that an image was signed by Cosign with a trusted key. This check requires that both the image and signature are stored in Artifact Registry.
              &quot;sigstoreAuthorities&quot;: [ # Required. The authorities required by this check to verify the signature. A signature only needs to be verified by one authority to pass the check.
                { # A Sigstore authority, used to verify signatures that are created by Sigstore. An authority is analogous to an attestation authenticator, verifying that a signature is valid or invalid.
                  &quot;displayName&quot;: &quot;A String&quot;, # Optional. A user-provided name for this `SigstoreAuthority`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
                  &quot;publicKeySet&quot;: { # A bundle of Sigstore public keys, used to verify Sigstore signatures. A signature is authenticated by a `SigstorePublicKeySet` if any of the keys verify it. # Required. A simple set of public keys. A signature is considered valid if any keys in the set validate the signature.
                    &quot;publicKeys&quot;: [ # Required. `public_keys` must have at least one entry.
                      { # A Sigstore public key. `SigstorePublicKey` is the public key material used to authenticate Sigstore signatures.
                        &quot;publicKeyPem&quot;: &quot;A String&quot;, # The public key material in PEM format.
                      },
                    ],
                  },
                },
              ],
            },
            &quot;simpleSigningAttestationCheck&quot;: { # Require a signed [DSSE](https://github.com/secure-systems-lab/dsse) attestation with type SimpleSigning. # Optional. Require a SimpleSigning-type attestation for every image in the deployment.
              &quot;attestationAuthenticators&quot;: [ # Required. The authenticators required by this check to verify an attestation. Typically this is one or more PKIX public keys for signature verification. Only one authenticator needs to consider an attestation verified in order for an attestation to be considered fully authenticated. In otherwords, this list of authenticators is an &quot;OR&quot; of the authenticator results. At least one authenticator is required.
                { # An attestation authenticator that will be used to verify attestations. Typically this is just a set of public keys. Conceptually, an authenticator can be treated as always returning either &quot;authenticated&quot; or &quot;not authenticated&quot; when presented with a signed attestation (almost always assumed to be a [DSSE](https://github.com/secure-systems-lab/dsse) attestation). The details of how an authenticator makes this decision are specific to the type of &#x27;authenticator&#x27; that this message wraps.
                  &quot;displayName&quot;: &quot;A String&quot;, # Optional. A user-provided name for this `AttestationAuthenticator`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
                  &quot;pkixPublicKeySet&quot;: { # A bundle of PKIX public keys, used to authenticate attestation signatures. Generally, a signature is considered to be authenticated by a `PkixPublicKeySet` if any of the public keys verify it (i.e. it is an &quot;OR&quot; of the keys). # Optional. A set of raw PKIX SubjectPublicKeyInfo format public keys. If any public key in the set validates the attestation signature, then the signature is considered authenticated (i.e. any one key is sufficient to authenticate).
                    &quot;pkixPublicKeys&quot;: [ # Required. `pkix_public_keys` must have at least one entry.
                      { # A public key in the PkixPublicKey [format](https://tools.ietf.org/html/rfc5280#section-4.1.2.7). Public keys of this type are typically textually encoded using the PEM format.
                        &quot;keyId&quot;: &quot;A String&quot;, # Optional. The ID of this public key. Signatures verified by Binary Authorization must include the ID of the public key that can be used to verify them. The ID must match exactly contents of the `key_id` field exactly. The ID may be explicitly provided by the caller, but it MUST be a valid RFC3986 URI. If `key_id` is left blank and this `PkixPublicKey` is not used in the context of a wrapper (see next paragraph), a default key ID will be computed based on the digest of the DER encoding of the public key. If this `PkixPublicKey` is used in the context of a wrapper that has its own notion of key ID (e.g. `AttestorPublicKey`), then this field can either match that value exactly, or be left blank, in which case it behaves exactly as though it is equal to that wrapper value.
                        &quot;publicKeyPem&quot;: &quot;A String&quot;, # A PEM-encoded public key, as described in https://tools.ietf.org/html/rfc7468#section-13
                        &quot;signatureAlgorithm&quot;: &quot;A String&quot;, # The signature algorithm used to verify a message against a signature using this key. These signature algorithm must match the structure and any object identifiers encoded in `public_key_pem` (i.e. this algorithm must match that of the public key).
                      },
                    ],
                  },
                },
              ],
              &quot;containerAnalysisAttestationProjects&quot;: [ # Optional. The projects where attestations are stored as Container Analysis Occurrences, in the format `projects/[PROJECT_ID]`. Only one attestation needs to successfully verify an image for this check to pass, so a single verified attestation found in any of `container_analysis_attestation_projects` is sufficient for the check to pass. A project ID must be used, not a project number. When fetching Occurrences from Container Analysis, only `AttestationOccurrence` kinds are considered. In the future, additional Occurrence kinds may be added to the query. Maximum number of `container_analysis_attestation_projects` allowed in each `SimpleSigningAttestationCheck` is 10.
                &quot;A String&quot;,
              ],
            },
            &quot;slsaCheck&quot;: { # A SLSA provenance attestation check, which ensures that images are built by a trusted builder using source code from its trusted repositories only. # Optional. Require that an image was built by a trusted builder (such as Google Cloud Build), meets requirements for Supply chain Levels for Software Artifacts (SLSA), and was built from a trusted source code repostitory.
              &quot;rules&quot;: [ # Specifies a list of verification rules for the SLSA attestations. An image is considered compliant with the SlsaCheck if any of the rules are satisfied.
                { # Specifies verification rules for evaluating the SLSA attestations including: which builders to trust, where to fetch the SLSA attestations generated by those builders, and other builder-specific evaluation rules such as which source repositories are trusted. An image is considered verified by the rule if any of the fetched SLSA attestations is verified.
                  &quot;attestationSource&quot;: { # Specifies the locations for fetching the provenance attestations. # Specifies where to fetch the provenances attestations generated by the builder (group).
                    &quot;containerAnalysisAttestationProjects&quot;: [ # The IDs of the Google Cloud projects that store the SLSA attestations as Container Analysis Occurrences, in the format `projects/[PROJECT_ID]`. Maximum number of `container_analysis_attestation_projects` allowed in each `AttestationSource` is 10.
                      &quot;A String&quot;,
                    ],
                  },
                  &quot;configBasedBuildRequired&quot;: True or False, # If true, require the image to be built from a top-level configuration. `trusted_source_repo_patterns` specifies the repositories containing this configuration.
                  &quot;trustedBuilder&quot;: &quot;A String&quot;, # Each verification rule is used for evaluation against provenances generated by a specific builder (group). For some of the builders, such as the Google Cloud Build, users don&#x27;t need to explicitly specify their roots of trust in the policy since the evaluation service can automatically fetch them based on the builder (group).
                  &quot;trustedSourceRepoPatterns&quot;: [ # List of trusted source code repository URL patterns. These patterns match the full repository URL without its scheme (e.g. `https://`). The patterns must not include schemes. For example, the pattern `source.cloud.google.com/my-project/my-repo-name` matches the following URLs: - `source.cloud.google.com/my-project/my-repo-name` - `git+ssh://source.cloud.google.com/my-project/my-repo-name` - `https://source.cloud.google.com/my-project/my-repo-name` A pattern matches a URL either exactly or with `*` wildcards. `*` can be used in only two ways: 1. trailing `*` after hosturi/ to match varying endings; 2. trailing `**` after hosturi/ to match `/` as well. `*` and `**` can only be used as wildcards and can only occur at the end of the pattern after a `/`. (So it&#x27;s not possible to match a URL that contains literal `*`.) For example: - `github.com/my-project/my-repo` is valid to match a single repo - `github.com/my-project/*` will match all direct repos in `my-project` - `github.com/**` matches all repos in GitHub
                    &quot;A String&quot;,
                  ],
                },
              ],
            },
            &quot;trustedDirectoryCheck&quot;: { # A trusted directory check, which rejects images that do not come from the set of user-configured trusted directories. # Optional. Require that an image lives in a trusted directory.
              &quot;trustedDirPatterns&quot;: [ # Required. List of trusted directory patterns. A pattern is in the form &quot;registry/path/to/directory&quot;. The registry domain part is defined as two or more dot-separated words, e.g., `us.pkg.dev`, or `gcr.io`. Additionally, `*` can be used in three ways as wildcards: 1. leading `*` to match varying prefixes in registry subdomain (useful for location prefixes); 2. trailing `*` after registry/ to match varying endings; 3. trailing `**` after registry/ to match &quot;/&quot; as well. For example: -- `gcr.io/my-project/my-repo` is valid to match a single directory -- `*-docker.pkg.dev/my-project/my-repo` or `*.gcr.io/my-project` are valid to match varying prefixes -- `gcr.io/my-project/*` will match all direct directories in `my-project` -- `gcr.io/my-project/**` would match all directories in `my-project` -- `gcr.i*` is not allowed since the registry is not completely specified -- `sub*domain.gcr.io/nginx` is not valid because only leading `*` or trailing `*` are allowed. -- `*pkg.dev/my-project/my-repo` is not valid because leading `*` can only match subdomain -- `**-docker.pkg.dev` is not valid because one leading `*` is allowed, and that it cannot match `/`
                &quot;A String&quot;,
              ],
            },
            &quot;vulnerabilityCheck&quot;: { # An image vulnerability check, which rejects images that violate the configured vulnerability rules. # Optional. Require that an image does not contain vulnerabilities that violate the configured rules, such as based on severity levels.
              &quot;allowedCves&quot;: [ # Optional. A list of specific CVEs to ignore even if the vulnerability level violates `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will allow vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
                &quot;A String&quot;,
              ],
              &quot;blockedCves&quot;: [ # Optional. A list of specific CVEs to always raise warnings about even if the vulnerability level meets `maximumUnfixableSeverity` or `maximumFixableSeverity`. CVEs are listed in the format of Container Analysis note id. For example: - CVE-2021-20305 - CVE-2020-10543 The CVEs are applicable regardless of note provider project, e.g., an entry of `CVE-2021-20305` will block vulnerabilities with a note name of either `projects/goog-vulnz/notes/CVE-2021-20305` or `projects/CUSTOM-PROJECT/notes/CVE-2021-20305`.
                &quot;A String&quot;,
              ],
              &quot;containerAnalysisVulnerabilityProjects&quot;: [ # Optional. The projects where vulnerabilities are stored as Container Analysis Occurrences. Each project is expressed in the resource format of `projects/[PROJECT_ID]`, e.g., `projects/my-gcp-project`. An attempt will be made for each project to fetch vulnerabilities, and all valid vulnerabilities will be used to check against the vulnerability policy. If no valid scan is found in all projects configured here, an error will be returned for the check. Maximum number of `container_analysis_vulnerability_projects` allowed in each `VulnerabilityCheck` is 10.
                &quot;A String&quot;,
              ],
              &quot;maximumFixableSeverity&quot;: &quot;A String&quot;, # Required. The threshold for severity for which a fix is currently available. This field is required and must be set.
              &quot;maximumUnfixableSeverity&quot;: &quot;A String&quot;, # Required. The threshold for severity for which a fix isn&#x27;t currently available. This field is required and must be set.
            },
          },
        ],
        &quot;displayName&quot;: &quot;A String&quot;, # Optional. A user-provided name for this `CheckSet`. This field has no effect on the policy evaluation behavior except to improve readability of messages in evaluation results.
        &quot;imageAllowlist&quot;: { # Images that are exempted from normal checks based on name pattern only. # Optional. Images exempted from this `CheckSet`. If any of the patterns match the image being evaluated, no checks in the `CheckSet` will be evaluated.
          &quot;allowPattern&quot;: [ # Required. A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
            &quot;A String&quot;,
          ],
        },
        &quot;scope&quot;: { # A scope specifier for `CheckSet` objects. # Optional. The scope to which this `CheckSet` applies. If unset or an empty string (the default), applies to all namespaces and service accounts. See the `Scope` message documentation for details on scoping rules.
          &quot;kubernetesNamespace&quot;: &quot;A String&quot;, # Optional. Matches all Kubernetes service accounts in the provided namespace, unless a more specific `kubernetes_service_account` scope already matched.
          &quot;kubernetesServiceAccount&quot;: &quot;A String&quot;, # Optional. Matches a single Kubernetes service account, e.g. `my-namespace:my-service-account`. `kubernetes_service_account` scope is always more specific than `kubernetes_namespace` scope for the same namespace.
        },
      },
    ],
    &quot;imageAllowlist&quot;: { # Images that are exempted from normal checks based on name pattern only. # Optional. Images exempted from this policy. If any of the patterns match the image being evaluated, the rest of the policy will not be evaluated.
      &quot;allowPattern&quot;: [ # Required. A disjunction of image patterns to allow. If any of these patterns match, then the image is considered exempted by this allowlist.
        &quot;A String&quot;,
      ],
    },
  },
  &quot;name&quot;: &quot;A String&quot;, # Output only. The relative resource name of the Binary Authorization platform policy, in the form of `projects/*/platforms/*/policies/*`.
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Time when the policy was last updated.
}</pre>
</div>

</body></html>