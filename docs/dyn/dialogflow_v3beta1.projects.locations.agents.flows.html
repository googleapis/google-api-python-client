<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="dialogflow_v3beta1.html">Dialogflow API</a> . <a href="dialogflow_v3beta1.projects.html">projects</a> . <a href="dialogflow_v3beta1.projects.locations.html">locations</a> . <a href="dialogflow_v3beta1.projects.locations.agents.html">agents</a> . <a href="dialogflow_v3beta1.projects.locations.agents.flows.html">flows</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="dialogflow_v3beta1.projects.locations.agents.flows.pages.html">pages()</a></code>
</p>
<p class="firstline">Returns the pages Resource.</p>

<p class="toc_element">
  <code><a href="dialogflow_v3beta1.projects.locations.agents.flows.transitionRouteGroups.html">transitionRouteGroups()</a></code>
</p>
<p class="firstline">Returns the transitionRouteGroups Resource.</p>

<p class="toc_element">
  <code><a href="dialogflow_v3beta1.projects.locations.agents.flows.versions.html">versions()</a></code>
</p>
<p class="firstline">Returns the versions Resource.</p>

<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#create">create(parent, body=None, languageCode=None, x__xgafv=None)</a></code></p>
<p class="firstline">Creates a flow in the specified agent. Note: You should always train a flow prior to sending it queries. See the [training documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).</p>
<p class="toc_element">
  <code><a href="#delete">delete(name, force=None, x__xgafv=None)</a></code></p>
<p class="firstline">Deletes a specified flow.</p>
<p class="toc_element">
  <code><a href="#export">export(name, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Exports the specified flow to a binary file. This method is a [long-running operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation). The returned `Operation` type has the following method-specific fields: - `metadata`: An empty [Struct message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#struct) - `response`: ExportFlowResponse Note that resources (e.g. intents, entities, webhooks) that the flow references will also be exported.</p>
<p class="toc_element">
  <code><a href="#get">get(name, languageCode=None, x__xgafv=None)</a></code></p>
<p class="firstline">Retrieves the specified flow.</p>
<p class="toc_element">
  <code><a href="#getValidationResult">getValidationResult(name, languageCode=None, x__xgafv=None)</a></code></p>
<p class="firstline">Gets the latest flow validation result. Flow validation is performed when ValidateFlow is called.</p>
<p class="toc_element">
  <code><a href="#import_">import_(parent, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Imports the specified flow to the specified agent from a binary file. This method is a [long-running operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation). The returned `Operation` type has the following method-specific fields: - `metadata`: An empty [Struct message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#struct) - `response`: ImportFlowResponse Note: You should always train a flow prior to sending it queries. See the [training documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).</p>
<p class="toc_element">
  <code><a href="#list">list(parent, languageCode=None, pageSize=None, pageToken=None, x__xgafv=None)</a></code></p>
<p class="firstline">Returns the list of all flows in the specified agent.</p>
<p class="toc_element">
  <code><a href="#list_next">list_next()</a></code></p>
<p class="firstline">Retrieves the next page of results.</p>
<p class="toc_element">
  <code><a href="#patch">patch(name, body=None, languageCode=None, updateMask=None, x__xgafv=None)</a></code></p>
<p class="firstline">Updates the specified flow. Note: You should always train a flow prior to sending it queries. See the [training documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).</p>
<p class="toc_element">
  <code><a href="#train">train(name, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Trains the specified flow. Note that only the flow in 'draft' environment is trained. This method is a [long-running operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation). The returned `Operation` type has the following method-specific fields: - `metadata`: An empty [Struct message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#struct) - `response`: An [Empty message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#empty) Note: You should always train a flow prior to sending it queries. See the [training documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).</p>
<p class="toc_element">
  <code><a href="#validate">validate(name, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Validates the specified flow and creates or updates validation results. Please call this API after the training is completed to get the complete validation results.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="create">create(parent, body=None, languageCode=None, x__xgafv=None)</code>
  <pre>Creates a flow in the specified agent. Note: You should always train a flow prior to sending it queries. See the [training documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).

Args:
  parent: string, Required. The agent to create a flow for. Format: `projects//locations//agents/`. (required)
  body: object, The request body.
    The object takes the form of:

{ # Flows represents the conversation flows when you build your chatbot agent. A flow consists of many pages connected by the transition routes. Conversations always start with the built-in Start Flow (with an all-0 ID). Transition routes can direct the conversation session from the current flow (parent flow) to another flow (sub flow). When the sub flow is finished, Dialogflow will bring the session back to the parent flow, where the sub flow is started. Usually, when a transition route is followed by a matched intent, the intent will be &quot;consumed&quot;. This means the intent won&#x27;t activate more transition routes. However, when the followed transition route moves the conversation session into a different flow, the matched intent can be carried over and to be consumed in the target flow.
  &quot;description&quot;: &quot;A String&quot;, # The description of the flow. The maximum length is 500 characters. If exceeded, the request is rejected.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the flow.
  &quot;eventHandlers&quot;: [ # A flow&#x27;s event handlers serve two purposes: * They are responsible for handling events (e.g. no match, webhook errors) in the flow. * They are inherited by every page&#x27;s event handlers, which can be used to handle common events regardless of the current page. Event handlers defined in the page have higher priority than those defined in the flow. Unlike transition_routes, these handlers are evaluated on a first-match basis. The first one that matches the event get executed, with the rest being ignored.
    { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
      &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
      &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
      &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
      &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
      &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
            &quot;cases&quot;: [ # A list of cascading if-else conditions.
              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                &quot;caseContent&quot;: [ # A list of case content.
                  { # The list of messages or conditional cases to activate for this case.
                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  },
                ],
                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
              },
            ],
          },
        ],
        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
            },
            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
              &quot;segments&quot;: [ # Segments this audio response is composed of.
                { # Represents one segment of audio.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                },
              ],
            },
            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
            },
            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
            },
            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
            },
            &quot;text&quot;: { # The text response message. # Returns a text response.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text responses.
                &quot;A String&quot;,
              ],
            },
          },
        ],
        &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
          { # Setting a parameter value.
            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
          },
        ],
        &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
      },
    },
  ],
  &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the flow. Format: `projects//locations//agents//flows/`.
  &quot;nluSettings&quot;: { # Settings related to NLU. # NLU related settings of the flow.
    &quot;classificationThreshold&quot;: 3.14, # To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold. If the returned score value is less than the threshold value, then a no-match event will be triggered. The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used.
    &quot;modelTrainingMode&quot;: &quot;A String&quot;, # Indicates NLU model training mode.
    &quot;modelType&quot;: &quot;A String&quot;, # Indicates the type of NLU model.
  },
  &quot;transitionRouteGroups&quot;: [ # A flow&#x27;s transition route group serve two purposes: * They are responsible for matching the user&#x27;s first utterances in the flow. * They are inherited by every page&#x27;s transition route groups. Transition route groups defined in the page have higher priority than those defined in the flow. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
    &quot;A String&quot;,
  ],
  &quot;transitionRoutes&quot;: [ # A flow&#x27;s transition routes serve two purposes: * They are responsible for matching the user&#x27;s first utterances in the flow. * They are inherited by every page&#x27;s transition routes and can support use cases such as the user saying &quot;help&quot; or &quot;can I talk to a human?&quot;, which can be handled in a common way regardless of the current page. Transition routes defined in the page have higher priority than those defined in the flow. TransitionRoutes are evalauted in the following order: * TransitionRoutes with intent specified. * TransitionRoutes with only condition specified. TransitionRoutes with intent specified are inherited by pages in the flow.
    { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
      &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
      &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
      &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
      &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
      &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
      &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
            &quot;cases&quot;: [ # A list of cascading if-else conditions.
              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                &quot;caseContent&quot;: [ # A list of case content.
                  { # The list of messages or conditional cases to activate for this case.
                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  },
                ],
                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
              },
            ],
          },
        ],
        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
            },
            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
              &quot;segments&quot;: [ # Segments this audio response is composed of.
                { # Represents one segment of audio.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                },
              ],
            },
            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
            },
            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
            },
            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
            },
            &quot;text&quot;: { # The text response message. # Returns a text response.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text responses.
                &quot;A String&quot;,
              ],
            },
          },
        ],
        &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
          { # Setting a parameter value.
            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
          },
        ],
        &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
      },
    },
  ],
}

  languageCode: string, The language of the following fields in `flow`: * `Flow.event_handlers.trigger_fulfillment.messages` * `Flow.event_handlers.trigger_fulfillment.conditional_cases` * `Flow.transition_routes.trigger_fulfillment.messages` * `Flow.transition_routes.trigger_fulfillment.conditional_cases` If not specified, the agent&#x27;s default language is used. [Many languages](https://cloud.google.com/dialogflow/cx/docs/reference/language) are supported. Note: languages must be enabled in the agent before they can be used.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Flows represents the conversation flows when you build your chatbot agent. A flow consists of many pages connected by the transition routes. Conversations always start with the built-in Start Flow (with an all-0 ID). Transition routes can direct the conversation session from the current flow (parent flow) to another flow (sub flow). When the sub flow is finished, Dialogflow will bring the session back to the parent flow, where the sub flow is started. Usually, when a transition route is followed by a matched intent, the intent will be &quot;consumed&quot;. This means the intent won&#x27;t activate more transition routes. However, when the followed transition route moves the conversation session into a different flow, the matched intent can be carried over and to be consumed in the target flow.
  &quot;description&quot;: &quot;A String&quot;, # The description of the flow. The maximum length is 500 characters. If exceeded, the request is rejected.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the flow.
  &quot;eventHandlers&quot;: [ # A flow&#x27;s event handlers serve two purposes: * They are responsible for handling events (e.g. no match, webhook errors) in the flow. * They are inherited by every page&#x27;s event handlers, which can be used to handle common events regardless of the current page. Event handlers defined in the page have higher priority than those defined in the flow. Unlike transition_routes, these handlers are evaluated on a first-match basis. The first one that matches the event get executed, with the rest being ignored.
    { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
      &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
      &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
      &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
      &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
      &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
            &quot;cases&quot;: [ # A list of cascading if-else conditions.
              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                &quot;caseContent&quot;: [ # A list of case content.
                  { # The list of messages or conditional cases to activate for this case.
                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  },
                ],
                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
              },
            ],
          },
        ],
        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
            },
            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
              &quot;segments&quot;: [ # Segments this audio response is composed of.
                { # Represents one segment of audio.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                },
              ],
            },
            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
            },
            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
            },
            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
            },
            &quot;text&quot;: { # The text response message. # Returns a text response.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text responses.
                &quot;A String&quot;,
              ],
            },
          },
        ],
        &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
          { # Setting a parameter value.
            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
          },
        ],
        &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
      },
    },
  ],
  &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the flow. Format: `projects//locations//agents//flows/`.
  &quot;nluSettings&quot;: { # Settings related to NLU. # NLU related settings of the flow.
    &quot;classificationThreshold&quot;: 3.14, # To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold. If the returned score value is less than the threshold value, then a no-match event will be triggered. The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used.
    &quot;modelTrainingMode&quot;: &quot;A String&quot;, # Indicates NLU model training mode.
    &quot;modelType&quot;: &quot;A String&quot;, # Indicates the type of NLU model.
  },
  &quot;transitionRouteGroups&quot;: [ # A flow&#x27;s transition route group serve two purposes: * They are responsible for matching the user&#x27;s first utterances in the flow. * They are inherited by every page&#x27;s transition route groups. Transition route groups defined in the page have higher priority than those defined in the flow. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
    &quot;A String&quot;,
  ],
  &quot;transitionRoutes&quot;: [ # A flow&#x27;s transition routes serve two purposes: * They are responsible for matching the user&#x27;s first utterances in the flow. * They are inherited by every page&#x27;s transition routes and can support use cases such as the user saying &quot;help&quot; or &quot;can I talk to a human?&quot;, which can be handled in a common way regardless of the current page. Transition routes defined in the page have higher priority than those defined in the flow. TransitionRoutes are evalauted in the following order: * TransitionRoutes with intent specified. * TransitionRoutes with only condition specified. TransitionRoutes with intent specified are inherited by pages in the flow.
    { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
      &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
      &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
      &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
      &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
      &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
      &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
            &quot;cases&quot;: [ # A list of cascading if-else conditions.
              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                &quot;caseContent&quot;: [ # A list of case content.
                  { # The list of messages or conditional cases to activate for this case.
                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  },
                ],
                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
              },
            ],
          },
        ],
        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
            },
            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
              &quot;segments&quot;: [ # Segments this audio response is composed of.
                { # Represents one segment of audio.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                },
              ],
            },
            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
            },
            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
            },
            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
            },
            &quot;text&quot;: { # The text response message. # Returns a text response.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text responses.
                &quot;A String&quot;,
              ],
            },
          },
        ],
        &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
          { # Setting a parameter value.
            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
          },
        ],
        &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
      },
    },
  ],
}</pre>
</div>

<div class="method">
    <code class="details" id="delete">delete(name, force=None, x__xgafv=None)</code>
  <pre>Deletes a specified flow.

Args:
  name: string, Required. The name of the flow to delete. Format: `projects//locations//agents//flows/`. (required)
  force: boolean, This field has no effect for flows with no incoming transitions. For flows with incoming transitions: * If `force` is set to false, an error will be returned with message indicating the incoming transitions. * If `force` is set to true, Dialogflow will remove the flow, as well as any transitions to the flow (i.e. Target flow in event handlers or Target flow in transition routes that point to this flow will be cleared).
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
}</pre>
</div>

<div class="method">
    <code class="details" id="export">export(name, body=None, x__xgafv=None)</code>
  <pre>Exports the specified flow to a binary file. This method is a [long-running operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation). The returned `Operation` type has the following method-specific fields: - `metadata`: An empty [Struct message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#struct) - `response`: ExportFlowResponse Note that resources (e.g. intents, entities, webhooks) that the flow references will also be exported.

Args:
  name: string, Required. The name of the flow to export. Format: `projects//locations//agents//flows/`. (required)
  body: object, The request body.
    The object takes the form of:

{ # The request message for Flows.ExportFlow.
  &quot;flowUri&quot;: &quot;A String&quot;, # Optional. The [Google Cloud Storage](https://cloud.google.com/storage/docs/) URI to export the flow to. The format of this URI must be `gs:///`. If left unspecified, the serialized flow is returned inline. Dialogflow performs a write operation for the Cloud Storage object on the caller&#x27;s behalf, so your request authentication must have write permissions for the object. For more information, see [Dialogflow access control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
  &quot;includeReferencedFlows&quot;: True or False, # Optional. Whether to export flows referenced by the specified flow.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # This resource represents a long-running operation that is the result of a network API call.
  &quot;done&quot;: True or False, # If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The error result of the operation in case of failure or cancellation.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;metadata&quot;: { # Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
  &quot;name&quot;: &quot;A String&quot;, # The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
  &quot;response&quot;: { # The normal response of the operation in case of success. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="get">get(name, languageCode=None, x__xgafv=None)</code>
  <pre>Retrieves the specified flow.

Args:
  name: string, Required. The name of the flow to get. Format: `projects//locations//agents//flows/`. (required)
  languageCode: string, The language to retrieve the flow for. The following fields are language dependent: * `Flow.event_handlers.trigger_fulfillment.messages` * `Flow.event_handlers.trigger_fulfillment.conditional_cases` * `Flow.transition_routes.trigger_fulfillment.messages` * `Flow.transition_routes.trigger_fulfillment.conditional_cases` If not specified, the agent&#x27;s default language is used. [Many languages](https://cloud.google.com/dialogflow/cx/docs/reference/language) are supported. Note: languages must be enabled in the agent before they can be used.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Flows represents the conversation flows when you build your chatbot agent. A flow consists of many pages connected by the transition routes. Conversations always start with the built-in Start Flow (with an all-0 ID). Transition routes can direct the conversation session from the current flow (parent flow) to another flow (sub flow). When the sub flow is finished, Dialogflow will bring the session back to the parent flow, where the sub flow is started. Usually, when a transition route is followed by a matched intent, the intent will be &quot;consumed&quot;. This means the intent won&#x27;t activate more transition routes. However, when the followed transition route moves the conversation session into a different flow, the matched intent can be carried over and to be consumed in the target flow.
  &quot;description&quot;: &quot;A String&quot;, # The description of the flow. The maximum length is 500 characters. If exceeded, the request is rejected.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the flow.
  &quot;eventHandlers&quot;: [ # A flow&#x27;s event handlers serve two purposes: * They are responsible for handling events (e.g. no match, webhook errors) in the flow. * They are inherited by every page&#x27;s event handlers, which can be used to handle common events regardless of the current page. Event handlers defined in the page have higher priority than those defined in the flow. Unlike transition_routes, these handlers are evaluated on a first-match basis. The first one that matches the event get executed, with the rest being ignored.
    { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
      &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
      &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
      &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
      &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
      &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
            &quot;cases&quot;: [ # A list of cascading if-else conditions.
              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                &quot;caseContent&quot;: [ # A list of case content.
                  { # The list of messages or conditional cases to activate for this case.
                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  },
                ],
                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
              },
            ],
          },
        ],
        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
            },
            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
              &quot;segments&quot;: [ # Segments this audio response is composed of.
                { # Represents one segment of audio.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                },
              ],
            },
            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
            },
            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
            },
            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
            },
            &quot;text&quot;: { # The text response message. # Returns a text response.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text responses.
                &quot;A String&quot;,
              ],
            },
          },
        ],
        &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
          { # Setting a parameter value.
            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
          },
        ],
        &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
      },
    },
  ],
  &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the flow. Format: `projects//locations//agents//flows/`.
  &quot;nluSettings&quot;: { # Settings related to NLU. # NLU related settings of the flow.
    &quot;classificationThreshold&quot;: 3.14, # To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold. If the returned score value is less than the threshold value, then a no-match event will be triggered. The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used.
    &quot;modelTrainingMode&quot;: &quot;A String&quot;, # Indicates NLU model training mode.
    &quot;modelType&quot;: &quot;A String&quot;, # Indicates the type of NLU model.
  },
  &quot;transitionRouteGroups&quot;: [ # A flow&#x27;s transition route group serve two purposes: * They are responsible for matching the user&#x27;s first utterances in the flow. * They are inherited by every page&#x27;s transition route groups. Transition route groups defined in the page have higher priority than those defined in the flow. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
    &quot;A String&quot;,
  ],
  &quot;transitionRoutes&quot;: [ # A flow&#x27;s transition routes serve two purposes: * They are responsible for matching the user&#x27;s first utterances in the flow. * They are inherited by every page&#x27;s transition routes and can support use cases such as the user saying &quot;help&quot; or &quot;can I talk to a human?&quot;, which can be handled in a common way regardless of the current page. Transition routes defined in the page have higher priority than those defined in the flow. TransitionRoutes are evalauted in the following order: * TransitionRoutes with intent specified. * TransitionRoutes with only condition specified. TransitionRoutes with intent specified are inherited by pages in the flow.
    { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
      &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
      &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
      &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
      &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
      &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
      &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
            &quot;cases&quot;: [ # A list of cascading if-else conditions.
              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                &quot;caseContent&quot;: [ # A list of case content.
                  { # The list of messages or conditional cases to activate for this case.
                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  },
                ],
                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
              },
            ],
          },
        ],
        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
            },
            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
              &quot;segments&quot;: [ # Segments this audio response is composed of.
                { # Represents one segment of audio.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                },
              ],
            },
            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
            },
            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
            },
            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
            },
            &quot;text&quot;: { # The text response message. # Returns a text response.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text responses.
                &quot;A String&quot;,
              ],
            },
          },
        ],
        &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
          { # Setting a parameter value.
            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
          },
        ],
        &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
      },
    },
  ],
}</pre>
</div>

<div class="method">
    <code class="details" id="getValidationResult">getValidationResult(name, languageCode=None, x__xgafv=None)</code>
  <pre>Gets the latest flow validation result. Flow validation is performed when ValidateFlow is called.

Args:
  name: string, Required. The flow name. Format: `projects//locations//agents//flows//validationResult`. (required)
  languageCode: string, If not specified, the agent&#x27;s default language is used.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The response message for Flows.GetFlowValidationResult.
  &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the flow validation result. Format: `projects//locations//agents//flows//validationResult`.
  &quot;updateTime&quot;: &quot;A String&quot;, # Last time the flow was validated.
  &quot;validationMessages&quot;: [ # Contains all validation messages.
    { # Agent/flow validation message.
      &quot;detail&quot;: &quot;A String&quot;, # The message detail.
      &quot;resourceNames&quot;: [ # The resource names of the resources where the message is found.
        { # Resource name and display name.
          &quot;displayName&quot;: &quot;A String&quot;, # Display name.
          &quot;name&quot;: &quot;A String&quot;, # Name.
        },
      ],
      &quot;resourceType&quot;: &quot;A String&quot;, # The type of the resources where the message is found.
      &quot;resources&quot;: [ # The names of the resources where the message is found.
        &quot;A String&quot;,
      ],
      &quot;severity&quot;: &quot;A String&quot;, # Indicates the severity of the message.
    },
  ],
}</pre>
</div>

<div class="method">
    <code class="details" id="import_">import_(parent, body=None, x__xgafv=None)</code>
  <pre>Imports the specified flow to the specified agent from a binary file. This method is a [long-running operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation). The returned `Operation` type has the following method-specific fields: - `metadata`: An empty [Struct message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#struct) - `response`: ImportFlowResponse Note: You should always train a flow prior to sending it queries. See the [training documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).

Args:
  parent: string, Required. The agent to import the flow into. Format: `projects//locations//agents/`. (required)
  body: object, The request body.
    The object takes the form of:

{ # The request message for Flows.ImportFlow.
  &quot;flowContent&quot;: &quot;A String&quot;, # Uncompressed raw byte content for flow.
  &quot;flowUri&quot;: &quot;A String&quot;, # The [Google Cloud Storage](https://cloud.google.com/storage/docs/) URI to import flow from. The format of this URI must be `gs:///`. Dialogflow performs a read operation for the Cloud Storage object on the caller&#x27;s behalf, so your request authentication must have read permissions for the object. For more information, see [Dialogflow access control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
  &quot;importOption&quot;: &quot;A String&quot;, # Flow import mode. If not specified, `KEEP` is assumed.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # This resource represents a long-running operation that is the result of a network API call.
  &quot;done&quot;: True or False, # If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The error result of the operation in case of failure or cancellation.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;metadata&quot;: { # Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
  &quot;name&quot;: &quot;A String&quot;, # The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
  &quot;response&quot;: { # The normal response of the operation in case of success. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="list">list(parent, languageCode=None, pageSize=None, pageToken=None, x__xgafv=None)</code>
  <pre>Returns the list of all flows in the specified agent.

Args:
  parent: string, Required. The agent containing the flows. Format: `projects//locations//agents/`. (required)
  languageCode: string, The language to list flows for. The following fields are language dependent: * `Flow.event_handlers.trigger_fulfillment.messages` * `Flow.event_handlers.trigger_fulfillment.conditional_cases` * `Flow.transition_routes.trigger_fulfillment.messages` * `Flow.transition_routes.trigger_fulfillment.conditional_cases` If not specified, the agent&#x27;s default language is used. [Many languages](https://cloud.google.com/dialogflow/cx/docs/reference/language) are supported. Note: languages must be enabled in the agent before they can be used.
  pageSize: integer, The maximum number of items to return in a single page. By default 100 and at most 1000.
  pageToken: string, The next_page_token value returned from a previous list request.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The response message for Flows.ListFlows.
  &quot;flows&quot;: [ # The list of flows. There will be a maximum number of items returned based on the page_size field in the request.
    { # Flows represents the conversation flows when you build your chatbot agent. A flow consists of many pages connected by the transition routes. Conversations always start with the built-in Start Flow (with an all-0 ID). Transition routes can direct the conversation session from the current flow (parent flow) to another flow (sub flow). When the sub flow is finished, Dialogflow will bring the session back to the parent flow, where the sub flow is started. Usually, when a transition route is followed by a matched intent, the intent will be &quot;consumed&quot;. This means the intent won&#x27;t activate more transition routes. However, when the followed transition route moves the conversation session into a different flow, the matched intent can be carried over and to be consumed in the target flow.
      &quot;description&quot;: &quot;A String&quot;, # The description of the flow. The maximum length is 500 characters. If exceeded, the request is rejected.
      &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the flow.
      &quot;eventHandlers&quot;: [ # A flow&#x27;s event handlers serve two purposes: * They are responsible for handling events (e.g. no match, webhook errors) in the flow. * They are inherited by every page&#x27;s event handlers, which can be used to handle common events regardless of the current page. Event handlers defined in the page have higher priority than those defined in the flow. Unlike transition_routes, these handlers are evaluated on a first-match basis. The first one that matches the event get executed, with the rest being ignored.
        { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
          &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
          &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
          &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
          &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
          &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text responses.
                              &quot;A String&quot;,
                            ],
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text responses.
                    &quot;A String&quot;,
                  ],
                },
              },
            ],
            &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
        },
      ],
      &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the flow. Format: `projects//locations//agents//flows/`.
      &quot;nluSettings&quot;: { # Settings related to NLU. # NLU related settings of the flow.
        &quot;classificationThreshold&quot;: 3.14, # To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold. If the returned score value is less than the threshold value, then a no-match event will be triggered. The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used.
        &quot;modelTrainingMode&quot;: &quot;A String&quot;, # Indicates NLU model training mode.
        &quot;modelType&quot;: &quot;A String&quot;, # Indicates the type of NLU model.
      },
      &quot;transitionRouteGroups&quot;: [ # A flow&#x27;s transition route group serve two purposes: * They are responsible for matching the user&#x27;s first utterances in the flow. * They are inherited by every page&#x27;s transition route groups. Transition route groups defined in the page have higher priority than those defined in the flow. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
        &quot;A String&quot;,
      ],
      &quot;transitionRoutes&quot;: [ # A flow&#x27;s transition routes serve two purposes: * They are responsible for matching the user&#x27;s first utterances in the flow. * They are inherited by every page&#x27;s transition routes and can support use cases such as the user saying &quot;help&quot; or &quot;can I talk to a human?&quot;, which can be handled in a common way regardless of the current page. Transition routes defined in the page have higher priority than those defined in the flow. TransitionRoutes are evalauted in the following order: * TransitionRoutes with intent specified. * TransitionRoutes with only condition specified. TransitionRoutes with intent specified are inherited by pages in the flow.
        { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
          &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
          &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
          &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
          &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
          &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
          &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text responses.
                              &quot;A String&quot;,
                            ],
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text responses.
                    &quot;A String&quot;,
                  ],
                },
              },
            ],
            &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
        },
      ],
    },
  ],
  &quot;nextPageToken&quot;: &quot;A String&quot;, # Token to retrieve the next page of results, or empty if there are no more results in the list.
}</pre>
</div>

<div class="method">
    <code class="details" id="list_next">list_next()</code>
  <pre>Retrieves the next page of results.

        Args:
          previous_request: The request for the previous page. (required)
          previous_response: The response from the request for the previous page. (required)

        Returns:
          A request object that you can call &#x27;execute()&#x27; on to request the next
          page. Returns None if there are no more items in the collection.
        </pre>
</div>

<div class="method">
    <code class="details" id="patch">patch(name, body=None, languageCode=None, updateMask=None, x__xgafv=None)</code>
  <pre>Updates the specified flow. Note: You should always train a flow prior to sending it queries. See the [training documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).

Args:
  name: string, The unique identifier of the flow. Format: `projects//locations//agents//flows/`. (required)
  body: object, The request body.
    The object takes the form of:

{ # Flows represents the conversation flows when you build your chatbot agent. A flow consists of many pages connected by the transition routes. Conversations always start with the built-in Start Flow (with an all-0 ID). Transition routes can direct the conversation session from the current flow (parent flow) to another flow (sub flow). When the sub flow is finished, Dialogflow will bring the session back to the parent flow, where the sub flow is started. Usually, when a transition route is followed by a matched intent, the intent will be &quot;consumed&quot;. This means the intent won&#x27;t activate more transition routes. However, when the followed transition route moves the conversation session into a different flow, the matched intent can be carried over and to be consumed in the target flow.
  &quot;description&quot;: &quot;A String&quot;, # The description of the flow. The maximum length is 500 characters. If exceeded, the request is rejected.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the flow.
  &quot;eventHandlers&quot;: [ # A flow&#x27;s event handlers serve two purposes: * They are responsible for handling events (e.g. no match, webhook errors) in the flow. * They are inherited by every page&#x27;s event handlers, which can be used to handle common events regardless of the current page. Event handlers defined in the page have higher priority than those defined in the flow. Unlike transition_routes, these handlers are evaluated on a first-match basis. The first one that matches the event get executed, with the rest being ignored.
    { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
      &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
      &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
      &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
      &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
      &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
            &quot;cases&quot;: [ # A list of cascading if-else conditions.
              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                &quot;caseContent&quot;: [ # A list of case content.
                  { # The list of messages or conditional cases to activate for this case.
                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  },
                ],
                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
              },
            ],
          },
        ],
        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
            },
            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
              &quot;segments&quot;: [ # Segments this audio response is composed of.
                { # Represents one segment of audio.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                },
              ],
            },
            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
            },
            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
            },
            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
            },
            &quot;text&quot;: { # The text response message. # Returns a text response.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text responses.
                &quot;A String&quot;,
              ],
            },
          },
        ],
        &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
          { # Setting a parameter value.
            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
          },
        ],
        &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
      },
    },
  ],
  &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the flow. Format: `projects//locations//agents//flows/`.
  &quot;nluSettings&quot;: { # Settings related to NLU. # NLU related settings of the flow.
    &quot;classificationThreshold&quot;: 3.14, # To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold. If the returned score value is less than the threshold value, then a no-match event will be triggered. The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used.
    &quot;modelTrainingMode&quot;: &quot;A String&quot;, # Indicates NLU model training mode.
    &quot;modelType&quot;: &quot;A String&quot;, # Indicates the type of NLU model.
  },
  &quot;transitionRouteGroups&quot;: [ # A flow&#x27;s transition route group serve two purposes: * They are responsible for matching the user&#x27;s first utterances in the flow. * They are inherited by every page&#x27;s transition route groups. Transition route groups defined in the page have higher priority than those defined in the flow. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
    &quot;A String&quot;,
  ],
  &quot;transitionRoutes&quot;: [ # A flow&#x27;s transition routes serve two purposes: * They are responsible for matching the user&#x27;s first utterances in the flow. * They are inherited by every page&#x27;s transition routes and can support use cases such as the user saying &quot;help&quot; or &quot;can I talk to a human?&quot;, which can be handled in a common way regardless of the current page. Transition routes defined in the page have higher priority than those defined in the flow. TransitionRoutes are evalauted in the following order: * TransitionRoutes with intent specified. * TransitionRoutes with only condition specified. TransitionRoutes with intent specified are inherited by pages in the flow.
    { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
      &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
      &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
      &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
      &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
      &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
      &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
            &quot;cases&quot;: [ # A list of cascading if-else conditions.
              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                &quot;caseContent&quot;: [ # A list of case content.
                  { # The list of messages or conditional cases to activate for this case.
                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  },
                ],
                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
              },
            ],
          },
        ],
        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
            },
            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
              &quot;segments&quot;: [ # Segments this audio response is composed of.
                { # Represents one segment of audio.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                },
              ],
            },
            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
            },
            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
            },
            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
            },
            &quot;text&quot;: { # The text response message. # Returns a text response.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text responses.
                &quot;A String&quot;,
              ],
            },
          },
        ],
        &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
          { # Setting a parameter value.
            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
          },
        ],
        &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
      },
    },
  ],
}

  languageCode: string, The language of the following fields in `flow`: * `Flow.event_handlers.trigger_fulfillment.messages` * `Flow.event_handlers.trigger_fulfillment.conditional_cases` * `Flow.transition_routes.trigger_fulfillment.messages` * `Flow.transition_routes.trigger_fulfillment.conditional_cases` If not specified, the agent&#x27;s default language is used. [Many languages](https://cloud.google.com/dialogflow/cx/docs/reference/language) are supported. Note: languages must be enabled in the agent before they can be used.
  updateMask: string, The mask to control which fields get updated. If the mask is not present, all fields will be updated.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Flows represents the conversation flows when you build your chatbot agent. A flow consists of many pages connected by the transition routes. Conversations always start with the built-in Start Flow (with an all-0 ID). Transition routes can direct the conversation session from the current flow (parent flow) to another flow (sub flow). When the sub flow is finished, Dialogflow will bring the session back to the parent flow, where the sub flow is started. Usually, when a transition route is followed by a matched intent, the intent will be &quot;consumed&quot;. This means the intent won&#x27;t activate more transition routes. However, when the followed transition route moves the conversation session into a different flow, the matched intent can be carried over and to be consumed in the target flow.
  &quot;description&quot;: &quot;A String&quot;, # The description of the flow. The maximum length is 500 characters. If exceeded, the request is rejected.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the flow.
  &quot;eventHandlers&quot;: [ # A flow&#x27;s event handlers serve two purposes: * They are responsible for handling events (e.g. no match, webhook errors) in the flow. * They are inherited by every page&#x27;s event handlers, which can be used to handle common events regardless of the current page. Event handlers defined in the page have higher priority than those defined in the flow. Unlike transition_routes, these handlers are evaluated on a first-match basis. The first one that matches the event get executed, with the rest being ignored.
    { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
      &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
      &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
      &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
      &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
      &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
            &quot;cases&quot;: [ # A list of cascading if-else conditions.
              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                &quot;caseContent&quot;: [ # A list of case content.
                  { # The list of messages or conditional cases to activate for this case.
                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  },
                ],
                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
              },
            ],
          },
        ],
        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
            },
            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
              &quot;segments&quot;: [ # Segments this audio response is composed of.
                { # Represents one segment of audio.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                },
              ],
            },
            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
            },
            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
            },
            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
            },
            &quot;text&quot;: { # The text response message. # Returns a text response.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text responses.
                &quot;A String&quot;,
              ],
            },
          },
        ],
        &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
          { # Setting a parameter value.
            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
          },
        ],
        &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
      },
    },
  ],
  &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the flow. Format: `projects//locations//agents//flows/`.
  &quot;nluSettings&quot;: { # Settings related to NLU. # NLU related settings of the flow.
    &quot;classificationThreshold&quot;: 3.14, # To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold. If the returned score value is less than the threshold value, then a no-match event will be triggered. The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used.
    &quot;modelTrainingMode&quot;: &quot;A String&quot;, # Indicates NLU model training mode.
    &quot;modelType&quot;: &quot;A String&quot;, # Indicates the type of NLU model.
  },
  &quot;transitionRouteGroups&quot;: [ # A flow&#x27;s transition route group serve two purposes: * They are responsible for matching the user&#x27;s first utterances in the flow. * They are inherited by every page&#x27;s transition route groups. Transition route groups defined in the page have higher priority than those defined in the flow. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
    &quot;A String&quot;,
  ],
  &quot;transitionRoutes&quot;: [ # A flow&#x27;s transition routes serve two purposes: * They are responsible for matching the user&#x27;s first utterances in the flow. * They are inherited by every page&#x27;s transition routes and can support use cases such as the user saying &quot;help&quot; or &quot;can I talk to a human?&quot;, which can be handled in a common way regardless of the current page. Transition routes defined in the page have higher priority than those defined in the flow. TransitionRoutes are evalauted in the following order: * TransitionRoutes with intent specified. * TransitionRoutes with only condition specified. TransitionRoutes with intent specified are inherited by pages in the flow.
    { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
      &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
      &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
      &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
      &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
      &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
      &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
            &quot;cases&quot;: [ # A list of cascading if-else conditions.
              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                &quot;caseContent&quot;: [ # A list of case content.
                  { # The list of messages or conditional cases to activate for this case.
                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  },
                ],
                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
              },
            ],
          },
        ],
        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
            },
            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
              &quot;segments&quot;: [ # Segments this audio response is composed of.
                { # Represents one segment of audio.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                },
              ],
            },
            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
            },
            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
            },
            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
            },
            &quot;text&quot;: { # The text response message. # Returns a text response.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text responses.
                &quot;A String&quot;,
              ],
            },
          },
        ],
        &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
          { # Setting a parameter value.
            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
          },
        ],
        &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
      },
    },
  ],
}</pre>
</div>

<div class="method">
    <code class="details" id="train">train(name, body=None, x__xgafv=None)</code>
  <pre>Trains the specified flow. Note that only the flow in &#x27;draft&#x27; environment is trained. This method is a [long-running operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation). The returned `Operation` type has the following method-specific fields: - `metadata`: An empty [Struct message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#struct) - `response`: An [Empty message](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#empty) Note: You should always train a flow prior to sending it queries. See the [training documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).

Args:
  name: string, Required. The flow to train. Format: `projects//locations//agents//flows/`. (required)
  body: object, The request body.
    The object takes the form of:

{ # The request message for Flows.TrainFlow.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # This resource represents a long-running operation that is the result of a network API call.
  &quot;done&quot;: True or False, # If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The error result of the operation in case of failure or cancellation.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;metadata&quot;: { # Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
  &quot;name&quot;: &quot;A String&quot;, # The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
  &quot;response&quot;: { # The normal response of the operation in case of success. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="validate">validate(name, body=None, x__xgafv=None)</code>
  <pre>Validates the specified flow and creates or updates validation results. Please call this API after the training is completed to get the complete validation results.

Args:
  name: string, Required. The flow to validate. Format: `projects//locations//agents//flows/`. (required)
  body: object, The request body.
    The object takes the form of:

{ # The request message for Flows.ValidateFlow.
  &quot;languageCode&quot;: &quot;A String&quot;, # If not specified, the agent&#x27;s default language is used.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The response message for Flows.GetFlowValidationResult.
  &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the flow validation result. Format: `projects//locations//agents//flows//validationResult`.
  &quot;updateTime&quot;: &quot;A String&quot;, # Last time the flow was validated.
  &quot;validationMessages&quot;: [ # Contains all validation messages.
    { # Agent/flow validation message.
      &quot;detail&quot;: &quot;A String&quot;, # The message detail.
      &quot;resourceNames&quot;: [ # The resource names of the resources where the message is found.
        { # Resource name and display name.
          &quot;displayName&quot;: &quot;A String&quot;, # Display name.
          &quot;name&quot;: &quot;A String&quot;, # Name.
        },
      ],
      &quot;resourceType&quot;: &quot;A String&quot;, # The type of the resources where the message is found.
      &quot;resources&quot;: [ # The names of the resources where the message is found.
        &quot;A String&quot;,
      ],
      &quot;severity&quot;: &quot;A String&quot;, # Indicates the severity of the message.
    },
  ],
}</pre>
</div>

</body></html>