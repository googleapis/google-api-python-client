<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="cloudchannel_v1.html">Cloud Channel API</a> . <a href="cloudchannel_v1.accounts.html">accounts</a> . <a href="cloudchannel_v1.accounts.customers.html">customers</a> . <a href="cloudchannel_v1.accounts.customers.customerRepricingConfigs.html">customerRepricingConfigs</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#create">create(parent, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Creates a CustomerRepricingConfig. Call this method to set modifications for a specific customer's bill. You can only create configs if the RepricingConfig.effective_invoice_month is a future month. If needed, you can create a config for the current month, with some restrictions. When creating a config for a future month, make sure there are no existing configs for that RepricingConfig.effective_invoice_month. The following restrictions are for creating configs in the current month. * This functionality is reserved for recovering from an erroneous config, and should not be used for regular business cases. * The new config will not modify exports used with other configs. Changes to the config may be immediate, but may take up to 24 hours. * There is a limit of ten configs for any RepricingConfig.EntitlementGranularity.entitlement or RepricingConfig.effective_invoice_month. * The contained CustomerRepricingConfig.repricing_config vaule must be different from the value used in the current config for a RepricingConfig.EntitlementGranularity.entitlement. Possible Error Codes: * PERMISSION_DENIED: If the account making the request and the account being queried are different. * INVALID_ARGUMENT: Missing or invalid required parameters in the request. Also displays if the updated config is for the current month or past months. * NOT_FOUND: The CustomerRepricingConfig specified does not exist or is not associated with the given account. * INTERNAL: Any non-user error related to technical issues in the backend. In this case, contact Cloud Channel support. Return Value: If successful, the updated CustomerRepricingConfig resource, otherwise returns an error.</p>
<p class="toc_element">
  <code><a href="#delete">delete(name, x__xgafv=None)</a></code></p>
<p class="firstline">Deletes the given CustomerRepricingConfig permanently. You can only delete configs if their RepricingConfig.effective_invoice_month is set to a date after the current month. Possible error codes: * PERMISSION_DENIED: The account making the request does not own this customer. * INVALID_ARGUMENT: Required request parameters are missing or invalid. * FAILED_PRECONDITION: The CustomerRepricingConfig is active or in the past. * NOT_FOUND: No CustomerRepricingConfig found for the name in the request.</p>
<p class="toc_element">
  <code><a href="#get">get(name, x__xgafv=None)</a></code></p>
<p class="firstline">Gets information about how a Reseller modifies their bill before sending it to a Customer. Possible Error Codes: * PERMISSION_DENIED: If the account making the request and the account being queried are different. * NOT_FOUND: The CustomerRepricingConfig was not found. * INTERNAL: Any non-user error related to technical issues in the backend. In this case, contact Cloud Channel support. Return Value: If successful, the CustomerRepricingConfig resource, otherwise returns an error.</p>
<p class="toc_element">
  <code><a href="#list">list(parent, filter=None, pageSize=None, pageToken=None, x__xgafv=None)</a></code></p>
<p class="firstline">Lists information about how a Reseller modifies their bill before sending it to a Customer. Possible Error Codes: * PERMISSION_DENIED: If the account making the request and the account being queried are different. * NOT_FOUND: The CustomerRepricingConfig specified does not exist or is not associated with the given account. * INTERNAL: Any non-user error related to technical issues in the backend. In this case, contact Cloud Channel support. Return Value: If successful, the CustomerRepricingConfig resources. The data for each resource is displayed in the ascending order of: * customer ID * RepricingConfig.EntitlementGranularity.entitlement * RepricingConfig.effective_invoice_month * CustomerRepricingConfig.update_time If unsuccessful, returns an error.</p>
<p class="toc_element">
  <code><a href="#list_next">list_next()</a></code></p>
<p class="firstline">Retrieves the next page of results.</p>
<p class="toc_element">
  <code><a href="#patch">patch(name, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Updates a CustomerRepricingConfig. Call this method to set modifications for a specific customer's bill. This method overwrites the existing CustomerRepricingConfig. You can only update configs if the RepricingConfig.effective_invoice_month is a future month. To make changes to configs for the current month, use CreateCustomerRepricingConfig, taking note of its restrictions. You cannot update the RepricingConfig.effective_invoice_month. When updating a config in the future: * This config must already exist. Possible Error Codes: * PERMISSION_DENIED: If the account making the request and the account being queried are different. * INVALID_ARGUMENT: Missing or invalid required parameters in the request. Also displays if the updated config is for the current month or past months. * NOT_FOUND: The CustomerRepricingConfig specified does not exist or is not associated with the given account. * INTERNAL: Any non-user error related to technical issues in the backend. In this case, contact Cloud Channel support. Return Value: If successful, the updated CustomerRepricingConfig resource, otherwise returns an error.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="create">create(parent, body=None, x__xgafv=None)</code>
  <pre>Creates a CustomerRepricingConfig. Call this method to set modifications for a specific customer&#x27;s bill. You can only create configs if the RepricingConfig.effective_invoice_month is a future month. If needed, you can create a config for the current month, with some restrictions. When creating a config for a future month, make sure there are no existing configs for that RepricingConfig.effective_invoice_month. The following restrictions are for creating configs in the current month. * This functionality is reserved for recovering from an erroneous config, and should not be used for regular business cases. * The new config will not modify exports used with other configs. Changes to the config may be immediate, but may take up to 24 hours. * There is a limit of ten configs for any RepricingConfig.EntitlementGranularity.entitlement or RepricingConfig.effective_invoice_month. * The contained CustomerRepricingConfig.repricing_config vaule must be different from the value used in the current config for a RepricingConfig.EntitlementGranularity.entitlement. Possible Error Codes: * PERMISSION_DENIED: If the account making the request and the account being queried are different. * INVALID_ARGUMENT: Missing or invalid required parameters in the request. Also displays if the updated config is for the current month or past months. * NOT_FOUND: The CustomerRepricingConfig specified does not exist or is not associated with the given account. * INTERNAL: Any non-user error related to technical issues in the backend. In this case, contact Cloud Channel support. Return Value: If successful, the updated CustomerRepricingConfig resource, otherwise returns an error.

Args:
  parent: string, Required. The resource name of the customer that will receive this repricing config. Parent uses the format: accounts/{account_id}/customers/{customer_id} (required)
  body: object, The request body.
    The object takes the form of:

{ # Configuration for how a reseller will reprice a Customer.
  &quot;name&quot;: &quot;A String&quot;, # Output only. Resource name of the CustomerRepricingConfig. Format: accounts/{account_id}/customers/{customer_id}/customerRepricingConfigs/{id}.
  &quot;repricingConfig&quot;: { # Configuration for repricing a Google bill over a period of time. # Required. The configuration for bill modifications made by a reseller before sending it to customers.
    &quot;adjustment&quot;: { # A type that represents the various adjustments you can apply to a bill. # Required. Information about the adjustment.
      &quot;percentageAdjustment&quot;: { # An adjustment that applies a flat markup or markdown to an entire bill. # Flat markup or markdown on an entire bill.
        &quot;percentage&quot;: { # A representation of a decimal value, such as 2.5. Clients may convert values into language-native decimal formats, such as Java&#x27;s BigDecimal or Python&#x27;s decimal.Decimal. [BigDecimal]: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigDecimal.html [decimal.Decimal]: https://docs.python.org/3/library/decimal.html # The percentage of the bill to adjust. For example: Mark down by 1% =&gt; &quot;-1.00&quot; Mark up by 1% =&gt; &quot;1.00&quot; Pass-Through =&gt; &quot;0.00&quot;
          &quot;value&quot;: &quot;A String&quot;, # The decimal value, as a string. The string representation consists of an optional sign, `+` (`U+002B`) or `-` (`U+002D`), followed by a sequence of zero or more decimal digits (&quot;the integer&quot;), optionally followed by a fraction, optionally followed by an exponent. An empty string **should** be interpreted as `0`. The fraction consists of a decimal point followed by zero or more decimal digits. The string must contain at least one digit in either the integer or the fraction. The number formed by the sign, the integer and the fraction is referred to as the significand. The exponent consists of the character `e` (`U+0065`) or `E` (`U+0045`) followed by one or more decimal digits. Services **should** normalize decimal values before storing them by: - Removing an explicitly-provided `+` sign (`+2.5` -&gt; `2.5`). - Replacing a zero-length integer value with `0` (`.5` -&gt; `0.5`). - Coercing the exponent character to upper-case, with explicit sign (`2.5e8` -&gt; `2.5E+8`). - Removing an explicitly-provided zero exponent (`2.5E0` -&gt; `2.5`). Services **may** perform additional normalization based on its own needs and the internal decimal implementation selected, such as shifting the decimal point and exponent value together (example: `2.5E-1` &lt;-&gt; `0.25`). Additionally, services **may** preserve trailing zeroes in the fraction to indicate increased precision, but are not required to do so. Note that only the `.` character is supported to divide the integer and the fraction; `,` **should not** be supported regardless of locale. Additionally, thousand separators **should not** be supported. If a service does support them, values **must** be normalized. The ENBF grammar is: DecimalString = &#x27;&#x27; | [Sign] Significand [Exponent]; Sign = &#x27;+&#x27; | &#x27;-&#x27;; Significand = Digits &#x27;.&#x27; | [Digits] &#x27;.&#x27; Digits; Exponent = (&#x27;e&#x27; | &#x27;E&#x27;) [Sign] Digits; Digits = { &#x27;0&#x27; | &#x27;1&#x27; | &#x27;2&#x27; | &#x27;3&#x27; | &#x27;4&#x27; | &#x27;5&#x27; | &#x27;6&#x27; | &#x27;7&#x27; | &#x27;8&#x27; | &#x27;9&#x27; }; Services **should** clearly document the range of supported values, the maximum supported precision (total number of digits), and, if applicable, the scale (number of digits after the decimal point), as well as how it behaves when receiving out-of-bounds values. Services **may** choose to accept values passed as input even when the value has a higher precision or scale than the service supports, and **should** round the value to fit the supported scale. Alternatively, the service **may** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC) if precision would be lost. Services **should** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC) if the service receives a value outside of the supported range.
        },
      },
    },
    &quot;channelPartnerGranularity&quot;: { # Applies the repricing configuration at the channel partner level. The channel partner value is derived from the resource name. Takes an empty json object. # Applies the repricing configuration at the channel partner level. This is the only supported value for ChannelPartnerRepricingConfig.
    },
    &quot;conditionalOverrides&quot;: [ # The conditional overrides to apply for this configuration. If you list multiple overrides, only the first valid override is used. If you don&#x27;t list any overrides, the API uses the normal adjustment and rebilling basis.
      { # Specifies the override to conditionally apply.
        &quot;adjustment&quot;: { # A type that represents the various adjustments you can apply to a bill. # Required. Information about the applied override&#x27;s adjustment.
          &quot;percentageAdjustment&quot;: { # An adjustment that applies a flat markup or markdown to an entire bill. # Flat markup or markdown on an entire bill.
            &quot;percentage&quot;: { # A representation of a decimal value, such as 2.5. Clients may convert values into language-native decimal formats, such as Java&#x27;s BigDecimal or Python&#x27;s decimal.Decimal. [BigDecimal]: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigDecimal.html [decimal.Decimal]: https://docs.python.org/3/library/decimal.html # The percentage of the bill to adjust. For example: Mark down by 1% =&gt; &quot;-1.00&quot; Mark up by 1% =&gt; &quot;1.00&quot; Pass-Through =&gt; &quot;0.00&quot;
              &quot;value&quot;: &quot;A String&quot;, # The decimal value, as a string. The string representation consists of an optional sign, `+` (`U+002B`) or `-` (`U+002D`), followed by a sequence of zero or more decimal digits (&quot;the integer&quot;), optionally followed by a fraction, optionally followed by an exponent. An empty string **should** be interpreted as `0`. The fraction consists of a decimal point followed by zero or more decimal digits. The string must contain at least one digit in either the integer or the fraction. The number formed by the sign, the integer and the fraction is referred to as the significand. The exponent consists of the character `e` (`U+0065`) or `E` (`U+0045`) followed by one or more decimal digits. Services **should** normalize decimal values before storing them by: - Removing an explicitly-provided `+` sign (`+2.5` -&gt; `2.5`). - Replacing a zero-length integer value with `0` (`.5` -&gt; `0.5`). - Coercing the exponent character to upper-case, with explicit sign (`2.5e8` -&gt; `2.5E+8`). - Removing an explicitly-provided zero exponent (`2.5E0` -&gt; `2.5`). Services **may** perform additional normalization based on its own needs and the internal decimal implementation selected, such as shifting the decimal point and exponent value together (example: `2.5E-1` &lt;-&gt; `0.25`). Additionally, services **may** preserve trailing zeroes in the fraction to indicate increased precision, but are not required to do so. Note that only the `.` character is supported to divide the integer and the fraction; `,` **should not** be supported regardless of locale. Additionally, thousand separators **should not** be supported. If a service does support them, values **must** be normalized. The ENBF grammar is: DecimalString = &#x27;&#x27; | [Sign] Significand [Exponent]; Sign = &#x27;+&#x27; | &#x27;-&#x27;; Significand = Digits &#x27;.&#x27; | [Digits] &#x27;.&#x27; Digits; Exponent = (&#x27;e&#x27; | &#x27;E&#x27;) [Sign] Digits; Digits = { &#x27;0&#x27; | &#x27;1&#x27; | &#x27;2&#x27; | &#x27;3&#x27; | &#x27;4&#x27; | &#x27;5&#x27; | &#x27;6&#x27; | &#x27;7&#x27; | &#x27;8&#x27; | &#x27;9&#x27; }; Services **should** clearly document the range of supported values, the maximum supported precision (total number of digits), and, if applicable, the scale (number of digits after the decimal point), as well as how it behaves when receiving out-of-bounds values. Services **may** choose to accept values passed as input even when the value has a higher precision or scale than the service supports, and **should** round the value to fit the supported scale. Alternatively, the service **may** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC) if precision would be lost. Services **should** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC) if the service receives a value outside of the supported range.
            },
          },
        },
        &quot;rebillingBasis&quot;: &quot;A String&quot;, # Required. The RebillingBasis to use for the applied override. Shows the relative cost based on your repricing costs.
        &quot;repricingCondition&quot;: { # Represents the various repricing conditions you can use for a conditional override. # Required. Specifies the condition which, if met, will apply the override.
          &quot;skuGroupCondition&quot;: { # A condition that applies the override if a line item SKU is found in the SKU group. # SKU Group condition for override.
            &quot;skuGroup&quot;: &quot;A String&quot;, # Specifies a SKU group (https://cloud.google.com/skus/sku-groups). Resource name of SKU group. Format: accounts/{account}/skuGroups/{sku_group}. Example: &quot;accounts/C01234/skuGroups/3d50fd57-3157-4577-a5a9-a219b8490041&quot;.
          },
        },
      },
    ],
    &quot;effectiveInvoiceMonth&quot;: { # Represents a whole or partial calendar date, such as a birthday. The time of day and time zone are either specified elsewhere or are insignificant. The date is relative to the Gregorian Calendar. This can represent one of the following: * A full date, with non-zero year, month, and day values. * A month and day, with a zero year (for example, an anniversary). * A year on its own, with a zero month and a zero day. * A year and month, with a zero day (for example, a credit card expiration date). Related types: * google.type.TimeOfDay * google.type.DateTime * google.protobuf.Timestamp # Required. The YearMonth when these adjustments activate. The Day field needs to be &quot;0&quot; since we only accept YearMonth repricing boundaries.
      &quot;day&quot;: 42, # Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn&#x27;t significant.
      &quot;month&quot;: 42, # Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
      &quot;year&quot;: 42, # Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
    },
    &quot;entitlementGranularity&quot;: { # Applies the repricing configuration at the entitlement level. # Applies the repricing configuration at the entitlement level. This is the only supported value for CustomerRepricingConfig.
      &quot;entitlement&quot;: &quot;A String&quot;, # Resource name of the entitlement. Format: accounts/{account_id}/customers/{customer_id}/entitlements/{entitlement_id}
    },
    &quot;rebillingBasis&quot;: &quot;A String&quot;, # Required. The RebillingBasis to use for this bill. Specifies the relative cost based on repricing costs you will apply.
  },
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp of an update to the repricing rule. If `update_time` is after RepricingConfig.effective_invoice_month then it indicates this was set mid-month.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Configuration for how a reseller will reprice a Customer.
  &quot;name&quot;: &quot;A String&quot;, # Output only. Resource name of the CustomerRepricingConfig. Format: accounts/{account_id}/customers/{customer_id}/customerRepricingConfigs/{id}.
  &quot;repricingConfig&quot;: { # Configuration for repricing a Google bill over a period of time. # Required. The configuration for bill modifications made by a reseller before sending it to customers.
    &quot;adjustment&quot;: { # A type that represents the various adjustments you can apply to a bill. # Required. Information about the adjustment.
      &quot;percentageAdjustment&quot;: { # An adjustment that applies a flat markup or markdown to an entire bill. # Flat markup or markdown on an entire bill.
        &quot;percentage&quot;: { # A representation of a decimal value, such as 2.5. Clients may convert values into language-native decimal formats, such as Java&#x27;s BigDecimal or Python&#x27;s decimal.Decimal. [BigDecimal]: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigDecimal.html [decimal.Decimal]: https://docs.python.org/3/library/decimal.html # The percentage of the bill to adjust. For example: Mark down by 1% =&gt; &quot;-1.00&quot; Mark up by 1% =&gt; &quot;1.00&quot; Pass-Through =&gt; &quot;0.00&quot;
          &quot;value&quot;: &quot;A String&quot;, # The decimal value, as a string. The string representation consists of an optional sign, `+` (`U+002B`) or `-` (`U+002D`), followed by a sequence of zero or more decimal digits (&quot;the integer&quot;), optionally followed by a fraction, optionally followed by an exponent. An empty string **should** be interpreted as `0`. The fraction consists of a decimal point followed by zero or more decimal digits. The string must contain at least one digit in either the integer or the fraction. The number formed by the sign, the integer and the fraction is referred to as the significand. The exponent consists of the character `e` (`U+0065`) or `E` (`U+0045`) followed by one or more decimal digits. Services **should** normalize decimal values before storing them by: - Removing an explicitly-provided `+` sign (`+2.5` -&gt; `2.5`). - Replacing a zero-length integer value with `0` (`.5` -&gt; `0.5`). - Coercing the exponent character to upper-case, with explicit sign (`2.5e8` -&gt; `2.5E+8`). - Removing an explicitly-provided zero exponent (`2.5E0` -&gt; `2.5`). Services **may** perform additional normalization based on its own needs and the internal decimal implementation selected, such as shifting the decimal point and exponent value together (example: `2.5E-1` &lt;-&gt; `0.25`). Additionally, services **may** preserve trailing zeroes in the fraction to indicate increased precision, but are not required to do so. Note that only the `.` character is supported to divide the integer and the fraction; `,` **should not** be supported regardless of locale. Additionally, thousand separators **should not** be supported. If a service does support them, values **must** be normalized. The ENBF grammar is: DecimalString = &#x27;&#x27; | [Sign] Significand [Exponent]; Sign = &#x27;+&#x27; | &#x27;-&#x27;; Significand = Digits &#x27;.&#x27; | [Digits] &#x27;.&#x27; Digits; Exponent = (&#x27;e&#x27; | &#x27;E&#x27;) [Sign] Digits; Digits = { &#x27;0&#x27; | &#x27;1&#x27; | &#x27;2&#x27; | &#x27;3&#x27; | &#x27;4&#x27; | &#x27;5&#x27; | &#x27;6&#x27; | &#x27;7&#x27; | &#x27;8&#x27; | &#x27;9&#x27; }; Services **should** clearly document the range of supported values, the maximum supported precision (total number of digits), and, if applicable, the scale (number of digits after the decimal point), as well as how it behaves when receiving out-of-bounds values. Services **may** choose to accept values passed as input even when the value has a higher precision or scale than the service supports, and **should** round the value to fit the supported scale. Alternatively, the service **may** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC) if precision would be lost. Services **should** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC) if the service receives a value outside of the supported range.
        },
      },
    },
    &quot;channelPartnerGranularity&quot;: { # Applies the repricing configuration at the channel partner level. The channel partner value is derived from the resource name. Takes an empty json object. # Applies the repricing configuration at the channel partner level. This is the only supported value for ChannelPartnerRepricingConfig.
    },
    &quot;conditionalOverrides&quot;: [ # The conditional overrides to apply for this configuration. If you list multiple overrides, only the first valid override is used. If you don&#x27;t list any overrides, the API uses the normal adjustment and rebilling basis.
      { # Specifies the override to conditionally apply.
        &quot;adjustment&quot;: { # A type that represents the various adjustments you can apply to a bill. # Required. Information about the applied override&#x27;s adjustment.
          &quot;percentageAdjustment&quot;: { # An adjustment that applies a flat markup or markdown to an entire bill. # Flat markup or markdown on an entire bill.
            &quot;percentage&quot;: { # A representation of a decimal value, such as 2.5. Clients may convert values into language-native decimal formats, such as Java&#x27;s BigDecimal or Python&#x27;s decimal.Decimal. [BigDecimal]: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigDecimal.html [decimal.Decimal]: https://docs.python.org/3/library/decimal.html # The percentage of the bill to adjust. For example: Mark down by 1% =&gt; &quot;-1.00&quot; Mark up by 1% =&gt; &quot;1.00&quot; Pass-Through =&gt; &quot;0.00&quot;
              &quot;value&quot;: &quot;A String&quot;, # The decimal value, as a string. The string representation consists of an optional sign, `+` (`U+002B`) or `-` (`U+002D`), followed by a sequence of zero or more decimal digits (&quot;the integer&quot;), optionally followed by a fraction, optionally followed by an exponent. An empty string **should** be interpreted as `0`. The fraction consists of a decimal point followed by zero or more decimal digits. The string must contain at least one digit in either the integer or the fraction. The number formed by the sign, the integer and the fraction is referred to as the significand. The exponent consists of the character `e` (`U+0065`) or `E` (`U+0045`) followed by one or more decimal digits. Services **should** normalize decimal values before storing them by: - Removing an explicitly-provided `+` sign (`+2.5` -&gt; `2.5`). - Replacing a zero-length integer value with `0` (`.5` -&gt; `0.5`). - Coercing the exponent character to upper-case, with explicit sign (`2.5e8` -&gt; `2.5E+8`). - Removing an explicitly-provided zero exponent (`2.5E0` -&gt; `2.5`). Services **may** perform additional normalization based on its own needs and the internal decimal implementation selected, such as shifting the decimal point and exponent value together (example: `2.5E-1` &lt;-&gt; `0.25`). Additionally, services **may** preserve trailing zeroes in the fraction to indicate increased precision, but are not required to do so. Note that only the `.` character is supported to divide the integer and the fraction; `,` **should not** be supported regardless of locale. Additionally, thousand separators **should not** be supported. If a service does support them, values **must** be normalized. The ENBF grammar is: DecimalString = &#x27;&#x27; | [Sign] Significand [Exponent]; Sign = &#x27;+&#x27; | &#x27;-&#x27;; Significand = Digits &#x27;.&#x27; | [Digits] &#x27;.&#x27; Digits; Exponent = (&#x27;e&#x27; | &#x27;E&#x27;) [Sign] Digits; Digits = { &#x27;0&#x27; | &#x27;1&#x27; | &#x27;2&#x27; | &#x27;3&#x27; | &#x27;4&#x27; | &#x27;5&#x27; | &#x27;6&#x27; | &#x27;7&#x27; | &#x27;8&#x27; | &#x27;9&#x27; }; Services **should** clearly document the range of supported values, the maximum supported precision (total number of digits), and, if applicable, the scale (number of digits after the decimal point), as well as how it behaves when receiving out-of-bounds values. Services **may** choose to accept values passed as input even when the value has a higher precision or scale than the service supports, and **should** round the value to fit the supported scale. Alternatively, the service **may** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC) if precision would be lost. Services **should** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC) if the service receives a value outside of the supported range.
            },
          },
        },
        &quot;rebillingBasis&quot;: &quot;A String&quot;, # Required. The RebillingBasis to use for the applied override. Shows the relative cost based on your repricing costs.
        &quot;repricingCondition&quot;: { # Represents the various repricing conditions you can use for a conditional override. # Required. Specifies the condition which, if met, will apply the override.
          &quot;skuGroupCondition&quot;: { # A condition that applies the override if a line item SKU is found in the SKU group. # SKU Group condition for override.
            &quot;skuGroup&quot;: &quot;A String&quot;, # Specifies a SKU group (https://cloud.google.com/skus/sku-groups). Resource name of SKU group. Format: accounts/{account}/skuGroups/{sku_group}. Example: &quot;accounts/C01234/skuGroups/3d50fd57-3157-4577-a5a9-a219b8490041&quot;.
          },
        },
      },
    ],
    &quot;effectiveInvoiceMonth&quot;: { # Represents a whole or partial calendar date, such as a birthday. The time of day and time zone are either specified elsewhere or are insignificant. The date is relative to the Gregorian Calendar. This can represent one of the following: * A full date, with non-zero year, month, and day values. * A month and day, with a zero year (for example, an anniversary). * A year on its own, with a zero month and a zero day. * A year and month, with a zero day (for example, a credit card expiration date). Related types: * google.type.TimeOfDay * google.type.DateTime * google.protobuf.Timestamp # Required. The YearMonth when these adjustments activate. The Day field needs to be &quot;0&quot; since we only accept YearMonth repricing boundaries.
      &quot;day&quot;: 42, # Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn&#x27;t significant.
      &quot;month&quot;: 42, # Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
      &quot;year&quot;: 42, # Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
    },
    &quot;entitlementGranularity&quot;: { # Applies the repricing configuration at the entitlement level. # Applies the repricing configuration at the entitlement level. This is the only supported value for CustomerRepricingConfig.
      &quot;entitlement&quot;: &quot;A String&quot;, # Resource name of the entitlement. Format: accounts/{account_id}/customers/{customer_id}/entitlements/{entitlement_id}
    },
    &quot;rebillingBasis&quot;: &quot;A String&quot;, # Required. The RebillingBasis to use for this bill. Specifies the relative cost based on repricing costs you will apply.
  },
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp of an update to the repricing rule. If `update_time` is after RepricingConfig.effective_invoice_month then it indicates this was set mid-month.
}</pre>
</div>

<div class="method">
    <code class="details" id="delete">delete(name, x__xgafv=None)</code>
  <pre>Deletes the given CustomerRepricingConfig permanently. You can only delete configs if their RepricingConfig.effective_invoice_month is set to a date after the current month. Possible error codes: * PERMISSION_DENIED: The account making the request does not own this customer. * INVALID_ARGUMENT: Required request parameters are missing or invalid. * FAILED_PRECONDITION: The CustomerRepricingConfig is active or in the past. * NOT_FOUND: No CustomerRepricingConfig found for the name in the request.

Args:
  name: string, Required. The resource name of the customer repricing config rule to delete. Format: accounts/{account_id}/customers/{customer_id}/customerRepricingConfigs/{id}. (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
}</pre>
</div>

<div class="method">
    <code class="details" id="get">get(name, x__xgafv=None)</code>
  <pre>Gets information about how a Reseller modifies their bill before sending it to a Customer. Possible Error Codes: * PERMISSION_DENIED: If the account making the request and the account being queried are different. * NOT_FOUND: The CustomerRepricingConfig was not found. * INTERNAL: Any non-user error related to technical issues in the backend. In this case, contact Cloud Channel support. Return Value: If successful, the CustomerRepricingConfig resource, otherwise returns an error.

Args:
  name: string, Required. The resource name of the CustomerRepricingConfig. Format: accounts/{account_id}/customers/{customer_id}/customerRepricingConfigs/{id}. (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Configuration for how a reseller will reprice a Customer.
  &quot;name&quot;: &quot;A String&quot;, # Output only. Resource name of the CustomerRepricingConfig. Format: accounts/{account_id}/customers/{customer_id}/customerRepricingConfigs/{id}.
  &quot;repricingConfig&quot;: { # Configuration for repricing a Google bill over a period of time. # Required. The configuration for bill modifications made by a reseller before sending it to customers.
    &quot;adjustment&quot;: { # A type that represents the various adjustments you can apply to a bill. # Required. Information about the adjustment.
      &quot;percentageAdjustment&quot;: { # An adjustment that applies a flat markup or markdown to an entire bill. # Flat markup or markdown on an entire bill.
        &quot;percentage&quot;: { # A representation of a decimal value, such as 2.5. Clients may convert values into language-native decimal formats, such as Java&#x27;s BigDecimal or Python&#x27;s decimal.Decimal. [BigDecimal]: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigDecimal.html [decimal.Decimal]: https://docs.python.org/3/library/decimal.html # The percentage of the bill to adjust. For example: Mark down by 1% =&gt; &quot;-1.00&quot; Mark up by 1% =&gt; &quot;1.00&quot; Pass-Through =&gt; &quot;0.00&quot;
          &quot;value&quot;: &quot;A String&quot;, # The decimal value, as a string. The string representation consists of an optional sign, `+` (`U+002B`) or `-` (`U+002D`), followed by a sequence of zero or more decimal digits (&quot;the integer&quot;), optionally followed by a fraction, optionally followed by an exponent. An empty string **should** be interpreted as `0`. The fraction consists of a decimal point followed by zero or more decimal digits. The string must contain at least one digit in either the integer or the fraction. The number formed by the sign, the integer and the fraction is referred to as the significand. The exponent consists of the character `e` (`U+0065`) or `E` (`U+0045`) followed by one or more decimal digits. Services **should** normalize decimal values before storing them by: - Removing an explicitly-provided `+` sign (`+2.5` -&gt; `2.5`). - Replacing a zero-length integer value with `0` (`.5` -&gt; `0.5`). - Coercing the exponent character to upper-case, with explicit sign (`2.5e8` -&gt; `2.5E+8`). - Removing an explicitly-provided zero exponent (`2.5E0` -&gt; `2.5`). Services **may** perform additional normalization based on its own needs and the internal decimal implementation selected, such as shifting the decimal point and exponent value together (example: `2.5E-1` &lt;-&gt; `0.25`). Additionally, services **may** preserve trailing zeroes in the fraction to indicate increased precision, but are not required to do so. Note that only the `.` character is supported to divide the integer and the fraction; `,` **should not** be supported regardless of locale. Additionally, thousand separators **should not** be supported. If a service does support them, values **must** be normalized. The ENBF grammar is: DecimalString = &#x27;&#x27; | [Sign] Significand [Exponent]; Sign = &#x27;+&#x27; | &#x27;-&#x27;; Significand = Digits &#x27;.&#x27; | [Digits] &#x27;.&#x27; Digits; Exponent = (&#x27;e&#x27; | &#x27;E&#x27;) [Sign] Digits; Digits = { &#x27;0&#x27; | &#x27;1&#x27; | &#x27;2&#x27; | &#x27;3&#x27; | &#x27;4&#x27; | &#x27;5&#x27; | &#x27;6&#x27; | &#x27;7&#x27; | &#x27;8&#x27; | &#x27;9&#x27; }; Services **should** clearly document the range of supported values, the maximum supported precision (total number of digits), and, if applicable, the scale (number of digits after the decimal point), as well as how it behaves when receiving out-of-bounds values. Services **may** choose to accept values passed as input even when the value has a higher precision or scale than the service supports, and **should** round the value to fit the supported scale. Alternatively, the service **may** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC) if precision would be lost. Services **should** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC) if the service receives a value outside of the supported range.
        },
      },
    },
    &quot;channelPartnerGranularity&quot;: { # Applies the repricing configuration at the channel partner level. The channel partner value is derived from the resource name. Takes an empty json object. # Applies the repricing configuration at the channel partner level. This is the only supported value for ChannelPartnerRepricingConfig.
    },
    &quot;conditionalOverrides&quot;: [ # The conditional overrides to apply for this configuration. If you list multiple overrides, only the first valid override is used. If you don&#x27;t list any overrides, the API uses the normal adjustment and rebilling basis.
      { # Specifies the override to conditionally apply.
        &quot;adjustment&quot;: { # A type that represents the various adjustments you can apply to a bill. # Required. Information about the applied override&#x27;s adjustment.
          &quot;percentageAdjustment&quot;: { # An adjustment that applies a flat markup or markdown to an entire bill. # Flat markup or markdown on an entire bill.
            &quot;percentage&quot;: { # A representation of a decimal value, such as 2.5. Clients may convert values into language-native decimal formats, such as Java&#x27;s BigDecimal or Python&#x27;s decimal.Decimal. [BigDecimal]: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigDecimal.html [decimal.Decimal]: https://docs.python.org/3/library/decimal.html # The percentage of the bill to adjust. For example: Mark down by 1% =&gt; &quot;-1.00&quot; Mark up by 1% =&gt; &quot;1.00&quot; Pass-Through =&gt; &quot;0.00&quot;
              &quot;value&quot;: &quot;A String&quot;, # The decimal value, as a string. The string representation consists of an optional sign, `+` (`U+002B`) or `-` (`U+002D`), followed by a sequence of zero or more decimal digits (&quot;the integer&quot;), optionally followed by a fraction, optionally followed by an exponent. An empty string **should** be interpreted as `0`. The fraction consists of a decimal point followed by zero or more decimal digits. The string must contain at least one digit in either the integer or the fraction. The number formed by the sign, the integer and the fraction is referred to as the significand. The exponent consists of the character `e` (`U+0065`) or `E` (`U+0045`) followed by one or more decimal digits. Services **should** normalize decimal values before storing them by: - Removing an explicitly-provided `+` sign (`+2.5` -&gt; `2.5`). - Replacing a zero-length integer value with `0` (`.5` -&gt; `0.5`). - Coercing the exponent character to upper-case, with explicit sign (`2.5e8` -&gt; `2.5E+8`). - Removing an explicitly-provided zero exponent (`2.5E0` -&gt; `2.5`). Services **may** perform additional normalization based on its own needs and the internal decimal implementation selected, such as shifting the decimal point and exponent value together (example: `2.5E-1` &lt;-&gt; `0.25`). Additionally, services **may** preserve trailing zeroes in the fraction to indicate increased precision, but are not required to do so. Note that only the `.` character is supported to divide the integer and the fraction; `,` **should not** be supported regardless of locale. Additionally, thousand separators **should not** be supported. If a service does support them, values **must** be normalized. The ENBF grammar is: DecimalString = &#x27;&#x27; | [Sign] Significand [Exponent]; Sign = &#x27;+&#x27; | &#x27;-&#x27;; Significand = Digits &#x27;.&#x27; | [Digits] &#x27;.&#x27; Digits; Exponent = (&#x27;e&#x27; | &#x27;E&#x27;) [Sign] Digits; Digits = { &#x27;0&#x27; | &#x27;1&#x27; | &#x27;2&#x27; | &#x27;3&#x27; | &#x27;4&#x27; | &#x27;5&#x27; | &#x27;6&#x27; | &#x27;7&#x27; | &#x27;8&#x27; | &#x27;9&#x27; }; Services **should** clearly document the range of supported values, the maximum supported precision (total number of digits), and, if applicable, the scale (number of digits after the decimal point), as well as how it behaves when receiving out-of-bounds values. Services **may** choose to accept values passed as input even when the value has a higher precision or scale than the service supports, and **should** round the value to fit the supported scale. Alternatively, the service **may** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC) if precision would be lost. Services **should** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC) if the service receives a value outside of the supported range.
            },
          },
        },
        &quot;rebillingBasis&quot;: &quot;A String&quot;, # Required. The RebillingBasis to use for the applied override. Shows the relative cost based on your repricing costs.
        &quot;repricingCondition&quot;: { # Represents the various repricing conditions you can use for a conditional override. # Required. Specifies the condition which, if met, will apply the override.
          &quot;skuGroupCondition&quot;: { # A condition that applies the override if a line item SKU is found in the SKU group. # SKU Group condition for override.
            &quot;skuGroup&quot;: &quot;A String&quot;, # Specifies a SKU group (https://cloud.google.com/skus/sku-groups). Resource name of SKU group. Format: accounts/{account}/skuGroups/{sku_group}. Example: &quot;accounts/C01234/skuGroups/3d50fd57-3157-4577-a5a9-a219b8490041&quot;.
          },
        },
      },
    ],
    &quot;effectiveInvoiceMonth&quot;: { # Represents a whole or partial calendar date, such as a birthday. The time of day and time zone are either specified elsewhere or are insignificant. The date is relative to the Gregorian Calendar. This can represent one of the following: * A full date, with non-zero year, month, and day values. * A month and day, with a zero year (for example, an anniversary). * A year on its own, with a zero month and a zero day. * A year and month, with a zero day (for example, a credit card expiration date). Related types: * google.type.TimeOfDay * google.type.DateTime * google.protobuf.Timestamp # Required. The YearMonth when these adjustments activate. The Day field needs to be &quot;0&quot; since we only accept YearMonth repricing boundaries.
      &quot;day&quot;: 42, # Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn&#x27;t significant.
      &quot;month&quot;: 42, # Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
      &quot;year&quot;: 42, # Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
    },
    &quot;entitlementGranularity&quot;: { # Applies the repricing configuration at the entitlement level. # Applies the repricing configuration at the entitlement level. This is the only supported value for CustomerRepricingConfig.
      &quot;entitlement&quot;: &quot;A String&quot;, # Resource name of the entitlement. Format: accounts/{account_id}/customers/{customer_id}/entitlements/{entitlement_id}
    },
    &quot;rebillingBasis&quot;: &quot;A String&quot;, # Required. The RebillingBasis to use for this bill. Specifies the relative cost based on repricing costs you will apply.
  },
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp of an update to the repricing rule. If `update_time` is after RepricingConfig.effective_invoice_month then it indicates this was set mid-month.
}</pre>
</div>

<div class="method">
    <code class="details" id="list">list(parent, filter=None, pageSize=None, pageToken=None, x__xgafv=None)</code>
  <pre>Lists information about how a Reseller modifies their bill before sending it to a Customer. Possible Error Codes: * PERMISSION_DENIED: If the account making the request and the account being queried are different. * NOT_FOUND: The CustomerRepricingConfig specified does not exist or is not associated with the given account. * INTERNAL: Any non-user error related to technical issues in the backend. In this case, contact Cloud Channel support. Return Value: If successful, the CustomerRepricingConfig resources. The data for each resource is displayed in the ascending order of: * customer ID * RepricingConfig.EntitlementGranularity.entitlement * RepricingConfig.effective_invoice_month * CustomerRepricingConfig.update_time If unsuccessful, returns an error.

Args:
  parent: string, Required. The resource name of the customer. Parent uses the format: accounts/{account_id}/customers/{customer_id}. Supports accounts/{account_id}/customers/- to retrieve configs for all customers. (required)
  filter: string, Optional. A filter for [CloudChannelService.ListCustomerRepricingConfigs] results (customer only). You can use this filter when you support a BatchGet-like query. To use the filter, you must set `parent=accounts/{account_id}/customers/-`. Example: customer = accounts/account_id/customers/c1 OR customer = accounts/account_id/customers/c2.
  pageSize: integer, Optional. The maximum number of repricing configs to return. The service may return fewer than this value. If unspecified, returns a maximum of 50 rules. The maximum value is 100; values above 100 will be coerced to 100.
  pageToken: string, Optional. A token identifying a page of results beyond the first page. Obtained through ListCustomerRepricingConfigsResponse.next_page_token of the previous CloudChannelService.ListCustomerRepricingConfigs call.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response message for CloudChannelService.ListCustomerRepricingConfigs.
  &quot;customerRepricingConfigs&quot;: [ # The repricing configs for this channel partner.
    { # Configuration for how a reseller will reprice a Customer.
      &quot;name&quot;: &quot;A String&quot;, # Output only. Resource name of the CustomerRepricingConfig. Format: accounts/{account_id}/customers/{customer_id}/customerRepricingConfigs/{id}.
      &quot;repricingConfig&quot;: { # Configuration for repricing a Google bill over a period of time. # Required. The configuration for bill modifications made by a reseller before sending it to customers.
        &quot;adjustment&quot;: { # A type that represents the various adjustments you can apply to a bill. # Required. Information about the adjustment.
          &quot;percentageAdjustment&quot;: { # An adjustment that applies a flat markup or markdown to an entire bill. # Flat markup or markdown on an entire bill.
            &quot;percentage&quot;: { # A representation of a decimal value, such as 2.5. Clients may convert values into language-native decimal formats, such as Java&#x27;s BigDecimal or Python&#x27;s decimal.Decimal. [BigDecimal]: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigDecimal.html [decimal.Decimal]: https://docs.python.org/3/library/decimal.html # The percentage of the bill to adjust. For example: Mark down by 1% =&gt; &quot;-1.00&quot; Mark up by 1% =&gt; &quot;1.00&quot; Pass-Through =&gt; &quot;0.00&quot;
              &quot;value&quot;: &quot;A String&quot;, # The decimal value, as a string. The string representation consists of an optional sign, `+` (`U+002B`) or `-` (`U+002D`), followed by a sequence of zero or more decimal digits (&quot;the integer&quot;), optionally followed by a fraction, optionally followed by an exponent. An empty string **should** be interpreted as `0`. The fraction consists of a decimal point followed by zero or more decimal digits. The string must contain at least one digit in either the integer or the fraction. The number formed by the sign, the integer and the fraction is referred to as the significand. The exponent consists of the character `e` (`U+0065`) or `E` (`U+0045`) followed by one or more decimal digits. Services **should** normalize decimal values before storing them by: - Removing an explicitly-provided `+` sign (`+2.5` -&gt; `2.5`). - Replacing a zero-length integer value with `0` (`.5` -&gt; `0.5`). - Coercing the exponent character to upper-case, with explicit sign (`2.5e8` -&gt; `2.5E+8`). - Removing an explicitly-provided zero exponent (`2.5E0` -&gt; `2.5`). Services **may** perform additional normalization based on its own needs and the internal decimal implementation selected, such as shifting the decimal point and exponent value together (example: `2.5E-1` &lt;-&gt; `0.25`). Additionally, services **may** preserve trailing zeroes in the fraction to indicate increased precision, but are not required to do so. Note that only the `.` character is supported to divide the integer and the fraction; `,` **should not** be supported regardless of locale. Additionally, thousand separators **should not** be supported. If a service does support them, values **must** be normalized. The ENBF grammar is: DecimalString = &#x27;&#x27; | [Sign] Significand [Exponent]; Sign = &#x27;+&#x27; | &#x27;-&#x27;; Significand = Digits &#x27;.&#x27; | [Digits] &#x27;.&#x27; Digits; Exponent = (&#x27;e&#x27; | &#x27;E&#x27;) [Sign] Digits; Digits = { &#x27;0&#x27; | &#x27;1&#x27; | &#x27;2&#x27; | &#x27;3&#x27; | &#x27;4&#x27; | &#x27;5&#x27; | &#x27;6&#x27; | &#x27;7&#x27; | &#x27;8&#x27; | &#x27;9&#x27; }; Services **should** clearly document the range of supported values, the maximum supported precision (total number of digits), and, if applicable, the scale (number of digits after the decimal point), as well as how it behaves when receiving out-of-bounds values. Services **may** choose to accept values passed as input even when the value has a higher precision or scale than the service supports, and **should** round the value to fit the supported scale. Alternatively, the service **may** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC) if precision would be lost. Services **should** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC) if the service receives a value outside of the supported range.
            },
          },
        },
        &quot;channelPartnerGranularity&quot;: { # Applies the repricing configuration at the channel partner level. The channel partner value is derived from the resource name. Takes an empty json object. # Applies the repricing configuration at the channel partner level. This is the only supported value for ChannelPartnerRepricingConfig.
        },
        &quot;conditionalOverrides&quot;: [ # The conditional overrides to apply for this configuration. If you list multiple overrides, only the first valid override is used. If you don&#x27;t list any overrides, the API uses the normal adjustment and rebilling basis.
          { # Specifies the override to conditionally apply.
            &quot;adjustment&quot;: { # A type that represents the various adjustments you can apply to a bill. # Required. Information about the applied override&#x27;s adjustment.
              &quot;percentageAdjustment&quot;: { # An adjustment that applies a flat markup or markdown to an entire bill. # Flat markup or markdown on an entire bill.
                &quot;percentage&quot;: { # A representation of a decimal value, such as 2.5. Clients may convert values into language-native decimal formats, such as Java&#x27;s BigDecimal or Python&#x27;s decimal.Decimal. [BigDecimal]: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigDecimal.html [decimal.Decimal]: https://docs.python.org/3/library/decimal.html # The percentage of the bill to adjust. For example: Mark down by 1% =&gt; &quot;-1.00&quot; Mark up by 1% =&gt; &quot;1.00&quot; Pass-Through =&gt; &quot;0.00&quot;
                  &quot;value&quot;: &quot;A String&quot;, # The decimal value, as a string. The string representation consists of an optional sign, `+` (`U+002B`) or `-` (`U+002D`), followed by a sequence of zero or more decimal digits (&quot;the integer&quot;), optionally followed by a fraction, optionally followed by an exponent. An empty string **should** be interpreted as `0`. The fraction consists of a decimal point followed by zero or more decimal digits. The string must contain at least one digit in either the integer or the fraction. The number formed by the sign, the integer and the fraction is referred to as the significand. The exponent consists of the character `e` (`U+0065`) or `E` (`U+0045`) followed by one or more decimal digits. Services **should** normalize decimal values before storing them by: - Removing an explicitly-provided `+` sign (`+2.5` -&gt; `2.5`). - Replacing a zero-length integer value with `0` (`.5` -&gt; `0.5`). - Coercing the exponent character to upper-case, with explicit sign (`2.5e8` -&gt; `2.5E+8`). - Removing an explicitly-provided zero exponent (`2.5E0` -&gt; `2.5`). Services **may** perform additional normalization based on its own needs and the internal decimal implementation selected, such as shifting the decimal point and exponent value together (example: `2.5E-1` &lt;-&gt; `0.25`). Additionally, services **may** preserve trailing zeroes in the fraction to indicate increased precision, but are not required to do so. Note that only the `.` character is supported to divide the integer and the fraction; `,` **should not** be supported regardless of locale. Additionally, thousand separators **should not** be supported. If a service does support them, values **must** be normalized. The ENBF grammar is: DecimalString = &#x27;&#x27; | [Sign] Significand [Exponent]; Sign = &#x27;+&#x27; | &#x27;-&#x27;; Significand = Digits &#x27;.&#x27; | [Digits] &#x27;.&#x27; Digits; Exponent = (&#x27;e&#x27; | &#x27;E&#x27;) [Sign] Digits; Digits = { &#x27;0&#x27; | &#x27;1&#x27; | &#x27;2&#x27; | &#x27;3&#x27; | &#x27;4&#x27; | &#x27;5&#x27; | &#x27;6&#x27; | &#x27;7&#x27; | &#x27;8&#x27; | &#x27;9&#x27; }; Services **should** clearly document the range of supported values, the maximum supported precision (total number of digits), and, if applicable, the scale (number of digits after the decimal point), as well as how it behaves when receiving out-of-bounds values. Services **may** choose to accept values passed as input even when the value has a higher precision or scale than the service supports, and **should** round the value to fit the supported scale. Alternatively, the service **may** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC) if precision would be lost. Services **should** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC) if the service receives a value outside of the supported range.
                },
              },
            },
            &quot;rebillingBasis&quot;: &quot;A String&quot;, # Required. The RebillingBasis to use for the applied override. Shows the relative cost based on your repricing costs.
            &quot;repricingCondition&quot;: { # Represents the various repricing conditions you can use for a conditional override. # Required. Specifies the condition which, if met, will apply the override.
              &quot;skuGroupCondition&quot;: { # A condition that applies the override if a line item SKU is found in the SKU group. # SKU Group condition for override.
                &quot;skuGroup&quot;: &quot;A String&quot;, # Specifies a SKU group (https://cloud.google.com/skus/sku-groups). Resource name of SKU group. Format: accounts/{account}/skuGroups/{sku_group}. Example: &quot;accounts/C01234/skuGroups/3d50fd57-3157-4577-a5a9-a219b8490041&quot;.
              },
            },
          },
        ],
        &quot;effectiveInvoiceMonth&quot;: { # Represents a whole or partial calendar date, such as a birthday. The time of day and time zone are either specified elsewhere or are insignificant. The date is relative to the Gregorian Calendar. This can represent one of the following: * A full date, with non-zero year, month, and day values. * A month and day, with a zero year (for example, an anniversary). * A year on its own, with a zero month and a zero day. * A year and month, with a zero day (for example, a credit card expiration date). Related types: * google.type.TimeOfDay * google.type.DateTime * google.protobuf.Timestamp # Required. The YearMonth when these adjustments activate. The Day field needs to be &quot;0&quot; since we only accept YearMonth repricing boundaries.
          &quot;day&quot;: 42, # Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn&#x27;t significant.
          &quot;month&quot;: 42, # Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
          &quot;year&quot;: 42, # Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        },
        &quot;entitlementGranularity&quot;: { # Applies the repricing configuration at the entitlement level. # Applies the repricing configuration at the entitlement level. This is the only supported value for CustomerRepricingConfig.
          &quot;entitlement&quot;: &quot;A String&quot;, # Resource name of the entitlement. Format: accounts/{account_id}/customers/{customer_id}/entitlements/{entitlement_id}
        },
        &quot;rebillingBasis&quot;: &quot;A String&quot;, # Required. The RebillingBasis to use for this bill. Specifies the relative cost based on repricing costs you will apply.
      },
      &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp of an update to the repricing rule. If `update_time` is after RepricingConfig.effective_invoice_month then it indicates this was set mid-month.
    },
  ],
  &quot;nextPageToken&quot;: &quot;A String&quot;, # A token to retrieve the next page of results. Pass to ListCustomerRepricingConfigsRequest.page_token to obtain that page.
}</pre>
</div>

<div class="method">
    <code class="details" id="list_next">list_next()</code>
  <pre>Retrieves the next page of results.

        Args:
          previous_request: The request for the previous page. (required)
          previous_response: The response from the request for the previous page. (required)

        Returns:
          A request object that you can call &#x27;execute()&#x27; on to request the next
          page. Returns None if there are no more items in the collection.
        </pre>
</div>

<div class="method">
    <code class="details" id="patch">patch(name, body=None, x__xgafv=None)</code>
  <pre>Updates a CustomerRepricingConfig. Call this method to set modifications for a specific customer&#x27;s bill. This method overwrites the existing CustomerRepricingConfig. You can only update configs if the RepricingConfig.effective_invoice_month is a future month. To make changes to configs for the current month, use CreateCustomerRepricingConfig, taking note of its restrictions. You cannot update the RepricingConfig.effective_invoice_month. When updating a config in the future: * This config must already exist. Possible Error Codes: * PERMISSION_DENIED: If the account making the request and the account being queried are different. * INVALID_ARGUMENT: Missing or invalid required parameters in the request. Also displays if the updated config is for the current month or past months. * NOT_FOUND: The CustomerRepricingConfig specified does not exist or is not associated with the given account. * INTERNAL: Any non-user error related to technical issues in the backend. In this case, contact Cloud Channel support. Return Value: If successful, the updated CustomerRepricingConfig resource, otherwise returns an error.

Args:
  name: string, Output only. Resource name of the CustomerRepricingConfig. Format: accounts/{account_id}/customers/{customer_id}/customerRepricingConfigs/{id}. (required)
  body: object, The request body.
    The object takes the form of:

{ # Configuration for how a reseller will reprice a Customer.
  &quot;name&quot;: &quot;A String&quot;, # Output only. Resource name of the CustomerRepricingConfig. Format: accounts/{account_id}/customers/{customer_id}/customerRepricingConfigs/{id}.
  &quot;repricingConfig&quot;: { # Configuration for repricing a Google bill over a period of time. # Required. The configuration for bill modifications made by a reseller before sending it to customers.
    &quot;adjustment&quot;: { # A type that represents the various adjustments you can apply to a bill. # Required. Information about the adjustment.
      &quot;percentageAdjustment&quot;: { # An adjustment that applies a flat markup or markdown to an entire bill. # Flat markup or markdown on an entire bill.
        &quot;percentage&quot;: { # A representation of a decimal value, such as 2.5. Clients may convert values into language-native decimal formats, such as Java&#x27;s BigDecimal or Python&#x27;s decimal.Decimal. [BigDecimal]: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigDecimal.html [decimal.Decimal]: https://docs.python.org/3/library/decimal.html # The percentage of the bill to adjust. For example: Mark down by 1% =&gt; &quot;-1.00&quot; Mark up by 1% =&gt; &quot;1.00&quot; Pass-Through =&gt; &quot;0.00&quot;
          &quot;value&quot;: &quot;A String&quot;, # The decimal value, as a string. The string representation consists of an optional sign, `+` (`U+002B`) or `-` (`U+002D`), followed by a sequence of zero or more decimal digits (&quot;the integer&quot;), optionally followed by a fraction, optionally followed by an exponent. An empty string **should** be interpreted as `0`. The fraction consists of a decimal point followed by zero or more decimal digits. The string must contain at least one digit in either the integer or the fraction. The number formed by the sign, the integer and the fraction is referred to as the significand. The exponent consists of the character `e` (`U+0065`) or `E` (`U+0045`) followed by one or more decimal digits. Services **should** normalize decimal values before storing them by: - Removing an explicitly-provided `+` sign (`+2.5` -&gt; `2.5`). - Replacing a zero-length integer value with `0` (`.5` -&gt; `0.5`). - Coercing the exponent character to upper-case, with explicit sign (`2.5e8` -&gt; `2.5E+8`). - Removing an explicitly-provided zero exponent (`2.5E0` -&gt; `2.5`). Services **may** perform additional normalization based on its own needs and the internal decimal implementation selected, such as shifting the decimal point and exponent value together (example: `2.5E-1` &lt;-&gt; `0.25`). Additionally, services **may** preserve trailing zeroes in the fraction to indicate increased precision, but are not required to do so. Note that only the `.` character is supported to divide the integer and the fraction; `,` **should not** be supported regardless of locale. Additionally, thousand separators **should not** be supported. If a service does support them, values **must** be normalized. The ENBF grammar is: DecimalString = &#x27;&#x27; | [Sign] Significand [Exponent]; Sign = &#x27;+&#x27; | &#x27;-&#x27;; Significand = Digits &#x27;.&#x27; | [Digits] &#x27;.&#x27; Digits; Exponent = (&#x27;e&#x27; | &#x27;E&#x27;) [Sign] Digits; Digits = { &#x27;0&#x27; | &#x27;1&#x27; | &#x27;2&#x27; | &#x27;3&#x27; | &#x27;4&#x27; | &#x27;5&#x27; | &#x27;6&#x27; | &#x27;7&#x27; | &#x27;8&#x27; | &#x27;9&#x27; }; Services **should** clearly document the range of supported values, the maximum supported precision (total number of digits), and, if applicable, the scale (number of digits after the decimal point), as well as how it behaves when receiving out-of-bounds values. Services **may** choose to accept values passed as input even when the value has a higher precision or scale than the service supports, and **should** round the value to fit the supported scale. Alternatively, the service **may** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC) if precision would be lost. Services **should** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC) if the service receives a value outside of the supported range.
        },
      },
    },
    &quot;channelPartnerGranularity&quot;: { # Applies the repricing configuration at the channel partner level. The channel partner value is derived from the resource name. Takes an empty json object. # Applies the repricing configuration at the channel partner level. This is the only supported value for ChannelPartnerRepricingConfig.
    },
    &quot;conditionalOverrides&quot;: [ # The conditional overrides to apply for this configuration. If you list multiple overrides, only the first valid override is used. If you don&#x27;t list any overrides, the API uses the normal adjustment and rebilling basis.
      { # Specifies the override to conditionally apply.
        &quot;adjustment&quot;: { # A type that represents the various adjustments you can apply to a bill. # Required. Information about the applied override&#x27;s adjustment.
          &quot;percentageAdjustment&quot;: { # An adjustment that applies a flat markup or markdown to an entire bill. # Flat markup or markdown on an entire bill.
            &quot;percentage&quot;: { # A representation of a decimal value, such as 2.5. Clients may convert values into language-native decimal formats, such as Java&#x27;s BigDecimal or Python&#x27;s decimal.Decimal. [BigDecimal]: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigDecimal.html [decimal.Decimal]: https://docs.python.org/3/library/decimal.html # The percentage of the bill to adjust. For example: Mark down by 1% =&gt; &quot;-1.00&quot; Mark up by 1% =&gt; &quot;1.00&quot; Pass-Through =&gt; &quot;0.00&quot;
              &quot;value&quot;: &quot;A String&quot;, # The decimal value, as a string. The string representation consists of an optional sign, `+` (`U+002B`) or `-` (`U+002D`), followed by a sequence of zero or more decimal digits (&quot;the integer&quot;), optionally followed by a fraction, optionally followed by an exponent. An empty string **should** be interpreted as `0`. The fraction consists of a decimal point followed by zero or more decimal digits. The string must contain at least one digit in either the integer or the fraction. The number formed by the sign, the integer and the fraction is referred to as the significand. The exponent consists of the character `e` (`U+0065`) or `E` (`U+0045`) followed by one or more decimal digits. Services **should** normalize decimal values before storing them by: - Removing an explicitly-provided `+` sign (`+2.5` -&gt; `2.5`). - Replacing a zero-length integer value with `0` (`.5` -&gt; `0.5`). - Coercing the exponent character to upper-case, with explicit sign (`2.5e8` -&gt; `2.5E+8`). - Removing an explicitly-provided zero exponent (`2.5E0` -&gt; `2.5`). Services **may** perform additional normalization based on its own needs and the internal decimal implementation selected, such as shifting the decimal point and exponent value together (example: `2.5E-1` &lt;-&gt; `0.25`). Additionally, services **may** preserve trailing zeroes in the fraction to indicate increased precision, but are not required to do so. Note that only the `.` character is supported to divide the integer and the fraction; `,` **should not** be supported regardless of locale. Additionally, thousand separators **should not** be supported. If a service does support them, values **must** be normalized. The ENBF grammar is: DecimalString = &#x27;&#x27; | [Sign] Significand [Exponent]; Sign = &#x27;+&#x27; | &#x27;-&#x27;; Significand = Digits &#x27;.&#x27; | [Digits] &#x27;.&#x27; Digits; Exponent = (&#x27;e&#x27; | &#x27;E&#x27;) [Sign] Digits; Digits = { &#x27;0&#x27; | &#x27;1&#x27; | &#x27;2&#x27; | &#x27;3&#x27; | &#x27;4&#x27; | &#x27;5&#x27; | &#x27;6&#x27; | &#x27;7&#x27; | &#x27;8&#x27; | &#x27;9&#x27; }; Services **should** clearly document the range of supported values, the maximum supported precision (total number of digits), and, if applicable, the scale (number of digits after the decimal point), as well as how it behaves when receiving out-of-bounds values. Services **may** choose to accept values passed as input even when the value has a higher precision or scale than the service supports, and **should** round the value to fit the supported scale. Alternatively, the service **may** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC) if precision would be lost. Services **should** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC) if the service receives a value outside of the supported range.
            },
          },
        },
        &quot;rebillingBasis&quot;: &quot;A String&quot;, # Required. The RebillingBasis to use for the applied override. Shows the relative cost based on your repricing costs.
        &quot;repricingCondition&quot;: { # Represents the various repricing conditions you can use for a conditional override. # Required. Specifies the condition which, if met, will apply the override.
          &quot;skuGroupCondition&quot;: { # A condition that applies the override if a line item SKU is found in the SKU group. # SKU Group condition for override.
            &quot;skuGroup&quot;: &quot;A String&quot;, # Specifies a SKU group (https://cloud.google.com/skus/sku-groups). Resource name of SKU group. Format: accounts/{account}/skuGroups/{sku_group}. Example: &quot;accounts/C01234/skuGroups/3d50fd57-3157-4577-a5a9-a219b8490041&quot;.
          },
        },
      },
    ],
    &quot;effectiveInvoiceMonth&quot;: { # Represents a whole or partial calendar date, such as a birthday. The time of day and time zone are either specified elsewhere or are insignificant. The date is relative to the Gregorian Calendar. This can represent one of the following: * A full date, with non-zero year, month, and day values. * A month and day, with a zero year (for example, an anniversary). * A year on its own, with a zero month and a zero day. * A year and month, with a zero day (for example, a credit card expiration date). Related types: * google.type.TimeOfDay * google.type.DateTime * google.protobuf.Timestamp # Required. The YearMonth when these adjustments activate. The Day field needs to be &quot;0&quot; since we only accept YearMonth repricing boundaries.
      &quot;day&quot;: 42, # Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn&#x27;t significant.
      &quot;month&quot;: 42, # Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
      &quot;year&quot;: 42, # Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
    },
    &quot;entitlementGranularity&quot;: { # Applies the repricing configuration at the entitlement level. # Applies the repricing configuration at the entitlement level. This is the only supported value for CustomerRepricingConfig.
      &quot;entitlement&quot;: &quot;A String&quot;, # Resource name of the entitlement. Format: accounts/{account_id}/customers/{customer_id}/entitlements/{entitlement_id}
    },
    &quot;rebillingBasis&quot;: &quot;A String&quot;, # Required. The RebillingBasis to use for this bill. Specifies the relative cost based on repricing costs you will apply.
  },
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp of an update to the repricing rule. If `update_time` is after RepricingConfig.effective_invoice_month then it indicates this was set mid-month.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Configuration for how a reseller will reprice a Customer.
  &quot;name&quot;: &quot;A String&quot;, # Output only. Resource name of the CustomerRepricingConfig. Format: accounts/{account_id}/customers/{customer_id}/customerRepricingConfigs/{id}.
  &quot;repricingConfig&quot;: { # Configuration for repricing a Google bill over a period of time. # Required. The configuration for bill modifications made by a reseller before sending it to customers.
    &quot;adjustment&quot;: { # A type that represents the various adjustments you can apply to a bill. # Required. Information about the adjustment.
      &quot;percentageAdjustment&quot;: { # An adjustment that applies a flat markup or markdown to an entire bill. # Flat markup or markdown on an entire bill.
        &quot;percentage&quot;: { # A representation of a decimal value, such as 2.5. Clients may convert values into language-native decimal formats, such as Java&#x27;s BigDecimal or Python&#x27;s decimal.Decimal. [BigDecimal]: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigDecimal.html [decimal.Decimal]: https://docs.python.org/3/library/decimal.html # The percentage of the bill to adjust. For example: Mark down by 1% =&gt; &quot;-1.00&quot; Mark up by 1% =&gt; &quot;1.00&quot; Pass-Through =&gt; &quot;0.00&quot;
          &quot;value&quot;: &quot;A String&quot;, # The decimal value, as a string. The string representation consists of an optional sign, `+` (`U+002B`) or `-` (`U+002D`), followed by a sequence of zero or more decimal digits (&quot;the integer&quot;), optionally followed by a fraction, optionally followed by an exponent. An empty string **should** be interpreted as `0`. The fraction consists of a decimal point followed by zero or more decimal digits. The string must contain at least one digit in either the integer or the fraction. The number formed by the sign, the integer and the fraction is referred to as the significand. The exponent consists of the character `e` (`U+0065`) or `E` (`U+0045`) followed by one or more decimal digits. Services **should** normalize decimal values before storing them by: - Removing an explicitly-provided `+` sign (`+2.5` -&gt; `2.5`). - Replacing a zero-length integer value with `0` (`.5` -&gt; `0.5`). - Coercing the exponent character to upper-case, with explicit sign (`2.5e8` -&gt; `2.5E+8`). - Removing an explicitly-provided zero exponent (`2.5E0` -&gt; `2.5`). Services **may** perform additional normalization based on its own needs and the internal decimal implementation selected, such as shifting the decimal point and exponent value together (example: `2.5E-1` &lt;-&gt; `0.25`). Additionally, services **may** preserve trailing zeroes in the fraction to indicate increased precision, but are not required to do so. Note that only the `.` character is supported to divide the integer and the fraction; `,` **should not** be supported regardless of locale. Additionally, thousand separators **should not** be supported. If a service does support them, values **must** be normalized. The ENBF grammar is: DecimalString = &#x27;&#x27; | [Sign] Significand [Exponent]; Sign = &#x27;+&#x27; | &#x27;-&#x27;; Significand = Digits &#x27;.&#x27; | [Digits] &#x27;.&#x27; Digits; Exponent = (&#x27;e&#x27; | &#x27;E&#x27;) [Sign] Digits; Digits = { &#x27;0&#x27; | &#x27;1&#x27; | &#x27;2&#x27; | &#x27;3&#x27; | &#x27;4&#x27; | &#x27;5&#x27; | &#x27;6&#x27; | &#x27;7&#x27; | &#x27;8&#x27; | &#x27;9&#x27; }; Services **should** clearly document the range of supported values, the maximum supported precision (total number of digits), and, if applicable, the scale (number of digits after the decimal point), as well as how it behaves when receiving out-of-bounds values. Services **may** choose to accept values passed as input even when the value has a higher precision or scale than the service supports, and **should** round the value to fit the supported scale. Alternatively, the service **may** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC) if precision would be lost. Services **should** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC) if the service receives a value outside of the supported range.
        },
      },
    },
    &quot;channelPartnerGranularity&quot;: { # Applies the repricing configuration at the channel partner level. The channel partner value is derived from the resource name. Takes an empty json object. # Applies the repricing configuration at the channel partner level. This is the only supported value for ChannelPartnerRepricingConfig.
    },
    &quot;conditionalOverrides&quot;: [ # The conditional overrides to apply for this configuration. If you list multiple overrides, only the first valid override is used. If you don&#x27;t list any overrides, the API uses the normal adjustment and rebilling basis.
      { # Specifies the override to conditionally apply.
        &quot;adjustment&quot;: { # A type that represents the various adjustments you can apply to a bill. # Required. Information about the applied override&#x27;s adjustment.
          &quot;percentageAdjustment&quot;: { # An adjustment that applies a flat markup or markdown to an entire bill. # Flat markup or markdown on an entire bill.
            &quot;percentage&quot;: { # A representation of a decimal value, such as 2.5. Clients may convert values into language-native decimal formats, such as Java&#x27;s BigDecimal or Python&#x27;s decimal.Decimal. [BigDecimal]: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigDecimal.html [decimal.Decimal]: https://docs.python.org/3/library/decimal.html # The percentage of the bill to adjust. For example: Mark down by 1% =&gt; &quot;-1.00&quot; Mark up by 1% =&gt; &quot;1.00&quot; Pass-Through =&gt; &quot;0.00&quot;
              &quot;value&quot;: &quot;A String&quot;, # The decimal value, as a string. The string representation consists of an optional sign, `+` (`U+002B`) or `-` (`U+002D`), followed by a sequence of zero or more decimal digits (&quot;the integer&quot;), optionally followed by a fraction, optionally followed by an exponent. An empty string **should** be interpreted as `0`. The fraction consists of a decimal point followed by zero or more decimal digits. The string must contain at least one digit in either the integer or the fraction. The number formed by the sign, the integer and the fraction is referred to as the significand. The exponent consists of the character `e` (`U+0065`) or `E` (`U+0045`) followed by one or more decimal digits. Services **should** normalize decimal values before storing them by: - Removing an explicitly-provided `+` sign (`+2.5` -&gt; `2.5`). - Replacing a zero-length integer value with `0` (`.5` -&gt; `0.5`). - Coercing the exponent character to upper-case, with explicit sign (`2.5e8` -&gt; `2.5E+8`). - Removing an explicitly-provided zero exponent (`2.5E0` -&gt; `2.5`). Services **may** perform additional normalization based on its own needs and the internal decimal implementation selected, such as shifting the decimal point and exponent value together (example: `2.5E-1` &lt;-&gt; `0.25`). Additionally, services **may** preserve trailing zeroes in the fraction to indicate increased precision, but are not required to do so. Note that only the `.` character is supported to divide the integer and the fraction; `,` **should not** be supported regardless of locale. Additionally, thousand separators **should not** be supported. If a service does support them, values **must** be normalized. The ENBF grammar is: DecimalString = &#x27;&#x27; | [Sign] Significand [Exponent]; Sign = &#x27;+&#x27; | &#x27;-&#x27;; Significand = Digits &#x27;.&#x27; | [Digits] &#x27;.&#x27; Digits; Exponent = (&#x27;e&#x27; | &#x27;E&#x27;) [Sign] Digits; Digits = { &#x27;0&#x27; | &#x27;1&#x27; | &#x27;2&#x27; | &#x27;3&#x27; | &#x27;4&#x27; | &#x27;5&#x27; | &#x27;6&#x27; | &#x27;7&#x27; | &#x27;8&#x27; | &#x27;9&#x27; }; Services **should** clearly document the range of supported values, the maximum supported precision (total number of digits), and, if applicable, the scale (number of digits after the decimal point), as well as how it behaves when receiving out-of-bounds values. Services **may** choose to accept values passed as input even when the value has a higher precision or scale than the service supports, and **should** round the value to fit the supported scale. Alternatively, the service **may** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC) if precision would be lost. Services **should** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC) if the service receives a value outside of the supported range.
            },
          },
        },
        &quot;rebillingBasis&quot;: &quot;A String&quot;, # Required. The RebillingBasis to use for the applied override. Shows the relative cost based on your repricing costs.
        &quot;repricingCondition&quot;: { # Represents the various repricing conditions you can use for a conditional override. # Required. Specifies the condition which, if met, will apply the override.
          &quot;skuGroupCondition&quot;: { # A condition that applies the override if a line item SKU is found in the SKU group. # SKU Group condition for override.
            &quot;skuGroup&quot;: &quot;A String&quot;, # Specifies a SKU group (https://cloud.google.com/skus/sku-groups). Resource name of SKU group. Format: accounts/{account}/skuGroups/{sku_group}. Example: &quot;accounts/C01234/skuGroups/3d50fd57-3157-4577-a5a9-a219b8490041&quot;.
          },
        },
      },
    ],
    &quot;effectiveInvoiceMonth&quot;: { # Represents a whole or partial calendar date, such as a birthday. The time of day and time zone are either specified elsewhere or are insignificant. The date is relative to the Gregorian Calendar. This can represent one of the following: * A full date, with non-zero year, month, and day values. * A month and day, with a zero year (for example, an anniversary). * A year on its own, with a zero month and a zero day. * A year and month, with a zero day (for example, a credit card expiration date). Related types: * google.type.TimeOfDay * google.type.DateTime * google.protobuf.Timestamp # Required. The YearMonth when these adjustments activate. The Day field needs to be &quot;0&quot; since we only accept YearMonth repricing boundaries.
      &quot;day&quot;: 42, # Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn&#x27;t significant.
      &quot;month&quot;: 42, # Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
      &quot;year&quot;: 42, # Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
    },
    &quot;entitlementGranularity&quot;: { # Applies the repricing configuration at the entitlement level. # Applies the repricing configuration at the entitlement level. This is the only supported value for CustomerRepricingConfig.
      &quot;entitlement&quot;: &quot;A String&quot;, # Resource name of the entitlement. Format: accounts/{account_id}/customers/{customer_id}/entitlements/{entitlement_id}
    },
    &quot;rebillingBasis&quot;: &quot;A String&quot;, # Required. The RebillingBasis to use for this bill. Specifies the relative cost based on repricing costs you will apply.
  },
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp of an update to the repricing rule. If `update_time` is after RepricingConfig.effective_invoice_month then it indicates this was set mid-month.
}</pre>
</div>

</body></html>