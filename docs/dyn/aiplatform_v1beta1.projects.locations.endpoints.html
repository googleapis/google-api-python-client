<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="aiplatform_v1beta1.html">Vertex AI API</a> . <a href="aiplatform_v1beta1.projects.html">projects</a> . <a href="aiplatform_v1beta1.projects.locations.html">locations</a> . <a href="aiplatform_v1beta1.projects.locations.endpoints.html">endpoints</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="aiplatform_v1beta1.projects.locations.endpoints.operations.html">operations()</a></code>
</p>
<p class="firstline">Returns the operations Resource.</p>

<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#countTokens">countTokens(endpoint, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Perform a token counting.</p>
<p class="toc_element">
  <code><a href="#create">create(parent, body=None, endpointId=None, x__xgafv=None)</a></code></p>
<p class="firstline">Creates an Endpoint.</p>
<p class="toc_element">
  <code><a href="#delete">delete(name, x__xgafv=None)</a></code></p>
<p class="firstline">Deletes an Endpoint.</p>
<p class="toc_element">
  <code><a href="#deployModel">deployModel(endpoint, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Deploys a Model into this Endpoint, creating a DeployedModel within it.</p>
<p class="toc_element">
  <code><a href="#explain">explain(endpoint, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Perform an online explanation. If deployed_model_id is specified, the corresponding DeployModel must have explanation_spec populated. If deployed_model_id is not specified, all DeployedModels must have explanation_spec populated.</p>
<p class="toc_element">
  <code><a href="#get">get(name, x__xgafv=None)</a></code></p>
<p class="firstline">Gets an Endpoint.</p>
<p class="toc_element">
  <code><a href="#getIamPolicy">getIamPolicy(resource, options_requestedPolicyVersion=None, x__xgafv=None)</a></code></p>
<p class="firstline">Gets the access control policy for a resource. Returns an empty policy if the resource exists and does not have a policy set.</p>
<p class="toc_element">
  <code><a href="#list">list(parent, filter=None, pageSize=None, pageToken=None, readMask=None, x__xgafv=None)</a></code></p>
<p class="firstline">Lists Endpoints in a Location.</p>
<p class="toc_element">
  <code><a href="#list_next">list_next()</a></code></p>
<p class="firstline">Retrieves the next page of results.</p>
<p class="toc_element">
  <code><a href="#mutateDeployedModel">mutateDeployedModel(endpoint, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Updates an existing deployed model. Updatable fields include `min_replica_count`, `max_replica_count`, `autoscaling_metric_specs`, `disable_container_logging` (v1 only), and `enable_container_logging` (v1beta1 only).</p>
<p class="toc_element">
  <code><a href="#patch">patch(name, body=None, updateMask=None, x__xgafv=None)</a></code></p>
<p class="firstline">Updates an Endpoint.</p>
<p class="toc_element">
  <code><a href="#predict">predict(endpoint, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Perform an online prediction.</p>
<p class="toc_element">
  <code><a href="#rawPredict">rawPredict(endpoint, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Perform an online prediction with an arbitrary HTTP payload. The response includes the following HTTP headers: * `X-Vertex-AI-Endpoint-Id`: ID of the Endpoint that served this prediction. * `X-Vertex-AI-Deployed-Model-Id`: ID of the Endpoint's DeployedModel that served this prediction.</p>
<p class="toc_element">
  <code><a href="#serverStreamingPredict">serverStreamingPredict(endpoint, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Perform a server-side streaming online prediction request for Vertex LLM streaming.</p>
<p class="toc_element">
  <code><a href="#setIamPolicy">setIamPolicy(resource, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Sets the access control policy on the specified resource. Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED` errors.</p>
<p class="toc_element">
  <code><a href="#testIamPermissions">testIamPermissions(resource, permissions=None, x__xgafv=None)</a></code></p>
<p class="firstline">Returns permissions that a caller has on the specified resource. If the resource does not exist, this will return an empty set of permissions, not a `NOT_FOUND` error. Note: This operation is designed to be used for building permission-aware UIs and command-line tools, not for authorization checking. This operation may "fail open" without warning.</p>
<p class="toc_element">
  <code><a href="#undeployModel">undeployModel(endpoint, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Undeploys a Model from an Endpoint, removing a DeployedModel from it, and freeing all resources it's using.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="countTokens">countTokens(endpoint, body=None, x__xgafv=None)</code>
  <pre>Perform a token counting.

Args:
  endpoint: string, Required. The name of the Endpoint requested to perform token counting. Format: `projects/{project}/locations/{location}/endpoints/{endpoint}` (required)
  body: object, The request body.
    The object takes the form of:

{ # Request message for PredictionService.CountTokens.
  &quot;instances&quot;: [ # Required. The instances that are the input to token counting call. Schema is identical to the prediction schema of the underlying model.
    &quot;&quot;,
  ],
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response message for PredictionService.CountTokens.
  &quot;totalBillableCharacters&quot;: 42, # The total number of billable characters counted across all instances from the request.
  &quot;totalTokens&quot;: 42, # The total number of tokens counted across all instances from the request.
}</pre>
</div>

<div class="method">
    <code class="details" id="create">create(parent, body=None, endpointId=None, x__xgafv=None)</code>
  <pre>Creates an Endpoint.

Args:
  parent: string, Required. The resource name of the Location to create the Endpoint in. Format: `projects/{project}/locations/{location}` (required)
  body: object, The request body.
    The object takes the form of:

{ # Models are deployed into it, and afterwards Endpoint is called to obtain predictions and explanations.
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Endpoint was created.
  &quot;deployedModels&quot;: [ # Output only. The models deployed in this Endpoint. To add or remove DeployedModels use EndpointService.DeployModel and EndpointService.UndeployModel respectively.
    { # A deployment of a Model. Endpoints contain one or more DeployedModels.
      &quot;automaticResources&quot;: { # A description of resources that to large degree are decided by Vertex AI, and require only a modest additional configuration. Each Model supporting these resources documents its specific guidelines. # A description of resources that to large degree are decided by Vertex AI, and require only a modest additional configuration.
        &quot;maxReplicaCount&quot;: 42, # Immutable. The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases. If the requested value is too large, the deployment will error, but if deployment succeeds then the ability to scale the model to that many replicas is guaranteed (barring service outages). If traffic against the DeployedModel increases beyond what its replicas at maximum may handle, a portion of the traffic will be dropped. If this value is not provided, a no upper bound for scaling under heavy traffic will be assume, though Vertex AI may be unable to scale beyond certain replica number.
        &quot;minReplicaCount&quot;: 42, # Immutable. The minimum number of replicas this DeployedModel will be always deployed on. If traffic against it increases, it may dynamically be deployed onto more replicas up to max_replica_count, and as traffic decreases, some of these extra replicas may be freed. If the requested value is too large, the deployment will error.
      },
      &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when the DeployedModel was created.
      &quot;dedicatedResources&quot;: { # A description of resources that are dedicated to a DeployedModel, and that need a higher degree of manual configuration. # A description of resources that are dedicated to the DeployedModel, and that need a higher degree of manual configuration.
        &quot;autoscalingMetricSpecs&quot;: [ # Immutable. The metric specifications that overrides a resource utilization metric (CPU utilization, accelerator&#x27;s duty cycle, and so on) target value (default to 60 if not set). At most one entry is allowed per metric. If machine_spec.accelerator_count is above 0, the autoscaling will be based on both CPU utilization and accelerator&#x27;s duty cycle metrics and scale up when either metrics exceeds its target value while scale down if both metrics are under their target value. The default target value is 60 for both metrics. If machine_spec.accelerator_count is 0, the autoscaling will be based on CPU utilization metric only with default target value 60 if not explicitly set. For example, in the case of Online Prediction, if you want to override target CPU utilization to 80, you should set autoscaling_metric_specs.metric_name to `aiplatform.googleapis.com/prediction/online/cpu/utilization` and autoscaling_metric_specs.target to `80`.
          { # The metric specification that defines the target resource utilization (CPU utilization, accelerator&#x27;s duty cycle, and so on) for calculating the desired replica count.
            &quot;metricName&quot;: &quot;A String&quot;, # Required. The resource metric name. Supported metrics: * For Online Prediction: * `aiplatform.googleapis.com/prediction/online/accelerator/duty_cycle` * `aiplatform.googleapis.com/prediction/online/cpu/utilization`
            &quot;target&quot;: 42, # The target resource utilization in percentage (1% - 100%) for the given metric; once the real usage deviates from the target by a certain percentage, the machine replicas change. The default value is 60 (representing 60%) if not provided.
          },
        ],
        &quot;machineSpec&quot;: { # Specification of a single machine. # Required. Immutable. The specification of a single machine used by the prediction.
          &quot;acceleratorCount&quot;: 42, # The number of accelerators to attach to the machine.
          &quot;acceleratorType&quot;: &quot;A String&quot;, # Immutable. The type of accelerator(s) that may be attached to the machine as per accelerator_count.
          &quot;machineType&quot;: &quot;A String&quot;, # Immutable. The type of the machine. See the [list of machine types supported for prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types) See the [list of machine types supported for custom training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types). For DeployedModel this field is optional, and the default value is `n1-standard-2`. For BatchPredictionJob or as part of WorkerPoolSpec this field is required.
        },
        &quot;maxReplicaCount&quot;: 42, # Immutable. The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases. If the requested value is too large, the deployment will error, but if deployment succeeds then the ability to scale the model to that many replicas is guaranteed (barring service outages). If traffic against the DeployedModel increases beyond what its replicas at maximum may handle, a portion of the traffic will be dropped. If this value is not provided, will use min_replica_count as the default value. The value of this field impacts the charge against Vertex CPU and GPU quotas. Specifically, you will be charged for (max_replica_count * number of cores in the selected machine type) and (max_replica_count * number of GPUs per replica in the selected machine type).
        &quot;minReplicaCount&quot;: 42, # Required. Immutable. The minimum number of machine replicas this DeployedModel will be always deployed on. This value must be greater than or equal to 1. If traffic against the DeployedModel increases, it may dynamically be deployed onto more replicas, and as traffic decreases, some of these extra replicas may be freed.
      },
      &quot;disableExplanations&quot;: True or False, # If true, deploy the model without explainable feature, regardless the existence of Model.explanation_spec or explanation_spec.
      &quot;displayName&quot;: &quot;A String&quot;, # The display name of the DeployedModel. If not provided upon creation, the Model&#x27;s display_name is used.
      &quot;enableAccessLogging&quot;: True or False, # If true, online prediction access logs are sent to Cloud Logging. These logs are like standard server access logs, containing information like timestamp and latency for each prediction request. Note that logs may incur a cost, especially if your project receives prediction requests at a high queries per second rate (QPS). Estimate your costs before enabling this option.
      &quot;enableContainerLogging&quot;: True or False, # If true, the container of the DeployedModel instances will send `stderr` and `stdout` streams to Cloud Logging. Only supported for custom-trained Models and AutoML Tabular Models.
      &quot;explanationSpec&quot;: { # Specification of Model explanation. # Explanation configuration for this DeployedModel. When deploying a Model using EndpointService.DeployModel, this value overrides the value of Model.explanation_spec. All fields of explanation_spec are optional in the request. If a field of explanation_spec is not populated, the value of the same field of Model.explanation_spec is inherited. If the corresponding Model.explanation_spec is not populated, all fields of the explanation_spec will be used for the explanation configuration.
        &quot;metadata&quot;: { # Metadata describing the Model&#x27;s input and output for explanation. # Optional. Metadata describing the Model&#x27;s input and output for explanation.
          &quot;featureAttributionsSchemaUri&quot;: &quot;A String&quot;, # Points to a YAML file stored on Google Cloud Storage describing the format of the feature attributions. The schema is defined as an OpenAPI 3.0.2 [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject). AutoML tabular Models always have this field populated by Vertex AI. Note: The URI given on output may be different, including the URI scheme, than the one given on input. The output URI will point to a location where the user only has a read access.
          &quot;inputs&quot;: { # Required. Map from feature names to feature input metadata. Keys are the name of the features. Values are the specification of the feature. An empty InputMetadata is valid. It describes a text feature which has the name specified as the key in ExplanationMetadata.inputs. The baseline of the empty feature is chosen by Vertex AI. For Vertex AI-provided Tensorflow images, the key can be any friendly name of the feature. Once specified, featureAttributions are keyed by this key (if not grouped with another feature). For custom images, the key must match with the key in instance.
            &quot;a_key&quot;: { # Metadata of the input of a feature. Fields other than InputMetadata.input_baselines are applicable only for Models that are using Vertex AI-provided images for Tensorflow.
              &quot;denseShapeTensorName&quot;: &quot;A String&quot;, # Specifies the shape of the values of the input if the input is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
              &quot;encodedBaselines&quot;: [ # A list of baselines for the encoded tensor. The shape of each baseline should match the shape of the encoded tensor. If a scalar is provided, Vertex AI broadcasts to the same shape as the encoded tensor.
                &quot;&quot;,
              ],
              &quot;encodedTensorName&quot;: &quot;A String&quot;, # Encoded tensor is a transformation of the input tensor. Must be provided if choosing Integrated Gradients attribution or XRAI attribution and the input tensor is not differentiable. An encoded tensor is generated if the input tensor is encoded by a lookup table.
              &quot;encoding&quot;: &quot;A String&quot;, # Defines how the feature is encoded into the input tensor. Defaults to IDENTITY.
              &quot;featureValueDomain&quot;: { # Domain details of the input feature value. Provides numeric information about the feature, such as its range (min, max). If the feature has been pre-processed, for example with z-scoring, then it provides information about how to recover the original feature. For example, if the input feature is an image and it has been pre-processed to obtain 0-mean and stddev = 1 values, then original_mean, and original_stddev refer to the mean and stddev of the original feature (e.g. image tensor) from which input feature (with mean = 0 and stddev = 1) was obtained. # The domain details of the input feature value. Like min/max, original mean or standard deviation if normalized.
                &quot;maxValue&quot;: 3.14, # The maximum permissible value for this feature.
                &quot;minValue&quot;: 3.14, # The minimum permissible value for this feature.
                &quot;originalMean&quot;: 3.14, # If this input feature has been normalized to a mean value of 0, the original_mean specifies the mean value of the domain prior to normalization.
                &quot;originalStddev&quot;: 3.14, # If this input feature has been normalized to a standard deviation of 1.0, the original_stddev specifies the standard deviation of the domain prior to normalization.
              },
              &quot;groupName&quot;: &quot;A String&quot;, # Name of the group that the input belongs to. Features with the same group name will be treated as one feature when computing attributions. Features grouped together can have different shapes in value. If provided, there will be one single attribution generated in Attribution.feature_attributions, keyed by the group name.
              &quot;indexFeatureMapping&quot;: [ # A list of feature names for each index in the input tensor. Required when the input InputMetadata.encoding is BAG_OF_FEATURES, BAG_OF_FEATURES_SPARSE, INDICATOR.
                &quot;A String&quot;,
              ],
              &quot;indicesTensorName&quot;: &quot;A String&quot;, # Specifies the index of the values of the input tensor. Required when the input tensor is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
              &quot;inputBaselines&quot;: [ # Baseline inputs for this feature. If no baseline is specified, Vertex AI chooses the baseline for this feature. If multiple baselines are specified, Vertex AI returns the average attributions across them in Attribution.feature_attributions. For Vertex AI-provided Tensorflow images (both 1.x and 2.x), the shape of each baseline must match the shape of the input tensor. If a scalar is provided, we broadcast to the same shape as the input tensor. For custom images, the element of the baselines must be in the same format as the feature&#x27;s input in the instance[]. The schema of any single instance may be specified via Endpoint&#x27;s DeployedModels&#x27; Model&#x27;s PredictSchemata&#x27;s instance_schema_uri.
                &quot;&quot;,
              ],
              &quot;inputTensorName&quot;: &quot;A String&quot;, # Name of the input tensor for this feature. Required and is only applicable to Vertex AI-provided images for Tensorflow.
              &quot;modality&quot;: &quot;A String&quot;, # Modality of the feature. Valid values are: numeric, image. Defaults to numeric.
              &quot;visualization&quot;: { # Visualization configurations for image explanation. # Visualization configurations for image explanation.
                &quot;clipPercentLowerbound&quot;: 3.14, # Excludes attributions below the specified percentile, from the highlighted areas. Defaults to 62.
                &quot;clipPercentUpperbound&quot;: 3.14, # Excludes attributions above the specified percentile from the highlighted areas. Using the clip_percent_upperbound and clip_percent_lowerbound together can be useful for filtering out noise and making it easier to see areas of strong attribution. Defaults to 99.9.
                &quot;colorMap&quot;: &quot;A String&quot;, # The color scheme used for the highlighted areas. Defaults to PINK_GREEN for Integrated Gradients attribution, which shows positive attributions in green and negative in pink. Defaults to VIRIDIS for XRAI attribution, which highlights the most influential regions in yellow and the least influential in blue.
                &quot;overlayType&quot;: &quot;A String&quot;, # How the original image is displayed in the visualization. Adjusting the overlay can help increase visual clarity if the original image makes it difficult to view the visualization. Defaults to NONE.
                &quot;polarity&quot;: &quot;A String&quot;, # Whether to only highlight pixels with positive contributions, negative or both. Defaults to POSITIVE.
                &quot;type&quot;: &quot;A String&quot;, # Type of the image visualization. Only applicable to Integrated Gradients attribution. OUTLINES shows regions of attribution, while PIXELS shows per-pixel attribution. Defaults to OUTLINES.
              },
            },
          },
          &quot;latentSpaceSource&quot;: &quot;A String&quot;, # Name of the source to generate embeddings for example based explanations.
          &quot;outputs&quot;: { # Required. Map from output names to output metadata. For Vertex AI-provided Tensorflow images, keys can be any user defined string that consists of any UTF-8 characters. For custom images, keys are the name of the output field in the prediction to be explained. Currently only one key is allowed.
            &quot;a_key&quot;: { # Metadata of the prediction output to be explained.
              &quot;displayNameMappingKey&quot;: &quot;A String&quot;, # Specify a field name in the prediction to look for the display name. Use this if the prediction contains the display names for the outputs. The display names in the prediction must have the same shape of the outputs, so that it can be located by Attribution.output_index for a specific output.
              &quot;indexDisplayNameMapping&quot;: &quot;&quot;, # Static mapping between the index and display name. Use this if the outputs are a deterministic n-dimensional array, e.g. a list of scores of all the classes in a pre-defined order for a multi-classification Model. It&#x27;s not feasible if the outputs are non-deterministic, e.g. the Model produces top-k classes or sort the outputs by their values. The shape of the value must be an n-dimensional array of strings. The number of dimensions must match that of the outputs to be explained. The Attribution.output_display_name is populated by locating in the mapping with Attribution.output_index.
              &quot;outputTensorName&quot;: &quot;A String&quot;, # Name of the output tensor. Required and is only applicable to Vertex AI provided images for Tensorflow.
            },
          },
        },
        &quot;parameters&quot;: { # Parameters to configure explaining for Model&#x27;s predictions. # Required. Parameters that configure explaining of the Model&#x27;s predictions.
          &quot;examples&quot;: { # Example-based explainability that returns the nearest neighbors from the provided dataset. # Example-based explanations that returns the nearest neighbors from the provided dataset.
            &quot;exampleGcsSource&quot;: { # The Cloud Storage input instances. # The Cloud Storage input instances.
              &quot;dataFormat&quot;: &quot;A String&quot;, # The format in which instances are given, if not specified, assume it&#x27;s JSONL format. Currently only JSONL format is supported.
              &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage location for the input instances.
                &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                  &quot;A String&quot;,
                ],
              },
            },
            &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage locations that contain the instances to be indexed for approximate nearest neighbor search.
              &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                &quot;A String&quot;,
              ],
            },
            &quot;nearestNeighborSearchConfig&quot;: &quot;&quot;, # The full configuration for the generated index, the semantics are the same as metadata and should match [NearestNeighborSearchConfig](https://cloud.google.com/vertex-ai/docs/explainable-ai/configuring-explanations-example-based#nearest-neighbor-search-config).
            &quot;neighborCount&quot;: 42, # The number of neighbors to return when querying for examples.
            &quot;presets&quot;: { # Preset configuration for example-based explanations # Simplified preset configuration, which automatically sets configuration values based on the desired query speed-precision trade-off and modality.
              &quot;modality&quot;: &quot;A String&quot;, # The modality of the uploaded model, which automatically configures the distance measurement and feature normalization for the underlying example index and queries. If your model does not precisely fit one of these types, it is okay to choose the closest type.
              &quot;query&quot;: &quot;A String&quot;, # Preset option controlling parameters for speed-precision trade-off when querying for examples. If omitted, defaults to `PRECISE`.
            },
          },
          &quot;integratedGradientsAttribution&quot;: { # An attribution method that computes the Aumann-Shapley value taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365 # An attribution method that computes Aumann-Shapley values taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365
            &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for IG with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
              &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
            },
            &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
              &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
                &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
                  { # Noise sigma for a single feature.
                    &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                    &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
                  },
                ],
              },
              &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
              &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
            },
            &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is within the desired error range. Valid range of its value is [1, 100], inclusively.
          },
          &quot;outputIndices&quot;: [ # If populated, only returns attributions that have output_index contained in output_indices. It must be an ndarray of integers, with the same shape of the output it&#x27;s explaining. If not populated, returns attributions for top_k indices of outputs. If neither top_k nor output_indices is populated, returns the argmax index of the outputs. Only applicable to Models that predict multiple outputs (e,g, multi-class Models that predict multiple classes).
            &quot;&quot;,
          ],
          &quot;sampledShapleyAttribution&quot;: { # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. Refer to this paper for model details: https://arxiv.org/abs/1306.4265.
            &quot;pathCount&quot;: 42, # Required. The number of feature permutations to consider when approximating the Shapley values. Valid range of its value is [1, 50], inclusively.
          },
          &quot;topK&quot;: 42, # If populated, returns attributions for top K indices of outputs (defaults to 1). Only applies to Models that predicts more than one outputs (e,g, multi-class Models). When set to -1, returns explanations for all outputs.
          &quot;xraiAttribution&quot;: { # An explanation method that redistributes Integrated Gradients attributions to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 Supported only by image Models. # An attribution method that redistributes Integrated Gradients attribution to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 XRAI currently performs better on natural images, like a picture of a house or an animal. If the images are taken in artificial environments, like a lab or manufacturing line, or from diagnostic equipment, like x-rays or quality-control cameras, use Integrated Gradients instead.
            &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for XRAI with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
              &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
            },
            &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
              &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
                &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
                  { # Noise sigma for a single feature.
                    &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                    &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
                  },
                ],
              },
              &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
              &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
            },
            &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is met within the desired error range. Valid range of its value is [1, 100], inclusively.
          },
        },
      },
      &quot;id&quot;: &quot;A String&quot;, # Immutable. The ID of the DeployedModel. If not provided upon deployment, Vertex AI will generate a value for this ID. This value should be 1-10 characters, and valid characters are /[0-9]/.
      &quot;model&quot;: &quot;A String&quot;, # Required. The resource name of the Model that this is the deployment of. Note that the Model may be in a different location than the DeployedModel&#x27;s Endpoint. The resource name may contain version id or version alias to specify the version. Example: `projects/{project}/locations/{location}/models/{model}@2` or `projects/{project}/locations/{location}/models/{model}@golden` if no version is specified, the default version will be deployed.
      &quot;modelVersionId&quot;: &quot;A String&quot;, # Output only. The version ID of the model that is deployed.
      &quot;privateEndpoints&quot;: { # PrivateEndpoints proto is used to provide paths for users to send requests privately. To send request via private service access, use predict_http_uri, explain_http_uri or health_http_uri. To send request via private service connect, use service_attachment. # Output only. Provide paths for users to send predict/explain/health requests directly to the deployed model services running on Cloud via private services access. This field is populated if network is configured.
        &quot;explainHttpUri&quot;: &quot;A String&quot;, # Output only. Http(s) path to send explain requests.
        &quot;healthHttpUri&quot;: &quot;A String&quot;, # Output only. Http(s) path to send health check requests.
        &quot;predictHttpUri&quot;: &quot;A String&quot;, # Output only. Http(s) path to send prediction requests.
        &quot;serviceAttachment&quot;: &quot;A String&quot;, # Output only. The name of the service attachment resource. Populated if private service connect is enabled.
      },
      &quot;serviceAccount&quot;: &quot;A String&quot;, # The service account that the DeployedModel&#x27;s container runs as. Specify the email address of the service account. If this service account is not specified, the container runs as a service account that doesn&#x27;t have access to the resource project. Users deploying the Model must have the `iam.serviceAccounts.actAs` permission on this service account.
      &quot;sharedResources&quot;: &quot;A String&quot;, # The resource name of the shared DeploymentResourcePool to deploy on. Format: `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
    },
  ],
  &quot;description&quot;: &quot;A String&quot;, # The description of the Endpoint.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The display name of the Endpoint. The name can be up to 128 characters long and can consist of any UTF-8 characters.
  &quot;enablePrivateServiceConnect&quot;: True or False, # Deprecated: If true, expose the Endpoint via private service connect. Only one of the fields, network or enable_private_service_connect, can be set.
  &quot;encryptionSpec&quot;: { # Represents a customer-managed encryption key spec that can be applied to a top-level resource. # Customer-managed encryption key spec for an Endpoint. If set, this Endpoint and all sub-resources of this Endpoint will be secured by this key.
    &quot;kmsKeyName&quot;: &quot;A String&quot;, # Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
  },
  &quot;etag&quot;: &quot;A String&quot;, # Used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
  &quot;labels&quot;: { # The labels with user-defined metadata to organize your Endpoints. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels.
    &quot;a_key&quot;: &quot;A String&quot;,
  },
  &quot;modelDeploymentMonitoringJob&quot;: &quot;A String&quot;, # Output only. Resource name of the Model Monitoring job associated with this Endpoint if monitoring is enabled by JobService.CreateModelDeploymentMonitoringJob. Format: `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the Endpoint.
  &quot;network&quot;: &quot;A String&quot;, # Optional. The full name of the Google Compute Engine [network](https://cloud.google.com//compute/docs/networks-and-firewalls#networks) to which the Endpoint should be peered. Private services access must already be configured for the network. If left unspecified, the Endpoint is not peered with any network. Only one of the fields, network or enable_private_service_connect, can be set. [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/insert): `projects/{project}/global/networks/{network}`. Where `{project}` is a project number, as in `12345`, and `{network}` is network name.
  &quot;predictRequestResponseLoggingConfig&quot;: { # Configuration for logging request-response to a BigQuery table. # Configures the request-response logging for online prediction.
    &quot;bigqueryDestination&quot;: { # The BigQuery location for the output content. # BigQuery table for logging. If only given a project, a new dataset will be created with name `logging__` where will be made BigQuery-dataset-name compatible (e.g. most special characters will become underscores). If no table name is given, a new table will be created with name `request_response_logging`
      &quot;outputUri&quot;: &quot;A String&quot;, # Required. BigQuery URI to a project or table, up to 2000 characters long. When only the project is specified, the Dataset and Table is created. When the full table reference is specified, the Dataset must exist and table must not exist. Accepted forms: * BigQuery path. For example: `bq://projectId` or `bq://projectId.bqDatasetId` or `bq://projectId.bqDatasetId.bqTableId`.
    },
    &quot;enabled&quot;: True or False, # If logging is enabled or not.
    &quot;samplingRate&quot;: 3.14, # Percentage of requests to be logged, expressed as a fraction in range(0,1].
  },
  &quot;trafficSplit&quot;: { # A map from a DeployedModel&#x27;s ID to the percentage of this Endpoint&#x27;s traffic that should be forwarded to that DeployedModel. If a DeployedModel&#x27;s ID is not listed in this map, then it receives no traffic. The traffic percentage values must add up to 100, or map must be empty if the Endpoint is to not accept any traffic at a moment.
    &quot;a_key&quot;: 42,
  },
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Endpoint was last updated.
}

  endpointId: string, Immutable. The ID to use for endpoint, which will become the final component of the endpoint resource name. If not provided, Vertex AI will generate a value for this ID. If the first character is a letter, this value may be up to 63 characters, and valid characters are `[a-z0-9-]`. The last character must be a letter or number. If the first character is a number, this value may be up to 9 characters, and valid characters are `[0-9]` with no leading zeros. When using HTTP/JSON, this field is populated based on a query string argument, such as `?endpoint_id=12345`. This is the fallback for fields that are not included in either the URI or the body.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # This resource represents a long-running operation that is the result of a network API call.
  &quot;done&quot;: True or False, # If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The error result of the operation in case of failure or cancellation.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;metadata&quot;: { # Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
  &quot;name&quot;: &quot;A String&quot;, # The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
  &quot;response&quot;: { # The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="delete">delete(name, x__xgafv=None)</code>
  <pre>Deletes an Endpoint.

Args:
  name: string, Required. The name of the Endpoint resource to be deleted. Format: `projects/{project}/locations/{location}/endpoints/{endpoint}` (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # This resource represents a long-running operation that is the result of a network API call.
  &quot;done&quot;: True or False, # If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The error result of the operation in case of failure or cancellation.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;metadata&quot;: { # Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
  &quot;name&quot;: &quot;A String&quot;, # The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
  &quot;response&quot;: { # The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="deployModel">deployModel(endpoint, body=None, x__xgafv=None)</code>
  <pre>Deploys a Model into this Endpoint, creating a DeployedModel within it.

Args:
  endpoint: string, Required. The name of the Endpoint resource into which to deploy a Model. Format: `projects/{project}/locations/{location}/endpoints/{endpoint}` (required)
  body: object, The request body.
    The object takes the form of:

{ # Request message for EndpointService.DeployModel.
  &quot;deployedModel&quot;: { # A deployment of a Model. Endpoints contain one or more DeployedModels. # Required. The DeployedModel to be created within the Endpoint. Note that Endpoint.traffic_split must be updated for the DeployedModel to start receiving traffic, either as part of this call, or via EndpointService.UpdateEndpoint.
    &quot;automaticResources&quot;: { # A description of resources that to large degree are decided by Vertex AI, and require only a modest additional configuration. Each Model supporting these resources documents its specific guidelines. # A description of resources that to large degree are decided by Vertex AI, and require only a modest additional configuration.
      &quot;maxReplicaCount&quot;: 42, # Immutable. The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases. If the requested value is too large, the deployment will error, but if deployment succeeds then the ability to scale the model to that many replicas is guaranteed (barring service outages). If traffic against the DeployedModel increases beyond what its replicas at maximum may handle, a portion of the traffic will be dropped. If this value is not provided, a no upper bound for scaling under heavy traffic will be assume, though Vertex AI may be unable to scale beyond certain replica number.
      &quot;minReplicaCount&quot;: 42, # Immutable. The minimum number of replicas this DeployedModel will be always deployed on. If traffic against it increases, it may dynamically be deployed onto more replicas up to max_replica_count, and as traffic decreases, some of these extra replicas may be freed. If the requested value is too large, the deployment will error.
    },
    &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when the DeployedModel was created.
    &quot;dedicatedResources&quot;: { # A description of resources that are dedicated to a DeployedModel, and that need a higher degree of manual configuration. # A description of resources that are dedicated to the DeployedModel, and that need a higher degree of manual configuration.
      &quot;autoscalingMetricSpecs&quot;: [ # Immutable. The metric specifications that overrides a resource utilization metric (CPU utilization, accelerator&#x27;s duty cycle, and so on) target value (default to 60 if not set). At most one entry is allowed per metric. If machine_spec.accelerator_count is above 0, the autoscaling will be based on both CPU utilization and accelerator&#x27;s duty cycle metrics and scale up when either metrics exceeds its target value while scale down if both metrics are under their target value. The default target value is 60 for both metrics. If machine_spec.accelerator_count is 0, the autoscaling will be based on CPU utilization metric only with default target value 60 if not explicitly set. For example, in the case of Online Prediction, if you want to override target CPU utilization to 80, you should set autoscaling_metric_specs.metric_name to `aiplatform.googleapis.com/prediction/online/cpu/utilization` and autoscaling_metric_specs.target to `80`.
        { # The metric specification that defines the target resource utilization (CPU utilization, accelerator&#x27;s duty cycle, and so on) for calculating the desired replica count.
          &quot;metricName&quot;: &quot;A String&quot;, # Required. The resource metric name. Supported metrics: * For Online Prediction: * `aiplatform.googleapis.com/prediction/online/accelerator/duty_cycle` * `aiplatform.googleapis.com/prediction/online/cpu/utilization`
          &quot;target&quot;: 42, # The target resource utilization in percentage (1% - 100%) for the given metric; once the real usage deviates from the target by a certain percentage, the machine replicas change. The default value is 60 (representing 60%) if not provided.
        },
      ],
      &quot;machineSpec&quot;: { # Specification of a single machine. # Required. Immutable. The specification of a single machine used by the prediction.
        &quot;acceleratorCount&quot;: 42, # The number of accelerators to attach to the machine.
        &quot;acceleratorType&quot;: &quot;A String&quot;, # Immutable. The type of accelerator(s) that may be attached to the machine as per accelerator_count.
        &quot;machineType&quot;: &quot;A String&quot;, # Immutable. The type of the machine. See the [list of machine types supported for prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types) See the [list of machine types supported for custom training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types). For DeployedModel this field is optional, and the default value is `n1-standard-2`. For BatchPredictionJob or as part of WorkerPoolSpec this field is required.
      },
      &quot;maxReplicaCount&quot;: 42, # Immutable. The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases. If the requested value is too large, the deployment will error, but if deployment succeeds then the ability to scale the model to that many replicas is guaranteed (barring service outages). If traffic against the DeployedModel increases beyond what its replicas at maximum may handle, a portion of the traffic will be dropped. If this value is not provided, will use min_replica_count as the default value. The value of this field impacts the charge against Vertex CPU and GPU quotas. Specifically, you will be charged for (max_replica_count * number of cores in the selected machine type) and (max_replica_count * number of GPUs per replica in the selected machine type).
      &quot;minReplicaCount&quot;: 42, # Required. Immutable. The minimum number of machine replicas this DeployedModel will be always deployed on. This value must be greater than or equal to 1. If traffic against the DeployedModel increases, it may dynamically be deployed onto more replicas, and as traffic decreases, some of these extra replicas may be freed.
    },
    &quot;disableExplanations&quot;: True or False, # If true, deploy the model without explainable feature, regardless the existence of Model.explanation_spec or explanation_spec.
    &quot;displayName&quot;: &quot;A String&quot;, # The display name of the DeployedModel. If not provided upon creation, the Model&#x27;s display_name is used.
    &quot;enableAccessLogging&quot;: True or False, # If true, online prediction access logs are sent to Cloud Logging. These logs are like standard server access logs, containing information like timestamp and latency for each prediction request. Note that logs may incur a cost, especially if your project receives prediction requests at a high queries per second rate (QPS). Estimate your costs before enabling this option.
    &quot;enableContainerLogging&quot;: True or False, # If true, the container of the DeployedModel instances will send `stderr` and `stdout` streams to Cloud Logging. Only supported for custom-trained Models and AutoML Tabular Models.
    &quot;explanationSpec&quot;: { # Specification of Model explanation. # Explanation configuration for this DeployedModel. When deploying a Model using EndpointService.DeployModel, this value overrides the value of Model.explanation_spec. All fields of explanation_spec are optional in the request. If a field of explanation_spec is not populated, the value of the same field of Model.explanation_spec is inherited. If the corresponding Model.explanation_spec is not populated, all fields of the explanation_spec will be used for the explanation configuration.
      &quot;metadata&quot;: { # Metadata describing the Model&#x27;s input and output for explanation. # Optional. Metadata describing the Model&#x27;s input and output for explanation.
        &quot;featureAttributionsSchemaUri&quot;: &quot;A String&quot;, # Points to a YAML file stored on Google Cloud Storage describing the format of the feature attributions. The schema is defined as an OpenAPI 3.0.2 [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject). AutoML tabular Models always have this field populated by Vertex AI. Note: The URI given on output may be different, including the URI scheme, than the one given on input. The output URI will point to a location where the user only has a read access.
        &quot;inputs&quot;: { # Required. Map from feature names to feature input metadata. Keys are the name of the features. Values are the specification of the feature. An empty InputMetadata is valid. It describes a text feature which has the name specified as the key in ExplanationMetadata.inputs. The baseline of the empty feature is chosen by Vertex AI. For Vertex AI-provided Tensorflow images, the key can be any friendly name of the feature. Once specified, featureAttributions are keyed by this key (if not grouped with another feature). For custom images, the key must match with the key in instance.
          &quot;a_key&quot;: { # Metadata of the input of a feature. Fields other than InputMetadata.input_baselines are applicable only for Models that are using Vertex AI-provided images for Tensorflow.
            &quot;denseShapeTensorName&quot;: &quot;A String&quot;, # Specifies the shape of the values of the input if the input is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
            &quot;encodedBaselines&quot;: [ # A list of baselines for the encoded tensor. The shape of each baseline should match the shape of the encoded tensor. If a scalar is provided, Vertex AI broadcasts to the same shape as the encoded tensor.
              &quot;&quot;,
            ],
            &quot;encodedTensorName&quot;: &quot;A String&quot;, # Encoded tensor is a transformation of the input tensor. Must be provided if choosing Integrated Gradients attribution or XRAI attribution and the input tensor is not differentiable. An encoded tensor is generated if the input tensor is encoded by a lookup table.
            &quot;encoding&quot;: &quot;A String&quot;, # Defines how the feature is encoded into the input tensor. Defaults to IDENTITY.
            &quot;featureValueDomain&quot;: { # Domain details of the input feature value. Provides numeric information about the feature, such as its range (min, max). If the feature has been pre-processed, for example with z-scoring, then it provides information about how to recover the original feature. For example, if the input feature is an image and it has been pre-processed to obtain 0-mean and stddev = 1 values, then original_mean, and original_stddev refer to the mean and stddev of the original feature (e.g. image tensor) from which input feature (with mean = 0 and stddev = 1) was obtained. # The domain details of the input feature value. Like min/max, original mean or standard deviation if normalized.
              &quot;maxValue&quot;: 3.14, # The maximum permissible value for this feature.
              &quot;minValue&quot;: 3.14, # The minimum permissible value for this feature.
              &quot;originalMean&quot;: 3.14, # If this input feature has been normalized to a mean value of 0, the original_mean specifies the mean value of the domain prior to normalization.
              &quot;originalStddev&quot;: 3.14, # If this input feature has been normalized to a standard deviation of 1.0, the original_stddev specifies the standard deviation of the domain prior to normalization.
            },
            &quot;groupName&quot;: &quot;A String&quot;, # Name of the group that the input belongs to. Features with the same group name will be treated as one feature when computing attributions. Features grouped together can have different shapes in value. If provided, there will be one single attribution generated in Attribution.feature_attributions, keyed by the group name.
            &quot;indexFeatureMapping&quot;: [ # A list of feature names for each index in the input tensor. Required when the input InputMetadata.encoding is BAG_OF_FEATURES, BAG_OF_FEATURES_SPARSE, INDICATOR.
              &quot;A String&quot;,
            ],
            &quot;indicesTensorName&quot;: &quot;A String&quot;, # Specifies the index of the values of the input tensor. Required when the input tensor is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
            &quot;inputBaselines&quot;: [ # Baseline inputs for this feature. If no baseline is specified, Vertex AI chooses the baseline for this feature. If multiple baselines are specified, Vertex AI returns the average attributions across them in Attribution.feature_attributions. For Vertex AI-provided Tensorflow images (both 1.x and 2.x), the shape of each baseline must match the shape of the input tensor. If a scalar is provided, we broadcast to the same shape as the input tensor. For custom images, the element of the baselines must be in the same format as the feature&#x27;s input in the instance[]. The schema of any single instance may be specified via Endpoint&#x27;s DeployedModels&#x27; Model&#x27;s PredictSchemata&#x27;s instance_schema_uri.
              &quot;&quot;,
            ],
            &quot;inputTensorName&quot;: &quot;A String&quot;, # Name of the input tensor for this feature. Required and is only applicable to Vertex AI-provided images for Tensorflow.
            &quot;modality&quot;: &quot;A String&quot;, # Modality of the feature. Valid values are: numeric, image. Defaults to numeric.
            &quot;visualization&quot;: { # Visualization configurations for image explanation. # Visualization configurations for image explanation.
              &quot;clipPercentLowerbound&quot;: 3.14, # Excludes attributions below the specified percentile, from the highlighted areas. Defaults to 62.
              &quot;clipPercentUpperbound&quot;: 3.14, # Excludes attributions above the specified percentile from the highlighted areas. Using the clip_percent_upperbound and clip_percent_lowerbound together can be useful for filtering out noise and making it easier to see areas of strong attribution. Defaults to 99.9.
              &quot;colorMap&quot;: &quot;A String&quot;, # The color scheme used for the highlighted areas. Defaults to PINK_GREEN for Integrated Gradients attribution, which shows positive attributions in green and negative in pink. Defaults to VIRIDIS for XRAI attribution, which highlights the most influential regions in yellow and the least influential in blue.
              &quot;overlayType&quot;: &quot;A String&quot;, # How the original image is displayed in the visualization. Adjusting the overlay can help increase visual clarity if the original image makes it difficult to view the visualization. Defaults to NONE.
              &quot;polarity&quot;: &quot;A String&quot;, # Whether to only highlight pixels with positive contributions, negative or both. Defaults to POSITIVE.
              &quot;type&quot;: &quot;A String&quot;, # Type of the image visualization. Only applicable to Integrated Gradients attribution. OUTLINES shows regions of attribution, while PIXELS shows per-pixel attribution. Defaults to OUTLINES.
            },
          },
        },
        &quot;latentSpaceSource&quot;: &quot;A String&quot;, # Name of the source to generate embeddings for example based explanations.
        &quot;outputs&quot;: { # Required. Map from output names to output metadata. For Vertex AI-provided Tensorflow images, keys can be any user defined string that consists of any UTF-8 characters. For custom images, keys are the name of the output field in the prediction to be explained. Currently only one key is allowed.
          &quot;a_key&quot;: { # Metadata of the prediction output to be explained.
            &quot;displayNameMappingKey&quot;: &quot;A String&quot;, # Specify a field name in the prediction to look for the display name. Use this if the prediction contains the display names for the outputs. The display names in the prediction must have the same shape of the outputs, so that it can be located by Attribution.output_index for a specific output.
            &quot;indexDisplayNameMapping&quot;: &quot;&quot;, # Static mapping between the index and display name. Use this if the outputs are a deterministic n-dimensional array, e.g. a list of scores of all the classes in a pre-defined order for a multi-classification Model. It&#x27;s not feasible if the outputs are non-deterministic, e.g. the Model produces top-k classes or sort the outputs by their values. The shape of the value must be an n-dimensional array of strings. The number of dimensions must match that of the outputs to be explained. The Attribution.output_display_name is populated by locating in the mapping with Attribution.output_index.
            &quot;outputTensorName&quot;: &quot;A String&quot;, # Name of the output tensor. Required and is only applicable to Vertex AI provided images for Tensorflow.
          },
        },
      },
      &quot;parameters&quot;: { # Parameters to configure explaining for Model&#x27;s predictions. # Required. Parameters that configure explaining of the Model&#x27;s predictions.
        &quot;examples&quot;: { # Example-based explainability that returns the nearest neighbors from the provided dataset. # Example-based explanations that returns the nearest neighbors from the provided dataset.
          &quot;exampleGcsSource&quot;: { # The Cloud Storage input instances. # The Cloud Storage input instances.
            &quot;dataFormat&quot;: &quot;A String&quot;, # The format in which instances are given, if not specified, assume it&#x27;s JSONL format. Currently only JSONL format is supported.
            &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage location for the input instances.
              &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                &quot;A String&quot;,
              ],
            },
          },
          &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage locations that contain the instances to be indexed for approximate nearest neighbor search.
            &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
              &quot;A String&quot;,
            ],
          },
          &quot;nearestNeighborSearchConfig&quot;: &quot;&quot;, # The full configuration for the generated index, the semantics are the same as metadata and should match [NearestNeighborSearchConfig](https://cloud.google.com/vertex-ai/docs/explainable-ai/configuring-explanations-example-based#nearest-neighbor-search-config).
          &quot;neighborCount&quot;: 42, # The number of neighbors to return when querying for examples.
          &quot;presets&quot;: { # Preset configuration for example-based explanations # Simplified preset configuration, which automatically sets configuration values based on the desired query speed-precision trade-off and modality.
            &quot;modality&quot;: &quot;A String&quot;, # The modality of the uploaded model, which automatically configures the distance measurement and feature normalization for the underlying example index and queries. If your model does not precisely fit one of these types, it is okay to choose the closest type.
            &quot;query&quot;: &quot;A String&quot;, # Preset option controlling parameters for speed-precision trade-off when querying for examples. If omitted, defaults to `PRECISE`.
          },
        },
        &quot;integratedGradientsAttribution&quot;: { # An attribution method that computes the Aumann-Shapley value taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365 # An attribution method that computes Aumann-Shapley values taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365
          &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for IG with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
            &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
          },
          &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
            &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
              &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
                { # Noise sigma for a single feature.
                  &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                  &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
                },
              ],
            },
            &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
            &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
          },
          &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is within the desired error range. Valid range of its value is [1, 100], inclusively.
        },
        &quot;outputIndices&quot;: [ # If populated, only returns attributions that have output_index contained in output_indices. It must be an ndarray of integers, with the same shape of the output it&#x27;s explaining. If not populated, returns attributions for top_k indices of outputs. If neither top_k nor output_indices is populated, returns the argmax index of the outputs. Only applicable to Models that predict multiple outputs (e,g, multi-class Models that predict multiple classes).
          &quot;&quot;,
        ],
        &quot;sampledShapleyAttribution&quot;: { # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. Refer to this paper for model details: https://arxiv.org/abs/1306.4265.
          &quot;pathCount&quot;: 42, # Required. The number of feature permutations to consider when approximating the Shapley values. Valid range of its value is [1, 50], inclusively.
        },
        &quot;topK&quot;: 42, # If populated, returns attributions for top K indices of outputs (defaults to 1). Only applies to Models that predicts more than one outputs (e,g, multi-class Models). When set to -1, returns explanations for all outputs.
        &quot;xraiAttribution&quot;: { # An explanation method that redistributes Integrated Gradients attributions to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 Supported only by image Models. # An attribution method that redistributes Integrated Gradients attribution to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 XRAI currently performs better on natural images, like a picture of a house or an animal. If the images are taken in artificial environments, like a lab or manufacturing line, or from diagnostic equipment, like x-rays or quality-control cameras, use Integrated Gradients instead.
          &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for XRAI with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
            &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
          },
          &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
            &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
              &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
                { # Noise sigma for a single feature.
                  &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                  &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
                },
              ],
            },
            &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
            &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
          },
          &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is met within the desired error range. Valid range of its value is [1, 100], inclusively.
        },
      },
    },
    &quot;id&quot;: &quot;A String&quot;, # Immutable. The ID of the DeployedModel. If not provided upon deployment, Vertex AI will generate a value for this ID. This value should be 1-10 characters, and valid characters are /[0-9]/.
    &quot;model&quot;: &quot;A String&quot;, # Required. The resource name of the Model that this is the deployment of. Note that the Model may be in a different location than the DeployedModel&#x27;s Endpoint. The resource name may contain version id or version alias to specify the version. Example: `projects/{project}/locations/{location}/models/{model}@2` or `projects/{project}/locations/{location}/models/{model}@golden` if no version is specified, the default version will be deployed.
    &quot;modelVersionId&quot;: &quot;A String&quot;, # Output only. The version ID of the model that is deployed.
    &quot;privateEndpoints&quot;: { # PrivateEndpoints proto is used to provide paths for users to send requests privately. To send request via private service access, use predict_http_uri, explain_http_uri or health_http_uri. To send request via private service connect, use service_attachment. # Output only. Provide paths for users to send predict/explain/health requests directly to the deployed model services running on Cloud via private services access. This field is populated if network is configured.
      &quot;explainHttpUri&quot;: &quot;A String&quot;, # Output only. Http(s) path to send explain requests.
      &quot;healthHttpUri&quot;: &quot;A String&quot;, # Output only. Http(s) path to send health check requests.
      &quot;predictHttpUri&quot;: &quot;A String&quot;, # Output only. Http(s) path to send prediction requests.
      &quot;serviceAttachment&quot;: &quot;A String&quot;, # Output only. The name of the service attachment resource. Populated if private service connect is enabled.
    },
    &quot;serviceAccount&quot;: &quot;A String&quot;, # The service account that the DeployedModel&#x27;s container runs as. Specify the email address of the service account. If this service account is not specified, the container runs as a service account that doesn&#x27;t have access to the resource project. Users deploying the Model must have the `iam.serviceAccounts.actAs` permission on this service account.
    &quot;sharedResources&quot;: &quot;A String&quot;, # The resource name of the shared DeploymentResourcePool to deploy on. Format: `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  },
  &quot;trafficSplit&quot;: { # A map from a DeployedModel&#x27;s ID to the percentage of this Endpoint&#x27;s traffic that should be forwarded to that DeployedModel. If this field is non-empty, then the Endpoint&#x27;s traffic_split will be overwritten with it. To refer to the ID of the just being deployed Model, a &quot;0&quot; should be used, and the actual ID of the new DeployedModel will be filled in its place by this method. The traffic percentage values must add up to 100. If this field is empty, then the Endpoint&#x27;s traffic_split is not updated.
    &quot;a_key&quot;: 42,
  },
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # This resource represents a long-running operation that is the result of a network API call.
  &quot;done&quot;: True or False, # If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The error result of the operation in case of failure or cancellation.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;metadata&quot;: { # Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
  &quot;name&quot;: &quot;A String&quot;, # The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
  &quot;response&quot;: { # The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="explain">explain(endpoint, body=None, x__xgafv=None)</code>
  <pre>Perform an online explanation. If deployed_model_id is specified, the corresponding DeployModel must have explanation_spec populated. If deployed_model_id is not specified, all DeployedModels must have explanation_spec populated.

Args:
  endpoint: string, Required. The name of the Endpoint requested to serve the explanation. Format: `projects/{project}/locations/{location}/endpoints/{endpoint}` (required)
  body: object, The request body.
    The object takes the form of:

{ # Request message for PredictionService.Explain.
  &quot;deployedModelId&quot;: &quot;A String&quot;, # If specified, this ExplainRequest will be served by the chosen DeployedModel, overriding Endpoint.traffic_split.
  &quot;explanationSpecOverride&quot;: { # The ExplanationSpec entries that can be overridden at online explanation time. # If specified, overrides the explanation_spec of the DeployedModel. Can be used for explaining prediction results with different configurations, such as: - Explaining top-5 predictions results as opposed to top-1; - Increasing path count or step count of the attribution methods to reduce approximate errors; - Using different baselines for explaining the prediction results.
    &quot;examplesOverride&quot;: { # Overrides for example-based explanations. # The example-based explanations parameter overrides.
      &quot;crowdingCount&quot;: 42, # The number of neighbors to return that have the same crowding tag.
      &quot;dataFormat&quot;: &quot;A String&quot;, # The format of the data being provided with each call.
      &quot;neighborCount&quot;: 42, # The number of neighbors to return.
      &quot;restrictions&quot;: [ # Restrict the resulting nearest neighbors to respect these constraints.
        { # Restrictions namespace for example-based explanations overrides.
          &quot;allow&quot;: [ # The list of allowed tags.
            &quot;A String&quot;,
          ],
          &quot;deny&quot;: [ # The list of deny tags.
            &quot;A String&quot;,
          ],
          &quot;namespaceName&quot;: &quot;A String&quot;, # The namespace name.
        },
      ],
      &quot;returnEmbeddings&quot;: True or False, # If true, return the embeddings instead of neighbors.
    },
    &quot;metadata&quot;: { # The ExplanationMetadata entries that can be overridden at online explanation time. # The metadata to be overridden. If not specified, no metadata is overridden.
      &quot;inputs&quot;: { # Required. Overrides the input metadata of the features. The key is the name of the feature to be overridden. The keys specified here must exist in the input metadata to be overridden. If a feature is not specified here, the corresponding feature&#x27;s input metadata is not overridden.
        &quot;a_key&quot;: { # The input metadata entries to be overridden.
          &quot;inputBaselines&quot;: [ # Baseline inputs for this feature. This overrides the `input_baseline` field of the ExplanationMetadata.InputMetadata object of the corresponding feature&#x27;s input metadata. If it&#x27;s not specified, the original baselines are not overridden.
            &quot;&quot;,
          ],
        },
      },
    },
    &quot;parameters&quot;: { # Parameters to configure explaining for Model&#x27;s predictions. # The parameters to be overridden. Note that the attribution method cannot be changed. If not specified, no parameter is overridden.
      &quot;examples&quot;: { # Example-based explainability that returns the nearest neighbors from the provided dataset. # Example-based explanations that returns the nearest neighbors from the provided dataset.
        &quot;exampleGcsSource&quot;: { # The Cloud Storage input instances. # The Cloud Storage input instances.
          &quot;dataFormat&quot;: &quot;A String&quot;, # The format in which instances are given, if not specified, assume it&#x27;s JSONL format. Currently only JSONL format is supported.
          &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage location for the input instances.
            &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
              &quot;A String&quot;,
            ],
          },
        },
        &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage locations that contain the instances to be indexed for approximate nearest neighbor search.
          &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
            &quot;A String&quot;,
          ],
        },
        &quot;nearestNeighborSearchConfig&quot;: &quot;&quot;, # The full configuration for the generated index, the semantics are the same as metadata and should match [NearestNeighborSearchConfig](https://cloud.google.com/vertex-ai/docs/explainable-ai/configuring-explanations-example-based#nearest-neighbor-search-config).
        &quot;neighborCount&quot;: 42, # The number of neighbors to return when querying for examples.
        &quot;presets&quot;: { # Preset configuration for example-based explanations # Simplified preset configuration, which automatically sets configuration values based on the desired query speed-precision trade-off and modality.
          &quot;modality&quot;: &quot;A String&quot;, # The modality of the uploaded model, which automatically configures the distance measurement and feature normalization for the underlying example index and queries. If your model does not precisely fit one of these types, it is okay to choose the closest type.
          &quot;query&quot;: &quot;A String&quot;, # Preset option controlling parameters for speed-precision trade-off when querying for examples. If omitted, defaults to `PRECISE`.
        },
      },
      &quot;integratedGradientsAttribution&quot;: { # An attribution method that computes the Aumann-Shapley value taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365 # An attribution method that computes Aumann-Shapley values taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365
        &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for IG with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
          &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
        },
        &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
          &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
            &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
              { # Noise sigma for a single feature.
                &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
              },
            ],
          },
          &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
          &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
        },
        &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is within the desired error range. Valid range of its value is [1, 100], inclusively.
      },
      &quot;outputIndices&quot;: [ # If populated, only returns attributions that have output_index contained in output_indices. It must be an ndarray of integers, with the same shape of the output it&#x27;s explaining. If not populated, returns attributions for top_k indices of outputs. If neither top_k nor output_indices is populated, returns the argmax index of the outputs. Only applicable to Models that predict multiple outputs (e,g, multi-class Models that predict multiple classes).
        &quot;&quot;,
      ],
      &quot;sampledShapleyAttribution&quot;: { # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. Refer to this paper for model details: https://arxiv.org/abs/1306.4265.
        &quot;pathCount&quot;: 42, # Required. The number of feature permutations to consider when approximating the Shapley values. Valid range of its value is [1, 50], inclusively.
      },
      &quot;topK&quot;: 42, # If populated, returns attributions for top K indices of outputs (defaults to 1). Only applies to Models that predicts more than one outputs (e,g, multi-class Models). When set to -1, returns explanations for all outputs.
      &quot;xraiAttribution&quot;: { # An explanation method that redistributes Integrated Gradients attributions to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 Supported only by image Models. # An attribution method that redistributes Integrated Gradients attribution to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 XRAI currently performs better on natural images, like a picture of a house or an animal. If the images are taken in artificial environments, like a lab or manufacturing line, or from diagnostic equipment, like x-rays or quality-control cameras, use Integrated Gradients instead.
        &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for XRAI with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
          &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
        },
        &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
          &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
            &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
              { # Noise sigma for a single feature.
                &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
              },
            ],
          },
          &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
          &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
        },
        &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is met within the desired error range. Valid range of its value is [1, 100], inclusively.
      },
    },
  },
  &quot;instances&quot;: [ # Required. The instances that are the input to the explanation call. A DeployedModel may have an upper limit on the number of instances it supports per request, and when it is exceeded the explanation call errors in case of AutoML Models, or, in case of customer created Models, the behaviour is as documented by that Model. The schema of any single instance may be specified via Endpoint&#x27;s DeployedModels&#x27; Model&#x27;s PredictSchemata&#x27;s instance_schema_uri.
    &quot;&quot;,
  ],
  &quot;parameters&quot;: &quot;&quot;, # The parameters that govern the prediction. The schema of the parameters may be specified via Endpoint&#x27;s DeployedModels&#x27; Model&#x27;s PredictSchemata&#x27;s parameters_schema_uri.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response message for PredictionService.Explain.
  &quot;deployedModelId&quot;: &quot;A String&quot;, # ID of the Endpoint&#x27;s DeployedModel that served this explanation.
  &quot;explanations&quot;: [ # The explanations of the Model&#x27;s PredictResponse.predictions. It has the same number of elements as instances to be explained.
    { # Explanation of a prediction (provided in PredictResponse.predictions) produced by the Model on a given instance.
      &quot;attributions&quot;: [ # Output only. Feature attributions grouped by predicted outputs. For Models that predict only one output, such as regression Models that predict only one score, there is only one attibution that explains the predicted output. For Models that predict multiple outputs, such as multiclass Models that predict multiple classes, each element explains one specific item. Attribution.output_index can be used to identify which output this attribution is explaining. If users set ExplanationParameters.top_k, the attributions are sorted by instance_output_value in descending order. If ExplanationParameters.output_indices is specified, the attributions are stored by Attribution.output_index in the same order as they appear in the output_indices.
        { # Attribution that explains a particular prediction output.
          &quot;approximationError&quot;: 3.14, # Output only. Error of feature_attributions caused by approximation used in the explanation method. Lower value means more precise attributions. * For Sampled Shapley attribution, increasing path_count might reduce the error. * For Integrated Gradients attribution, increasing step_count might reduce the error. * For XRAI attribution, increasing step_count might reduce the error. See [this introduction](/vertex-ai/docs/explainable-ai/overview) for more information.
          &quot;baselineOutputValue&quot;: 3.14, # Output only. Model predicted output if the input instance is constructed from the baselines of all the features defined in ExplanationMetadata.inputs. The field name of the output is determined by the key in ExplanationMetadata.outputs. If the Model&#x27;s predicted output has multiple dimensions (rank &gt; 1), this is the value in the output located by output_index. If there are multiple baselines, their output values are averaged.
          &quot;featureAttributions&quot;: &quot;&quot;, # Output only. Attributions of each explained feature. Features are extracted from the prediction instances according to explanation metadata for inputs. The value is a struct, whose keys are the name of the feature. The values are how much the feature in the instance contributed to the predicted result. The format of the value is determined by the feature&#x27;s input format: * If the feature is a scalar value, the attribution value is a floating number. * If the feature is an array of scalar values, the attribution value is an array. * If the feature is a struct, the attribution value is a struct. The keys in the attribution value struct are the same as the keys in the feature struct. The formats of the values in the attribution struct are determined by the formats of the values in the feature struct. The ExplanationMetadata.feature_attributions_schema_uri field, pointed to by the ExplanationSpec field of the Endpoint.deployed_models object, points to the schema file that describes the features and their attribution values (if it is populated).
          &quot;instanceOutputValue&quot;: 3.14, # Output only. Model predicted output on the corresponding explanation instance. The field name of the output is determined by the key in ExplanationMetadata.outputs. If the Model predicted output has multiple dimensions, this is the value in the output located by output_index.
          &quot;outputDisplayName&quot;: &quot;A String&quot;, # Output only. The display name of the output identified by output_index. For example, the predicted class name by a multi-classification Model. This field is only populated iff the Model predicts display names as a separate field along with the explained output. The predicted display name must has the same shape of the explained output, and can be located using output_index.
          &quot;outputIndex&quot;: [ # Output only. The index that locates the explained prediction output. If the prediction output is a scalar value, output_index is not populated. If the prediction output has multiple dimensions, the length of the output_index list is the same as the number of dimensions of the output. The i-th element in output_index is the element index of the i-th dimension of the output vector. Indices start from 0.
            42,
          ],
          &quot;outputName&quot;: &quot;A String&quot;, # Output only. Name of the explain output. Specified as the key in ExplanationMetadata.outputs.
        },
      ],
      &quot;neighbors&quot;: [ # Output only. List of the nearest neighbors for example-based explanations. For models deployed with the examples explanations feature enabled, the attributions field is empty and instead the neighbors field is populated.
        { # Neighbors for example-based explanations.
          &quot;neighborDistance&quot;: 3.14, # Output only. The neighbor distance.
          &quot;neighborId&quot;: &quot;A String&quot;, # Output only. The neighbor id.
        },
      ],
    },
  ],
  &quot;predictions&quot;: [ # The predictions that are the output of the predictions call. Same as PredictResponse.predictions.
    &quot;&quot;,
  ],
}</pre>
</div>

<div class="method">
    <code class="details" id="get">get(name, x__xgafv=None)</code>
  <pre>Gets an Endpoint.

Args:
  name: string, Required. The name of the Endpoint resource. Format: `projects/{project}/locations/{location}/endpoints/{endpoint}` (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Models are deployed into it, and afterwards Endpoint is called to obtain predictions and explanations.
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Endpoint was created.
  &quot;deployedModels&quot;: [ # Output only. The models deployed in this Endpoint. To add or remove DeployedModels use EndpointService.DeployModel and EndpointService.UndeployModel respectively.
    { # A deployment of a Model. Endpoints contain one or more DeployedModels.
      &quot;automaticResources&quot;: { # A description of resources that to large degree are decided by Vertex AI, and require only a modest additional configuration. Each Model supporting these resources documents its specific guidelines. # A description of resources that to large degree are decided by Vertex AI, and require only a modest additional configuration.
        &quot;maxReplicaCount&quot;: 42, # Immutable. The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases. If the requested value is too large, the deployment will error, but if deployment succeeds then the ability to scale the model to that many replicas is guaranteed (barring service outages). If traffic against the DeployedModel increases beyond what its replicas at maximum may handle, a portion of the traffic will be dropped. If this value is not provided, a no upper bound for scaling under heavy traffic will be assume, though Vertex AI may be unable to scale beyond certain replica number.
        &quot;minReplicaCount&quot;: 42, # Immutable. The minimum number of replicas this DeployedModel will be always deployed on. If traffic against it increases, it may dynamically be deployed onto more replicas up to max_replica_count, and as traffic decreases, some of these extra replicas may be freed. If the requested value is too large, the deployment will error.
      },
      &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when the DeployedModel was created.
      &quot;dedicatedResources&quot;: { # A description of resources that are dedicated to a DeployedModel, and that need a higher degree of manual configuration. # A description of resources that are dedicated to the DeployedModel, and that need a higher degree of manual configuration.
        &quot;autoscalingMetricSpecs&quot;: [ # Immutable. The metric specifications that overrides a resource utilization metric (CPU utilization, accelerator&#x27;s duty cycle, and so on) target value (default to 60 if not set). At most one entry is allowed per metric. If machine_spec.accelerator_count is above 0, the autoscaling will be based on both CPU utilization and accelerator&#x27;s duty cycle metrics and scale up when either metrics exceeds its target value while scale down if both metrics are under their target value. The default target value is 60 for both metrics. If machine_spec.accelerator_count is 0, the autoscaling will be based on CPU utilization metric only with default target value 60 if not explicitly set. For example, in the case of Online Prediction, if you want to override target CPU utilization to 80, you should set autoscaling_metric_specs.metric_name to `aiplatform.googleapis.com/prediction/online/cpu/utilization` and autoscaling_metric_specs.target to `80`.
          { # The metric specification that defines the target resource utilization (CPU utilization, accelerator&#x27;s duty cycle, and so on) for calculating the desired replica count.
            &quot;metricName&quot;: &quot;A String&quot;, # Required. The resource metric name. Supported metrics: * For Online Prediction: * `aiplatform.googleapis.com/prediction/online/accelerator/duty_cycle` * `aiplatform.googleapis.com/prediction/online/cpu/utilization`
            &quot;target&quot;: 42, # The target resource utilization in percentage (1% - 100%) for the given metric; once the real usage deviates from the target by a certain percentage, the machine replicas change. The default value is 60 (representing 60%) if not provided.
          },
        ],
        &quot;machineSpec&quot;: { # Specification of a single machine. # Required. Immutable. The specification of a single machine used by the prediction.
          &quot;acceleratorCount&quot;: 42, # The number of accelerators to attach to the machine.
          &quot;acceleratorType&quot;: &quot;A String&quot;, # Immutable. The type of accelerator(s) that may be attached to the machine as per accelerator_count.
          &quot;machineType&quot;: &quot;A String&quot;, # Immutable. The type of the machine. See the [list of machine types supported for prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types) See the [list of machine types supported for custom training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types). For DeployedModel this field is optional, and the default value is `n1-standard-2`. For BatchPredictionJob or as part of WorkerPoolSpec this field is required.
        },
        &quot;maxReplicaCount&quot;: 42, # Immutable. The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases. If the requested value is too large, the deployment will error, but if deployment succeeds then the ability to scale the model to that many replicas is guaranteed (barring service outages). If traffic against the DeployedModel increases beyond what its replicas at maximum may handle, a portion of the traffic will be dropped. If this value is not provided, will use min_replica_count as the default value. The value of this field impacts the charge against Vertex CPU and GPU quotas. Specifically, you will be charged for (max_replica_count * number of cores in the selected machine type) and (max_replica_count * number of GPUs per replica in the selected machine type).
        &quot;minReplicaCount&quot;: 42, # Required. Immutable. The minimum number of machine replicas this DeployedModel will be always deployed on. This value must be greater than or equal to 1. If traffic against the DeployedModel increases, it may dynamically be deployed onto more replicas, and as traffic decreases, some of these extra replicas may be freed.
      },
      &quot;disableExplanations&quot;: True or False, # If true, deploy the model without explainable feature, regardless the existence of Model.explanation_spec or explanation_spec.
      &quot;displayName&quot;: &quot;A String&quot;, # The display name of the DeployedModel. If not provided upon creation, the Model&#x27;s display_name is used.
      &quot;enableAccessLogging&quot;: True or False, # If true, online prediction access logs are sent to Cloud Logging. These logs are like standard server access logs, containing information like timestamp and latency for each prediction request. Note that logs may incur a cost, especially if your project receives prediction requests at a high queries per second rate (QPS). Estimate your costs before enabling this option.
      &quot;enableContainerLogging&quot;: True or False, # If true, the container of the DeployedModel instances will send `stderr` and `stdout` streams to Cloud Logging. Only supported for custom-trained Models and AutoML Tabular Models.
      &quot;explanationSpec&quot;: { # Specification of Model explanation. # Explanation configuration for this DeployedModel. When deploying a Model using EndpointService.DeployModel, this value overrides the value of Model.explanation_spec. All fields of explanation_spec are optional in the request. If a field of explanation_spec is not populated, the value of the same field of Model.explanation_spec is inherited. If the corresponding Model.explanation_spec is not populated, all fields of the explanation_spec will be used for the explanation configuration.
        &quot;metadata&quot;: { # Metadata describing the Model&#x27;s input and output for explanation. # Optional. Metadata describing the Model&#x27;s input and output for explanation.
          &quot;featureAttributionsSchemaUri&quot;: &quot;A String&quot;, # Points to a YAML file stored on Google Cloud Storage describing the format of the feature attributions. The schema is defined as an OpenAPI 3.0.2 [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject). AutoML tabular Models always have this field populated by Vertex AI. Note: The URI given on output may be different, including the URI scheme, than the one given on input. The output URI will point to a location where the user only has a read access.
          &quot;inputs&quot;: { # Required. Map from feature names to feature input metadata. Keys are the name of the features. Values are the specification of the feature. An empty InputMetadata is valid. It describes a text feature which has the name specified as the key in ExplanationMetadata.inputs. The baseline of the empty feature is chosen by Vertex AI. For Vertex AI-provided Tensorflow images, the key can be any friendly name of the feature. Once specified, featureAttributions are keyed by this key (if not grouped with another feature). For custom images, the key must match with the key in instance.
            &quot;a_key&quot;: { # Metadata of the input of a feature. Fields other than InputMetadata.input_baselines are applicable only for Models that are using Vertex AI-provided images for Tensorflow.
              &quot;denseShapeTensorName&quot;: &quot;A String&quot;, # Specifies the shape of the values of the input if the input is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
              &quot;encodedBaselines&quot;: [ # A list of baselines for the encoded tensor. The shape of each baseline should match the shape of the encoded tensor. If a scalar is provided, Vertex AI broadcasts to the same shape as the encoded tensor.
                &quot;&quot;,
              ],
              &quot;encodedTensorName&quot;: &quot;A String&quot;, # Encoded tensor is a transformation of the input tensor. Must be provided if choosing Integrated Gradients attribution or XRAI attribution and the input tensor is not differentiable. An encoded tensor is generated if the input tensor is encoded by a lookup table.
              &quot;encoding&quot;: &quot;A String&quot;, # Defines how the feature is encoded into the input tensor. Defaults to IDENTITY.
              &quot;featureValueDomain&quot;: { # Domain details of the input feature value. Provides numeric information about the feature, such as its range (min, max). If the feature has been pre-processed, for example with z-scoring, then it provides information about how to recover the original feature. For example, if the input feature is an image and it has been pre-processed to obtain 0-mean and stddev = 1 values, then original_mean, and original_stddev refer to the mean and stddev of the original feature (e.g. image tensor) from which input feature (with mean = 0 and stddev = 1) was obtained. # The domain details of the input feature value. Like min/max, original mean or standard deviation if normalized.
                &quot;maxValue&quot;: 3.14, # The maximum permissible value for this feature.
                &quot;minValue&quot;: 3.14, # The minimum permissible value for this feature.
                &quot;originalMean&quot;: 3.14, # If this input feature has been normalized to a mean value of 0, the original_mean specifies the mean value of the domain prior to normalization.
                &quot;originalStddev&quot;: 3.14, # If this input feature has been normalized to a standard deviation of 1.0, the original_stddev specifies the standard deviation of the domain prior to normalization.
              },
              &quot;groupName&quot;: &quot;A String&quot;, # Name of the group that the input belongs to. Features with the same group name will be treated as one feature when computing attributions. Features grouped together can have different shapes in value. If provided, there will be one single attribution generated in Attribution.feature_attributions, keyed by the group name.
              &quot;indexFeatureMapping&quot;: [ # A list of feature names for each index in the input tensor. Required when the input InputMetadata.encoding is BAG_OF_FEATURES, BAG_OF_FEATURES_SPARSE, INDICATOR.
                &quot;A String&quot;,
              ],
              &quot;indicesTensorName&quot;: &quot;A String&quot;, # Specifies the index of the values of the input tensor. Required when the input tensor is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
              &quot;inputBaselines&quot;: [ # Baseline inputs for this feature. If no baseline is specified, Vertex AI chooses the baseline for this feature. If multiple baselines are specified, Vertex AI returns the average attributions across them in Attribution.feature_attributions. For Vertex AI-provided Tensorflow images (both 1.x and 2.x), the shape of each baseline must match the shape of the input tensor. If a scalar is provided, we broadcast to the same shape as the input tensor. For custom images, the element of the baselines must be in the same format as the feature&#x27;s input in the instance[]. The schema of any single instance may be specified via Endpoint&#x27;s DeployedModels&#x27; Model&#x27;s PredictSchemata&#x27;s instance_schema_uri.
                &quot;&quot;,
              ],
              &quot;inputTensorName&quot;: &quot;A String&quot;, # Name of the input tensor for this feature. Required and is only applicable to Vertex AI-provided images for Tensorflow.
              &quot;modality&quot;: &quot;A String&quot;, # Modality of the feature. Valid values are: numeric, image. Defaults to numeric.
              &quot;visualization&quot;: { # Visualization configurations for image explanation. # Visualization configurations for image explanation.
                &quot;clipPercentLowerbound&quot;: 3.14, # Excludes attributions below the specified percentile, from the highlighted areas. Defaults to 62.
                &quot;clipPercentUpperbound&quot;: 3.14, # Excludes attributions above the specified percentile from the highlighted areas. Using the clip_percent_upperbound and clip_percent_lowerbound together can be useful for filtering out noise and making it easier to see areas of strong attribution. Defaults to 99.9.
                &quot;colorMap&quot;: &quot;A String&quot;, # The color scheme used for the highlighted areas. Defaults to PINK_GREEN for Integrated Gradients attribution, which shows positive attributions in green and negative in pink. Defaults to VIRIDIS for XRAI attribution, which highlights the most influential regions in yellow and the least influential in blue.
                &quot;overlayType&quot;: &quot;A String&quot;, # How the original image is displayed in the visualization. Adjusting the overlay can help increase visual clarity if the original image makes it difficult to view the visualization. Defaults to NONE.
                &quot;polarity&quot;: &quot;A String&quot;, # Whether to only highlight pixels with positive contributions, negative or both. Defaults to POSITIVE.
                &quot;type&quot;: &quot;A String&quot;, # Type of the image visualization. Only applicable to Integrated Gradients attribution. OUTLINES shows regions of attribution, while PIXELS shows per-pixel attribution. Defaults to OUTLINES.
              },
            },
          },
          &quot;latentSpaceSource&quot;: &quot;A String&quot;, # Name of the source to generate embeddings for example based explanations.
          &quot;outputs&quot;: { # Required. Map from output names to output metadata. For Vertex AI-provided Tensorflow images, keys can be any user defined string that consists of any UTF-8 characters. For custom images, keys are the name of the output field in the prediction to be explained. Currently only one key is allowed.
            &quot;a_key&quot;: { # Metadata of the prediction output to be explained.
              &quot;displayNameMappingKey&quot;: &quot;A String&quot;, # Specify a field name in the prediction to look for the display name. Use this if the prediction contains the display names for the outputs. The display names in the prediction must have the same shape of the outputs, so that it can be located by Attribution.output_index for a specific output.
              &quot;indexDisplayNameMapping&quot;: &quot;&quot;, # Static mapping between the index and display name. Use this if the outputs are a deterministic n-dimensional array, e.g. a list of scores of all the classes in a pre-defined order for a multi-classification Model. It&#x27;s not feasible if the outputs are non-deterministic, e.g. the Model produces top-k classes or sort the outputs by their values. The shape of the value must be an n-dimensional array of strings. The number of dimensions must match that of the outputs to be explained. The Attribution.output_display_name is populated by locating in the mapping with Attribution.output_index.
              &quot;outputTensorName&quot;: &quot;A String&quot;, # Name of the output tensor. Required and is only applicable to Vertex AI provided images for Tensorflow.
            },
          },
        },
        &quot;parameters&quot;: { # Parameters to configure explaining for Model&#x27;s predictions. # Required. Parameters that configure explaining of the Model&#x27;s predictions.
          &quot;examples&quot;: { # Example-based explainability that returns the nearest neighbors from the provided dataset. # Example-based explanations that returns the nearest neighbors from the provided dataset.
            &quot;exampleGcsSource&quot;: { # The Cloud Storage input instances. # The Cloud Storage input instances.
              &quot;dataFormat&quot;: &quot;A String&quot;, # The format in which instances are given, if not specified, assume it&#x27;s JSONL format. Currently only JSONL format is supported.
              &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage location for the input instances.
                &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                  &quot;A String&quot;,
                ],
              },
            },
            &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage locations that contain the instances to be indexed for approximate nearest neighbor search.
              &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                &quot;A String&quot;,
              ],
            },
            &quot;nearestNeighborSearchConfig&quot;: &quot;&quot;, # The full configuration for the generated index, the semantics are the same as metadata and should match [NearestNeighborSearchConfig](https://cloud.google.com/vertex-ai/docs/explainable-ai/configuring-explanations-example-based#nearest-neighbor-search-config).
            &quot;neighborCount&quot;: 42, # The number of neighbors to return when querying for examples.
            &quot;presets&quot;: { # Preset configuration for example-based explanations # Simplified preset configuration, which automatically sets configuration values based on the desired query speed-precision trade-off and modality.
              &quot;modality&quot;: &quot;A String&quot;, # The modality of the uploaded model, which automatically configures the distance measurement and feature normalization for the underlying example index and queries. If your model does not precisely fit one of these types, it is okay to choose the closest type.
              &quot;query&quot;: &quot;A String&quot;, # Preset option controlling parameters for speed-precision trade-off when querying for examples. If omitted, defaults to `PRECISE`.
            },
          },
          &quot;integratedGradientsAttribution&quot;: { # An attribution method that computes the Aumann-Shapley value taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365 # An attribution method that computes Aumann-Shapley values taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365
            &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for IG with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
              &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
            },
            &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
              &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
                &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
                  { # Noise sigma for a single feature.
                    &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                    &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
                  },
                ],
              },
              &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
              &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
            },
            &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is within the desired error range. Valid range of its value is [1, 100], inclusively.
          },
          &quot;outputIndices&quot;: [ # If populated, only returns attributions that have output_index contained in output_indices. It must be an ndarray of integers, with the same shape of the output it&#x27;s explaining. If not populated, returns attributions for top_k indices of outputs. If neither top_k nor output_indices is populated, returns the argmax index of the outputs. Only applicable to Models that predict multiple outputs (e,g, multi-class Models that predict multiple classes).
            &quot;&quot;,
          ],
          &quot;sampledShapleyAttribution&quot;: { # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. Refer to this paper for model details: https://arxiv.org/abs/1306.4265.
            &quot;pathCount&quot;: 42, # Required. The number of feature permutations to consider when approximating the Shapley values. Valid range of its value is [1, 50], inclusively.
          },
          &quot;topK&quot;: 42, # If populated, returns attributions for top K indices of outputs (defaults to 1). Only applies to Models that predicts more than one outputs (e,g, multi-class Models). When set to -1, returns explanations for all outputs.
          &quot;xraiAttribution&quot;: { # An explanation method that redistributes Integrated Gradients attributions to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 Supported only by image Models. # An attribution method that redistributes Integrated Gradients attribution to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 XRAI currently performs better on natural images, like a picture of a house or an animal. If the images are taken in artificial environments, like a lab or manufacturing line, or from diagnostic equipment, like x-rays or quality-control cameras, use Integrated Gradients instead.
            &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for XRAI with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
              &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
            },
            &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
              &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
                &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
                  { # Noise sigma for a single feature.
                    &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                    &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
                  },
                ],
              },
              &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
              &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
            },
            &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is met within the desired error range. Valid range of its value is [1, 100], inclusively.
          },
        },
      },
      &quot;id&quot;: &quot;A String&quot;, # Immutable. The ID of the DeployedModel. If not provided upon deployment, Vertex AI will generate a value for this ID. This value should be 1-10 characters, and valid characters are /[0-9]/.
      &quot;model&quot;: &quot;A String&quot;, # Required. The resource name of the Model that this is the deployment of. Note that the Model may be in a different location than the DeployedModel&#x27;s Endpoint. The resource name may contain version id or version alias to specify the version. Example: `projects/{project}/locations/{location}/models/{model}@2` or `projects/{project}/locations/{location}/models/{model}@golden` if no version is specified, the default version will be deployed.
      &quot;modelVersionId&quot;: &quot;A String&quot;, # Output only. The version ID of the model that is deployed.
      &quot;privateEndpoints&quot;: { # PrivateEndpoints proto is used to provide paths for users to send requests privately. To send request via private service access, use predict_http_uri, explain_http_uri or health_http_uri. To send request via private service connect, use service_attachment. # Output only. Provide paths for users to send predict/explain/health requests directly to the deployed model services running on Cloud via private services access. This field is populated if network is configured.
        &quot;explainHttpUri&quot;: &quot;A String&quot;, # Output only. Http(s) path to send explain requests.
        &quot;healthHttpUri&quot;: &quot;A String&quot;, # Output only. Http(s) path to send health check requests.
        &quot;predictHttpUri&quot;: &quot;A String&quot;, # Output only. Http(s) path to send prediction requests.
        &quot;serviceAttachment&quot;: &quot;A String&quot;, # Output only. The name of the service attachment resource. Populated if private service connect is enabled.
      },
      &quot;serviceAccount&quot;: &quot;A String&quot;, # The service account that the DeployedModel&#x27;s container runs as. Specify the email address of the service account. If this service account is not specified, the container runs as a service account that doesn&#x27;t have access to the resource project. Users deploying the Model must have the `iam.serviceAccounts.actAs` permission on this service account.
      &quot;sharedResources&quot;: &quot;A String&quot;, # The resource name of the shared DeploymentResourcePool to deploy on. Format: `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
    },
  ],
  &quot;description&quot;: &quot;A String&quot;, # The description of the Endpoint.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The display name of the Endpoint. The name can be up to 128 characters long and can consist of any UTF-8 characters.
  &quot;enablePrivateServiceConnect&quot;: True or False, # Deprecated: If true, expose the Endpoint via private service connect. Only one of the fields, network or enable_private_service_connect, can be set.
  &quot;encryptionSpec&quot;: { # Represents a customer-managed encryption key spec that can be applied to a top-level resource. # Customer-managed encryption key spec for an Endpoint. If set, this Endpoint and all sub-resources of this Endpoint will be secured by this key.
    &quot;kmsKeyName&quot;: &quot;A String&quot;, # Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
  },
  &quot;etag&quot;: &quot;A String&quot;, # Used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
  &quot;labels&quot;: { # The labels with user-defined metadata to organize your Endpoints. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels.
    &quot;a_key&quot;: &quot;A String&quot;,
  },
  &quot;modelDeploymentMonitoringJob&quot;: &quot;A String&quot;, # Output only. Resource name of the Model Monitoring job associated with this Endpoint if monitoring is enabled by JobService.CreateModelDeploymentMonitoringJob. Format: `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the Endpoint.
  &quot;network&quot;: &quot;A String&quot;, # Optional. The full name of the Google Compute Engine [network](https://cloud.google.com//compute/docs/networks-and-firewalls#networks) to which the Endpoint should be peered. Private services access must already be configured for the network. If left unspecified, the Endpoint is not peered with any network. Only one of the fields, network or enable_private_service_connect, can be set. [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/insert): `projects/{project}/global/networks/{network}`. Where `{project}` is a project number, as in `12345`, and `{network}` is network name.
  &quot;predictRequestResponseLoggingConfig&quot;: { # Configuration for logging request-response to a BigQuery table. # Configures the request-response logging for online prediction.
    &quot;bigqueryDestination&quot;: { # The BigQuery location for the output content. # BigQuery table for logging. If only given a project, a new dataset will be created with name `logging__` where will be made BigQuery-dataset-name compatible (e.g. most special characters will become underscores). If no table name is given, a new table will be created with name `request_response_logging`
      &quot;outputUri&quot;: &quot;A String&quot;, # Required. BigQuery URI to a project or table, up to 2000 characters long. When only the project is specified, the Dataset and Table is created. When the full table reference is specified, the Dataset must exist and table must not exist. Accepted forms: * BigQuery path. For example: `bq://projectId` or `bq://projectId.bqDatasetId` or `bq://projectId.bqDatasetId.bqTableId`.
    },
    &quot;enabled&quot;: True or False, # If logging is enabled or not.
    &quot;samplingRate&quot;: 3.14, # Percentage of requests to be logged, expressed as a fraction in range(0,1].
  },
  &quot;trafficSplit&quot;: { # A map from a DeployedModel&#x27;s ID to the percentage of this Endpoint&#x27;s traffic that should be forwarded to that DeployedModel. If a DeployedModel&#x27;s ID is not listed in this map, then it receives no traffic. The traffic percentage values must add up to 100, or map must be empty if the Endpoint is to not accept any traffic at a moment.
    &quot;a_key&quot;: 42,
  },
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Endpoint was last updated.
}</pre>
</div>

<div class="method">
    <code class="details" id="getIamPolicy">getIamPolicy(resource, options_requestedPolicyVersion=None, x__xgafv=None)</code>
  <pre>Gets the access control policy for a resource. Returns an empty policy if the resource exists and does not have a policy set.

Args:
  resource: string, REQUIRED: The resource for which the policy is being requested. See [Resource names](https://cloud.google.com/apis/design/resource_names) for the appropriate value for this field. (required)
  options_requestedPolicyVersion: integer, Optional. The maximum policy version that will be used to format the policy. Valid values are 0, 1, and 3. Requests specifying an invalid value will be rejected. Requests for policies with any conditional role bindings must specify version 3. Policies with no conditional role bindings may specify any valid value or leave the field unset. The policy in the response might use the policy version that you specified, or it might use a lower policy version. For example, if you specify version 3, but the policy has no conditional role bindings, the response uses version 1. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # An Identity and Access Management (IAM) policy, which specifies access controls for Google Cloud resources. A `Policy` is a collection of `bindings`. A `binding` binds one or more `members`, or principals, to a single `role`. Principals can be user accounts, service accounts, Google groups, and domains (such as G Suite). A `role` is a named list of permissions; each `role` can be an IAM predefined role or a user-created custom role. For some types of Google Cloud resources, a `binding` can also specify a `condition`, which is a logical expression that allows access to a resource only if the expression evaluates to `true`. A condition can add constraints based on attributes of the request, the resource, or both. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies). **JSON example:** ``` { &quot;bindings&quot;: [ { &quot;role&quot;: &quot;roles/resourcemanager.organizationAdmin&quot;, &quot;members&quot;: [ &quot;user:mike@example.com&quot;, &quot;group:admins@example.com&quot;, &quot;domain:google.com&quot;, &quot;serviceAccount:my-project-id@appspot.gserviceaccount.com&quot; ] }, { &quot;role&quot;: &quot;roles/resourcemanager.organizationViewer&quot;, &quot;members&quot;: [ &quot;user:eve@example.com&quot; ], &quot;condition&quot;: { &quot;title&quot;: &quot;expirable access&quot;, &quot;description&quot;: &quot;Does not grant access after Sep 2020&quot;, &quot;expression&quot;: &quot;request.time &lt; timestamp(&#x27;2020-10-01T00:00:00.000Z&#x27;)&quot;, } } ], &quot;etag&quot;: &quot;BwWWja0YfJA=&quot;, &quot;version&quot;: 3 } ``` **YAML example:** ``` bindings: - members: - user:mike@example.com - group:admins@example.com - domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com role: roles/resourcemanager.organizationAdmin - members: - user:eve@example.com role: roles/resourcemanager.organizationViewer condition: title: expirable access description: Does not grant access after Sep 2020 expression: request.time &lt; timestamp(&#x27;2020-10-01T00:00:00.000Z&#x27;) etag: BwWWja0YfJA= version: 3 ``` For a description of IAM and its features, see the [IAM documentation](https://cloud.google.com/iam/docs/).
  &quot;bindings&quot;: [ # Associates a list of `members`, or principals, with a `role`. Optionally, may specify a `condition` that determines how and when the `bindings` are applied. Each of the `bindings` must contain at least one principal. The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250 of these principals can be Google groups. Each occurrence of a principal counts towards these limits. For example, if the `bindings` grant 50 different roles to `user:alice@example.com`, and not to any other principal, then you can add another 1,450 principals to the `bindings` in the `Policy`.
    { # Associates `members`, or principals, with a `role`.
      &quot;condition&quot;: { # Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: &quot;Summary size limit&quot; description: &quot;Determines if a summary is less than 100 chars&quot; expression: &quot;document.summary.size() &lt; 100&quot; Example (Equality): title: &quot;Requestor is owner&quot; description: &quot;Determines if requestor is the document owner&quot; expression: &quot;document.owner == request.auth.claims.email&quot; Example (Logic): title: &quot;Public documents&quot; description: &quot;Determine whether the document should be publicly visible&quot; expression: &quot;document.type != &#x27;private&#x27; &amp;&amp; document.type != &#x27;internal&#x27;&quot; Example (Data Manipulation): title: &quot;Notification string&quot; description: &quot;Create a notification string with a timestamp.&quot; expression: &quot;&#x27;New message received at &#x27; + string(document.create_time)&quot; The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information. # The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
        &quot;description&quot;: &quot;A String&quot;, # Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        &quot;expression&quot;: &quot;A String&quot;, # Textual representation of an expression in Common Expression Language syntax.
        &quot;location&quot;: &quot;A String&quot;, # Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
        &quot;title&quot;: &quot;A String&quot;, # Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
      },
      &quot;members&quot;: [ # Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
        &quot;A String&quot;,
      ],
      &quot;role&quot;: &quot;A String&quot;, # Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
    },
  ],
  &quot;etag&quot;: &quot;A String&quot;, # `etag` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. It is strongly suggested that systems make use of the `etag` in the read-modify-write cycle to perform policy updates in order to avoid race conditions: An `etag` is returned in the response to `getIamPolicy`, and systems are expected to put that etag in the request to `setIamPolicy` to ensure that their change will be applied to the same version of the policy. **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost.
  &quot;version&quot;: 42, # Specifies the format of the policy. Valid values are `0`, `1`, and `3`. Requests that specify an invalid value are rejected. Any operation that affects conditional role bindings must specify version `3`. This requirement applies to the following operations: * Getting a policy that includes a conditional role binding * Adding a conditional role binding to a policy * Changing a conditional role binding in a policy * Removing any role binding, with or without a condition, from a policy that includes conditions **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost. If a policy does not include any conditions, operations on that policy may specify any valid version or leave the field unset. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
}</pre>
</div>

<div class="method">
    <code class="details" id="list">list(parent, filter=None, pageSize=None, pageToken=None, readMask=None, x__xgafv=None)</code>
  <pre>Lists Endpoints in a Location.

Args:
  parent: string, Required. The resource name of the Location from which to list the Endpoints. Format: `projects/{project}/locations/{location}` (required)
  filter: string, Optional. An expression for filtering the results of the request. For field names both snake_case and camelCase are supported. * `endpoint` supports = and !=. `endpoint` represents the Endpoint ID, i.e. the last segment of the Endpoint&#x27;s resource name. * `display_name` supports = and, != * `labels` supports general map functions that is: * `labels.key=value` - key:value equality * `labels.key:* or labels:key - key existence * A key including a space must be quoted. `labels.&quot;a key&quot;`. Some examples: * `endpoint=1` * `displayName=&quot;myDisplayName&quot;` * `labels.myKey=&quot;myValue&quot;`
  pageSize: integer, Optional. The standard list page size.
  pageToken: string, Optional. The standard list page token. Typically obtained via ListEndpointsResponse.next_page_token of the previous EndpointService.ListEndpoints call.
  readMask: string, Optional. Mask specifying which fields to read.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response message for EndpointService.ListEndpoints.
  &quot;endpoints&quot;: [ # List of Endpoints in the requested page.
    { # Models are deployed into it, and afterwards Endpoint is called to obtain predictions and explanations.
      &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Endpoint was created.
      &quot;deployedModels&quot;: [ # Output only. The models deployed in this Endpoint. To add or remove DeployedModels use EndpointService.DeployModel and EndpointService.UndeployModel respectively.
        { # A deployment of a Model. Endpoints contain one or more DeployedModels.
          &quot;automaticResources&quot;: { # A description of resources that to large degree are decided by Vertex AI, and require only a modest additional configuration. Each Model supporting these resources documents its specific guidelines. # A description of resources that to large degree are decided by Vertex AI, and require only a modest additional configuration.
            &quot;maxReplicaCount&quot;: 42, # Immutable. The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases. If the requested value is too large, the deployment will error, but if deployment succeeds then the ability to scale the model to that many replicas is guaranteed (barring service outages). If traffic against the DeployedModel increases beyond what its replicas at maximum may handle, a portion of the traffic will be dropped. If this value is not provided, a no upper bound for scaling under heavy traffic will be assume, though Vertex AI may be unable to scale beyond certain replica number.
            &quot;minReplicaCount&quot;: 42, # Immutable. The minimum number of replicas this DeployedModel will be always deployed on. If traffic against it increases, it may dynamically be deployed onto more replicas up to max_replica_count, and as traffic decreases, some of these extra replicas may be freed. If the requested value is too large, the deployment will error.
          },
          &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when the DeployedModel was created.
          &quot;dedicatedResources&quot;: { # A description of resources that are dedicated to a DeployedModel, and that need a higher degree of manual configuration. # A description of resources that are dedicated to the DeployedModel, and that need a higher degree of manual configuration.
            &quot;autoscalingMetricSpecs&quot;: [ # Immutable. The metric specifications that overrides a resource utilization metric (CPU utilization, accelerator&#x27;s duty cycle, and so on) target value (default to 60 if not set). At most one entry is allowed per metric. If machine_spec.accelerator_count is above 0, the autoscaling will be based on both CPU utilization and accelerator&#x27;s duty cycle metrics and scale up when either metrics exceeds its target value while scale down if both metrics are under their target value. The default target value is 60 for both metrics. If machine_spec.accelerator_count is 0, the autoscaling will be based on CPU utilization metric only with default target value 60 if not explicitly set. For example, in the case of Online Prediction, if you want to override target CPU utilization to 80, you should set autoscaling_metric_specs.metric_name to `aiplatform.googleapis.com/prediction/online/cpu/utilization` and autoscaling_metric_specs.target to `80`.
              { # The metric specification that defines the target resource utilization (CPU utilization, accelerator&#x27;s duty cycle, and so on) for calculating the desired replica count.
                &quot;metricName&quot;: &quot;A String&quot;, # Required. The resource metric name. Supported metrics: * For Online Prediction: * `aiplatform.googleapis.com/prediction/online/accelerator/duty_cycle` * `aiplatform.googleapis.com/prediction/online/cpu/utilization`
                &quot;target&quot;: 42, # The target resource utilization in percentage (1% - 100%) for the given metric; once the real usage deviates from the target by a certain percentage, the machine replicas change. The default value is 60 (representing 60%) if not provided.
              },
            ],
            &quot;machineSpec&quot;: { # Specification of a single machine. # Required. Immutable. The specification of a single machine used by the prediction.
              &quot;acceleratorCount&quot;: 42, # The number of accelerators to attach to the machine.
              &quot;acceleratorType&quot;: &quot;A String&quot;, # Immutable. The type of accelerator(s) that may be attached to the machine as per accelerator_count.
              &quot;machineType&quot;: &quot;A String&quot;, # Immutable. The type of the machine. See the [list of machine types supported for prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types) See the [list of machine types supported for custom training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types). For DeployedModel this field is optional, and the default value is `n1-standard-2`. For BatchPredictionJob or as part of WorkerPoolSpec this field is required.
            },
            &quot;maxReplicaCount&quot;: 42, # Immutable. The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases. If the requested value is too large, the deployment will error, but if deployment succeeds then the ability to scale the model to that many replicas is guaranteed (barring service outages). If traffic against the DeployedModel increases beyond what its replicas at maximum may handle, a portion of the traffic will be dropped. If this value is not provided, will use min_replica_count as the default value. The value of this field impacts the charge against Vertex CPU and GPU quotas. Specifically, you will be charged for (max_replica_count * number of cores in the selected machine type) and (max_replica_count * number of GPUs per replica in the selected machine type).
            &quot;minReplicaCount&quot;: 42, # Required. Immutable. The minimum number of machine replicas this DeployedModel will be always deployed on. This value must be greater than or equal to 1. If traffic against the DeployedModel increases, it may dynamically be deployed onto more replicas, and as traffic decreases, some of these extra replicas may be freed.
          },
          &quot;disableExplanations&quot;: True or False, # If true, deploy the model without explainable feature, regardless the existence of Model.explanation_spec or explanation_spec.
          &quot;displayName&quot;: &quot;A String&quot;, # The display name of the DeployedModel. If not provided upon creation, the Model&#x27;s display_name is used.
          &quot;enableAccessLogging&quot;: True or False, # If true, online prediction access logs are sent to Cloud Logging. These logs are like standard server access logs, containing information like timestamp and latency for each prediction request. Note that logs may incur a cost, especially if your project receives prediction requests at a high queries per second rate (QPS). Estimate your costs before enabling this option.
          &quot;enableContainerLogging&quot;: True or False, # If true, the container of the DeployedModel instances will send `stderr` and `stdout` streams to Cloud Logging. Only supported for custom-trained Models and AutoML Tabular Models.
          &quot;explanationSpec&quot;: { # Specification of Model explanation. # Explanation configuration for this DeployedModel. When deploying a Model using EndpointService.DeployModel, this value overrides the value of Model.explanation_spec. All fields of explanation_spec are optional in the request. If a field of explanation_spec is not populated, the value of the same field of Model.explanation_spec is inherited. If the corresponding Model.explanation_spec is not populated, all fields of the explanation_spec will be used for the explanation configuration.
            &quot;metadata&quot;: { # Metadata describing the Model&#x27;s input and output for explanation. # Optional. Metadata describing the Model&#x27;s input and output for explanation.
              &quot;featureAttributionsSchemaUri&quot;: &quot;A String&quot;, # Points to a YAML file stored on Google Cloud Storage describing the format of the feature attributions. The schema is defined as an OpenAPI 3.0.2 [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject). AutoML tabular Models always have this field populated by Vertex AI. Note: The URI given on output may be different, including the URI scheme, than the one given on input. The output URI will point to a location where the user only has a read access.
              &quot;inputs&quot;: { # Required. Map from feature names to feature input metadata. Keys are the name of the features. Values are the specification of the feature. An empty InputMetadata is valid. It describes a text feature which has the name specified as the key in ExplanationMetadata.inputs. The baseline of the empty feature is chosen by Vertex AI. For Vertex AI-provided Tensorflow images, the key can be any friendly name of the feature. Once specified, featureAttributions are keyed by this key (if not grouped with another feature). For custom images, the key must match with the key in instance.
                &quot;a_key&quot;: { # Metadata of the input of a feature. Fields other than InputMetadata.input_baselines are applicable only for Models that are using Vertex AI-provided images for Tensorflow.
                  &quot;denseShapeTensorName&quot;: &quot;A String&quot;, # Specifies the shape of the values of the input if the input is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
                  &quot;encodedBaselines&quot;: [ # A list of baselines for the encoded tensor. The shape of each baseline should match the shape of the encoded tensor. If a scalar is provided, Vertex AI broadcasts to the same shape as the encoded tensor.
                    &quot;&quot;,
                  ],
                  &quot;encodedTensorName&quot;: &quot;A String&quot;, # Encoded tensor is a transformation of the input tensor. Must be provided if choosing Integrated Gradients attribution or XRAI attribution and the input tensor is not differentiable. An encoded tensor is generated if the input tensor is encoded by a lookup table.
                  &quot;encoding&quot;: &quot;A String&quot;, # Defines how the feature is encoded into the input tensor. Defaults to IDENTITY.
                  &quot;featureValueDomain&quot;: { # Domain details of the input feature value. Provides numeric information about the feature, such as its range (min, max). If the feature has been pre-processed, for example with z-scoring, then it provides information about how to recover the original feature. For example, if the input feature is an image and it has been pre-processed to obtain 0-mean and stddev = 1 values, then original_mean, and original_stddev refer to the mean and stddev of the original feature (e.g. image tensor) from which input feature (with mean = 0 and stddev = 1) was obtained. # The domain details of the input feature value. Like min/max, original mean or standard deviation if normalized.
                    &quot;maxValue&quot;: 3.14, # The maximum permissible value for this feature.
                    &quot;minValue&quot;: 3.14, # The minimum permissible value for this feature.
                    &quot;originalMean&quot;: 3.14, # If this input feature has been normalized to a mean value of 0, the original_mean specifies the mean value of the domain prior to normalization.
                    &quot;originalStddev&quot;: 3.14, # If this input feature has been normalized to a standard deviation of 1.0, the original_stddev specifies the standard deviation of the domain prior to normalization.
                  },
                  &quot;groupName&quot;: &quot;A String&quot;, # Name of the group that the input belongs to. Features with the same group name will be treated as one feature when computing attributions. Features grouped together can have different shapes in value. If provided, there will be one single attribution generated in Attribution.feature_attributions, keyed by the group name.
                  &quot;indexFeatureMapping&quot;: [ # A list of feature names for each index in the input tensor. Required when the input InputMetadata.encoding is BAG_OF_FEATURES, BAG_OF_FEATURES_SPARSE, INDICATOR.
                    &quot;A String&quot;,
                  ],
                  &quot;indicesTensorName&quot;: &quot;A String&quot;, # Specifies the index of the values of the input tensor. Required when the input tensor is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
                  &quot;inputBaselines&quot;: [ # Baseline inputs for this feature. If no baseline is specified, Vertex AI chooses the baseline for this feature. If multiple baselines are specified, Vertex AI returns the average attributions across them in Attribution.feature_attributions. For Vertex AI-provided Tensorflow images (both 1.x and 2.x), the shape of each baseline must match the shape of the input tensor. If a scalar is provided, we broadcast to the same shape as the input tensor. For custom images, the element of the baselines must be in the same format as the feature&#x27;s input in the instance[]. The schema of any single instance may be specified via Endpoint&#x27;s DeployedModels&#x27; Model&#x27;s PredictSchemata&#x27;s instance_schema_uri.
                    &quot;&quot;,
                  ],
                  &quot;inputTensorName&quot;: &quot;A String&quot;, # Name of the input tensor for this feature. Required and is only applicable to Vertex AI-provided images for Tensorflow.
                  &quot;modality&quot;: &quot;A String&quot;, # Modality of the feature. Valid values are: numeric, image. Defaults to numeric.
                  &quot;visualization&quot;: { # Visualization configurations for image explanation. # Visualization configurations for image explanation.
                    &quot;clipPercentLowerbound&quot;: 3.14, # Excludes attributions below the specified percentile, from the highlighted areas. Defaults to 62.
                    &quot;clipPercentUpperbound&quot;: 3.14, # Excludes attributions above the specified percentile from the highlighted areas. Using the clip_percent_upperbound and clip_percent_lowerbound together can be useful for filtering out noise and making it easier to see areas of strong attribution. Defaults to 99.9.
                    &quot;colorMap&quot;: &quot;A String&quot;, # The color scheme used for the highlighted areas. Defaults to PINK_GREEN for Integrated Gradients attribution, which shows positive attributions in green and negative in pink. Defaults to VIRIDIS for XRAI attribution, which highlights the most influential regions in yellow and the least influential in blue.
                    &quot;overlayType&quot;: &quot;A String&quot;, # How the original image is displayed in the visualization. Adjusting the overlay can help increase visual clarity if the original image makes it difficult to view the visualization. Defaults to NONE.
                    &quot;polarity&quot;: &quot;A String&quot;, # Whether to only highlight pixels with positive contributions, negative or both. Defaults to POSITIVE.
                    &quot;type&quot;: &quot;A String&quot;, # Type of the image visualization. Only applicable to Integrated Gradients attribution. OUTLINES shows regions of attribution, while PIXELS shows per-pixel attribution. Defaults to OUTLINES.
                  },
                },
              },
              &quot;latentSpaceSource&quot;: &quot;A String&quot;, # Name of the source to generate embeddings for example based explanations.
              &quot;outputs&quot;: { # Required. Map from output names to output metadata. For Vertex AI-provided Tensorflow images, keys can be any user defined string that consists of any UTF-8 characters. For custom images, keys are the name of the output field in the prediction to be explained. Currently only one key is allowed.
                &quot;a_key&quot;: { # Metadata of the prediction output to be explained.
                  &quot;displayNameMappingKey&quot;: &quot;A String&quot;, # Specify a field name in the prediction to look for the display name. Use this if the prediction contains the display names for the outputs. The display names in the prediction must have the same shape of the outputs, so that it can be located by Attribution.output_index for a specific output.
                  &quot;indexDisplayNameMapping&quot;: &quot;&quot;, # Static mapping between the index and display name. Use this if the outputs are a deterministic n-dimensional array, e.g. a list of scores of all the classes in a pre-defined order for a multi-classification Model. It&#x27;s not feasible if the outputs are non-deterministic, e.g. the Model produces top-k classes or sort the outputs by their values. The shape of the value must be an n-dimensional array of strings. The number of dimensions must match that of the outputs to be explained. The Attribution.output_display_name is populated by locating in the mapping with Attribution.output_index.
                  &quot;outputTensorName&quot;: &quot;A String&quot;, # Name of the output tensor. Required and is only applicable to Vertex AI provided images for Tensorflow.
                },
              },
            },
            &quot;parameters&quot;: { # Parameters to configure explaining for Model&#x27;s predictions. # Required. Parameters that configure explaining of the Model&#x27;s predictions.
              &quot;examples&quot;: { # Example-based explainability that returns the nearest neighbors from the provided dataset. # Example-based explanations that returns the nearest neighbors from the provided dataset.
                &quot;exampleGcsSource&quot;: { # The Cloud Storage input instances. # The Cloud Storage input instances.
                  &quot;dataFormat&quot;: &quot;A String&quot;, # The format in which instances are given, if not specified, assume it&#x27;s JSONL format. Currently only JSONL format is supported.
                  &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage location for the input instances.
                    &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                      &quot;A String&quot;,
                    ],
                  },
                },
                &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage locations that contain the instances to be indexed for approximate nearest neighbor search.
                  &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                    &quot;A String&quot;,
                  ],
                },
                &quot;nearestNeighborSearchConfig&quot;: &quot;&quot;, # The full configuration for the generated index, the semantics are the same as metadata and should match [NearestNeighborSearchConfig](https://cloud.google.com/vertex-ai/docs/explainable-ai/configuring-explanations-example-based#nearest-neighbor-search-config).
                &quot;neighborCount&quot;: 42, # The number of neighbors to return when querying for examples.
                &quot;presets&quot;: { # Preset configuration for example-based explanations # Simplified preset configuration, which automatically sets configuration values based on the desired query speed-precision trade-off and modality.
                  &quot;modality&quot;: &quot;A String&quot;, # The modality of the uploaded model, which automatically configures the distance measurement and feature normalization for the underlying example index and queries. If your model does not precisely fit one of these types, it is okay to choose the closest type.
                  &quot;query&quot;: &quot;A String&quot;, # Preset option controlling parameters for speed-precision trade-off when querying for examples. If omitted, defaults to `PRECISE`.
                },
              },
              &quot;integratedGradientsAttribution&quot;: { # An attribution method that computes the Aumann-Shapley value taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365 # An attribution method that computes Aumann-Shapley values taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365
                &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for IG with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
                  &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
                },
                &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
                  &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
                    &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
                      { # Noise sigma for a single feature.
                        &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                        &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
                      },
                    ],
                  },
                  &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
                  &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
                },
                &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is within the desired error range. Valid range of its value is [1, 100], inclusively.
              },
              &quot;outputIndices&quot;: [ # If populated, only returns attributions that have output_index contained in output_indices. It must be an ndarray of integers, with the same shape of the output it&#x27;s explaining. If not populated, returns attributions for top_k indices of outputs. If neither top_k nor output_indices is populated, returns the argmax index of the outputs. Only applicable to Models that predict multiple outputs (e,g, multi-class Models that predict multiple classes).
                &quot;&quot;,
              ],
              &quot;sampledShapleyAttribution&quot;: { # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. Refer to this paper for model details: https://arxiv.org/abs/1306.4265.
                &quot;pathCount&quot;: 42, # Required. The number of feature permutations to consider when approximating the Shapley values. Valid range of its value is [1, 50], inclusively.
              },
              &quot;topK&quot;: 42, # If populated, returns attributions for top K indices of outputs (defaults to 1). Only applies to Models that predicts more than one outputs (e,g, multi-class Models). When set to -1, returns explanations for all outputs.
              &quot;xraiAttribution&quot;: { # An explanation method that redistributes Integrated Gradients attributions to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 Supported only by image Models. # An attribution method that redistributes Integrated Gradients attribution to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 XRAI currently performs better on natural images, like a picture of a house or an animal. If the images are taken in artificial environments, like a lab or manufacturing line, or from diagnostic equipment, like x-rays or quality-control cameras, use Integrated Gradients instead.
                &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for XRAI with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
                  &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
                },
                &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
                  &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
                    &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
                      { # Noise sigma for a single feature.
                        &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                        &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
                      },
                    ],
                  },
                  &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
                  &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
                },
                &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is met within the desired error range. Valid range of its value is [1, 100], inclusively.
              },
            },
          },
          &quot;id&quot;: &quot;A String&quot;, # Immutable. The ID of the DeployedModel. If not provided upon deployment, Vertex AI will generate a value for this ID. This value should be 1-10 characters, and valid characters are /[0-9]/.
          &quot;model&quot;: &quot;A String&quot;, # Required. The resource name of the Model that this is the deployment of. Note that the Model may be in a different location than the DeployedModel&#x27;s Endpoint. The resource name may contain version id or version alias to specify the version. Example: `projects/{project}/locations/{location}/models/{model}@2` or `projects/{project}/locations/{location}/models/{model}@golden` if no version is specified, the default version will be deployed.
          &quot;modelVersionId&quot;: &quot;A String&quot;, # Output only. The version ID of the model that is deployed.
          &quot;privateEndpoints&quot;: { # PrivateEndpoints proto is used to provide paths for users to send requests privately. To send request via private service access, use predict_http_uri, explain_http_uri or health_http_uri. To send request via private service connect, use service_attachment. # Output only. Provide paths for users to send predict/explain/health requests directly to the deployed model services running on Cloud via private services access. This field is populated if network is configured.
            &quot;explainHttpUri&quot;: &quot;A String&quot;, # Output only. Http(s) path to send explain requests.
            &quot;healthHttpUri&quot;: &quot;A String&quot;, # Output only. Http(s) path to send health check requests.
            &quot;predictHttpUri&quot;: &quot;A String&quot;, # Output only. Http(s) path to send prediction requests.
            &quot;serviceAttachment&quot;: &quot;A String&quot;, # Output only. The name of the service attachment resource. Populated if private service connect is enabled.
          },
          &quot;serviceAccount&quot;: &quot;A String&quot;, # The service account that the DeployedModel&#x27;s container runs as. Specify the email address of the service account. If this service account is not specified, the container runs as a service account that doesn&#x27;t have access to the resource project. Users deploying the Model must have the `iam.serviceAccounts.actAs` permission on this service account.
          &quot;sharedResources&quot;: &quot;A String&quot;, # The resource name of the shared DeploymentResourcePool to deploy on. Format: `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
        },
      ],
      &quot;description&quot;: &quot;A String&quot;, # The description of the Endpoint.
      &quot;displayName&quot;: &quot;A String&quot;, # Required. The display name of the Endpoint. The name can be up to 128 characters long and can consist of any UTF-8 characters.
      &quot;enablePrivateServiceConnect&quot;: True or False, # Deprecated: If true, expose the Endpoint via private service connect. Only one of the fields, network or enable_private_service_connect, can be set.
      &quot;encryptionSpec&quot;: { # Represents a customer-managed encryption key spec that can be applied to a top-level resource. # Customer-managed encryption key spec for an Endpoint. If set, this Endpoint and all sub-resources of this Endpoint will be secured by this key.
        &quot;kmsKeyName&quot;: &quot;A String&quot;, # Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
      },
      &quot;etag&quot;: &quot;A String&quot;, # Used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
      &quot;labels&quot;: { # The labels with user-defined metadata to organize your Endpoints. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
      &quot;modelDeploymentMonitoringJob&quot;: &quot;A String&quot;, # Output only. Resource name of the Model Monitoring job associated with this Endpoint if monitoring is enabled by JobService.CreateModelDeploymentMonitoringJob. Format: `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
      &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the Endpoint.
      &quot;network&quot;: &quot;A String&quot;, # Optional. The full name of the Google Compute Engine [network](https://cloud.google.com//compute/docs/networks-and-firewalls#networks) to which the Endpoint should be peered. Private services access must already be configured for the network. If left unspecified, the Endpoint is not peered with any network. Only one of the fields, network or enable_private_service_connect, can be set. [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/insert): `projects/{project}/global/networks/{network}`. Where `{project}` is a project number, as in `12345`, and `{network}` is network name.
      &quot;predictRequestResponseLoggingConfig&quot;: { # Configuration for logging request-response to a BigQuery table. # Configures the request-response logging for online prediction.
        &quot;bigqueryDestination&quot;: { # The BigQuery location for the output content. # BigQuery table for logging. If only given a project, a new dataset will be created with name `logging__` where will be made BigQuery-dataset-name compatible (e.g. most special characters will become underscores). If no table name is given, a new table will be created with name `request_response_logging`
          &quot;outputUri&quot;: &quot;A String&quot;, # Required. BigQuery URI to a project or table, up to 2000 characters long. When only the project is specified, the Dataset and Table is created. When the full table reference is specified, the Dataset must exist and table must not exist. Accepted forms: * BigQuery path. For example: `bq://projectId` or `bq://projectId.bqDatasetId` or `bq://projectId.bqDatasetId.bqTableId`.
        },
        &quot;enabled&quot;: True or False, # If logging is enabled or not.
        &quot;samplingRate&quot;: 3.14, # Percentage of requests to be logged, expressed as a fraction in range(0,1].
      },
      &quot;trafficSplit&quot;: { # A map from a DeployedModel&#x27;s ID to the percentage of this Endpoint&#x27;s traffic that should be forwarded to that DeployedModel. If a DeployedModel&#x27;s ID is not listed in this map, then it receives no traffic. The traffic percentage values must add up to 100, or map must be empty if the Endpoint is to not accept any traffic at a moment.
        &quot;a_key&quot;: 42,
      },
      &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Endpoint was last updated.
    },
  ],
  &quot;nextPageToken&quot;: &quot;A String&quot;, # A token to retrieve the next page of results. Pass to ListEndpointsRequest.page_token to obtain that page.
}</pre>
</div>

<div class="method">
    <code class="details" id="list_next">list_next()</code>
  <pre>Retrieves the next page of results.

        Args:
          previous_request: The request for the previous page. (required)
          previous_response: The response from the request for the previous page. (required)

        Returns:
          A request object that you can call &#x27;execute()&#x27; on to request the next
          page. Returns None if there are no more items in the collection.
        </pre>
</div>

<div class="method">
    <code class="details" id="mutateDeployedModel">mutateDeployedModel(endpoint, body=None, x__xgafv=None)</code>
  <pre>Updates an existing deployed model. Updatable fields include `min_replica_count`, `max_replica_count`, `autoscaling_metric_specs`, `disable_container_logging` (v1 only), and `enable_container_logging` (v1beta1 only).

Args:
  endpoint: string, Required. The name of the Endpoint resource into which to mutate a DeployedModel. Format: `projects/{project}/locations/{location}/endpoints/{endpoint}` (required)
  body: object, The request body.
    The object takes the form of:

{ # Request message for EndpointService.MutateDeployedModel.
  &quot;deployedModel&quot;: { # A deployment of a Model. Endpoints contain one or more DeployedModels. # Required. The DeployedModel to be mutated within the Endpoint. Only the following fields can be mutated: * `min_replica_count` in either DedicatedResources or AutomaticResources * `max_replica_count` in either DedicatedResources or AutomaticResources * autoscaling_metric_specs * `disable_container_logging` (v1 only) * `enable_container_logging` (v1beta1 only)
    &quot;automaticResources&quot;: { # A description of resources that to large degree are decided by Vertex AI, and require only a modest additional configuration. Each Model supporting these resources documents its specific guidelines. # A description of resources that to large degree are decided by Vertex AI, and require only a modest additional configuration.
      &quot;maxReplicaCount&quot;: 42, # Immutable. The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases. If the requested value is too large, the deployment will error, but if deployment succeeds then the ability to scale the model to that many replicas is guaranteed (barring service outages). If traffic against the DeployedModel increases beyond what its replicas at maximum may handle, a portion of the traffic will be dropped. If this value is not provided, a no upper bound for scaling under heavy traffic will be assume, though Vertex AI may be unable to scale beyond certain replica number.
      &quot;minReplicaCount&quot;: 42, # Immutable. The minimum number of replicas this DeployedModel will be always deployed on. If traffic against it increases, it may dynamically be deployed onto more replicas up to max_replica_count, and as traffic decreases, some of these extra replicas may be freed. If the requested value is too large, the deployment will error.
    },
    &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when the DeployedModel was created.
    &quot;dedicatedResources&quot;: { # A description of resources that are dedicated to a DeployedModel, and that need a higher degree of manual configuration. # A description of resources that are dedicated to the DeployedModel, and that need a higher degree of manual configuration.
      &quot;autoscalingMetricSpecs&quot;: [ # Immutable. The metric specifications that overrides a resource utilization metric (CPU utilization, accelerator&#x27;s duty cycle, and so on) target value (default to 60 if not set). At most one entry is allowed per metric. If machine_spec.accelerator_count is above 0, the autoscaling will be based on both CPU utilization and accelerator&#x27;s duty cycle metrics and scale up when either metrics exceeds its target value while scale down if both metrics are under their target value. The default target value is 60 for both metrics. If machine_spec.accelerator_count is 0, the autoscaling will be based on CPU utilization metric only with default target value 60 if not explicitly set. For example, in the case of Online Prediction, if you want to override target CPU utilization to 80, you should set autoscaling_metric_specs.metric_name to `aiplatform.googleapis.com/prediction/online/cpu/utilization` and autoscaling_metric_specs.target to `80`.
        { # The metric specification that defines the target resource utilization (CPU utilization, accelerator&#x27;s duty cycle, and so on) for calculating the desired replica count.
          &quot;metricName&quot;: &quot;A String&quot;, # Required. The resource metric name. Supported metrics: * For Online Prediction: * `aiplatform.googleapis.com/prediction/online/accelerator/duty_cycle` * `aiplatform.googleapis.com/prediction/online/cpu/utilization`
          &quot;target&quot;: 42, # The target resource utilization in percentage (1% - 100%) for the given metric; once the real usage deviates from the target by a certain percentage, the machine replicas change. The default value is 60 (representing 60%) if not provided.
        },
      ],
      &quot;machineSpec&quot;: { # Specification of a single machine. # Required. Immutable. The specification of a single machine used by the prediction.
        &quot;acceleratorCount&quot;: 42, # The number of accelerators to attach to the machine.
        &quot;acceleratorType&quot;: &quot;A String&quot;, # Immutable. The type of accelerator(s) that may be attached to the machine as per accelerator_count.
        &quot;machineType&quot;: &quot;A String&quot;, # Immutable. The type of the machine. See the [list of machine types supported for prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types) See the [list of machine types supported for custom training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types). For DeployedModel this field is optional, and the default value is `n1-standard-2`. For BatchPredictionJob or as part of WorkerPoolSpec this field is required.
      },
      &quot;maxReplicaCount&quot;: 42, # Immutable. The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases. If the requested value is too large, the deployment will error, but if deployment succeeds then the ability to scale the model to that many replicas is guaranteed (barring service outages). If traffic against the DeployedModel increases beyond what its replicas at maximum may handle, a portion of the traffic will be dropped. If this value is not provided, will use min_replica_count as the default value. The value of this field impacts the charge against Vertex CPU and GPU quotas. Specifically, you will be charged for (max_replica_count * number of cores in the selected machine type) and (max_replica_count * number of GPUs per replica in the selected machine type).
      &quot;minReplicaCount&quot;: 42, # Required. Immutable. The minimum number of machine replicas this DeployedModel will be always deployed on. This value must be greater than or equal to 1. If traffic against the DeployedModel increases, it may dynamically be deployed onto more replicas, and as traffic decreases, some of these extra replicas may be freed.
    },
    &quot;disableExplanations&quot;: True or False, # If true, deploy the model without explainable feature, regardless the existence of Model.explanation_spec or explanation_spec.
    &quot;displayName&quot;: &quot;A String&quot;, # The display name of the DeployedModel. If not provided upon creation, the Model&#x27;s display_name is used.
    &quot;enableAccessLogging&quot;: True or False, # If true, online prediction access logs are sent to Cloud Logging. These logs are like standard server access logs, containing information like timestamp and latency for each prediction request. Note that logs may incur a cost, especially if your project receives prediction requests at a high queries per second rate (QPS). Estimate your costs before enabling this option.
    &quot;enableContainerLogging&quot;: True or False, # If true, the container of the DeployedModel instances will send `stderr` and `stdout` streams to Cloud Logging. Only supported for custom-trained Models and AutoML Tabular Models.
    &quot;explanationSpec&quot;: { # Specification of Model explanation. # Explanation configuration for this DeployedModel. When deploying a Model using EndpointService.DeployModel, this value overrides the value of Model.explanation_spec. All fields of explanation_spec are optional in the request. If a field of explanation_spec is not populated, the value of the same field of Model.explanation_spec is inherited. If the corresponding Model.explanation_spec is not populated, all fields of the explanation_spec will be used for the explanation configuration.
      &quot;metadata&quot;: { # Metadata describing the Model&#x27;s input and output for explanation. # Optional. Metadata describing the Model&#x27;s input and output for explanation.
        &quot;featureAttributionsSchemaUri&quot;: &quot;A String&quot;, # Points to a YAML file stored on Google Cloud Storage describing the format of the feature attributions. The schema is defined as an OpenAPI 3.0.2 [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject). AutoML tabular Models always have this field populated by Vertex AI. Note: The URI given on output may be different, including the URI scheme, than the one given on input. The output URI will point to a location where the user only has a read access.
        &quot;inputs&quot;: { # Required. Map from feature names to feature input metadata. Keys are the name of the features. Values are the specification of the feature. An empty InputMetadata is valid. It describes a text feature which has the name specified as the key in ExplanationMetadata.inputs. The baseline of the empty feature is chosen by Vertex AI. For Vertex AI-provided Tensorflow images, the key can be any friendly name of the feature. Once specified, featureAttributions are keyed by this key (if not grouped with another feature). For custom images, the key must match with the key in instance.
          &quot;a_key&quot;: { # Metadata of the input of a feature. Fields other than InputMetadata.input_baselines are applicable only for Models that are using Vertex AI-provided images for Tensorflow.
            &quot;denseShapeTensorName&quot;: &quot;A String&quot;, # Specifies the shape of the values of the input if the input is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
            &quot;encodedBaselines&quot;: [ # A list of baselines for the encoded tensor. The shape of each baseline should match the shape of the encoded tensor. If a scalar is provided, Vertex AI broadcasts to the same shape as the encoded tensor.
              &quot;&quot;,
            ],
            &quot;encodedTensorName&quot;: &quot;A String&quot;, # Encoded tensor is a transformation of the input tensor. Must be provided if choosing Integrated Gradients attribution or XRAI attribution and the input tensor is not differentiable. An encoded tensor is generated if the input tensor is encoded by a lookup table.
            &quot;encoding&quot;: &quot;A String&quot;, # Defines how the feature is encoded into the input tensor. Defaults to IDENTITY.
            &quot;featureValueDomain&quot;: { # Domain details of the input feature value. Provides numeric information about the feature, such as its range (min, max). If the feature has been pre-processed, for example with z-scoring, then it provides information about how to recover the original feature. For example, if the input feature is an image and it has been pre-processed to obtain 0-mean and stddev = 1 values, then original_mean, and original_stddev refer to the mean and stddev of the original feature (e.g. image tensor) from which input feature (with mean = 0 and stddev = 1) was obtained. # The domain details of the input feature value. Like min/max, original mean or standard deviation if normalized.
              &quot;maxValue&quot;: 3.14, # The maximum permissible value for this feature.
              &quot;minValue&quot;: 3.14, # The minimum permissible value for this feature.
              &quot;originalMean&quot;: 3.14, # If this input feature has been normalized to a mean value of 0, the original_mean specifies the mean value of the domain prior to normalization.
              &quot;originalStddev&quot;: 3.14, # If this input feature has been normalized to a standard deviation of 1.0, the original_stddev specifies the standard deviation of the domain prior to normalization.
            },
            &quot;groupName&quot;: &quot;A String&quot;, # Name of the group that the input belongs to. Features with the same group name will be treated as one feature when computing attributions. Features grouped together can have different shapes in value. If provided, there will be one single attribution generated in Attribution.feature_attributions, keyed by the group name.
            &quot;indexFeatureMapping&quot;: [ # A list of feature names for each index in the input tensor. Required when the input InputMetadata.encoding is BAG_OF_FEATURES, BAG_OF_FEATURES_SPARSE, INDICATOR.
              &quot;A String&quot;,
            ],
            &quot;indicesTensorName&quot;: &quot;A String&quot;, # Specifies the index of the values of the input tensor. Required when the input tensor is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
            &quot;inputBaselines&quot;: [ # Baseline inputs for this feature. If no baseline is specified, Vertex AI chooses the baseline for this feature. If multiple baselines are specified, Vertex AI returns the average attributions across them in Attribution.feature_attributions. For Vertex AI-provided Tensorflow images (both 1.x and 2.x), the shape of each baseline must match the shape of the input tensor. If a scalar is provided, we broadcast to the same shape as the input tensor. For custom images, the element of the baselines must be in the same format as the feature&#x27;s input in the instance[]. The schema of any single instance may be specified via Endpoint&#x27;s DeployedModels&#x27; Model&#x27;s PredictSchemata&#x27;s instance_schema_uri.
              &quot;&quot;,
            ],
            &quot;inputTensorName&quot;: &quot;A String&quot;, # Name of the input tensor for this feature. Required and is only applicable to Vertex AI-provided images for Tensorflow.
            &quot;modality&quot;: &quot;A String&quot;, # Modality of the feature. Valid values are: numeric, image. Defaults to numeric.
            &quot;visualization&quot;: { # Visualization configurations for image explanation. # Visualization configurations for image explanation.
              &quot;clipPercentLowerbound&quot;: 3.14, # Excludes attributions below the specified percentile, from the highlighted areas. Defaults to 62.
              &quot;clipPercentUpperbound&quot;: 3.14, # Excludes attributions above the specified percentile from the highlighted areas. Using the clip_percent_upperbound and clip_percent_lowerbound together can be useful for filtering out noise and making it easier to see areas of strong attribution. Defaults to 99.9.
              &quot;colorMap&quot;: &quot;A String&quot;, # The color scheme used for the highlighted areas. Defaults to PINK_GREEN for Integrated Gradients attribution, which shows positive attributions in green and negative in pink. Defaults to VIRIDIS for XRAI attribution, which highlights the most influential regions in yellow and the least influential in blue.
              &quot;overlayType&quot;: &quot;A String&quot;, # How the original image is displayed in the visualization. Adjusting the overlay can help increase visual clarity if the original image makes it difficult to view the visualization. Defaults to NONE.
              &quot;polarity&quot;: &quot;A String&quot;, # Whether to only highlight pixels with positive contributions, negative or both. Defaults to POSITIVE.
              &quot;type&quot;: &quot;A String&quot;, # Type of the image visualization. Only applicable to Integrated Gradients attribution. OUTLINES shows regions of attribution, while PIXELS shows per-pixel attribution. Defaults to OUTLINES.
            },
          },
        },
        &quot;latentSpaceSource&quot;: &quot;A String&quot;, # Name of the source to generate embeddings for example based explanations.
        &quot;outputs&quot;: { # Required. Map from output names to output metadata. For Vertex AI-provided Tensorflow images, keys can be any user defined string that consists of any UTF-8 characters. For custom images, keys are the name of the output field in the prediction to be explained. Currently only one key is allowed.
          &quot;a_key&quot;: { # Metadata of the prediction output to be explained.
            &quot;displayNameMappingKey&quot;: &quot;A String&quot;, # Specify a field name in the prediction to look for the display name. Use this if the prediction contains the display names for the outputs. The display names in the prediction must have the same shape of the outputs, so that it can be located by Attribution.output_index for a specific output.
            &quot;indexDisplayNameMapping&quot;: &quot;&quot;, # Static mapping between the index and display name. Use this if the outputs are a deterministic n-dimensional array, e.g. a list of scores of all the classes in a pre-defined order for a multi-classification Model. It&#x27;s not feasible if the outputs are non-deterministic, e.g. the Model produces top-k classes or sort the outputs by their values. The shape of the value must be an n-dimensional array of strings. The number of dimensions must match that of the outputs to be explained. The Attribution.output_display_name is populated by locating in the mapping with Attribution.output_index.
            &quot;outputTensorName&quot;: &quot;A String&quot;, # Name of the output tensor. Required and is only applicable to Vertex AI provided images for Tensorflow.
          },
        },
      },
      &quot;parameters&quot;: { # Parameters to configure explaining for Model&#x27;s predictions. # Required. Parameters that configure explaining of the Model&#x27;s predictions.
        &quot;examples&quot;: { # Example-based explainability that returns the nearest neighbors from the provided dataset. # Example-based explanations that returns the nearest neighbors from the provided dataset.
          &quot;exampleGcsSource&quot;: { # The Cloud Storage input instances. # The Cloud Storage input instances.
            &quot;dataFormat&quot;: &quot;A String&quot;, # The format in which instances are given, if not specified, assume it&#x27;s JSONL format. Currently only JSONL format is supported.
            &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage location for the input instances.
              &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                &quot;A String&quot;,
              ],
            },
          },
          &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage locations that contain the instances to be indexed for approximate nearest neighbor search.
            &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
              &quot;A String&quot;,
            ],
          },
          &quot;nearestNeighborSearchConfig&quot;: &quot;&quot;, # The full configuration for the generated index, the semantics are the same as metadata and should match [NearestNeighborSearchConfig](https://cloud.google.com/vertex-ai/docs/explainable-ai/configuring-explanations-example-based#nearest-neighbor-search-config).
          &quot;neighborCount&quot;: 42, # The number of neighbors to return when querying for examples.
          &quot;presets&quot;: { # Preset configuration for example-based explanations # Simplified preset configuration, which automatically sets configuration values based on the desired query speed-precision trade-off and modality.
            &quot;modality&quot;: &quot;A String&quot;, # The modality of the uploaded model, which automatically configures the distance measurement and feature normalization for the underlying example index and queries. If your model does not precisely fit one of these types, it is okay to choose the closest type.
            &quot;query&quot;: &quot;A String&quot;, # Preset option controlling parameters for speed-precision trade-off when querying for examples. If omitted, defaults to `PRECISE`.
          },
        },
        &quot;integratedGradientsAttribution&quot;: { # An attribution method that computes the Aumann-Shapley value taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365 # An attribution method that computes Aumann-Shapley values taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365
          &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for IG with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
            &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
          },
          &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
            &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
              &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
                { # Noise sigma for a single feature.
                  &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                  &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
                },
              ],
            },
            &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
            &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
          },
          &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is within the desired error range. Valid range of its value is [1, 100], inclusively.
        },
        &quot;outputIndices&quot;: [ # If populated, only returns attributions that have output_index contained in output_indices. It must be an ndarray of integers, with the same shape of the output it&#x27;s explaining. If not populated, returns attributions for top_k indices of outputs. If neither top_k nor output_indices is populated, returns the argmax index of the outputs. Only applicable to Models that predict multiple outputs (e,g, multi-class Models that predict multiple classes).
          &quot;&quot;,
        ],
        &quot;sampledShapleyAttribution&quot;: { # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. Refer to this paper for model details: https://arxiv.org/abs/1306.4265.
          &quot;pathCount&quot;: 42, # Required. The number of feature permutations to consider when approximating the Shapley values. Valid range of its value is [1, 50], inclusively.
        },
        &quot;topK&quot;: 42, # If populated, returns attributions for top K indices of outputs (defaults to 1). Only applies to Models that predicts more than one outputs (e,g, multi-class Models). When set to -1, returns explanations for all outputs.
        &quot;xraiAttribution&quot;: { # An explanation method that redistributes Integrated Gradients attributions to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 Supported only by image Models. # An attribution method that redistributes Integrated Gradients attribution to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 XRAI currently performs better on natural images, like a picture of a house or an animal. If the images are taken in artificial environments, like a lab or manufacturing line, or from diagnostic equipment, like x-rays or quality-control cameras, use Integrated Gradients instead.
          &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for XRAI with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
            &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
          },
          &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
            &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
              &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
                { # Noise sigma for a single feature.
                  &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                  &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
                },
              ],
            },
            &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
            &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
          },
          &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is met within the desired error range. Valid range of its value is [1, 100], inclusively.
        },
      },
    },
    &quot;id&quot;: &quot;A String&quot;, # Immutable. The ID of the DeployedModel. If not provided upon deployment, Vertex AI will generate a value for this ID. This value should be 1-10 characters, and valid characters are /[0-9]/.
    &quot;model&quot;: &quot;A String&quot;, # Required. The resource name of the Model that this is the deployment of. Note that the Model may be in a different location than the DeployedModel&#x27;s Endpoint. The resource name may contain version id or version alias to specify the version. Example: `projects/{project}/locations/{location}/models/{model}@2` or `projects/{project}/locations/{location}/models/{model}@golden` if no version is specified, the default version will be deployed.
    &quot;modelVersionId&quot;: &quot;A String&quot;, # Output only. The version ID of the model that is deployed.
    &quot;privateEndpoints&quot;: { # PrivateEndpoints proto is used to provide paths for users to send requests privately. To send request via private service access, use predict_http_uri, explain_http_uri or health_http_uri. To send request via private service connect, use service_attachment. # Output only. Provide paths for users to send predict/explain/health requests directly to the deployed model services running on Cloud via private services access. This field is populated if network is configured.
      &quot;explainHttpUri&quot;: &quot;A String&quot;, # Output only. Http(s) path to send explain requests.
      &quot;healthHttpUri&quot;: &quot;A String&quot;, # Output only. Http(s) path to send health check requests.
      &quot;predictHttpUri&quot;: &quot;A String&quot;, # Output only. Http(s) path to send prediction requests.
      &quot;serviceAttachment&quot;: &quot;A String&quot;, # Output only. The name of the service attachment resource. Populated if private service connect is enabled.
    },
    &quot;serviceAccount&quot;: &quot;A String&quot;, # The service account that the DeployedModel&#x27;s container runs as. Specify the email address of the service account. If this service account is not specified, the container runs as a service account that doesn&#x27;t have access to the resource project. Users deploying the Model must have the `iam.serviceAccounts.actAs` permission on this service account.
    &quot;sharedResources&quot;: &quot;A String&quot;, # The resource name of the shared DeploymentResourcePool to deploy on. Format: `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  },
  &quot;updateMask&quot;: &quot;A String&quot;, # Required. The update mask applies to the resource. See google.protobuf.FieldMask.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # This resource represents a long-running operation that is the result of a network API call.
  &quot;done&quot;: True or False, # If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The error result of the operation in case of failure or cancellation.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;metadata&quot;: { # Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
  &quot;name&quot;: &quot;A String&quot;, # The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
  &quot;response&quot;: { # The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="patch">patch(name, body=None, updateMask=None, x__xgafv=None)</code>
  <pre>Updates an Endpoint.

Args:
  name: string, Output only. The resource name of the Endpoint. (required)
  body: object, The request body.
    The object takes the form of:

{ # Models are deployed into it, and afterwards Endpoint is called to obtain predictions and explanations.
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Endpoint was created.
  &quot;deployedModels&quot;: [ # Output only. The models deployed in this Endpoint. To add or remove DeployedModels use EndpointService.DeployModel and EndpointService.UndeployModel respectively.
    { # A deployment of a Model. Endpoints contain one or more DeployedModels.
      &quot;automaticResources&quot;: { # A description of resources that to large degree are decided by Vertex AI, and require only a modest additional configuration. Each Model supporting these resources documents its specific guidelines. # A description of resources that to large degree are decided by Vertex AI, and require only a modest additional configuration.
        &quot;maxReplicaCount&quot;: 42, # Immutable. The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases. If the requested value is too large, the deployment will error, but if deployment succeeds then the ability to scale the model to that many replicas is guaranteed (barring service outages). If traffic against the DeployedModel increases beyond what its replicas at maximum may handle, a portion of the traffic will be dropped. If this value is not provided, a no upper bound for scaling under heavy traffic will be assume, though Vertex AI may be unable to scale beyond certain replica number.
        &quot;minReplicaCount&quot;: 42, # Immutable. The minimum number of replicas this DeployedModel will be always deployed on. If traffic against it increases, it may dynamically be deployed onto more replicas up to max_replica_count, and as traffic decreases, some of these extra replicas may be freed. If the requested value is too large, the deployment will error.
      },
      &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when the DeployedModel was created.
      &quot;dedicatedResources&quot;: { # A description of resources that are dedicated to a DeployedModel, and that need a higher degree of manual configuration. # A description of resources that are dedicated to the DeployedModel, and that need a higher degree of manual configuration.
        &quot;autoscalingMetricSpecs&quot;: [ # Immutable. The metric specifications that overrides a resource utilization metric (CPU utilization, accelerator&#x27;s duty cycle, and so on) target value (default to 60 if not set). At most one entry is allowed per metric. If machine_spec.accelerator_count is above 0, the autoscaling will be based on both CPU utilization and accelerator&#x27;s duty cycle metrics and scale up when either metrics exceeds its target value while scale down if both metrics are under their target value. The default target value is 60 for both metrics. If machine_spec.accelerator_count is 0, the autoscaling will be based on CPU utilization metric only with default target value 60 if not explicitly set. For example, in the case of Online Prediction, if you want to override target CPU utilization to 80, you should set autoscaling_metric_specs.metric_name to `aiplatform.googleapis.com/prediction/online/cpu/utilization` and autoscaling_metric_specs.target to `80`.
          { # The metric specification that defines the target resource utilization (CPU utilization, accelerator&#x27;s duty cycle, and so on) for calculating the desired replica count.
            &quot;metricName&quot;: &quot;A String&quot;, # Required. The resource metric name. Supported metrics: * For Online Prediction: * `aiplatform.googleapis.com/prediction/online/accelerator/duty_cycle` * `aiplatform.googleapis.com/prediction/online/cpu/utilization`
            &quot;target&quot;: 42, # The target resource utilization in percentage (1% - 100%) for the given metric; once the real usage deviates from the target by a certain percentage, the machine replicas change. The default value is 60 (representing 60%) if not provided.
          },
        ],
        &quot;machineSpec&quot;: { # Specification of a single machine. # Required. Immutable. The specification of a single machine used by the prediction.
          &quot;acceleratorCount&quot;: 42, # The number of accelerators to attach to the machine.
          &quot;acceleratorType&quot;: &quot;A String&quot;, # Immutable. The type of accelerator(s) that may be attached to the machine as per accelerator_count.
          &quot;machineType&quot;: &quot;A String&quot;, # Immutable. The type of the machine. See the [list of machine types supported for prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types) See the [list of machine types supported for custom training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types). For DeployedModel this field is optional, and the default value is `n1-standard-2`. For BatchPredictionJob or as part of WorkerPoolSpec this field is required.
        },
        &quot;maxReplicaCount&quot;: 42, # Immutable. The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases. If the requested value is too large, the deployment will error, but if deployment succeeds then the ability to scale the model to that many replicas is guaranteed (barring service outages). If traffic against the DeployedModel increases beyond what its replicas at maximum may handle, a portion of the traffic will be dropped. If this value is not provided, will use min_replica_count as the default value. The value of this field impacts the charge against Vertex CPU and GPU quotas. Specifically, you will be charged for (max_replica_count * number of cores in the selected machine type) and (max_replica_count * number of GPUs per replica in the selected machine type).
        &quot;minReplicaCount&quot;: 42, # Required. Immutable. The minimum number of machine replicas this DeployedModel will be always deployed on. This value must be greater than or equal to 1. If traffic against the DeployedModel increases, it may dynamically be deployed onto more replicas, and as traffic decreases, some of these extra replicas may be freed.
      },
      &quot;disableExplanations&quot;: True or False, # If true, deploy the model without explainable feature, regardless the existence of Model.explanation_spec or explanation_spec.
      &quot;displayName&quot;: &quot;A String&quot;, # The display name of the DeployedModel. If not provided upon creation, the Model&#x27;s display_name is used.
      &quot;enableAccessLogging&quot;: True or False, # If true, online prediction access logs are sent to Cloud Logging. These logs are like standard server access logs, containing information like timestamp and latency for each prediction request. Note that logs may incur a cost, especially if your project receives prediction requests at a high queries per second rate (QPS). Estimate your costs before enabling this option.
      &quot;enableContainerLogging&quot;: True or False, # If true, the container of the DeployedModel instances will send `stderr` and `stdout` streams to Cloud Logging. Only supported for custom-trained Models and AutoML Tabular Models.
      &quot;explanationSpec&quot;: { # Specification of Model explanation. # Explanation configuration for this DeployedModel. When deploying a Model using EndpointService.DeployModel, this value overrides the value of Model.explanation_spec. All fields of explanation_spec are optional in the request. If a field of explanation_spec is not populated, the value of the same field of Model.explanation_spec is inherited. If the corresponding Model.explanation_spec is not populated, all fields of the explanation_spec will be used for the explanation configuration.
        &quot;metadata&quot;: { # Metadata describing the Model&#x27;s input and output for explanation. # Optional. Metadata describing the Model&#x27;s input and output for explanation.
          &quot;featureAttributionsSchemaUri&quot;: &quot;A String&quot;, # Points to a YAML file stored on Google Cloud Storage describing the format of the feature attributions. The schema is defined as an OpenAPI 3.0.2 [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject). AutoML tabular Models always have this field populated by Vertex AI. Note: The URI given on output may be different, including the URI scheme, than the one given on input. The output URI will point to a location where the user only has a read access.
          &quot;inputs&quot;: { # Required. Map from feature names to feature input metadata. Keys are the name of the features. Values are the specification of the feature. An empty InputMetadata is valid. It describes a text feature which has the name specified as the key in ExplanationMetadata.inputs. The baseline of the empty feature is chosen by Vertex AI. For Vertex AI-provided Tensorflow images, the key can be any friendly name of the feature. Once specified, featureAttributions are keyed by this key (if not grouped with another feature). For custom images, the key must match with the key in instance.
            &quot;a_key&quot;: { # Metadata of the input of a feature. Fields other than InputMetadata.input_baselines are applicable only for Models that are using Vertex AI-provided images for Tensorflow.
              &quot;denseShapeTensorName&quot;: &quot;A String&quot;, # Specifies the shape of the values of the input if the input is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
              &quot;encodedBaselines&quot;: [ # A list of baselines for the encoded tensor. The shape of each baseline should match the shape of the encoded tensor. If a scalar is provided, Vertex AI broadcasts to the same shape as the encoded tensor.
                &quot;&quot;,
              ],
              &quot;encodedTensorName&quot;: &quot;A String&quot;, # Encoded tensor is a transformation of the input tensor. Must be provided if choosing Integrated Gradients attribution or XRAI attribution and the input tensor is not differentiable. An encoded tensor is generated if the input tensor is encoded by a lookup table.
              &quot;encoding&quot;: &quot;A String&quot;, # Defines how the feature is encoded into the input tensor. Defaults to IDENTITY.
              &quot;featureValueDomain&quot;: { # Domain details of the input feature value. Provides numeric information about the feature, such as its range (min, max). If the feature has been pre-processed, for example with z-scoring, then it provides information about how to recover the original feature. For example, if the input feature is an image and it has been pre-processed to obtain 0-mean and stddev = 1 values, then original_mean, and original_stddev refer to the mean and stddev of the original feature (e.g. image tensor) from which input feature (with mean = 0 and stddev = 1) was obtained. # The domain details of the input feature value. Like min/max, original mean or standard deviation if normalized.
                &quot;maxValue&quot;: 3.14, # The maximum permissible value for this feature.
                &quot;minValue&quot;: 3.14, # The minimum permissible value for this feature.
                &quot;originalMean&quot;: 3.14, # If this input feature has been normalized to a mean value of 0, the original_mean specifies the mean value of the domain prior to normalization.
                &quot;originalStddev&quot;: 3.14, # If this input feature has been normalized to a standard deviation of 1.0, the original_stddev specifies the standard deviation of the domain prior to normalization.
              },
              &quot;groupName&quot;: &quot;A String&quot;, # Name of the group that the input belongs to. Features with the same group name will be treated as one feature when computing attributions. Features grouped together can have different shapes in value. If provided, there will be one single attribution generated in Attribution.feature_attributions, keyed by the group name.
              &quot;indexFeatureMapping&quot;: [ # A list of feature names for each index in the input tensor. Required when the input InputMetadata.encoding is BAG_OF_FEATURES, BAG_OF_FEATURES_SPARSE, INDICATOR.
                &quot;A String&quot;,
              ],
              &quot;indicesTensorName&quot;: &quot;A String&quot;, # Specifies the index of the values of the input tensor. Required when the input tensor is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
              &quot;inputBaselines&quot;: [ # Baseline inputs for this feature. If no baseline is specified, Vertex AI chooses the baseline for this feature. If multiple baselines are specified, Vertex AI returns the average attributions across them in Attribution.feature_attributions. For Vertex AI-provided Tensorflow images (both 1.x and 2.x), the shape of each baseline must match the shape of the input tensor. If a scalar is provided, we broadcast to the same shape as the input tensor. For custom images, the element of the baselines must be in the same format as the feature&#x27;s input in the instance[]. The schema of any single instance may be specified via Endpoint&#x27;s DeployedModels&#x27; Model&#x27;s PredictSchemata&#x27;s instance_schema_uri.
                &quot;&quot;,
              ],
              &quot;inputTensorName&quot;: &quot;A String&quot;, # Name of the input tensor for this feature. Required and is only applicable to Vertex AI-provided images for Tensorflow.
              &quot;modality&quot;: &quot;A String&quot;, # Modality of the feature. Valid values are: numeric, image. Defaults to numeric.
              &quot;visualization&quot;: { # Visualization configurations for image explanation. # Visualization configurations for image explanation.
                &quot;clipPercentLowerbound&quot;: 3.14, # Excludes attributions below the specified percentile, from the highlighted areas. Defaults to 62.
                &quot;clipPercentUpperbound&quot;: 3.14, # Excludes attributions above the specified percentile from the highlighted areas. Using the clip_percent_upperbound and clip_percent_lowerbound together can be useful for filtering out noise and making it easier to see areas of strong attribution. Defaults to 99.9.
                &quot;colorMap&quot;: &quot;A String&quot;, # The color scheme used for the highlighted areas. Defaults to PINK_GREEN for Integrated Gradients attribution, which shows positive attributions in green and negative in pink. Defaults to VIRIDIS for XRAI attribution, which highlights the most influential regions in yellow and the least influential in blue.
                &quot;overlayType&quot;: &quot;A String&quot;, # How the original image is displayed in the visualization. Adjusting the overlay can help increase visual clarity if the original image makes it difficult to view the visualization. Defaults to NONE.
                &quot;polarity&quot;: &quot;A String&quot;, # Whether to only highlight pixels with positive contributions, negative or both. Defaults to POSITIVE.
                &quot;type&quot;: &quot;A String&quot;, # Type of the image visualization. Only applicable to Integrated Gradients attribution. OUTLINES shows regions of attribution, while PIXELS shows per-pixel attribution. Defaults to OUTLINES.
              },
            },
          },
          &quot;latentSpaceSource&quot;: &quot;A String&quot;, # Name of the source to generate embeddings for example based explanations.
          &quot;outputs&quot;: { # Required. Map from output names to output metadata. For Vertex AI-provided Tensorflow images, keys can be any user defined string that consists of any UTF-8 characters. For custom images, keys are the name of the output field in the prediction to be explained. Currently only one key is allowed.
            &quot;a_key&quot;: { # Metadata of the prediction output to be explained.
              &quot;displayNameMappingKey&quot;: &quot;A String&quot;, # Specify a field name in the prediction to look for the display name. Use this if the prediction contains the display names for the outputs. The display names in the prediction must have the same shape of the outputs, so that it can be located by Attribution.output_index for a specific output.
              &quot;indexDisplayNameMapping&quot;: &quot;&quot;, # Static mapping between the index and display name. Use this if the outputs are a deterministic n-dimensional array, e.g. a list of scores of all the classes in a pre-defined order for a multi-classification Model. It&#x27;s not feasible if the outputs are non-deterministic, e.g. the Model produces top-k classes or sort the outputs by their values. The shape of the value must be an n-dimensional array of strings. The number of dimensions must match that of the outputs to be explained. The Attribution.output_display_name is populated by locating in the mapping with Attribution.output_index.
              &quot;outputTensorName&quot;: &quot;A String&quot;, # Name of the output tensor. Required and is only applicable to Vertex AI provided images for Tensorflow.
            },
          },
        },
        &quot;parameters&quot;: { # Parameters to configure explaining for Model&#x27;s predictions. # Required. Parameters that configure explaining of the Model&#x27;s predictions.
          &quot;examples&quot;: { # Example-based explainability that returns the nearest neighbors from the provided dataset. # Example-based explanations that returns the nearest neighbors from the provided dataset.
            &quot;exampleGcsSource&quot;: { # The Cloud Storage input instances. # The Cloud Storage input instances.
              &quot;dataFormat&quot;: &quot;A String&quot;, # The format in which instances are given, if not specified, assume it&#x27;s JSONL format. Currently only JSONL format is supported.
              &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage location for the input instances.
                &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                  &quot;A String&quot;,
                ],
              },
            },
            &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage locations that contain the instances to be indexed for approximate nearest neighbor search.
              &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                &quot;A String&quot;,
              ],
            },
            &quot;nearestNeighborSearchConfig&quot;: &quot;&quot;, # The full configuration for the generated index, the semantics are the same as metadata and should match [NearestNeighborSearchConfig](https://cloud.google.com/vertex-ai/docs/explainable-ai/configuring-explanations-example-based#nearest-neighbor-search-config).
            &quot;neighborCount&quot;: 42, # The number of neighbors to return when querying for examples.
            &quot;presets&quot;: { # Preset configuration for example-based explanations # Simplified preset configuration, which automatically sets configuration values based on the desired query speed-precision trade-off and modality.
              &quot;modality&quot;: &quot;A String&quot;, # The modality of the uploaded model, which automatically configures the distance measurement and feature normalization for the underlying example index and queries. If your model does not precisely fit one of these types, it is okay to choose the closest type.
              &quot;query&quot;: &quot;A String&quot;, # Preset option controlling parameters for speed-precision trade-off when querying for examples. If omitted, defaults to `PRECISE`.
            },
          },
          &quot;integratedGradientsAttribution&quot;: { # An attribution method that computes the Aumann-Shapley value taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365 # An attribution method that computes Aumann-Shapley values taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365
            &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for IG with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
              &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
            },
            &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
              &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
                &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
                  { # Noise sigma for a single feature.
                    &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                    &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
                  },
                ],
              },
              &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
              &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
            },
            &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is within the desired error range. Valid range of its value is [1, 100], inclusively.
          },
          &quot;outputIndices&quot;: [ # If populated, only returns attributions that have output_index contained in output_indices. It must be an ndarray of integers, with the same shape of the output it&#x27;s explaining. If not populated, returns attributions for top_k indices of outputs. If neither top_k nor output_indices is populated, returns the argmax index of the outputs. Only applicable to Models that predict multiple outputs (e,g, multi-class Models that predict multiple classes).
            &quot;&quot;,
          ],
          &quot;sampledShapleyAttribution&quot;: { # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. Refer to this paper for model details: https://arxiv.org/abs/1306.4265.
            &quot;pathCount&quot;: 42, # Required. The number of feature permutations to consider when approximating the Shapley values. Valid range of its value is [1, 50], inclusively.
          },
          &quot;topK&quot;: 42, # If populated, returns attributions for top K indices of outputs (defaults to 1). Only applies to Models that predicts more than one outputs (e,g, multi-class Models). When set to -1, returns explanations for all outputs.
          &quot;xraiAttribution&quot;: { # An explanation method that redistributes Integrated Gradients attributions to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 Supported only by image Models. # An attribution method that redistributes Integrated Gradients attribution to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 XRAI currently performs better on natural images, like a picture of a house or an animal. If the images are taken in artificial environments, like a lab or manufacturing line, or from diagnostic equipment, like x-rays or quality-control cameras, use Integrated Gradients instead.
            &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for XRAI with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
              &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
            },
            &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
              &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
                &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
                  { # Noise sigma for a single feature.
                    &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                    &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
                  },
                ],
              },
              &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
              &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
            },
            &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is met within the desired error range. Valid range of its value is [1, 100], inclusively.
          },
        },
      },
      &quot;id&quot;: &quot;A String&quot;, # Immutable. The ID of the DeployedModel. If not provided upon deployment, Vertex AI will generate a value for this ID. This value should be 1-10 characters, and valid characters are /[0-9]/.
      &quot;model&quot;: &quot;A String&quot;, # Required. The resource name of the Model that this is the deployment of. Note that the Model may be in a different location than the DeployedModel&#x27;s Endpoint. The resource name may contain version id or version alias to specify the version. Example: `projects/{project}/locations/{location}/models/{model}@2` or `projects/{project}/locations/{location}/models/{model}@golden` if no version is specified, the default version will be deployed.
      &quot;modelVersionId&quot;: &quot;A String&quot;, # Output only. The version ID of the model that is deployed.
      &quot;privateEndpoints&quot;: { # PrivateEndpoints proto is used to provide paths for users to send requests privately. To send request via private service access, use predict_http_uri, explain_http_uri or health_http_uri. To send request via private service connect, use service_attachment. # Output only. Provide paths for users to send predict/explain/health requests directly to the deployed model services running on Cloud via private services access. This field is populated if network is configured.
        &quot;explainHttpUri&quot;: &quot;A String&quot;, # Output only. Http(s) path to send explain requests.
        &quot;healthHttpUri&quot;: &quot;A String&quot;, # Output only. Http(s) path to send health check requests.
        &quot;predictHttpUri&quot;: &quot;A String&quot;, # Output only. Http(s) path to send prediction requests.
        &quot;serviceAttachment&quot;: &quot;A String&quot;, # Output only. The name of the service attachment resource. Populated if private service connect is enabled.
      },
      &quot;serviceAccount&quot;: &quot;A String&quot;, # The service account that the DeployedModel&#x27;s container runs as. Specify the email address of the service account. If this service account is not specified, the container runs as a service account that doesn&#x27;t have access to the resource project. Users deploying the Model must have the `iam.serviceAccounts.actAs` permission on this service account.
      &quot;sharedResources&quot;: &quot;A String&quot;, # The resource name of the shared DeploymentResourcePool to deploy on. Format: `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
    },
  ],
  &quot;description&quot;: &quot;A String&quot;, # The description of the Endpoint.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The display name of the Endpoint. The name can be up to 128 characters long and can consist of any UTF-8 characters.
  &quot;enablePrivateServiceConnect&quot;: True or False, # Deprecated: If true, expose the Endpoint via private service connect. Only one of the fields, network or enable_private_service_connect, can be set.
  &quot;encryptionSpec&quot;: { # Represents a customer-managed encryption key spec that can be applied to a top-level resource. # Customer-managed encryption key spec for an Endpoint. If set, this Endpoint and all sub-resources of this Endpoint will be secured by this key.
    &quot;kmsKeyName&quot;: &quot;A String&quot;, # Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
  },
  &quot;etag&quot;: &quot;A String&quot;, # Used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
  &quot;labels&quot;: { # The labels with user-defined metadata to organize your Endpoints. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels.
    &quot;a_key&quot;: &quot;A String&quot;,
  },
  &quot;modelDeploymentMonitoringJob&quot;: &quot;A String&quot;, # Output only. Resource name of the Model Monitoring job associated with this Endpoint if monitoring is enabled by JobService.CreateModelDeploymentMonitoringJob. Format: `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the Endpoint.
  &quot;network&quot;: &quot;A String&quot;, # Optional. The full name of the Google Compute Engine [network](https://cloud.google.com//compute/docs/networks-and-firewalls#networks) to which the Endpoint should be peered. Private services access must already be configured for the network. If left unspecified, the Endpoint is not peered with any network. Only one of the fields, network or enable_private_service_connect, can be set. [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/insert): `projects/{project}/global/networks/{network}`. Where `{project}` is a project number, as in `12345`, and `{network}` is network name.
  &quot;predictRequestResponseLoggingConfig&quot;: { # Configuration for logging request-response to a BigQuery table. # Configures the request-response logging for online prediction.
    &quot;bigqueryDestination&quot;: { # The BigQuery location for the output content. # BigQuery table for logging. If only given a project, a new dataset will be created with name `logging__` where will be made BigQuery-dataset-name compatible (e.g. most special characters will become underscores). If no table name is given, a new table will be created with name `request_response_logging`
      &quot;outputUri&quot;: &quot;A String&quot;, # Required. BigQuery URI to a project or table, up to 2000 characters long. When only the project is specified, the Dataset and Table is created. When the full table reference is specified, the Dataset must exist and table must not exist. Accepted forms: * BigQuery path. For example: `bq://projectId` or `bq://projectId.bqDatasetId` or `bq://projectId.bqDatasetId.bqTableId`.
    },
    &quot;enabled&quot;: True or False, # If logging is enabled or not.
    &quot;samplingRate&quot;: 3.14, # Percentage of requests to be logged, expressed as a fraction in range(0,1].
  },
  &quot;trafficSplit&quot;: { # A map from a DeployedModel&#x27;s ID to the percentage of this Endpoint&#x27;s traffic that should be forwarded to that DeployedModel. If a DeployedModel&#x27;s ID is not listed in this map, then it receives no traffic. The traffic percentage values must add up to 100, or map must be empty if the Endpoint is to not accept any traffic at a moment.
    &quot;a_key&quot;: 42,
  },
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Endpoint was last updated.
}

  updateMask: string, Required. The update mask applies to the resource. See google.protobuf.FieldMask.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Models are deployed into it, and afterwards Endpoint is called to obtain predictions and explanations.
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Endpoint was created.
  &quot;deployedModels&quot;: [ # Output only. The models deployed in this Endpoint. To add or remove DeployedModels use EndpointService.DeployModel and EndpointService.UndeployModel respectively.
    { # A deployment of a Model. Endpoints contain one or more DeployedModels.
      &quot;automaticResources&quot;: { # A description of resources that to large degree are decided by Vertex AI, and require only a modest additional configuration. Each Model supporting these resources documents its specific guidelines. # A description of resources that to large degree are decided by Vertex AI, and require only a modest additional configuration.
        &quot;maxReplicaCount&quot;: 42, # Immutable. The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases. If the requested value is too large, the deployment will error, but if deployment succeeds then the ability to scale the model to that many replicas is guaranteed (barring service outages). If traffic against the DeployedModel increases beyond what its replicas at maximum may handle, a portion of the traffic will be dropped. If this value is not provided, a no upper bound for scaling under heavy traffic will be assume, though Vertex AI may be unable to scale beyond certain replica number.
        &quot;minReplicaCount&quot;: 42, # Immutable. The minimum number of replicas this DeployedModel will be always deployed on. If traffic against it increases, it may dynamically be deployed onto more replicas up to max_replica_count, and as traffic decreases, some of these extra replicas may be freed. If the requested value is too large, the deployment will error.
      },
      &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when the DeployedModel was created.
      &quot;dedicatedResources&quot;: { # A description of resources that are dedicated to a DeployedModel, and that need a higher degree of manual configuration. # A description of resources that are dedicated to the DeployedModel, and that need a higher degree of manual configuration.
        &quot;autoscalingMetricSpecs&quot;: [ # Immutable. The metric specifications that overrides a resource utilization metric (CPU utilization, accelerator&#x27;s duty cycle, and so on) target value (default to 60 if not set). At most one entry is allowed per metric. If machine_spec.accelerator_count is above 0, the autoscaling will be based on both CPU utilization and accelerator&#x27;s duty cycle metrics and scale up when either metrics exceeds its target value while scale down if both metrics are under their target value. The default target value is 60 for both metrics. If machine_spec.accelerator_count is 0, the autoscaling will be based on CPU utilization metric only with default target value 60 if not explicitly set. For example, in the case of Online Prediction, if you want to override target CPU utilization to 80, you should set autoscaling_metric_specs.metric_name to `aiplatform.googleapis.com/prediction/online/cpu/utilization` and autoscaling_metric_specs.target to `80`.
          { # The metric specification that defines the target resource utilization (CPU utilization, accelerator&#x27;s duty cycle, and so on) for calculating the desired replica count.
            &quot;metricName&quot;: &quot;A String&quot;, # Required. The resource metric name. Supported metrics: * For Online Prediction: * `aiplatform.googleapis.com/prediction/online/accelerator/duty_cycle` * `aiplatform.googleapis.com/prediction/online/cpu/utilization`
            &quot;target&quot;: 42, # The target resource utilization in percentage (1% - 100%) for the given metric; once the real usage deviates from the target by a certain percentage, the machine replicas change. The default value is 60 (representing 60%) if not provided.
          },
        ],
        &quot;machineSpec&quot;: { # Specification of a single machine. # Required. Immutable. The specification of a single machine used by the prediction.
          &quot;acceleratorCount&quot;: 42, # The number of accelerators to attach to the machine.
          &quot;acceleratorType&quot;: &quot;A String&quot;, # Immutable. The type of accelerator(s) that may be attached to the machine as per accelerator_count.
          &quot;machineType&quot;: &quot;A String&quot;, # Immutable. The type of the machine. See the [list of machine types supported for prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types) See the [list of machine types supported for custom training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types). For DeployedModel this field is optional, and the default value is `n1-standard-2`. For BatchPredictionJob or as part of WorkerPoolSpec this field is required.
        },
        &quot;maxReplicaCount&quot;: 42, # Immutable. The maximum number of replicas this DeployedModel may be deployed on when the traffic against it increases. If the requested value is too large, the deployment will error, but if deployment succeeds then the ability to scale the model to that many replicas is guaranteed (barring service outages). If traffic against the DeployedModel increases beyond what its replicas at maximum may handle, a portion of the traffic will be dropped. If this value is not provided, will use min_replica_count as the default value. The value of this field impacts the charge against Vertex CPU and GPU quotas. Specifically, you will be charged for (max_replica_count * number of cores in the selected machine type) and (max_replica_count * number of GPUs per replica in the selected machine type).
        &quot;minReplicaCount&quot;: 42, # Required. Immutable. The minimum number of machine replicas this DeployedModel will be always deployed on. This value must be greater than or equal to 1. If traffic against the DeployedModel increases, it may dynamically be deployed onto more replicas, and as traffic decreases, some of these extra replicas may be freed.
      },
      &quot;disableExplanations&quot;: True or False, # If true, deploy the model without explainable feature, regardless the existence of Model.explanation_spec or explanation_spec.
      &quot;displayName&quot;: &quot;A String&quot;, # The display name of the DeployedModel. If not provided upon creation, the Model&#x27;s display_name is used.
      &quot;enableAccessLogging&quot;: True or False, # If true, online prediction access logs are sent to Cloud Logging. These logs are like standard server access logs, containing information like timestamp and latency for each prediction request. Note that logs may incur a cost, especially if your project receives prediction requests at a high queries per second rate (QPS). Estimate your costs before enabling this option.
      &quot;enableContainerLogging&quot;: True or False, # If true, the container of the DeployedModel instances will send `stderr` and `stdout` streams to Cloud Logging. Only supported for custom-trained Models and AutoML Tabular Models.
      &quot;explanationSpec&quot;: { # Specification of Model explanation. # Explanation configuration for this DeployedModel. When deploying a Model using EndpointService.DeployModel, this value overrides the value of Model.explanation_spec. All fields of explanation_spec are optional in the request. If a field of explanation_spec is not populated, the value of the same field of Model.explanation_spec is inherited. If the corresponding Model.explanation_spec is not populated, all fields of the explanation_spec will be used for the explanation configuration.
        &quot;metadata&quot;: { # Metadata describing the Model&#x27;s input and output for explanation. # Optional. Metadata describing the Model&#x27;s input and output for explanation.
          &quot;featureAttributionsSchemaUri&quot;: &quot;A String&quot;, # Points to a YAML file stored on Google Cloud Storage describing the format of the feature attributions. The schema is defined as an OpenAPI 3.0.2 [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject). AutoML tabular Models always have this field populated by Vertex AI. Note: The URI given on output may be different, including the URI scheme, than the one given on input. The output URI will point to a location where the user only has a read access.
          &quot;inputs&quot;: { # Required. Map from feature names to feature input metadata. Keys are the name of the features. Values are the specification of the feature. An empty InputMetadata is valid. It describes a text feature which has the name specified as the key in ExplanationMetadata.inputs. The baseline of the empty feature is chosen by Vertex AI. For Vertex AI-provided Tensorflow images, the key can be any friendly name of the feature. Once specified, featureAttributions are keyed by this key (if not grouped with another feature). For custom images, the key must match with the key in instance.
            &quot;a_key&quot;: { # Metadata of the input of a feature. Fields other than InputMetadata.input_baselines are applicable only for Models that are using Vertex AI-provided images for Tensorflow.
              &quot;denseShapeTensorName&quot;: &quot;A String&quot;, # Specifies the shape of the values of the input if the input is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
              &quot;encodedBaselines&quot;: [ # A list of baselines for the encoded tensor. The shape of each baseline should match the shape of the encoded tensor. If a scalar is provided, Vertex AI broadcasts to the same shape as the encoded tensor.
                &quot;&quot;,
              ],
              &quot;encodedTensorName&quot;: &quot;A String&quot;, # Encoded tensor is a transformation of the input tensor. Must be provided if choosing Integrated Gradients attribution or XRAI attribution and the input tensor is not differentiable. An encoded tensor is generated if the input tensor is encoded by a lookup table.
              &quot;encoding&quot;: &quot;A String&quot;, # Defines how the feature is encoded into the input tensor. Defaults to IDENTITY.
              &quot;featureValueDomain&quot;: { # Domain details of the input feature value. Provides numeric information about the feature, such as its range (min, max). If the feature has been pre-processed, for example with z-scoring, then it provides information about how to recover the original feature. For example, if the input feature is an image and it has been pre-processed to obtain 0-mean and stddev = 1 values, then original_mean, and original_stddev refer to the mean and stddev of the original feature (e.g. image tensor) from which input feature (with mean = 0 and stddev = 1) was obtained. # The domain details of the input feature value. Like min/max, original mean or standard deviation if normalized.
                &quot;maxValue&quot;: 3.14, # The maximum permissible value for this feature.
                &quot;minValue&quot;: 3.14, # The minimum permissible value for this feature.
                &quot;originalMean&quot;: 3.14, # If this input feature has been normalized to a mean value of 0, the original_mean specifies the mean value of the domain prior to normalization.
                &quot;originalStddev&quot;: 3.14, # If this input feature has been normalized to a standard deviation of 1.0, the original_stddev specifies the standard deviation of the domain prior to normalization.
              },
              &quot;groupName&quot;: &quot;A String&quot;, # Name of the group that the input belongs to. Features with the same group name will be treated as one feature when computing attributions. Features grouped together can have different shapes in value. If provided, there will be one single attribution generated in Attribution.feature_attributions, keyed by the group name.
              &quot;indexFeatureMapping&quot;: [ # A list of feature names for each index in the input tensor. Required when the input InputMetadata.encoding is BAG_OF_FEATURES, BAG_OF_FEATURES_SPARSE, INDICATOR.
                &quot;A String&quot;,
              ],
              &quot;indicesTensorName&quot;: &quot;A String&quot;, # Specifies the index of the values of the input tensor. Required when the input tensor is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
              &quot;inputBaselines&quot;: [ # Baseline inputs for this feature. If no baseline is specified, Vertex AI chooses the baseline for this feature. If multiple baselines are specified, Vertex AI returns the average attributions across them in Attribution.feature_attributions. For Vertex AI-provided Tensorflow images (both 1.x and 2.x), the shape of each baseline must match the shape of the input tensor. If a scalar is provided, we broadcast to the same shape as the input tensor. For custom images, the element of the baselines must be in the same format as the feature&#x27;s input in the instance[]. The schema of any single instance may be specified via Endpoint&#x27;s DeployedModels&#x27; Model&#x27;s PredictSchemata&#x27;s instance_schema_uri.
                &quot;&quot;,
              ],
              &quot;inputTensorName&quot;: &quot;A String&quot;, # Name of the input tensor for this feature. Required and is only applicable to Vertex AI-provided images for Tensorflow.
              &quot;modality&quot;: &quot;A String&quot;, # Modality of the feature. Valid values are: numeric, image. Defaults to numeric.
              &quot;visualization&quot;: { # Visualization configurations for image explanation. # Visualization configurations for image explanation.
                &quot;clipPercentLowerbound&quot;: 3.14, # Excludes attributions below the specified percentile, from the highlighted areas. Defaults to 62.
                &quot;clipPercentUpperbound&quot;: 3.14, # Excludes attributions above the specified percentile from the highlighted areas. Using the clip_percent_upperbound and clip_percent_lowerbound together can be useful for filtering out noise and making it easier to see areas of strong attribution. Defaults to 99.9.
                &quot;colorMap&quot;: &quot;A String&quot;, # The color scheme used for the highlighted areas. Defaults to PINK_GREEN for Integrated Gradients attribution, which shows positive attributions in green and negative in pink. Defaults to VIRIDIS for XRAI attribution, which highlights the most influential regions in yellow and the least influential in blue.
                &quot;overlayType&quot;: &quot;A String&quot;, # How the original image is displayed in the visualization. Adjusting the overlay can help increase visual clarity if the original image makes it difficult to view the visualization. Defaults to NONE.
                &quot;polarity&quot;: &quot;A String&quot;, # Whether to only highlight pixels with positive contributions, negative or both. Defaults to POSITIVE.
                &quot;type&quot;: &quot;A String&quot;, # Type of the image visualization. Only applicable to Integrated Gradients attribution. OUTLINES shows regions of attribution, while PIXELS shows per-pixel attribution. Defaults to OUTLINES.
              },
            },
          },
          &quot;latentSpaceSource&quot;: &quot;A String&quot;, # Name of the source to generate embeddings for example based explanations.
          &quot;outputs&quot;: { # Required. Map from output names to output metadata. For Vertex AI-provided Tensorflow images, keys can be any user defined string that consists of any UTF-8 characters. For custom images, keys are the name of the output field in the prediction to be explained. Currently only one key is allowed.
            &quot;a_key&quot;: { # Metadata of the prediction output to be explained.
              &quot;displayNameMappingKey&quot;: &quot;A String&quot;, # Specify a field name in the prediction to look for the display name. Use this if the prediction contains the display names for the outputs. The display names in the prediction must have the same shape of the outputs, so that it can be located by Attribution.output_index for a specific output.
              &quot;indexDisplayNameMapping&quot;: &quot;&quot;, # Static mapping between the index and display name. Use this if the outputs are a deterministic n-dimensional array, e.g. a list of scores of all the classes in a pre-defined order for a multi-classification Model. It&#x27;s not feasible if the outputs are non-deterministic, e.g. the Model produces top-k classes or sort the outputs by their values. The shape of the value must be an n-dimensional array of strings. The number of dimensions must match that of the outputs to be explained. The Attribution.output_display_name is populated by locating in the mapping with Attribution.output_index.
              &quot;outputTensorName&quot;: &quot;A String&quot;, # Name of the output tensor. Required and is only applicable to Vertex AI provided images for Tensorflow.
            },
          },
        },
        &quot;parameters&quot;: { # Parameters to configure explaining for Model&#x27;s predictions. # Required. Parameters that configure explaining of the Model&#x27;s predictions.
          &quot;examples&quot;: { # Example-based explainability that returns the nearest neighbors from the provided dataset. # Example-based explanations that returns the nearest neighbors from the provided dataset.
            &quot;exampleGcsSource&quot;: { # The Cloud Storage input instances. # The Cloud Storage input instances.
              &quot;dataFormat&quot;: &quot;A String&quot;, # The format in which instances are given, if not specified, assume it&#x27;s JSONL format. Currently only JSONL format is supported.
              &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage location for the input instances.
                &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                  &quot;A String&quot;,
                ],
              },
            },
            &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage locations that contain the instances to be indexed for approximate nearest neighbor search.
              &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                &quot;A String&quot;,
              ],
            },
            &quot;nearestNeighborSearchConfig&quot;: &quot;&quot;, # The full configuration for the generated index, the semantics are the same as metadata and should match [NearestNeighborSearchConfig](https://cloud.google.com/vertex-ai/docs/explainable-ai/configuring-explanations-example-based#nearest-neighbor-search-config).
            &quot;neighborCount&quot;: 42, # The number of neighbors to return when querying for examples.
            &quot;presets&quot;: { # Preset configuration for example-based explanations # Simplified preset configuration, which automatically sets configuration values based on the desired query speed-precision trade-off and modality.
              &quot;modality&quot;: &quot;A String&quot;, # The modality of the uploaded model, which automatically configures the distance measurement and feature normalization for the underlying example index and queries. If your model does not precisely fit one of these types, it is okay to choose the closest type.
              &quot;query&quot;: &quot;A String&quot;, # Preset option controlling parameters for speed-precision trade-off when querying for examples. If omitted, defaults to `PRECISE`.
            },
          },
          &quot;integratedGradientsAttribution&quot;: { # An attribution method that computes the Aumann-Shapley value taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365 # An attribution method that computes Aumann-Shapley values taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365
            &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for IG with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
              &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
            },
            &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
              &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
                &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
                  { # Noise sigma for a single feature.
                    &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                    &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
                  },
                ],
              },
              &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
              &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
            },
            &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is within the desired error range. Valid range of its value is [1, 100], inclusively.
          },
          &quot;outputIndices&quot;: [ # If populated, only returns attributions that have output_index contained in output_indices. It must be an ndarray of integers, with the same shape of the output it&#x27;s explaining. If not populated, returns attributions for top_k indices of outputs. If neither top_k nor output_indices is populated, returns the argmax index of the outputs. Only applicable to Models that predict multiple outputs (e,g, multi-class Models that predict multiple classes).
            &quot;&quot;,
          ],
          &quot;sampledShapleyAttribution&quot;: { # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. Refer to this paper for model details: https://arxiv.org/abs/1306.4265.
            &quot;pathCount&quot;: 42, # Required. The number of feature permutations to consider when approximating the Shapley values. Valid range of its value is [1, 50], inclusively.
          },
          &quot;topK&quot;: 42, # If populated, returns attributions for top K indices of outputs (defaults to 1). Only applies to Models that predicts more than one outputs (e,g, multi-class Models). When set to -1, returns explanations for all outputs.
          &quot;xraiAttribution&quot;: { # An explanation method that redistributes Integrated Gradients attributions to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 Supported only by image Models. # An attribution method that redistributes Integrated Gradients attribution to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 XRAI currently performs better on natural images, like a picture of a house or an animal. If the images are taken in artificial environments, like a lab or manufacturing line, or from diagnostic equipment, like x-rays or quality-control cameras, use Integrated Gradients instead.
            &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for XRAI with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
              &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
            },
            &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
              &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
                &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
                  { # Noise sigma for a single feature.
                    &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                    &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
                  },
                ],
              },
              &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
              &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
            },
            &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is met within the desired error range. Valid range of its value is [1, 100], inclusively.
          },
        },
      },
      &quot;id&quot;: &quot;A String&quot;, # Immutable. The ID of the DeployedModel. If not provided upon deployment, Vertex AI will generate a value for this ID. This value should be 1-10 characters, and valid characters are /[0-9]/.
      &quot;model&quot;: &quot;A String&quot;, # Required. The resource name of the Model that this is the deployment of. Note that the Model may be in a different location than the DeployedModel&#x27;s Endpoint. The resource name may contain version id or version alias to specify the version. Example: `projects/{project}/locations/{location}/models/{model}@2` or `projects/{project}/locations/{location}/models/{model}@golden` if no version is specified, the default version will be deployed.
      &quot;modelVersionId&quot;: &quot;A String&quot;, # Output only. The version ID of the model that is deployed.
      &quot;privateEndpoints&quot;: { # PrivateEndpoints proto is used to provide paths for users to send requests privately. To send request via private service access, use predict_http_uri, explain_http_uri or health_http_uri. To send request via private service connect, use service_attachment. # Output only. Provide paths for users to send predict/explain/health requests directly to the deployed model services running on Cloud via private services access. This field is populated if network is configured.
        &quot;explainHttpUri&quot;: &quot;A String&quot;, # Output only. Http(s) path to send explain requests.
        &quot;healthHttpUri&quot;: &quot;A String&quot;, # Output only. Http(s) path to send health check requests.
        &quot;predictHttpUri&quot;: &quot;A String&quot;, # Output only. Http(s) path to send prediction requests.
        &quot;serviceAttachment&quot;: &quot;A String&quot;, # Output only. The name of the service attachment resource. Populated if private service connect is enabled.
      },
      &quot;serviceAccount&quot;: &quot;A String&quot;, # The service account that the DeployedModel&#x27;s container runs as. Specify the email address of the service account. If this service account is not specified, the container runs as a service account that doesn&#x27;t have access to the resource project. Users deploying the Model must have the `iam.serviceAccounts.actAs` permission on this service account.
      &quot;sharedResources&quot;: &quot;A String&quot;, # The resource name of the shared DeploymentResourcePool to deploy on. Format: `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
    },
  ],
  &quot;description&quot;: &quot;A String&quot;, # The description of the Endpoint.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The display name of the Endpoint. The name can be up to 128 characters long and can consist of any UTF-8 characters.
  &quot;enablePrivateServiceConnect&quot;: True or False, # Deprecated: If true, expose the Endpoint via private service connect. Only one of the fields, network or enable_private_service_connect, can be set.
  &quot;encryptionSpec&quot;: { # Represents a customer-managed encryption key spec that can be applied to a top-level resource. # Customer-managed encryption key spec for an Endpoint. If set, this Endpoint and all sub-resources of this Endpoint will be secured by this key.
    &quot;kmsKeyName&quot;: &quot;A String&quot;, # Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
  },
  &quot;etag&quot;: &quot;A String&quot;, # Used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
  &quot;labels&quot;: { # The labels with user-defined metadata to organize your Endpoints. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels.
    &quot;a_key&quot;: &quot;A String&quot;,
  },
  &quot;modelDeploymentMonitoringJob&quot;: &quot;A String&quot;, # Output only. Resource name of the Model Monitoring job associated with this Endpoint if monitoring is enabled by JobService.CreateModelDeploymentMonitoringJob. Format: `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the Endpoint.
  &quot;network&quot;: &quot;A String&quot;, # Optional. The full name of the Google Compute Engine [network](https://cloud.google.com//compute/docs/networks-and-firewalls#networks) to which the Endpoint should be peered. Private services access must already be configured for the network. If left unspecified, the Endpoint is not peered with any network. Only one of the fields, network or enable_private_service_connect, can be set. [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/insert): `projects/{project}/global/networks/{network}`. Where `{project}` is a project number, as in `12345`, and `{network}` is network name.
  &quot;predictRequestResponseLoggingConfig&quot;: { # Configuration for logging request-response to a BigQuery table. # Configures the request-response logging for online prediction.
    &quot;bigqueryDestination&quot;: { # The BigQuery location for the output content. # BigQuery table for logging. If only given a project, a new dataset will be created with name `logging__` where will be made BigQuery-dataset-name compatible (e.g. most special characters will become underscores). If no table name is given, a new table will be created with name `request_response_logging`
      &quot;outputUri&quot;: &quot;A String&quot;, # Required. BigQuery URI to a project or table, up to 2000 characters long. When only the project is specified, the Dataset and Table is created. When the full table reference is specified, the Dataset must exist and table must not exist. Accepted forms: * BigQuery path. For example: `bq://projectId` or `bq://projectId.bqDatasetId` or `bq://projectId.bqDatasetId.bqTableId`.
    },
    &quot;enabled&quot;: True or False, # If logging is enabled or not.
    &quot;samplingRate&quot;: 3.14, # Percentage of requests to be logged, expressed as a fraction in range(0,1].
  },
  &quot;trafficSplit&quot;: { # A map from a DeployedModel&#x27;s ID to the percentage of this Endpoint&#x27;s traffic that should be forwarded to that DeployedModel. If a DeployedModel&#x27;s ID is not listed in this map, then it receives no traffic. The traffic percentage values must add up to 100, or map must be empty if the Endpoint is to not accept any traffic at a moment.
    &quot;a_key&quot;: 42,
  },
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Endpoint was last updated.
}</pre>
</div>

<div class="method">
    <code class="details" id="predict">predict(endpoint, body=None, x__xgafv=None)</code>
  <pre>Perform an online prediction.

Args:
  endpoint: string, Required. The name of the Endpoint requested to serve the prediction. Format: `projects/{project}/locations/{location}/endpoints/{endpoint}` (required)
  body: object, The request body.
    The object takes the form of:

{ # Request message for PredictionService.Predict.
  &quot;instances&quot;: [ # Required. The instances that are the input to the prediction call. A DeployedModel may have an upper limit on the number of instances it supports per request, and when it is exceeded the prediction call errors in case of AutoML Models, or, in case of customer created Models, the behaviour is as documented by that Model. The schema of any single instance may be specified via Endpoint&#x27;s DeployedModels&#x27; Model&#x27;s PredictSchemata&#x27;s instance_schema_uri.
    &quot;&quot;,
  ],
  &quot;parameters&quot;: &quot;&quot;, # The parameters that govern the prediction. The schema of the parameters may be specified via Endpoint&#x27;s DeployedModels&#x27; Model&#x27;s PredictSchemata&#x27;s parameters_schema_uri.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response message for PredictionService.Predict.
  &quot;deployedModelId&quot;: &quot;A String&quot;, # ID of the Endpoint&#x27;s DeployedModel that served this prediction.
  &quot;metadata&quot;: &quot;&quot;, # Output only. Request-level metadata returned by the model. The metadata type will be dependent upon the model implementation.
  &quot;model&quot;: &quot;A String&quot;, # Output only. The resource name of the Model which is deployed as the DeployedModel that this prediction hits.
  &quot;modelDisplayName&quot;: &quot;A String&quot;, # Output only. The display name of the Model which is deployed as the DeployedModel that this prediction hits.
  &quot;modelVersionId&quot;: &quot;A String&quot;, # Output only. The version ID of the Model which is deployed as the DeployedModel that this prediction hits.
  &quot;predictions&quot;: [ # The predictions that are the output of the predictions call. The schema of any single prediction may be specified via Endpoint&#x27;s DeployedModels&#x27; Model&#x27;s PredictSchemata&#x27;s prediction_schema_uri.
    &quot;&quot;,
  ],
}</pre>
</div>

<div class="method">
    <code class="details" id="rawPredict">rawPredict(endpoint, body=None, x__xgafv=None)</code>
  <pre>Perform an online prediction with an arbitrary HTTP payload. The response includes the following HTTP headers: * `X-Vertex-AI-Endpoint-Id`: ID of the Endpoint that served this prediction. * `X-Vertex-AI-Deployed-Model-Id`: ID of the Endpoint&#x27;s DeployedModel that served this prediction.

Args:
  endpoint: string, Required. The name of the Endpoint requested to serve the prediction. Format: `projects/{project}/locations/{location}/endpoints/{endpoint}` (required)
  body: object, The request body.
    The object takes the form of:

{ # Request message for PredictionService.RawPredict.
  &quot;httpBody&quot;: { # Message that represents an arbitrary HTTP body. It should only be used for payload formats that can&#x27;t be represented as JSON, such as raw binary or an HTML page. This message can be used both in streaming and non-streaming API methods in the request as well as the response. It can be used as a top-level request field, which is convenient if one wants to extract parameters from either the URL or HTTP template into the request fields and also want access to the raw HTTP body. Example: message GetResourceRequest { // A unique request id. string request_id = 1; // The raw HTTP body is bound to this field. google.api.HttpBody http_body = 2; } service ResourceService { rpc GetResource(GetResourceRequest) returns (google.api.HttpBody); rpc UpdateResource(google.api.HttpBody) returns (google.protobuf.Empty); } Example with streaming methods: service CaldavService { rpc GetCalendar(stream google.api.HttpBody) returns (stream google.api.HttpBody); rpc UpdateCalendar(stream google.api.HttpBody) returns (stream google.api.HttpBody); } Use of this type only changes how the request and response bodies are handled, all other features will continue to work unchanged. # The prediction input. Supports HTTP headers and arbitrary data payload. A DeployedModel may have an upper limit on the number of instances it supports per request. When this limit it is exceeded for an AutoML model, the RawPredict method returns an error. When this limit is exceeded for a custom-trained model, the behavior varies depending on the model. You can specify the schema for each instance in the predict_schemata.instance_schema_uri field when you create a Model. This schema applies when you deploy the `Model` as a `DeployedModel` to an Endpoint and use the `RawPredict` method.
    &quot;contentType&quot;: &quot;A String&quot;, # The HTTP Content-Type header value specifying the content type of the body.
    &quot;data&quot;: &quot;A String&quot;, # The HTTP request/response body as raw binary.
    &quot;extensions&quot;: [ # Application specific response metadata. Must be set in the first response for streaming APIs.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
  },
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Message that represents an arbitrary HTTP body. It should only be used for payload formats that can&#x27;t be represented as JSON, such as raw binary or an HTML page. This message can be used both in streaming and non-streaming API methods in the request as well as the response. It can be used as a top-level request field, which is convenient if one wants to extract parameters from either the URL or HTTP template into the request fields and also want access to the raw HTTP body. Example: message GetResourceRequest { // A unique request id. string request_id = 1; // The raw HTTP body is bound to this field. google.api.HttpBody http_body = 2; } service ResourceService { rpc GetResource(GetResourceRequest) returns (google.api.HttpBody); rpc UpdateResource(google.api.HttpBody) returns (google.protobuf.Empty); } Example with streaming methods: service CaldavService { rpc GetCalendar(stream google.api.HttpBody) returns (stream google.api.HttpBody); rpc UpdateCalendar(stream google.api.HttpBody) returns (stream google.api.HttpBody); } Use of this type only changes how the request and response bodies are handled, all other features will continue to work unchanged.
  &quot;contentType&quot;: &quot;A String&quot;, # The HTTP Content-Type header value specifying the content type of the body.
  &quot;data&quot;: &quot;A String&quot;, # The HTTP request/response body as raw binary.
  &quot;extensions&quot;: [ # Application specific response metadata. Must be set in the first response for streaming APIs.
    {
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
    },
  ],
}</pre>
</div>

<div class="method">
    <code class="details" id="serverStreamingPredict">serverStreamingPredict(endpoint, body=None, x__xgafv=None)</code>
  <pre>Perform a server-side streaming online prediction request for Vertex LLM streaming.

Args:
  endpoint: string, Required. The name of the Endpoint requested to serve the prediction. Format: `projects/{project}/locations/{location}/endpoints/{endpoint}` (required)
  body: object, The request body.
    The object takes the form of:

{ # Request message for PredictionService.StreamingPredict. The first message must contain endpoint field and optionally input. The subsequent messages must contain input.
  &quot;inputs&quot;: [ # The prediction input.
    { # A tensor value type.
      &quot;boolVal&quot;: [ # Type specific representations that make it easy to create tensor protos in all languages. Only the representation corresponding to &quot;dtype&quot; can be set. The values hold the flattened representation of the tensor in row major order. BOOL
        True or False,
      ],
      &quot;bytesVal&quot;: [ # STRING
        &quot;A String&quot;,
      ],
      &quot;doubleVal&quot;: [ # DOUBLE
        3.14,
      ],
      &quot;dtype&quot;: &quot;A String&quot;, # The data type of tensor.
      &quot;floatVal&quot;: [ # FLOAT
        3.14,
      ],
      &quot;int64Val&quot;: [ # INT64
        &quot;A String&quot;,
      ],
      &quot;intVal&quot;: [ # INT_8 INT_16 INT_32
        42,
      ],
      &quot;listVal&quot;: [ # A list of tensor values.
        # Object with schema name: GoogleCloudAiplatformV1beta1Tensor
      ],
      &quot;shape&quot;: [ # Shape of the tensor.
        &quot;A String&quot;,
      ],
      &quot;stringVal&quot;: [ # STRING
        &quot;A String&quot;,
      ],
      &quot;structVal&quot;: { # A map of string to tensor.
        &quot;a_key&quot;: # Object with schema name: GoogleCloudAiplatformV1beta1Tensor
      },
      &quot;tensorVal&quot;: &quot;A String&quot;, # Serialized raw tensor content.
      &quot;uint64Val&quot;: [ # UINT64
        &quot;A String&quot;,
      ],
      &quot;uintVal&quot;: [ # UINT8 UINT16 UINT32
        42,
      ],
    },
  ],
  &quot;parameters&quot;: { # A tensor value type. # The parameters that govern the prediction.
    &quot;boolVal&quot;: [ # Type specific representations that make it easy to create tensor protos in all languages. Only the representation corresponding to &quot;dtype&quot; can be set. The values hold the flattened representation of the tensor in row major order. BOOL
      True or False,
    ],
    &quot;bytesVal&quot;: [ # STRING
      &quot;A String&quot;,
    ],
    &quot;doubleVal&quot;: [ # DOUBLE
      3.14,
    ],
    &quot;dtype&quot;: &quot;A String&quot;, # The data type of tensor.
    &quot;floatVal&quot;: [ # FLOAT
      3.14,
    ],
    &quot;int64Val&quot;: [ # INT64
      &quot;A String&quot;,
    ],
    &quot;intVal&quot;: [ # INT_8 INT_16 INT_32
      42,
    ],
    &quot;listVal&quot;: [ # A list of tensor values.
      # Object with schema name: GoogleCloudAiplatformV1beta1Tensor
    ],
    &quot;shape&quot;: [ # Shape of the tensor.
      &quot;A String&quot;,
    ],
    &quot;stringVal&quot;: [ # STRING
      &quot;A String&quot;,
    ],
    &quot;structVal&quot;: { # A map of string to tensor.
      &quot;a_key&quot;: # Object with schema name: GoogleCloudAiplatformV1beta1Tensor
    },
    &quot;tensorVal&quot;: &quot;A String&quot;, # Serialized raw tensor content.
    &quot;uint64Val&quot;: [ # UINT64
      &quot;A String&quot;,
    ],
    &quot;uintVal&quot;: [ # UINT8 UINT16 UINT32
      42,
    ],
  },
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response message for PredictionService.StreamingPredict.
  &quot;outputs&quot;: [ # The prediction output.
    { # A tensor value type.
      &quot;boolVal&quot;: [ # Type specific representations that make it easy to create tensor protos in all languages. Only the representation corresponding to &quot;dtype&quot; can be set. The values hold the flattened representation of the tensor in row major order. BOOL
        True or False,
      ],
      &quot;bytesVal&quot;: [ # STRING
        &quot;A String&quot;,
      ],
      &quot;doubleVal&quot;: [ # DOUBLE
        3.14,
      ],
      &quot;dtype&quot;: &quot;A String&quot;, # The data type of tensor.
      &quot;floatVal&quot;: [ # FLOAT
        3.14,
      ],
      &quot;int64Val&quot;: [ # INT64
        &quot;A String&quot;,
      ],
      &quot;intVal&quot;: [ # INT_8 INT_16 INT_32
        42,
      ],
      &quot;listVal&quot;: [ # A list of tensor values.
        # Object with schema name: GoogleCloudAiplatformV1beta1Tensor
      ],
      &quot;shape&quot;: [ # Shape of the tensor.
        &quot;A String&quot;,
      ],
      &quot;stringVal&quot;: [ # STRING
        &quot;A String&quot;,
      ],
      &quot;structVal&quot;: { # A map of string to tensor.
        &quot;a_key&quot;: # Object with schema name: GoogleCloudAiplatformV1beta1Tensor
      },
      &quot;tensorVal&quot;: &quot;A String&quot;, # Serialized raw tensor content.
      &quot;uint64Val&quot;: [ # UINT64
        &quot;A String&quot;,
      ],
      &quot;uintVal&quot;: [ # UINT8 UINT16 UINT32
        42,
      ],
    },
  ],
  &quot;parameters&quot;: { # A tensor value type. # The parameters that govern the prediction.
    &quot;boolVal&quot;: [ # Type specific representations that make it easy to create tensor protos in all languages. Only the representation corresponding to &quot;dtype&quot; can be set. The values hold the flattened representation of the tensor in row major order. BOOL
      True or False,
    ],
    &quot;bytesVal&quot;: [ # STRING
      &quot;A String&quot;,
    ],
    &quot;doubleVal&quot;: [ # DOUBLE
      3.14,
    ],
    &quot;dtype&quot;: &quot;A String&quot;, # The data type of tensor.
    &quot;floatVal&quot;: [ # FLOAT
      3.14,
    ],
    &quot;int64Val&quot;: [ # INT64
      &quot;A String&quot;,
    ],
    &quot;intVal&quot;: [ # INT_8 INT_16 INT_32
      42,
    ],
    &quot;listVal&quot;: [ # A list of tensor values.
      # Object with schema name: GoogleCloudAiplatformV1beta1Tensor
    ],
    &quot;shape&quot;: [ # Shape of the tensor.
      &quot;A String&quot;,
    ],
    &quot;stringVal&quot;: [ # STRING
      &quot;A String&quot;,
    ],
    &quot;structVal&quot;: { # A map of string to tensor.
      &quot;a_key&quot;: # Object with schema name: GoogleCloudAiplatformV1beta1Tensor
    },
    &quot;tensorVal&quot;: &quot;A String&quot;, # Serialized raw tensor content.
    &quot;uint64Val&quot;: [ # UINT64
      &quot;A String&quot;,
    ],
    &quot;uintVal&quot;: [ # UINT8 UINT16 UINT32
      42,
    ],
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="setIamPolicy">setIamPolicy(resource, body=None, x__xgafv=None)</code>
  <pre>Sets the access control policy on the specified resource. Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED` errors.

Args:
  resource: string, REQUIRED: The resource for which the policy is being specified. See [Resource names](https://cloud.google.com/apis/design/resource_names) for the appropriate value for this field. (required)
  body: object, The request body.
    The object takes the form of:

{ # Request message for `SetIamPolicy` method.
  &quot;policy&quot;: { # An Identity and Access Management (IAM) policy, which specifies access controls for Google Cloud resources. A `Policy` is a collection of `bindings`. A `binding` binds one or more `members`, or principals, to a single `role`. Principals can be user accounts, service accounts, Google groups, and domains (such as G Suite). A `role` is a named list of permissions; each `role` can be an IAM predefined role or a user-created custom role. For some types of Google Cloud resources, a `binding` can also specify a `condition`, which is a logical expression that allows access to a resource only if the expression evaluates to `true`. A condition can add constraints based on attributes of the request, the resource, or both. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies). **JSON example:** ``` { &quot;bindings&quot;: [ { &quot;role&quot;: &quot;roles/resourcemanager.organizationAdmin&quot;, &quot;members&quot;: [ &quot;user:mike@example.com&quot;, &quot;group:admins@example.com&quot;, &quot;domain:google.com&quot;, &quot;serviceAccount:my-project-id@appspot.gserviceaccount.com&quot; ] }, { &quot;role&quot;: &quot;roles/resourcemanager.organizationViewer&quot;, &quot;members&quot;: [ &quot;user:eve@example.com&quot; ], &quot;condition&quot;: { &quot;title&quot;: &quot;expirable access&quot;, &quot;description&quot;: &quot;Does not grant access after Sep 2020&quot;, &quot;expression&quot;: &quot;request.time &lt; timestamp(&#x27;2020-10-01T00:00:00.000Z&#x27;)&quot;, } } ], &quot;etag&quot;: &quot;BwWWja0YfJA=&quot;, &quot;version&quot;: 3 } ``` **YAML example:** ``` bindings: - members: - user:mike@example.com - group:admins@example.com - domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com role: roles/resourcemanager.organizationAdmin - members: - user:eve@example.com role: roles/resourcemanager.organizationViewer condition: title: expirable access description: Does not grant access after Sep 2020 expression: request.time &lt; timestamp(&#x27;2020-10-01T00:00:00.000Z&#x27;) etag: BwWWja0YfJA= version: 3 ``` For a description of IAM and its features, see the [IAM documentation](https://cloud.google.com/iam/docs/). # REQUIRED: The complete policy to be applied to the `resource`. The size of the policy is limited to a few 10s of KB. An empty policy is a valid policy but certain Google Cloud services (such as Projects) might reject them.
    &quot;bindings&quot;: [ # Associates a list of `members`, or principals, with a `role`. Optionally, may specify a `condition` that determines how and when the `bindings` are applied. Each of the `bindings` must contain at least one principal. The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250 of these principals can be Google groups. Each occurrence of a principal counts towards these limits. For example, if the `bindings` grant 50 different roles to `user:alice@example.com`, and not to any other principal, then you can add another 1,450 principals to the `bindings` in the `Policy`.
      { # Associates `members`, or principals, with a `role`.
        &quot;condition&quot;: { # Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: &quot;Summary size limit&quot; description: &quot;Determines if a summary is less than 100 chars&quot; expression: &quot;document.summary.size() &lt; 100&quot; Example (Equality): title: &quot;Requestor is owner&quot; description: &quot;Determines if requestor is the document owner&quot; expression: &quot;document.owner == request.auth.claims.email&quot; Example (Logic): title: &quot;Public documents&quot; description: &quot;Determine whether the document should be publicly visible&quot; expression: &quot;document.type != &#x27;private&#x27; &amp;&amp; document.type != &#x27;internal&#x27;&quot; Example (Data Manipulation): title: &quot;Notification string&quot; description: &quot;Create a notification string with a timestamp.&quot; expression: &quot;&#x27;New message received at &#x27; + string(document.create_time)&quot; The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information. # The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
          &quot;description&quot;: &quot;A String&quot;, # Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
          &quot;expression&quot;: &quot;A String&quot;, # Textual representation of an expression in Common Expression Language syntax.
          &quot;location&quot;: &quot;A String&quot;, # Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
          &quot;title&quot;: &quot;A String&quot;, # Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
        },
        &quot;members&quot;: [ # Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
          &quot;A String&quot;,
        ],
        &quot;role&quot;: &quot;A String&quot;, # Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
      },
    ],
    &quot;etag&quot;: &quot;A String&quot;, # `etag` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. It is strongly suggested that systems make use of the `etag` in the read-modify-write cycle to perform policy updates in order to avoid race conditions: An `etag` is returned in the response to `getIamPolicy`, and systems are expected to put that etag in the request to `setIamPolicy` to ensure that their change will be applied to the same version of the policy. **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost.
    &quot;version&quot;: 42, # Specifies the format of the policy. Valid values are `0`, `1`, and `3`. Requests that specify an invalid value are rejected. Any operation that affects conditional role bindings must specify version `3`. This requirement applies to the following operations: * Getting a policy that includes a conditional role binding * Adding a conditional role binding to a policy * Changing a conditional role binding in a policy * Removing any role binding, with or without a condition, from a policy that includes conditions **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost. If a policy does not include any conditions, operations on that policy may specify any valid version or leave the field unset. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  },
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # An Identity and Access Management (IAM) policy, which specifies access controls for Google Cloud resources. A `Policy` is a collection of `bindings`. A `binding` binds one or more `members`, or principals, to a single `role`. Principals can be user accounts, service accounts, Google groups, and domains (such as G Suite). A `role` is a named list of permissions; each `role` can be an IAM predefined role or a user-created custom role. For some types of Google Cloud resources, a `binding` can also specify a `condition`, which is a logical expression that allows access to a resource only if the expression evaluates to `true`. A condition can add constraints based on attributes of the request, the resource, or both. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies). **JSON example:** ``` { &quot;bindings&quot;: [ { &quot;role&quot;: &quot;roles/resourcemanager.organizationAdmin&quot;, &quot;members&quot;: [ &quot;user:mike@example.com&quot;, &quot;group:admins@example.com&quot;, &quot;domain:google.com&quot;, &quot;serviceAccount:my-project-id@appspot.gserviceaccount.com&quot; ] }, { &quot;role&quot;: &quot;roles/resourcemanager.organizationViewer&quot;, &quot;members&quot;: [ &quot;user:eve@example.com&quot; ], &quot;condition&quot;: { &quot;title&quot;: &quot;expirable access&quot;, &quot;description&quot;: &quot;Does not grant access after Sep 2020&quot;, &quot;expression&quot;: &quot;request.time &lt; timestamp(&#x27;2020-10-01T00:00:00.000Z&#x27;)&quot;, } } ], &quot;etag&quot;: &quot;BwWWja0YfJA=&quot;, &quot;version&quot;: 3 } ``` **YAML example:** ``` bindings: - members: - user:mike@example.com - group:admins@example.com - domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com role: roles/resourcemanager.organizationAdmin - members: - user:eve@example.com role: roles/resourcemanager.organizationViewer condition: title: expirable access description: Does not grant access after Sep 2020 expression: request.time &lt; timestamp(&#x27;2020-10-01T00:00:00.000Z&#x27;) etag: BwWWja0YfJA= version: 3 ``` For a description of IAM and its features, see the [IAM documentation](https://cloud.google.com/iam/docs/).
  &quot;bindings&quot;: [ # Associates a list of `members`, or principals, with a `role`. Optionally, may specify a `condition` that determines how and when the `bindings` are applied. Each of the `bindings` must contain at least one principal. The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250 of these principals can be Google groups. Each occurrence of a principal counts towards these limits. For example, if the `bindings` grant 50 different roles to `user:alice@example.com`, and not to any other principal, then you can add another 1,450 principals to the `bindings` in the `Policy`.
    { # Associates `members`, or principals, with a `role`.
      &quot;condition&quot;: { # Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: &quot;Summary size limit&quot; description: &quot;Determines if a summary is less than 100 chars&quot; expression: &quot;document.summary.size() &lt; 100&quot; Example (Equality): title: &quot;Requestor is owner&quot; description: &quot;Determines if requestor is the document owner&quot; expression: &quot;document.owner == request.auth.claims.email&quot; Example (Logic): title: &quot;Public documents&quot; description: &quot;Determine whether the document should be publicly visible&quot; expression: &quot;document.type != &#x27;private&#x27; &amp;&amp; document.type != &#x27;internal&#x27;&quot; Example (Data Manipulation): title: &quot;Notification string&quot; description: &quot;Create a notification string with a timestamp.&quot; expression: &quot;&#x27;New message received at &#x27; + string(document.create_time)&quot; The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information. # The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
        &quot;description&quot;: &quot;A String&quot;, # Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
        &quot;expression&quot;: &quot;A String&quot;, # Textual representation of an expression in Common Expression Language syntax.
        &quot;location&quot;: &quot;A String&quot;, # Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
        &quot;title&quot;: &quot;A String&quot;, # Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
      },
      &quot;members&quot;: [ # Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
        &quot;A String&quot;,
      ],
      &quot;role&quot;: &quot;A String&quot;, # Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
    },
  ],
  &quot;etag&quot;: &quot;A String&quot;, # `etag` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. It is strongly suggested that systems make use of the `etag` in the read-modify-write cycle to perform policy updates in order to avoid race conditions: An `etag` is returned in the response to `getIamPolicy`, and systems are expected to put that etag in the request to `setIamPolicy` to ensure that their change will be applied to the same version of the policy. **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost.
  &quot;version&quot;: 42, # Specifies the format of the policy. Valid values are `0`, `1`, and `3`. Requests that specify an invalid value are rejected. Any operation that affects conditional role bindings must specify version `3`. This requirement applies to the following operations: * Getting a policy that includes a conditional role binding * Adding a conditional role binding to a policy * Changing a conditional role binding in a policy * Removing any role binding, with or without a condition, from a policy that includes conditions **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost. If a policy does not include any conditions, operations on that policy may specify any valid version or leave the field unset. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
}</pre>
</div>

<div class="method">
    <code class="details" id="testIamPermissions">testIamPermissions(resource, permissions=None, x__xgafv=None)</code>
  <pre>Returns permissions that a caller has on the specified resource. If the resource does not exist, this will return an empty set of permissions, not a `NOT_FOUND` error. Note: This operation is designed to be used for building permission-aware UIs and command-line tools, not for authorization checking. This operation may &quot;fail open&quot; without warning.

Args:
  resource: string, REQUIRED: The resource for which the policy detail is being requested. See [Resource names](https://cloud.google.com/apis/design/resource_names) for the appropriate value for this field. (required)
  permissions: string, The set of permissions to check for the `resource`. Permissions with wildcards (such as `*` or `storage.*`) are not allowed. For more information see [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions). (repeated)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response message for `TestIamPermissions` method.
  &quot;permissions&quot;: [ # A subset of `TestPermissionsRequest.permissions` that the caller is allowed.
    &quot;A String&quot;,
  ],
}</pre>
</div>

<div class="method">
    <code class="details" id="undeployModel">undeployModel(endpoint, body=None, x__xgafv=None)</code>
  <pre>Undeploys a Model from an Endpoint, removing a DeployedModel from it, and freeing all resources it&#x27;s using.

Args:
  endpoint: string, Required. The name of the Endpoint resource from which to undeploy a Model. Format: `projects/{project}/locations/{location}/endpoints/{endpoint}` (required)
  body: object, The request body.
    The object takes the form of:

{ # Request message for EndpointService.UndeployModel.
  &quot;deployedModelId&quot;: &quot;A String&quot;, # Required. The ID of the DeployedModel to be undeployed from the Endpoint.
  &quot;trafficSplit&quot;: { # If this field is provided, then the Endpoint&#x27;s traffic_split will be overwritten with it. If last DeployedModel is being undeployed from the Endpoint, the [Endpoint.traffic_split] will always end up empty when this call returns. A DeployedModel will be successfully undeployed only if it doesn&#x27;t have any traffic assigned to it when this method executes, or if this field unassigns any traffic to it.
    &quot;a_key&quot;: 42,
  },
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # This resource represents a long-running operation that is the result of a network API call.
  &quot;done&quot;: True or False, # If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The error result of the operation in case of failure or cancellation.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;metadata&quot;: { # Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
  &quot;name&quot;: &quot;A String&quot;, # The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
  &quot;response&quot;: { # The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
}</pre>
</div>

</body></html>