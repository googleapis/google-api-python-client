<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="datamigration_v1.html">Database Migration API</a> . <a href="datamigration_v1.projects.html">projects</a> . <a href="datamigration_v1.projects.locations.html">locations</a> . <a href="datamigration_v1.projects.locations.conversionWorkspaces.html">conversionWorkspaces</a> . <a href="datamigration_v1.projects.locations.conversionWorkspaces.mappingRules.html">mappingRules</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#create">create(parent, body=None, mappingRuleId=None, requestId=None, x__xgafv=None)</a></code></p>
<p class="firstline">Creates a new mapping rule for a given conversion workspace.</p>
<p class="toc_element">
  <code><a href="#delete">delete(name, requestId=None, x__xgafv=None)</a></code></p>
<p class="firstline">Deletes a single mapping rule.</p>
<p class="toc_element">
  <code><a href="#get">get(name, x__xgafv=None)</a></code></p>
<p class="firstline">Gets the details of a mapping rule.</p>
<p class="toc_element">
  <code><a href="#import_">import_(parent, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Imports the mapping rules for a given conversion workspace. Supports various formats of external rules files.</p>
<p class="toc_element">
  <code><a href="#list">list(parent, pageSize=None, pageToken=None, x__xgafv=None)</a></code></p>
<p class="firstline">Lists the mapping rules for a specific conversion workspace.</p>
<p class="toc_element">
  <code><a href="#list_next">list_next()</a></code></p>
<p class="firstline">Retrieves the next page of results.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="create">create(parent, body=None, mappingRuleId=None, requestId=None, x__xgafv=None)</code>
  <pre>Creates a new mapping rule for a given conversion workspace.

Args:
  parent: string, Required. The parent which owns this collection of mapping rules. (required)
  body: object, The request body.
    The object takes the form of:

{ # Definition of a transformation that is to be applied to a group of entities in the source schema. Several such transformations can be applied to an entity sequentially to define the corresponding entity in the target schema.
  &quot;conditionalColumnSetValue&quot;: { # Options to configure rule type ConditionalColumnSetValue. The rule is used to transform the data which is being replicated/migrated. The rule filter field can refer to one or more entities. The rule scope can be one of: Column. # Optional. Rule to specify how the data contained in a column should be transformed (such as trimmed, rounded, etc) provided that the data meets certain criteria.
    &quot;customFeatures&quot;: { # Optional. Custom engine specific features.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;sourceNumericFilter&quot;: { # Filter for fixed point number data types such as NUMERIC/NUMBER # Optional. Optional filter on source column precision and scale. Used for fixed point numbers such as NUMERIC/NUMBER data types.
      &quot;numericFilterOption&quot;: &quot;A String&quot;, # Required. Enum to set the option defining the datatypes numeric filter has to be applied to
      &quot;sourceMaxPrecisionFilter&quot;: 42, # Optional. The filter will match columns with precision smaller than or equal to this number.
      &quot;sourceMaxScaleFilter&quot;: 42, # Optional. The filter will match columns with scale smaller than or equal to this number.
      &quot;sourceMinPrecisionFilter&quot;: 42, # Optional. The filter will match columns with precision greater than or equal to this number.
      &quot;sourceMinScaleFilter&quot;: 42, # Optional. The filter will match columns with scale greater than or equal to this number.
    },
    &quot;sourceTextFilter&quot;: { # Filter for text-based data types like varchar. # Optional. Optional filter on source column length. Used for text based data types like varchar.
      &quot;sourceMaxLengthFilter&quot;: &quot;A String&quot;, # Optional. The filter will match columns with length smaller than or equal to this number.
      &quot;sourceMinLengthFilter&quot;: &quot;A String&quot;, # Optional. The filter will match columns with length greater than or equal to this number.
    },
    &quot;valueTransformation&quot;: { # Description of data transformation during migration as part of the ConditionalColumnSetValue. # Required. Description of data transformation during migration.
      &quot;applyHash&quot;: { # Apply a hash function on the value. # Optional. Applies a hash function on the data
        &quot;uuidFromBytes&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Optional. Generate UUID from the data&#x27;s byte array
        },
      },
      &quot;assignMaxValue&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Optional. Set to max_value - if integer or numeric, will use int.maxvalue, etc
      },
      &quot;assignMinValue&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Optional. Set to min_value - if integer or numeric, will use int.minvalue, etc
      },
      &quot;assignNull&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Optional. Set to null
      },
      &quot;assignSpecificValue&quot;: { # Set to a specific value (value is converted to fit the target data type) # Optional. Set to a specific value (value is converted to fit the target data type)
        &quot;value&quot;: &quot;A String&quot;, # Required. Specific value to be assigned
      },
      &quot;doubleComparison&quot;: { # Filter based on relation between source value and compare value of type double in ConditionalColumnSetValue # Optional. Filter on relation between source value and compare value of type double.
        &quot;value&quot;: 3.14, # Required. Double compare value to be used
        &quot;valueComparison&quot;: &quot;A String&quot;, # Required. Relation between source value and compare value
      },
      &quot;intComparison&quot;: { # Filter based on relation between source value and compare value of type integer in ConditionalColumnSetValue # Optional. Filter on relation between source value and compare value of type integer.
        &quot;value&quot;: &quot;A String&quot;, # Required. Integer compare value to be used
        &quot;valueComparison&quot;: &quot;A String&quot;, # Required. Relation between source value and compare value
      },
      &quot;isNull&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Optional. Value is null
      },
      &quot;roundScale&quot;: { # This allows the data to change scale, for example if the source is 2 digits after the decimal point, specify round to scale value = 2. If for example the value needs to be converted to an integer, use round to scale value = 0. # Optional. Allows the data to change scale
        &quot;scale&quot;: 42, # Required. Scale value to be used
      },
      &quot;valueList&quot;: { # A list of values to filter by in ConditionalColumnSetValue # Optional. Value is found in the specified list.
        &quot;ignoreCase&quot;: True or False, # Required. Whether to ignore case when filtering by values. Defaults to false
        &quot;valuePresentList&quot;: &quot;A String&quot;, # Required. Indicates whether the filter matches rows with values that are present in the list or those with values not present in it.
        &quot;values&quot;: [ # Required. The list to be used to filter by
          &quot;A String&quot;,
        ],
      },
    },
  },
  &quot;convertRowidColumn&quot;: { # Options to configure rule type ConvertROWIDToColumn. The rule is used to add column rowid to destination tables based on an Oracle rowid function/property. The rule filter field can refer to one or more entities. The rule scope can be one of: Table. This rule requires additional filter to be specified beyond the basic rule filter field, which is whether or not to work on tables which already have a primary key defined. # Optional. Rule to specify how multiple tables should be converted with an additional rowid column.
    &quot;onlyIfNoPrimaryKey&quot;: True or False, # Required. Only work on tables without primary key defined
  },
  &quot;displayName&quot;: &quot;A String&quot;, # Optional. A human readable name
  &quot;entityMove&quot;: { # Options to configure rule type EntityMove. The rule is used to move an entity to a new schema. The rule filter field can refer to one or more entities. The rule scope can be one of: Table, Column, Constraint, Index, View, Function, Stored Procedure, Materialized View, Sequence, UDT # Optional. Rule to specify how multiple entities should be relocated into a different schema.
    &quot;newSchema&quot;: &quot;A String&quot;, # Required. The new schema
  },
  &quot;filter&quot;: { # A filter defining the entities that a mapping rule should be applied to. When more than one field is specified, the rule is applied only to entities which match all the fields. # Required. The rule filter
    &quot;entities&quot;: [ # Optional. The rule should be applied to specific entities defined by their fully qualified names.
      &quot;A String&quot;,
    ],
    &quot;entityNameContains&quot;: &quot;A String&quot;, # Optional. The rule should be applied to entities whose non-qualified name contains the given string.
    &quot;entityNamePrefix&quot;: &quot;A String&quot;, # Optional. The rule should be applied to entities whose non-qualified name starts with the given prefix.
    &quot;entityNameSuffix&quot;: &quot;A String&quot;, # Optional. The rule should be applied to entities whose non-qualified name ends with the given suffix.
    &quot;parentEntity&quot;: &quot;A String&quot;, # Optional. The rule should be applied to entities whose parent entity (fully qualified name) matches the given value. For example, if the rule applies to a table entity, the expected value should be a schema (schema). If the rule applies to a column or index entity, the expected value can be either a schema (schema) or a table (schema.table)
  },
  &quot;filterTableColumns&quot;: { # Options to configure rule type FilterTableColumns. The rule is used to filter the list of columns to include or exclude from a table. The rule filter field can refer to one entity. The rule scope can be: Table Only one of the two lists can be specified for the rule. # Optional. Rule to specify the list of columns to include or exclude from a table.
    &quot;excludeColumns&quot;: [ # Optional. List of columns to be excluded for a particular table.
      &quot;A String&quot;,
    ],
    &quot;includeColumns&quot;: [ # Optional. List of columns to be included for a particular table.
      &quot;A String&quot;,
    ],
  },
  &quot;multiColumnDataTypeChange&quot;: { # Options to configure rule type MultiColumnDatatypeChange. The rule is used to change the data type and associated properties of multiple columns at once. The rule filter field can refer to one or more entities. The rule scope can be one of:Column. This rule requires additional filters to be specified beyond the basic rule filter field, which is the source data type, but the rule supports additional filtering capabilities such as the minimum and maximum field length. All additional filters which are specified are required to be met in order for the rule to be applied (logical AND between the fields). # Optional. Rule to specify how multiple columns should be converted to a different data type.
    &quot;customFeatures&quot;: { # Optional. Custom engine specific features.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;newDataType&quot;: &quot;A String&quot;, # Required. New data type.
    &quot;overrideFractionalSecondsPrecision&quot;: 42, # Optional. Column fractional seconds precision - used only for timestamp based datatypes - if not specified and relevant uses the source column fractional seconds precision.
    &quot;overrideLength&quot;: &quot;A String&quot;, # Optional. Column length - e.g. varchar (50) - if not specified and relevant uses the source column length.
    &quot;overridePrecision&quot;: 42, # Optional. Column precision - when relevant - if not specified and relevant uses the source column precision.
    &quot;overrideScale&quot;: 42, # Optional. Column scale - when relevant - if not specified and relevant uses the source column scale.
    &quot;sourceDataTypeFilter&quot;: &quot;A String&quot;, # Required. Filter on source data type.
    &quot;sourceNumericFilter&quot;: { # Filter for fixed point number data types such as NUMERIC/NUMBER # Optional. Filter for fixed point number data types such as NUMERIC/NUMBER.
      &quot;numericFilterOption&quot;: &quot;A String&quot;, # Required. Enum to set the option defining the datatypes numeric filter has to be applied to
      &quot;sourceMaxPrecisionFilter&quot;: 42, # Optional. The filter will match columns with precision smaller than or equal to this number.
      &quot;sourceMaxScaleFilter&quot;: 42, # Optional. The filter will match columns with scale smaller than or equal to this number.
      &quot;sourceMinPrecisionFilter&quot;: 42, # Optional. The filter will match columns with precision greater than or equal to this number.
      &quot;sourceMinScaleFilter&quot;: 42, # Optional. The filter will match columns with scale greater than or equal to this number.
    },
    &quot;sourceTextFilter&quot;: { # Filter for text-based data types like varchar. # Optional. Filter for text-based data types like varchar.
      &quot;sourceMaxLengthFilter&quot;: &quot;A String&quot;, # Optional. The filter will match columns with length smaller than or equal to this number.
      &quot;sourceMinLengthFilter&quot;: &quot;A String&quot;, # Optional. The filter will match columns with length greater than or equal to this number.
    },
  },
  &quot;multiEntityRename&quot;: { # Options to configure rule type MultiEntityRename. The rule is used to rename multiple entities. The rule filter field can refer to one or more entities. The rule scope can be one of: Database, Schema, Table, Column, Constraint, Index, View, Function, Stored Procedure, Materialized View, Sequence, UDT # Optional. Rule to specify how multiple entities should be renamed.
    &quot;newNamePattern&quot;: &quot;A String&quot;, # Optional. The pattern used to generate the new entity&#x27;s name. This pattern must include the characters &#x27;{name}&#x27;, which will be replaced with the name of the original entity. For example, the pattern &#x27;t_{name}&#x27; for an entity name jobs would be converted to &#x27;t_jobs&#x27;. If unspecified, the default value for this field is &#x27;{name}&#x27;
    &quot;sourceNameTransformation&quot;: &quot;A String&quot;, # Optional. Additional transformation that can be done on the source entity name before it is being used by the new_name_pattern, for example lower case. If no transformation is desired, use NO_TRANSFORMATION
  },
  &quot;name&quot;: &quot;A String&quot;, # Full name of the mapping rule resource, in the form of: projects/{project}/locations/{location}/conversionWorkspaces/{set}/mappingRule/{rule}.
  &quot;revisionCreateTime&quot;: &quot;A String&quot;, # Output only. The timestamp that the revision was created.
  &quot;revisionId&quot;: &quot;A String&quot;, # Output only. The revision ID of the mapping rule. A new revision is committed whenever the mapping rule is changed in any way. The format is an 8-character hexadecimal string.
  &quot;ruleOrder&quot;: &quot;A String&quot;, # Required. The order in which the rule is applied. Lower order rules are applied before higher value rules so they may end up being overridden.
  &quot;ruleScope&quot;: &quot;A String&quot;, # Required. The rule scope
  &quot;setTablePrimaryKey&quot;: { # Options to configure rule type SetTablePrimaryKey. The rule is used to specify the columns and name to configure/alter the primary key of a table. The rule filter field can refer to one entity. The rule scope can be one of: Table. # Optional. Rule to specify the primary key for a table
    &quot;primaryKey&quot;: &quot;A String&quot;, # Optional. Name for the primary key
    &quot;primaryKeyColumns&quot;: [ # Required. List of column names for the primary key
      &quot;A String&quot;,
    ],
  },
  &quot;singleColumnChange&quot;: { # Options to configure rule type SingleColumnChange. The rule is used to change the properties of a column. The rule filter field can refer to one entity. The rule scope can be one of: Column. When using this rule, if a field is not specified than the destination column&#x27;s configuration will be the same as the one in the source column.. # Optional. Rule to specify how a single column is converted.
    &quot;array&quot;: True or False, # Optional. Is the column of array type.
    &quot;arrayLength&quot;: 42, # Optional. The length of the array, only relevant if the column type is an array.
    &quot;autoGenerated&quot;: True or False, # Optional. Is the column auto-generated/identity.
    &quot;charset&quot;: &quot;A String&quot;, # Optional. Charset override - instead of table level charset.
    &quot;collation&quot;: &quot;A String&quot;, # Optional. Collation override - instead of table level collation.
    &quot;comment&quot;: &quot;A String&quot;, # Optional. Comment associated with the column.
    &quot;customFeatures&quot;: { # Optional. Custom engine specific features.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;dataType&quot;: &quot;A String&quot;, # Optional. Column data type name.
    &quot;fractionalSecondsPrecision&quot;: 42, # Optional. Column fractional seconds precision - e.g. 2 as in timestamp (2) - when relevant.
    &quot;length&quot;: &quot;A String&quot;, # Optional. Column length - e.g. 50 as in varchar (50) - when relevant.
    &quot;nullable&quot;: True or False, # Optional. Is the column nullable.
    &quot;precision&quot;: 42, # Optional. Column precision - e.g. 8 as in double (8,2) - when relevant.
    &quot;scale&quot;: 42, # Optional. Column scale - e.g. 2 as in double (8,2) - when relevant.
    &quot;setValues&quot;: [ # Optional. Specifies the list of values allowed in the column.
      &quot;A String&quot;,
    ],
    &quot;udt&quot;: True or False, # Optional. Is the column a UDT (User-defined Type).
  },
  &quot;singleEntityRename&quot;: { # Options to configure rule type SingleEntityRename. The rule is used to rename an entity. The rule filter field can refer to only one entity. The rule scope can be one of: Database, Schema, Table, Column, Constraint, Index, View, Function, Stored Procedure, Materialized View, Sequence, UDT, Synonym # Optional. Rule to specify how a single entity should be renamed.
    &quot;newName&quot;: &quot;A String&quot;, # Required. The new name of the destination entity
  },
  &quot;singlePackageChange&quot;: { # Options to configure rule type SinglePackageChange. The rule is used to alter the sql code for a package entities. The rule filter field can refer to one entity. The rule scope can be: Package # Optional. Rule to specify how a single package is converted.
    &quot;packageBody&quot;: &quot;A String&quot;, # Optional. Sql code for package body
    &quot;packageDescription&quot;: &quot;A String&quot;, # Optional. Sql code for package description
  },
  &quot;sourceSqlChange&quot;: { # Options to configure rule type SourceSqlChange. The rule is used to alter the sql code for database entities. The rule filter field can refer to one entity. The rule scope can be: StoredProcedure, Function, Trigger, View # Optional. Rule to change the sql code for an entity, for example, function, procedure.
    &quot;sqlCode&quot;: &quot;A String&quot;, # Required. Sql code for source (stored procedure, function, trigger or view)
  },
  &quot;state&quot;: &quot;A String&quot;, # Optional. The mapping rule state
}

  mappingRuleId: string, Required. The ID of the rule to create.
  requestId: string, A unique ID used to identify the request. If the server receives two requests with the same ID, then the second request is ignored. It is recommended to always set this value to a UUID. The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores (_), and hyphens (-). The maximum length is 40 characters.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Definition of a transformation that is to be applied to a group of entities in the source schema. Several such transformations can be applied to an entity sequentially to define the corresponding entity in the target schema.
  &quot;conditionalColumnSetValue&quot;: { # Options to configure rule type ConditionalColumnSetValue. The rule is used to transform the data which is being replicated/migrated. The rule filter field can refer to one or more entities. The rule scope can be one of: Column. # Optional. Rule to specify how the data contained in a column should be transformed (such as trimmed, rounded, etc) provided that the data meets certain criteria.
    &quot;customFeatures&quot;: { # Optional. Custom engine specific features.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;sourceNumericFilter&quot;: { # Filter for fixed point number data types such as NUMERIC/NUMBER # Optional. Optional filter on source column precision and scale. Used for fixed point numbers such as NUMERIC/NUMBER data types.
      &quot;numericFilterOption&quot;: &quot;A String&quot;, # Required. Enum to set the option defining the datatypes numeric filter has to be applied to
      &quot;sourceMaxPrecisionFilter&quot;: 42, # Optional. The filter will match columns with precision smaller than or equal to this number.
      &quot;sourceMaxScaleFilter&quot;: 42, # Optional. The filter will match columns with scale smaller than or equal to this number.
      &quot;sourceMinPrecisionFilter&quot;: 42, # Optional. The filter will match columns with precision greater than or equal to this number.
      &quot;sourceMinScaleFilter&quot;: 42, # Optional. The filter will match columns with scale greater than or equal to this number.
    },
    &quot;sourceTextFilter&quot;: { # Filter for text-based data types like varchar. # Optional. Optional filter on source column length. Used for text based data types like varchar.
      &quot;sourceMaxLengthFilter&quot;: &quot;A String&quot;, # Optional. The filter will match columns with length smaller than or equal to this number.
      &quot;sourceMinLengthFilter&quot;: &quot;A String&quot;, # Optional. The filter will match columns with length greater than or equal to this number.
    },
    &quot;valueTransformation&quot;: { # Description of data transformation during migration as part of the ConditionalColumnSetValue. # Required. Description of data transformation during migration.
      &quot;applyHash&quot;: { # Apply a hash function on the value. # Optional. Applies a hash function on the data
        &quot;uuidFromBytes&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Optional. Generate UUID from the data&#x27;s byte array
        },
      },
      &quot;assignMaxValue&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Optional. Set to max_value - if integer or numeric, will use int.maxvalue, etc
      },
      &quot;assignMinValue&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Optional. Set to min_value - if integer or numeric, will use int.minvalue, etc
      },
      &quot;assignNull&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Optional. Set to null
      },
      &quot;assignSpecificValue&quot;: { # Set to a specific value (value is converted to fit the target data type) # Optional. Set to a specific value (value is converted to fit the target data type)
        &quot;value&quot;: &quot;A String&quot;, # Required. Specific value to be assigned
      },
      &quot;doubleComparison&quot;: { # Filter based on relation between source value and compare value of type double in ConditionalColumnSetValue # Optional. Filter on relation between source value and compare value of type double.
        &quot;value&quot;: 3.14, # Required. Double compare value to be used
        &quot;valueComparison&quot;: &quot;A String&quot;, # Required. Relation between source value and compare value
      },
      &quot;intComparison&quot;: { # Filter based on relation between source value and compare value of type integer in ConditionalColumnSetValue # Optional. Filter on relation between source value and compare value of type integer.
        &quot;value&quot;: &quot;A String&quot;, # Required. Integer compare value to be used
        &quot;valueComparison&quot;: &quot;A String&quot;, # Required. Relation between source value and compare value
      },
      &quot;isNull&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Optional. Value is null
      },
      &quot;roundScale&quot;: { # This allows the data to change scale, for example if the source is 2 digits after the decimal point, specify round to scale value = 2. If for example the value needs to be converted to an integer, use round to scale value = 0. # Optional. Allows the data to change scale
        &quot;scale&quot;: 42, # Required. Scale value to be used
      },
      &quot;valueList&quot;: { # A list of values to filter by in ConditionalColumnSetValue # Optional. Value is found in the specified list.
        &quot;ignoreCase&quot;: True or False, # Required. Whether to ignore case when filtering by values. Defaults to false
        &quot;valuePresentList&quot;: &quot;A String&quot;, # Required. Indicates whether the filter matches rows with values that are present in the list or those with values not present in it.
        &quot;values&quot;: [ # Required. The list to be used to filter by
          &quot;A String&quot;,
        ],
      },
    },
  },
  &quot;convertRowidColumn&quot;: { # Options to configure rule type ConvertROWIDToColumn. The rule is used to add column rowid to destination tables based on an Oracle rowid function/property. The rule filter field can refer to one or more entities. The rule scope can be one of: Table. This rule requires additional filter to be specified beyond the basic rule filter field, which is whether or not to work on tables which already have a primary key defined. # Optional. Rule to specify how multiple tables should be converted with an additional rowid column.
    &quot;onlyIfNoPrimaryKey&quot;: True or False, # Required. Only work on tables without primary key defined
  },
  &quot;displayName&quot;: &quot;A String&quot;, # Optional. A human readable name
  &quot;entityMove&quot;: { # Options to configure rule type EntityMove. The rule is used to move an entity to a new schema. The rule filter field can refer to one or more entities. The rule scope can be one of: Table, Column, Constraint, Index, View, Function, Stored Procedure, Materialized View, Sequence, UDT # Optional. Rule to specify how multiple entities should be relocated into a different schema.
    &quot;newSchema&quot;: &quot;A String&quot;, # Required. The new schema
  },
  &quot;filter&quot;: { # A filter defining the entities that a mapping rule should be applied to. When more than one field is specified, the rule is applied only to entities which match all the fields. # Required. The rule filter
    &quot;entities&quot;: [ # Optional. The rule should be applied to specific entities defined by their fully qualified names.
      &quot;A String&quot;,
    ],
    &quot;entityNameContains&quot;: &quot;A String&quot;, # Optional. The rule should be applied to entities whose non-qualified name contains the given string.
    &quot;entityNamePrefix&quot;: &quot;A String&quot;, # Optional. The rule should be applied to entities whose non-qualified name starts with the given prefix.
    &quot;entityNameSuffix&quot;: &quot;A String&quot;, # Optional. The rule should be applied to entities whose non-qualified name ends with the given suffix.
    &quot;parentEntity&quot;: &quot;A String&quot;, # Optional. The rule should be applied to entities whose parent entity (fully qualified name) matches the given value. For example, if the rule applies to a table entity, the expected value should be a schema (schema). If the rule applies to a column or index entity, the expected value can be either a schema (schema) or a table (schema.table)
  },
  &quot;filterTableColumns&quot;: { # Options to configure rule type FilterTableColumns. The rule is used to filter the list of columns to include or exclude from a table. The rule filter field can refer to one entity. The rule scope can be: Table Only one of the two lists can be specified for the rule. # Optional. Rule to specify the list of columns to include or exclude from a table.
    &quot;excludeColumns&quot;: [ # Optional. List of columns to be excluded for a particular table.
      &quot;A String&quot;,
    ],
    &quot;includeColumns&quot;: [ # Optional. List of columns to be included for a particular table.
      &quot;A String&quot;,
    ],
  },
  &quot;multiColumnDataTypeChange&quot;: { # Options to configure rule type MultiColumnDatatypeChange. The rule is used to change the data type and associated properties of multiple columns at once. The rule filter field can refer to one or more entities. The rule scope can be one of:Column. This rule requires additional filters to be specified beyond the basic rule filter field, which is the source data type, but the rule supports additional filtering capabilities such as the minimum and maximum field length. All additional filters which are specified are required to be met in order for the rule to be applied (logical AND between the fields). # Optional. Rule to specify how multiple columns should be converted to a different data type.
    &quot;customFeatures&quot;: { # Optional. Custom engine specific features.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;newDataType&quot;: &quot;A String&quot;, # Required. New data type.
    &quot;overrideFractionalSecondsPrecision&quot;: 42, # Optional. Column fractional seconds precision - used only for timestamp based datatypes - if not specified and relevant uses the source column fractional seconds precision.
    &quot;overrideLength&quot;: &quot;A String&quot;, # Optional. Column length - e.g. varchar (50) - if not specified and relevant uses the source column length.
    &quot;overridePrecision&quot;: 42, # Optional. Column precision - when relevant - if not specified and relevant uses the source column precision.
    &quot;overrideScale&quot;: 42, # Optional. Column scale - when relevant - if not specified and relevant uses the source column scale.
    &quot;sourceDataTypeFilter&quot;: &quot;A String&quot;, # Required. Filter on source data type.
    &quot;sourceNumericFilter&quot;: { # Filter for fixed point number data types such as NUMERIC/NUMBER # Optional. Filter for fixed point number data types such as NUMERIC/NUMBER.
      &quot;numericFilterOption&quot;: &quot;A String&quot;, # Required. Enum to set the option defining the datatypes numeric filter has to be applied to
      &quot;sourceMaxPrecisionFilter&quot;: 42, # Optional. The filter will match columns with precision smaller than or equal to this number.
      &quot;sourceMaxScaleFilter&quot;: 42, # Optional. The filter will match columns with scale smaller than or equal to this number.
      &quot;sourceMinPrecisionFilter&quot;: 42, # Optional. The filter will match columns with precision greater than or equal to this number.
      &quot;sourceMinScaleFilter&quot;: 42, # Optional. The filter will match columns with scale greater than or equal to this number.
    },
    &quot;sourceTextFilter&quot;: { # Filter for text-based data types like varchar. # Optional. Filter for text-based data types like varchar.
      &quot;sourceMaxLengthFilter&quot;: &quot;A String&quot;, # Optional. The filter will match columns with length smaller than or equal to this number.
      &quot;sourceMinLengthFilter&quot;: &quot;A String&quot;, # Optional. The filter will match columns with length greater than or equal to this number.
    },
  },
  &quot;multiEntityRename&quot;: { # Options to configure rule type MultiEntityRename. The rule is used to rename multiple entities. The rule filter field can refer to one or more entities. The rule scope can be one of: Database, Schema, Table, Column, Constraint, Index, View, Function, Stored Procedure, Materialized View, Sequence, UDT # Optional. Rule to specify how multiple entities should be renamed.
    &quot;newNamePattern&quot;: &quot;A String&quot;, # Optional. The pattern used to generate the new entity&#x27;s name. This pattern must include the characters &#x27;{name}&#x27;, which will be replaced with the name of the original entity. For example, the pattern &#x27;t_{name}&#x27; for an entity name jobs would be converted to &#x27;t_jobs&#x27;. If unspecified, the default value for this field is &#x27;{name}&#x27;
    &quot;sourceNameTransformation&quot;: &quot;A String&quot;, # Optional. Additional transformation that can be done on the source entity name before it is being used by the new_name_pattern, for example lower case. If no transformation is desired, use NO_TRANSFORMATION
  },
  &quot;name&quot;: &quot;A String&quot;, # Full name of the mapping rule resource, in the form of: projects/{project}/locations/{location}/conversionWorkspaces/{set}/mappingRule/{rule}.
  &quot;revisionCreateTime&quot;: &quot;A String&quot;, # Output only. The timestamp that the revision was created.
  &quot;revisionId&quot;: &quot;A String&quot;, # Output only. The revision ID of the mapping rule. A new revision is committed whenever the mapping rule is changed in any way. The format is an 8-character hexadecimal string.
  &quot;ruleOrder&quot;: &quot;A String&quot;, # Required. The order in which the rule is applied. Lower order rules are applied before higher value rules so they may end up being overridden.
  &quot;ruleScope&quot;: &quot;A String&quot;, # Required. The rule scope
  &quot;setTablePrimaryKey&quot;: { # Options to configure rule type SetTablePrimaryKey. The rule is used to specify the columns and name to configure/alter the primary key of a table. The rule filter field can refer to one entity. The rule scope can be one of: Table. # Optional. Rule to specify the primary key for a table
    &quot;primaryKey&quot;: &quot;A String&quot;, # Optional. Name for the primary key
    &quot;primaryKeyColumns&quot;: [ # Required. List of column names for the primary key
      &quot;A String&quot;,
    ],
  },
  &quot;singleColumnChange&quot;: { # Options to configure rule type SingleColumnChange. The rule is used to change the properties of a column. The rule filter field can refer to one entity. The rule scope can be one of: Column. When using this rule, if a field is not specified than the destination column&#x27;s configuration will be the same as the one in the source column.. # Optional. Rule to specify how a single column is converted.
    &quot;array&quot;: True or False, # Optional. Is the column of array type.
    &quot;arrayLength&quot;: 42, # Optional. The length of the array, only relevant if the column type is an array.
    &quot;autoGenerated&quot;: True or False, # Optional. Is the column auto-generated/identity.
    &quot;charset&quot;: &quot;A String&quot;, # Optional. Charset override - instead of table level charset.
    &quot;collation&quot;: &quot;A String&quot;, # Optional. Collation override - instead of table level collation.
    &quot;comment&quot;: &quot;A String&quot;, # Optional. Comment associated with the column.
    &quot;customFeatures&quot;: { # Optional. Custom engine specific features.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;dataType&quot;: &quot;A String&quot;, # Optional. Column data type name.
    &quot;fractionalSecondsPrecision&quot;: 42, # Optional. Column fractional seconds precision - e.g. 2 as in timestamp (2) - when relevant.
    &quot;length&quot;: &quot;A String&quot;, # Optional. Column length - e.g. 50 as in varchar (50) - when relevant.
    &quot;nullable&quot;: True or False, # Optional. Is the column nullable.
    &quot;precision&quot;: 42, # Optional. Column precision - e.g. 8 as in double (8,2) - when relevant.
    &quot;scale&quot;: 42, # Optional. Column scale - e.g. 2 as in double (8,2) - when relevant.
    &quot;setValues&quot;: [ # Optional. Specifies the list of values allowed in the column.
      &quot;A String&quot;,
    ],
    &quot;udt&quot;: True or False, # Optional. Is the column a UDT (User-defined Type).
  },
  &quot;singleEntityRename&quot;: { # Options to configure rule type SingleEntityRename. The rule is used to rename an entity. The rule filter field can refer to only one entity. The rule scope can be one of: Database, Schema, Table, Column, Constraint, Index, View, Function, Stored Procedure, Materialized View, Sequence, UDT, Synonym # Optional. Rule to specify how a single entity should be renamed.
    &quot;newName&quot;: &quot;A String&quot;, # Required. The new name of the destination entity
  },
  &quot;singlePackageChange&quot;: { # Options to configure rule type SinglePackageChange. The rule is used to alter the sql code for a package entities. The rule filter field can refer to one entity. The rule scope can be: Package # Optional. Rule to specify how a single package is converted.
    &quot;packageBody&quot;: &quot;A String&quot;, # Optional. Sql code for package body
    &quot;packageDescription&quot;: &quot;A String&quot;, # Optional. Sql code for package description
  },
  &quot;sourceSqlChange&quot;: { # Options to configure rule type SourceSqlChange. The rule is used to alter the sql code for database entities. The rule filter field can refer to one entity. The rule scope can be: StoredProcedure, Function, Trigger, View # Optional. Rule to change the sql code for an entity, for example, function, procedure.
    &quot;sqlCode&quot;: &quot;A String&quot;, # Required. Sql code for source (stored procedure, function, trigger or view)
  },
  &quot;state&quot;: &quot;A String&quot;, # Optional. The mapping rule state
}</pre>
</div>

<div class="method">
    <code class="details" id="delete">delete(name, requestId=None, x__xgafv=None)</code>
  <pre>Deletes a single mapping rule.

Args:
  name: string, Required. Name of the mapping rule resource to delete. (required)
  requestId: string, Optional. A unique ID used to identify the request. If the server receives two requests with the same ID, then the second request is ignored. It is recommended to always set this value to a UUID. The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores (_), and hyphens (-). The maximum length is 40 characters.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
}</pre>
</div>

<div class="method">
    <code class="details" id="get">get(name, x__xgafv=None)</code>
  <pre>Gets the details of a mapping rule.

Args:
  name: string, Required. Name of the mapping rule resource to get. Example: conversionWorkspaces/123/mappingRules/rule123 In order to retrieve a previous revision of the mapping rule, also provide the revision ID. Example: conversionWorkspace/123/mappingRules/rule123@c7cfa2a8c7cfa2a8c7cfa2a8c7cfa2a8 (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Definition of a transformation that is to be applied to a group of entities in the source schema. Several such transformations can be applied to an entity sequentially to define the corresponding entity in the target schema.
  &quot;conditionalColumnSetValue&quot;: { # Options to configure rule type ConditionalColumnSetValue. The rule is used to transform the data which is being replicated/migrated. The rule filter field can refer to one or more entities. The rule scope can be one of: Column. # Optional. Rule to specify how the data contained in a column should be transformed (such as trimmed, rounded, etc) provided that the data meets certain criteria.
    &quot;customFeatures&quot;: { # Optional. Custom engine specific features.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;sourceNumericFilter&quot;: { # Filter for fixed point number data types such as NUMERIC/NUMBER # Optional. Optional filter on source column precision and scale. Used for fixed point numbers such as NUMERIC/NUMBER data types.
      &quot;numericFilterOption&quot;: &quot;A String&quot;, # Required. Enum to set the option defining the datatypes numeric filter has to be applied to
      &quot;sourceMaxPrecisionFilter&quot;: 42, # Optional. The filter will match columns with precision smaller than or equal to this number.
      &quot;sourceMaxScaleFilter&quot;: 42, # Optional. The filter will match columns with scale smaller than or equal to this number.
      &quot;sourceMinPrecisionFilter&quot;: 42, # Optional. The filter will match columns with precision greater than or equal to this number.
      &quot;sourceMinScaleFilter&quot;: 42, # Optional. The filter will match columns with scale greater than or equal to this number.
    },
    &quot;sourceTextFilter&quot;: { # Filter for text-based data types like varchar. # Optional. Optional filter on source column length. Used for text based data types like varchar.
      &quot;sourceMaxLengthFilter&quot;: &quot;A String&quot;, # Optional. The filter will match columns with length smaller than or equal to this number.
      &quot;sourceMinLengthFilter&quot;: &quot;A String&quot;, # Optional. The filter will match columns with length greater than or equal to this number.
    },
    &quot;valueTransformation&quot;: { # Description of data transformation during migration as part of the ConditionalColumnSetValue. # Required. Description of data transformation during migration.
      &quot;applyHash&quot;: { # Apply a hash function on the value. # Optional. Applies a hash function on the data
        &quot;uuidFromBytes&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Optional. Generate UUID from the data&#x27;s byte array
        },
      },
      &quot;assignMaxValue&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Optional. Set to max_value - if integer or numeric, will use int.maxvalue, etc
      },
      &quot;assignMinValue&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Optional. Set to min_value - if integer or numeric, will use int.minvalue, etc
      },
      &quot;assignNull&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Optional. Set to null
      },
      &quot;assignSpecificValue&quot;: { # Set to a specific value (value is converted to fit the target data type) # Optional. Set to a specific value (value is converted to fit the target data type)
        &quot;value&quot;: &quot;A String&quot;, # Required. Specific value to be assigned
      },
      &quot;doubleComparison&quot;: { # Filter based on relation between source value and compare value of type double in ConditionalColumnSetValue # Optional. Filter on relation between source value and compare value of type double.
        &quot;value&quot;: 3.14, # Required. Double compare value to be used
        &quot;valueComparison&quot;: &quot;A String&quot;, # Required. Relation between source value and compare value
      },
      &quot;intComparison&quot;: { # Filter based on relation between source value and compare value of type integer in ConditionalColumnSetValue # Optional. Filter on relation between source value and compare value of type integer.
        &quot;value&quot;: &quot;A String&quot;, # Required. Integer compare value to be used
        &quot;valueComparison&quot;: &quot;A String&quot;, # Required. Relation between source value and compare value
      },
      &quot;isNull&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Optional. Value is null
      },
      &quot;roundScale&quot;: { # This allows the data to change scale, for example if the source is 2 digits after the decimal point, specify round to scale value = 2. If for example the value needs to be converted to an integer, use round to scale value = 0. # Optional. Allows the data to change scale
        &quot;scale&quot;: 42, # Required. Scale value to be used
      },
      &quot;valueList&quot;: { # A list of values to filter by in ConditionalColumnSetValue # Optional. Value is found in the specified list.
        &quot;ignoreCase&quot;: True or False, # Required. Whether to ignore case when filtering by values. Defaults to false
        &quot;valuePresentList&quot;: &quot;A String&quot;, # Required. Indicates whether the filter matches rows with values that are present in the list or those with values not present in it.
        &quot;values&quot;: [ # Required. The list to be used to filter by
          &quot;A String&quot;,
        ],
      },
    },
  },
  &quot;convertRowidColumn&quot;: { # Options to configure rule type ConvertROWIDToColumn. The rule is used to add column rowid to destination tables based on an Oracle rowid function/property. The rule filter field can refer to one or more entities. The rule scope can be one of: Table. This rule requires additional filter to be specified beyond the basic rule filter field, which is whether or not to work on tables which already have a primary key defined. # Optional. Rule to specify how multiple tables should be converted with an additional rowid column.
    &quot;onlyIfNoPrimaryKey&quot;: True or False, # Required. Only work on tables without primary key defined
  },
  &quot;displayName&quot;: &quot;A String&quot;, # Optional. A human readable name
  &quot;entityMove&quot;: { # Options to configure rule type EntityMove. The rule is used to move an entity to a new schema. The rule filter field can refer to one or more entities. The rule scope can be one of: Table, Column, Constraint, Index, View, Function, Stored Procedure, Materialized View, Sequence, UDT # Optional. Rule to specify how multiple entities should be relocated into a different schema.
    &quot;newSchema&quot;: &quot;A String&quot;, # Required. The new schema
  },
  &quot;filter&quot;: { # A filter defining the entities that a mapping rule should be applied to. When more than one field is specified, the rule is applied only to entities which match all the fields. # Required. The rule filter
    &quot;entities&quot;: [ # Optional. The rule should be applied to specific entities defined by their fully qualified names.
      &quot;A String&quot;,
    ],
    &quot;entityNameContains&quot;: &quot;A String&quot;, # Optional. The rule should be applied to entities whose non-qualified name contains the given string.
    &quot;entityNamePrefix&quot;: &quot;A String&quot;, # Optional. The rule should be applied to entities whose non-qualified name starts with the given prefix.
    &quot;entityNameSuffix&quot;: &quot;A String&quot;, # Optional. The rule should be applied to entities whose non-qualified name ends with the given suffix.
    &quot;parentEntity&quot;: &quot;A String&quot;, # Optional. The rule should be applied to entities whose parent entity (fully qualified name) matches the given value. For example, if the rule applies to a table entity, the expected value should be a schema (schema). If the rule applies to a column or index entity, the expected value can be either a schema (schema) or a table (schema.table)
  },
  &quot;filterTableColumns&quot;: { # Options to configure rule type FilterTableColumns. The rule is used to filter the list of columns to include or exclude from a table. The rule filter field can refer to one entity. The rule scope can be: Table Only one of the two lists can be specified for the rule. # Optional. Rule to specify the list of columns to include or exclude from a table.
    &quot;excludeColumns&quot;: [ # Optional. List of columns to be excluded for a particular table.
      &quot;A String&quot;,
    ],
    &quot;includeColumns&quot;: [ # Optional. List of columns to be included for a particular table.
      &quot;A String&quot;,
    ],
  },
  &quot;multiColumnDataTypeChange&quot;: { # Options to configure rule type MultiColumnDatatypeChange. The rule is used to change the data type and associated properties of multiple columns at once. The rule filter field can refer to one or more entities. The rule scope can be one of:Column. This rule requires additional filters to be specified beyond the basic rule filter field, which is the source data type, but the rule supports additional filtering capabilities such as the minimum and maximum field length. All additional filters which are specified are required to be met in order for the rule to be applied (logical AND between the fields). # Optional. Rule to specify how multiple columns should be converted to a different data type.
    &quot;customFeatures&quot;: { # Optional. Custom engine specific features.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;newDataType&quot;: &quot;A String&quot;, # Required. New data type.
    &quot;overrideFractionalSecondsPrecision&quot;: 42, # Optional. Column fractional seconds precision - used only for timestamp based datatypes - if not specified and relevant uses the source column fractional seconds precision.
    &quot;overrideLength&quot;: &quot;A String&quot;, # Optional. Column length - e.g. varchar (50) - if not specified and relevant uses the source column length.
    &quot;overridePrecision&quot;: 42, # Optional. Column precision - when relevant - if not specified and relevant uses the source column precision.
    &quot;overrideScale&quot;: 42, # Optional. Column scale - when relevant - if not specified and relevant uses the source column scale.
    &quot;sourceDataTypeFilter&quot;: &quot;A String&quot;, # Required. Filter on source data type.
    &quot;sourceNumericFilter&quot;: { # Filter for fixed point number data types such as NUMERIC/NUMBER # Optional. Filter for fixed point number data types such as NUMERIC/NUMBER.
      &quot;numericFilterOption&quot;: &quot;A String&quot;, # Required. Enum to set the option defining the datatypes numeric filter has to be applied to
      &quot;sourceMaxPrecisionFilter&quot;: 42, # Optional. The filter will match columns with precision smaller than or equal to this number.
      &quot;sourceMaxScaleFilter&quot;: 42, # Optional. The filter will match columns with scale smaller than or equal to this number.
      &quot;sourceMinPrecisionFilter&quot;: 42, # Optional. The filter will match columns with precision greater than or equal to this number.
      &quot;sourceMinScaleFilter&quot;: 42, # Optional. The filter will match columns with scale greater than or equal to this number.
    },
    &quot;sourceTextFilter&quot;: { # Filter for text-based data types like varchar. # Optional. Filter for text-based data types like varchar.
      &quot;sourceMaxLengthFilter&quot;: &quot;A String&quot;, # Optional. The filter will match columns with length smaller than or equal to this number.
      &quot;sourceMinLengthFilter&quot;: &quot;A String&quot;, # Optional. The filter will match columns with length greater than or equal to this number.
    },
  },
  &quot;multiEntityRename&quot;: { # Options to configure rule type MultiEntityRename. The rule is used to rename multiple entities. The rule filter field can refer to one or more entities. The rule scope can be one of: Database, Schema, Table, Column, Constraint, Index, View, Function, Stored Procedure, Materialized View, Sequence, UDT # Optional. Rule to specify how multiple entities should be renamed.
    &quot;newNamePattern&quot;: &quot;A String&quot;, # Optional. The pattern used to generate the new entity&#x27;s name. This pattern must include the characters &#x27;{name}&#x27;, which will be replaced with the name of the original entity. For example, the pattern &#x27;t_{name}&#x27; for an entity name jobs would be converted to &#x27;t_jobs&#x27;. If unspecified, the default value for this field is &#x27;{name}&#x27;
    &quot;sourceNameTransformation&quot;: &quot;A String&quot;, # Optional. Additional transformation that can be done on the source entity name before it is being used by the new_name_pattern, for example lower case. If no transformation is desired, use NO_TRANSFORMATION
  },
  &quot;name&quot;: &quot;A String&quot;, # Full name of the mapping rule resource, in the form of: projects/{project}/locations/{location}/conversionWorkspaces/{set}/mappingRule/{rule}.
  &quot;revisionCreateTime&quot;: &quot;A String&quot;, # Output only. The timestamp that the revision was created.
  &quot;revisionId&quot;: &quot;A String&quot;, # Output only. The revision ID of the mapping rule. A new revision is committed whenever the mapping rule is changed in any way. The format is an 8-character hexadecimal string.
  &quot;ruleOrder&quot;: &quot;A String&quot;, # Required. The order in which the rule is applied. Lower order rules are applied before higher value rules so they may end up being overridden.
  &quot;ruleScope&quot;: &quot;A String&quot;, # Required. The rule scope
  &quot;setTablePrimaryKey&quot;: { # Options to configure rule type SetTablePrimaryKey. The rule is used to specify the columns and name to configure/alter the primary key of a table. The rule filter field can refer to one entity. The rule scope can be one of: Table. # Optional. Rule to specify the primary key for a table
    &quot;primaryKey&quot;: &quot;A String&quot;, # Optional. Name for the primary key
    &quot;primaryKeyColumns&quot;: [ # Required. List of column names for the primary key
      &quot;A String&quot;,
    ],
  },
  &quot;singleColumnChange&quot;: { # Options to configure rule type SingleColumnChange. The rule is used to change the properties of a column. The rule filter field can refer to one entity. The rule scope can be one of: Column. When using this rule, if a field is not specified than the destination column&#x27;s configuration will be the same as the one in the source column.. # Optional. Rule to specify how a single column is converted.
    &quot;array&quot;: True or False, # Optional. Is the column of array type.
    &quot;arrayLength&quot;: 42, # Optional. The length of the array, only relevant if the column type is an array.
    &quot;autoGenerated&quot;: True or False, # Optional. Is the column auto-generated/identity.
    &quot;charset&quot;: &quot;A String&quot;, # Optional. Charset override - instead of table level charset.
    &quot;collation&quot;: &quot;A String&quot;, # Optional. Collation override - instead of table level collation.
    &quot;comment&quot;: &quot;A String&quot;, # Optional. Comment associated with the column.
    &quot;customFeatures&quot;: { # Optional. Custom engine specific features.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;dataType&quot;: &quot;A String&quot;, # Optional. Column data type name.
    &quot;fractionalSecondsPrecision&quot;: 42, # Optional. Column fractional seconds precision - e.g. 2 as in timestamp (2) - when relevant.
    &quot;length&quot;: &quot;A String&quot;, # Optional. Column length - e.g. 50 as in varchar (50) - when relevant.
    &quot;nullable&quot;: True or False, # Optional. Is the column nullable.
    &quot;precision&quot;: 42, # Optional. Column precision - e.g. 8 as in double (8,2) - when relevant.
    &quot;scale&quot;: 42, # Optional. Column scale - e.g. 2 as in double (8,2) - when relevant.
    &quot;setValues&quot;: [ # Optional. Specifies the list of values allowed in the column.
      &quot;A String&quot;,
    ],
    &quot;udt&quot;: True or False, # Optional. Is the column a UDT (User-defined Type).
  },
  &quot;singleEntityRename&quot;: { # Options to configure rule type SingleEntityRename. The rule is used to rename an entity. The rule filter field can refer to only one entity. The rule scope can be one of: Database, Schema, Table, Column, Constraint, Index, View, Function, Stored Procedure, Materialized View, Sequence, UDT, Synonym # Optional. Rule to specify how a single entity should be renamed.
    &quot;newName&quot;: &quot;A String&quot;, # Required. The new name of the destination entity
  },
  &quot;singlePackageChange&quot;: { # Options to configure rule type SinglePackageChange. The rule is used to alter the sql code for a package entities. The rule filter field can refer to one entity. The rule scope can be: Package # Optional. Rule to specify how a single package is converted.
    &quot;packageBody&quot;: &quot;A String&quot;, # Optional. Sql code for package body
    &quot;packageDescription&quot;: &quot;A String&quot;, # Optional. Sql code for package description
  },
  &quot;sourceSqlChange&quot;: { # Options to configure rule type SourceSqlChange. The rule is used to alter the sql code for database entities. The rule filter field can refer to one entity. The rule scope can be: StoredProcedure, Function, Trigger, View # Optional. Rule to change the sql code for an entity, for example, function, procedure.
    &quot;sqlCode&quot;: &quot;A String&quot;, # Required. Sql code for source (stored procedure, function, trigger or view)
  },
  &quot;state&quot;: &quot;A String&quot;, # Optional. The mapping rule state
}</pre>
</div>

<div class="method">
    <code class="details" id="import_">import_(parent, body=None, x__xgafv=None)</code>
  <pre>Imports the mapping rules for a given conversion workspace. Supports various formats of external rules files.

Args:
  parent: string, Required. Name of the conversion workspace resource to import the rules to in the form of: projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}. (required)
  body: object, The request body.
    The object takes the form of:

{ # Request message for &#x27;ImportMappingRules&#x27; request.
  &quot;autoCommit&quot;: True or False, # Required. Should the conversion workspace be committed automatically after the import operation.
  &quot;rulesFiles&quot;: [ # Required. One or more rules files.
    { # Details of a single rules file.
      &quot;rulesContent&quot;: &quot;A String&quot;, # Required. The text content of the rules that needs to be converted.
      &quot;rulesSourceFilename&quot;: &quot;A String&quot;, # Required. The filename of the rules that needs to be converted. The filename is used mainly so that future logs of the import rules job contain it, and can therefore be searched by it.
    },
  ],
  &quot;rulesFormat&quot;: &quot;A String&quot;, # Required. The format of the rules content file.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # This resource represents a long-running operation that is the result of a network API call.
  &quot;done&quot;: True or False, # If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The error result of the operation in case of failure or cancellation.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;metadata&quot;: { # Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
  &quot;name&quot;: &quot;A String&quot;, # The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
  &quot;response&quot;: { # The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="list">list(parent, pageSize=None, pageToken=None, x__xgafv=None)</code>
  <pre>Lists the mapping rules for a specific conversion workspace.

Args:
  parent: string, Required. Name of the conversion workspace resource whose mapping rules are listed in the form of: projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}. (required)
  pageSize: integer, The maximum number of rules to return. The service may return fewer than this value.
  pageToken: string, The nextPageToken value received in the previous call to mappingRules.list, used in the subsequent request to retrieve the next page of results. On first call this should be left blank. When paginating, all other parameters provided to mappingRules.list must match the call that provided the page token.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response message for &#x27;ListMappingRulesRequest&#x27; request.
  &quot;mappingRules&quot;: [ # The list of conversion workspace mapping rules.
    { # Definition of a transformation that is to be applied to a group of entities in the source schema. Several such transformations can be applied to an entity sequentially to define the corresponding entity in the target schema.
      &quot;conditionalColumnSetValue&quot;: { # Options to configure rule type ConditionalColumnSetValue. The rule is used to transform the data which is being replicated/migrated. The rule filter field can refer to one or more entities. The rule scope can be one of: Column. # Optional. Rule to specify how the data contained in a column should be transformed (such as trimmed, rounded, etc) provided that the data meets certain criteria.
        &quot;customFeatures&quot;: { # Optional. Custom engine specific features.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;sourceNumericFilter&quot;: { # Filter for fixed point number data types such as NUMERIC/NUMBER # Optional. Optional filter on source column precision and scale. Used for fixed point numbers such as NUMERIC/NUMBER data types.
          &quot;numericFilterOption&quot;: &quot;A String&quot;, # Required. Enum to set the option defining the datatypes numeric filter has to be applied to
          &quot;sourceMaxPrecisionFilter&quot;: 42, # Optional. The filter will match columns with precision smaller than or equal to this number.
          &quot;sourceMaxScaleFilter&quot;: 42, # Optional. The filter will match columns with scale smaller than or equal to this number.
          &quot;sourceMinPrecisionFilter&quot;: 42, # Optional. The filter will match columns with precision greater than or equal to this number.
          &quot;sourceMinScaleFilter&quot;: 42, # Optional. The filter will match columns with scale greater than or equal to this number.
        },
        &quot;sourceTextFilter&quot;: { # Filter for text-based data types like varchar. # Optional. Optional filter on source column length. Used for text based data types like varchar.
          &quot;sourceMaxLengthFilter&quot;: &quot;A String&quot;, # Optional. The filter will match columns with length smaller than or equal to this number.
          &quot;sourceMinLengthFilter&quot;: &quot;A String&quot;, # Optional. The filter will match columns with length greater than or equal to this number.
        },
        &quot;valueTransformation&quot;: { # Description of data transformation during migration as part of the ConditionalColumnSetValue. # Required. Description of data transformation during migration.
          &quot;applyHash&quot;: { # Apply a hash function on the value. # Optional. Applies a hash function on the data
            &quot;uuidFromBytes&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Optional. Generate UUID from the data&#x27;s byte array
            },
          },
          &quot;assignMaxValue&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Optional. Set to max_value - if integer or numeric, will use int.maxvalue, etc
          },
          &quot;assignMinValue&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Optional. Set to min_value - if integer or numeric, will use int.minvalue, etc
          },
          &quot;assignNull&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Optional. Set to null
          },
          &quot;assignSpecificValue&quot;: { # Set to a specific value (value is converted to fit the target data type) # Optional. Set to a specific value (value is converted to fit the target data type)
            &quot;value&quot;: &quot;A String&quot;, # Required. Specific value to be assigned
          },
          &quot;doubleComparison&quot;: { # Filter based on relation between source value and compare value of type double in ConditionalColumnSetValue # Optional. Filter on relation between source value and compare value of type double.
            &quot;value&quot;: 3.14, # Required. Double compare value to be used
            &quot;valueComparison&quot;: &quot;A String&quot;, # Required. Relation between source value and compare value
          },
          &quot;intComparison&quot;: { # Filter based on relation between source value and compare value of type integer in ConditionalColumnSetValue # Optional. Filter on relation between source value and compare value of type integer.
            &quot;value&quot;: &quot;A String&quot;, # Required. Integer compare value to be used
            &quot;valueComparison&quot;: &quot;A String&quot;, # Required. Relation between source value and compare value
          },
          &quot;isNull&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Optional. Value is null
          },
          &quot;roundScale&quot;: { # This allows the data to change scale, for example if the source is 2 digits after the decimal point, specify round to scale value = 2. If for example the value needs to be converted to an integer, use round to scale value = 0. # Optional. Allows the data to change scale
            &quot;scale&quot;: 42, # Required. Scale value to be used
          },
          &quot;valueList&quot;: { # A list of values to filter by in ConditionalColumnSetValue # Optional. Value is found in the specified list.
            &quot;ignoreCase&quot;: True or False, # Required. Whether to ignore case when filtering by values. Defaults to false
            &quot;valuePresentList&quot;: &quot;A String&quot;, # Required. Indicates whether the filter matches rows with values that are present in the list or those with values not present in it.
            &quot;values&quot;: [ # Required. The list to be used to filter by
              &quot;A String&quot;,
            ],
          },
        },
      },
      &quot;convertRowidColumn&quot;: { # Options to configure rule type ConvertROWIDToColumn. The rule is used to add column rowid to destination tables based on an Oracle rowid function/property. The rule filter field can refer to one or more entities. The rule scope can be one of: Table. This rule requires additional filter to be specified beyond the basic rule filter field, which is whether or not to work on tables which already have a primary key defined. # Optional. Rule to specify how multiple tables should be converted with an additional rowid column.
        &quot;onlyIfNoPrimaryKey&quot;: True or False, # Required. Only work on tables without primary key defined
      },
      &quot;displayName&quot;: &quot;A String&quot;, # Optional. A human readable name
      &quot;entityMove&quot;: { # Options to configure rule type EntityMove. The rule is used to move an entity to a new schema. The rule filter field can refer to one or more entities. The rule scope can be one of: Table, Column, Constraint, Index, View, Function, Stored Procedure, Materialized View, Sequence, UDT # Optional. Rule to specify how multiple entities should be relocated into a different schema.
        &quot;newSchema&quot;: &quot;A String&quot;, # Required. The new schema
      },
      &quot;filter&quot;: { # A filter defining the entities that a mapping rule should be applied to. When more than one field is specified, the rule is applied only to entities which match all the fields. # Required. The rule filter
        &quot;entities&quot;: [ # Optional. The rule should be applied to specific entities defined by their fully qualified names.
          &quot;A String&quot;,
        ],
        &quot;entityNameContains&quot;: &quot;A String&quot;, # Optional. The rule should be applied to entities whose non-qualified name contains the given string.
        &quot;entityNamePrefix&quot;: &quot;A String&quot;, # Optional. The rule should be applied to entities whose non-qualified name starts with the given prefix.
        &quot;entityNameSuffix&quot;: &quot;A String&quot;, # Optional. The rule should be applied to entities whose non-qualified name ends with the given suffix.
        &quot;parentEntity&quot;: &quot;A String&quot;, # Optional. The rule should be applied to entities whose parent entity (fully qualified name) matches the given value. For example, if the rule applies to a table entity, the expected value should be a schema (schema). If the rule applies to a column or index entity, the expected value can be either a schema (schema) or a table (schema.table)
      },
      &quot;filterTableColumns&quot;: { # Options to configure rule type FilterTableColumns. The rule is used to filter the list of columns to include or exclude from a table. The rule filter field can refer to one entity. The rule scope can be: Table Only one of the two lists can be specified for the rule. # Optional. Rule to specify the list of columns to include or exclude from a table.
        &quot;excludeColumns&quot;: [ # Optional. List of columns to be excluded for a particular table.
          &quot;A String&quot;,
        ],
        &quot;includeColumns&quot;: [ # Optional. List of columns to be included for a particular table.
          &quot;A String&quot;,
        ],
      },
      &quot;multiColumnDataTypeChange&quot;: { # Options to configure rule type MultiColumnDatatypeChange. The rule is used to change the data type and associated properties of multiple columns at once. The rule filter field can refer to one or more entities. The rule scope can be one of:Column. This rule requires additional filters to be specified beyond the basic rule filter field, which is the source data type, but the rule supports additional filtering capabilities such as the minimum and maximum field length. All additional filters which are specified are required to be met in order for the rule to be applied (logical AND between the fields). # Optional. Rule to specify how multiple columns should be converted to a different data type.
        &quot;customFeatures&quot;: { # Optional. Custom engine specific features.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;newDataType&quot;: &quot;A String&quot;, # Required. New data type.
        &quot;overrideFractionalSecondsPrecision&quot;: 42, # Optional. Column fractional seconds precision - used only for timestamp based datatypes - if not specified and relevant uses the source column fractional seconds precision.
        &quot;overrideLength&quot;: &quot;A String&quot;, # Optional. Column length - e.g. varchar (50) - if not specified and relevant uses the source column length.
        &quot;overridePrecision&quot;: 42, # Optional. Column precision - when relevant - if not specified and relevant uses the source column precision.
        &quot;overrideScale&quot;: 42, # Optional. Column scale - when relevant - if not specified and relevant uses the source column scale.
        &quot;sourceDataTypeFilter&quot;: &quot;A String&quot;, # Required. Filter on source data type.
        &quot;sourceNumericFilter&quot;: { # Filter for fixed point number data types such as NUMERIC/NUMBER # Optional. Filter for fixed point number data types such as NUMERIC/NUMBER.
          &quot;numericFilterOption&quot;: &quot;A String&quot;, # Required. Enum to set the option defining the datatypes numeric filter has to be applied to
          &quot;sourceMaxPrecisionFilter&quot;: 42, # Optional. The filter will match columns with precision smaller than or equal to this number.
          &quot;sourceMaxScaleFilter&quot;: 42, # Optional. The filter will match columns with scale smaller than or equal to this number.
          &quot;sourceMinPrecisionFilter&quot;: 42, # Optional. The filter will match columns with precision greater than or equal to this number.
          &quot;sourceMinScaleFilter&quot;: 42, # Optional. The filter will match columns with scale greater than or equal to this number.
        },
        &quot;sourceTextFilter&quot;: { # Filter for text-based data types like varchar. # Optional. Filter for text-based data types like varchar.
          &quot;sourceMaxLengthFilter&quot;: &quot;A String&quot;, # Optional. The filter will match columns with length smaller than or equal to this number.
          &quot;sourceMinLengthFilter&quot;: &quot;A String&quot;, # Optional. The filter will match columns with length greater than or equal to this number.
        },
      },
      &quot;multiEntityRename&quot;: { # Options to configure rule type MultiEntityRename. The rule is used to rename multiple entities. The rule filter field can refer to one or more entities. The rule scope can be one of: Database, Schema, Table, Column, Constraint, Index, View, Function, Stored Procedure, Materialized View, Sequence, UDT # Optional. Rule to specify how multiple entities should be renamed.
        &quot;newNamePattern&quot;: &quot;A String&quot;, # Optional. The pattern used to generate the new entity&#x27;s name. This pattern must include the characters &#x27;{name}&#x27;, which will be replaced with the name of the original entity. For example, the pattern &#x27;t_{name}&#x27; for an entity name jobs would be converted to &#x27;t_jobs&#x27;. If unspecified, the default value for this field is &#x27;{name}&#x27;
        &quot;sourceNameTransformation&quot;: &quot;A String&quot;, # Optional. Additional transformation that can be done on the source entity name before it is being used by the new_name_pattern, for example lower case. If no transformation is desired, use NO_TRANSFORMATION
      },
      &quot;name&quot;: &quot;A String&quot;, # Full name of the mapping rule resource, in the form of: projects/{project}/locations/{location}/conversionWorkspaces/{set}/mappingRule/{rule}.
      &quot;revisionCreateTime&quot;: &quot;A String&quot;, # Output only. The timestamp that the revision was created.
      &quot;revisionId&quot;: &quot;A String&quot;, # Output only. The revision ID of the mapping rule. A new revision is committed whenever the mapping rule is changed in any way. The format is an 8-character hexadecimal string.
      &quot;ruleOrder&quot;: &quot;A String&quot;, # Required. The order in which the rule is applied. Lower order rules are applied before higher value rules so they may end up being overridden.
      &quot;ruleScope&quot;: &quot;A String&quot;, # Required. The rule scope
      &quot;setTablePrimaryKey&quot;: { # Options to configure rule type SetTablePrimaryKey. The rule is used to specify the columns and name to configure/alter the primary key of a table. The rule filter field can refer to one entity. The rule scope can be one of: Table. # Optional. Rule to specify the primary key for a table
        &quot;primaryKey&quot;: &quot;A String&quot;, # Optional. Name for the primary key
        &quot;primaryKeyColumns&quot;: [ # Required. List of column names for the primary key
          &quot;A String&quot;,
        ],
      },
      &quot;singleColumnChange&quot;: { # Options to configure rule type SingleColumnChange. The rule is used to change the properties of a column. The rule filter field can refer to one entity. The rule scope can be one of: Column. When using this rule, if a field is not specified than the destination column&#x27;s configuration will be the same as the one in the source column.. # Optional. Rule to specify how a single column is converted.
        &quot;array&quot;: True or False, # Optional. Is the column of array type.
        &quot;arrayLength&quot;: 42, # Optional. The length of the array, only relevant if the column type is an array.
        &quot;autoGenerated&quot;: True or False, # Optional. Is the column auto-generated/identity.
        &quot;charset&quot;: &quot;A String&quot;, # Optional. Charset override - instead of table level charset.
        &quot;collation&quot;: &quot;A String&quot;, # Optional. Collation override - instead of table level collation.
        &quot;comment&quot;: &quot;A String&quot;, # Optional. Comment associated with the column.
        &quot;customFeatures&quot;: { # Optional. Custom engine specific features.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;dataType&quot;: &quot;A String&quot;, # Optional. Column data type name.
        &quot;fractionalSecondsPrecision&quot;: 42, # Optional. Column fractional seconds precision - e.g. 2 as in timestamp (2) - when relevant.
        &quot;length&quot;: &quot;A String&quot;, # Optional. Column length - e.g. 50 as in varchar (50) - when relevant.
        &quot;nullable&quot;: True or False, # Optional. Is the column nullable.
        &quot;precision&quot;: 42, # Optional. Column precision - e.g. 8 as in double (8,2) - when relevant.
        &quot;scale&quot;: 42, # Optional. Column scale - e.g. 2 as in double (8,2) - when relevant.
        &quot;setValues&quot;: [ # Optional. Specifies the list of values allowed in the column.
          &quot;A String&quot;,
        ],
        &quot;udt&quot;: True or False, # Optional. Is the column a UDT (User-defined Type).
      },
      &quot;singleEntityRename&quot;: { # Options to configure rule type SingleEntityRename. The rule is used to rename an entity. The rule filter field can refer to only one entity. The rule scope can be one of: Database, Schema, Table, Column, Constraint, Index, View, Function, Stored Procedure, Materialized View, Sequence, UDT, Synonym # Optional. Rule to specify how a single entity should be renamed.
        &quot;newName&quot;: &quot;A String&quot;, # Required. The new name of the destination entity
      },
      &quot;singlePackageChange&quot;: { # Options to configure rule type SinglePackageChange. The rule is used to alter the sql code for a package entities. The rule filter field can refer to one entity. The rule scope can be: Package # Optional. Rule to specify how a single package is converted.
        &quot;packageBody&quot;: &quot;A String&quot;, # Optional. Sql code for package body
        &quot;packageDescription&quot;: &quot;A String&quot;, # Optional. Sql code for package description
      },
      &quot;sourceSqlChange&quot;: { # Options to configure rule type SourceSqlChange. The rule is used to alter the sql code for database entities. The rule filter field can refer to one entity. The rule scope can be: StoredProcedure, Function, Trigger, View # Optional. Rule to change the sql code for an entity, for example, function, procedure.
        &quot;sqlCode&quot;: &quot;A String&quot;, # Required. Sql code for source (stored procedure, function, trigger or view)
      },
      &quot;state&quot;: &quot;A String&quot;, # Optional. The mapping rule state
    },
  ],
  &quot;nextPageToken&quot;: &quot;A String&quot;, # A token which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
}</pre>
</div>

<div class="method">
    <code class="details" id="list_next">list_next()</code>
  <pre>Retrieves the next page of results.

        Args:
          previous_request: The request for the previous page. (required)
          previous_response: The response from the request for the previous page. (required)

        Returns:
          A request object that you can call &#x27;execute()&#x27; on to request the next
          page. Returns None if there are no more items in the collection.
        </pre>
</div>

</body></html>