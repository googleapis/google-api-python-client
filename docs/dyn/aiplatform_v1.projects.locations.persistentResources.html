<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="aiplatform_v1.html">Vertex AI API</a> . <a href="aiplatform_v1.projects.html">projects</a> . <a href="aiplatform_v1.projects.locations.html">locations</a> . <a href="aiplatform_v1.projects.locations.persistentResources.html">persistentResources</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="aiplatform_v1.projects.locations.persistentResources.operations.html">operations()</a></code>
</p>
<p class="firstline">Returns the operations Resource.</p>

<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#create">create(parent, body=None, persistentResourceId=None, x__xgafv=None)</a></code></p>
<p class="firstline">Creates a PersistentResource.</p>
<p class="toc_element">
  <code><a href="#delete">delete(name, x__xgafv=None)</a></code></p>
<p class="firstline">Deletes a PersistentResource.</p>
<p class="toc_element">
  <code><a href="#get">get(name, x__xgafv=None)</a></code></p>
<p class="firstline">Gets a PersistentResource.</p>
<p class="toc_element">
  <code><a href="#list">list(parent, pageSize=None, pageToken=None, x__xgafv=None)</a></code></p>
<p class="firstline">Lists PersistentResources in a Location.</p>
<p class="toc_element">
  <code><a href="#list_next">list_next()</a></code></p>
<p class="firstline">Retrieves the next page of results.</p>
<p class="toc_element">
  <code><a href="#patch">patch(name, body=None, updateMask=None, x__xgafv=None)</a></code></p>
<p class="firstline">Updates a PersistentResource.</p>
<p class="toc_element">
  <code><a href="#reboot">reboot(name, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Reboots a PersistentResource.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="create">create(parent, body=None, persistentResourceId=None, x__xgafv=None)</code>
  <pre>Creates a PersistentResource.

Args:
  parent: string, Required. The resource name of the Location to create the PersistentResource in. Format: `projects/{project}/locations/{location}` (required)
  body: object, The request body.
    The object takes the form of:

{ # Represents long-lasting resources that are dedicated to users to runs custom workloads. A PersistentResource can have multiple node pools and each node pool can have its own machine spec.
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Time when the PersistentResource was created.
  &quot;displayName&quot;: &quot;A String&quot;, # Optional. The display name of the PersistentResource. The name can be up to 128 characters long and can consist of any UTF-8 characters.
  &quot;encryptionSpec&quot;: { # Represents a customer-managed encryption key spec that can be applied to a top-level resource. # Optional. Customer-managed encryption key spec for a PersistentResource. If set, this PersistentResource and all sub-resources of this PersistentResource will be secured by this key.
    &quot;kmsKeyName&quot;: &quot;A String&quot;, # Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
  },
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. Only populated when persistent resource&#x27;s state is `STOPPING` or `ERROR`.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;labels&quot;: { # Optional. The labels with user-defined metadata to organize PersistentResource. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels.
    &quot;a_key&quot;: &quot;A String&quot;,
  },
  &quot;name&quot;: &quot;A String&quot;, # Immutable. Resource name of a PersistentResource.
  &quot;network&quot;: &quot;A String&quot;, # Optional. The full name of the Compute Engine [network](/compute/docs/networks-and-firewalls#networks) to peered with Vertex AI to host the persistent resources. For example, `projects/12345/global/networks/myVPC`. [Format](/compute/docs/reference/rest/v1/networks/insert) is of the form `projects/{project}/global/networks/{network}`. Where {project} is a project number, as in `12345`, and {network} is a network name. To specify this field, you must have already [configured VPC Network Peering for Vertex AI](https://cloud.google.com/vertex-ai/docs/general/vpc-peering). If this field is left unspecified, the resources aren&#x27;t peered with any network.
  &quot;reservedIpRanges&quot;: [ # Optional. A list of names for the reserved IP ranges under the VPC network that can be used for this persistent resource. If set, we will deploy the persistent resource within the provided IP ranges. Otherwise, the persistent resource is deployed to any IP ranges under the provided VPC network. Example: [&#x27;vertex-ai-ip-range&#x27;].
    &quot;A String&quot;,
  ],
  &quot;resourcePools&quot;: [ # Required. The spec of the pools of different resources.
    { # Represents the spec of a group of resources of the same type, for example machine type, disk, and accelerators, in a PersistentResource.
      &quot;autoscalingSpec&quot;: { # The min/max number of replicas allowed if enabling autoscaling # Optional. Optional spec to configure GKE or Ray-on-Vertex autoscaling
        &quot;maxReplicaCount&quot;: &quot;A String&quot;, # Optional. max replicas in the node pool, must be ≥ replica_count and &gt; min_replica_count or will throw error
        &quot;minReplicaCount&quot;: &quot;A String&quot;, # Optional. min replicas in the node pool, must be ≤ replica_count and &lt; max_replica_count or will throw error. For autoscaling enabled Ray-on-Vertex, we allow min_replica_count of a resource_pool to be 0 to match the OSS Ray behavior(https://docs.ray.io/en/latest/cluster/vms/user-guides/configuring-autoscaling.html#cluster-config-parameters). As for Persistent Resource, the min_replica_count must be &gt; 0, we added a corresponding validation inside CreatePersistentResourceRequestValidator.java.
      },
      &quot;diskSpec&quot;: { # Represents the spec of disk options. # Optional. Disk spec for the machine in this node pool.
        &quot;bootDiskSizeGb&quot;: 42, # Size in GB of the boot disk (default is 100GB).
        &quot;bootDiskType&quot;: &quot;A String&quot;, # Type of the boot disk (default is &quot;pd-ssd&quot;). Valid values: &quot;pd-ssd&quot; (Persistent Disk Solid State Drive) or &quot;pd-standard&quot; (Persistent Disk Hard Disk Drive).
      },
      &quot;id&quot;: &quot;A String&quot;, # Immutable. The unique ID in a PersistentResource for referring to this resource pool. User can specify it if necessary. Otherwise, it&#x27;s generated automatically.
      &quot;machineSpec&quot;: { # Specification of a single machine. # Required. Immutable. The specification of a single machine.
        &quot;acceleratorCount&quot;: 42, # The number of accelerators to attach to the machine.
        &quot;acceleratorType&quot;: &quot;A String&quot;, # Immutable. The type of accelerator(s) that may be attached to the machine as per accelerator_count.
        &quot;machineType&quot;: &quot;A String&quot;, # Immutable. The type of the machine. See the [list of machine types supported for prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types) See the [list of machine types supported for custom training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types). For DeployedModel this field is optional, and the default value is `n1-standard-2`. For BatchPredictionJob or as part of WorkerPoolSpec this field is required.
        &quot;reservationAffinity&quot;: { # A ReservationAffinity can be used to configure a Vertex AI resource (e.g., a DeployedModel) to draw its Compute Engine resources from a Shared Reservation, or exclusively from on-demand capacity. # Optional. Immutable. Configuration controlling how this resource pool consumes reservation.
          &quot;key&quot;: &quot;A String&quot;, # Optional. Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, use `compute.googleapis.com/reservation-name` as the key and specify the name of your reservation as its value.
          &quot;reservationAffinityType&quot;: &quot;A String&quot;, # Required. Specifies the reservation affinity type.
          &quot;values&quot;: [ # Optional. Corresponds to the label values of a reservation resource. This must be the full resource name of the reservation.
            &quot;A String&quot;,
          ],
        },
        &quot;tpuTopology&quot;: &quot;A String&quot;, # Immutable. The topology of the TPUs. Corresponds to the TPU topologies available from GKE. (Example: tpu_topology: &quot;2x2x1&quot;).
      },
      &quot;replicaCount&quot;: &quot;A String&quot;, # Optional. The total number of machines to use for this resource pool.
      &quot;usedReplicaCount&quot;: &quot;A String&quot;, # Output only. The number of machines currently in use by training jobs for this resource pool. Will replace idle_replica_count.
    },
  ],
  &quot;resourceRuntime&quot;: { # Persistent Cluster runtime information as output # Output only. Runtime information of the Persistent Resource.
    &quot;accessUris&quot;: { # Output only. URIs for user to connect to the Cluster. Example: { &quot;RAY_HEAD_NODE_INTERNAL_IP&quot;: &quot;head-node-IP:10001&quot; &quot;RAY_DASHBOARD_URI&quot;: &quot;ray-dashboard-address:8888&quot; }
      &quot;a_key&quot;: &quot;A String&quot;,
    },
  },
  &quot;resourceRuntimeSpec&quot;: { # Configuration for the runtime on a PersistentResource instance, including but not limited to: * Service accounts used to run the workloads. * Whether to make it a dedicated Ray Cluster. # Optional. Persistent Resource runtime spec. For example, used for Ray cluster configuration.
    &quot;raySpec&quot;: { # Configuration information for the Ray cluster. For experimental launch, Ray cluster creation and Persistent cluster creation are 1:1 mapping: We will provision all the nodes within the Persistent cluster as Ray nodes. # Optional. Ray cluster configuration. Required when creating a dedicated RayCluster on the PersistentResource.
      &quot;headNodeResourcePoolId&quot;: &quot;A String&quot;, # Optional. This will be used to indicate which resource pool will serve as the Ray head node(the first node within that pool). Will use the machine from the first workerpool as the head node by default if this field isn&#x27;t set.
      &quot;imageUri&quot;: &quot;A String&quot;, # Optional. Default image for user to choose a preferred ML framework (for example, TensorFlow or Pytorch) by choosing from [Vertex prebuilt images](https://cloud.google.com/vertex-ai/docs/training/pre-built-containers). Either this or the resource_pool_images is required. Use this field if you need all the resource pools to have the same Ray image. Otherwise, use the {@code resource_pool_images} field.
      &quot;rayLogsSpec&quot;: { # Configuration for the Ray OSS Logs. # Optional. OSS Ray logging configurations.
        &quot;disabled&quot;: True or False, # Optional. Flag to disable the export of Ray OSS logs to Cloud Logging.
      },
      &quot;rayMetricSpec&quot;: { # Configuration for the Ray metrics. # Optional. Ray metrics configurations.
        &quot;disabled&quot;: True or False, # Optional. Flag to disable the Ray metrics collection.
      },
      &quot;resourcePoolImages&quot;: { # Optional. Required if image_uri isn&#x27;t set. A map of resource_pool_id to prebuild Ray image if user need to use different images for different head/worker pools. This map needs to cover all the resource pool ids. Example: { &quot;ray_head_node_pool&quot;: &quot;head image&quot; &quot;ray_worker_node_pool1&quot;: &quot;worker image&quot; &quot;ray_worker_node_pool2&quot;: &quot;another worker image&quot; }
        &quot;a_key&quot;: &quot;A String&quot;,
      },
    },
    &quot;serviceAccountSpec&quot;: { # Configuration for the use of custom service account to run the workloads. # Optional. Configure the use of workload identity on the PersistentResource
      &quot;enableCustomServiceAccount&quot;: True or False, # Required. If true, custom user-managed service account is enforced to run any workloads (for example, Vertex Jobs) on the resource. Otherwise, uses the [Vertex AI Custom Code Service Agent](https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents).
      &quot;serviceAccount&quot;: &quot;A String&quot;, # Optional. Required when all below conditions are met * `enable_custom_service_account` is true; * any runtime is specified via `ResourceRuntimeSpec` on creation time, for example, Ray The users must have `iam.serviceAccounts.actAs` permission on this service account and then the specified runtime containers will run as it. Do not set this field if you want to submit jobs using custom service account to this PersistentResource after creation, but only specify the `service_account` inside the job.
    },
  },
  &quot;startTime&quot;: &quot;A String&quot;, # Output only. Time when the PersistentResource for the first time entered the `RUNNING` state.
  &quot;state&quot;: &quot;A String&quot;, # Output only. The detailed state of a Study.
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Time when the PersistentResource was most recently updated.
}

  persistentResourceId: string, Required. The ID to use for the PersistentResource, which become the final component of the PersistentResource&#x27;s resource name. The maximum length is 63 characters, and valid characters are `/^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$/`.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # This resource represents a long-running operation that is the result of a network API call.
  &quot;done&quot;: True or False, # If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The error result of the operation in case of failure or cancellation.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;metadata&quot;: { # Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
  &quot;name&quot;: &quot;A String&quot;, # The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
  &quot;response&quot;: { # The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="delete">delete(name, x__xgafv=None)</code>
  <pre>Deletes a PersistentResource.

Args:
  name: string, Required. The name of the PersistentResource to be deleted. Format: `projects/{project}/locations/{location}/persistentResources/{persistent_resource}` (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # This resource represents a long-running operation that is the result of a network API call.
  &quot;done&quot;: True or False, # If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The error result of the operation in case of failure or cancellation.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;metadata&quot;: { # Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
  &quot;name&quot;: &quot;A String&quot;, # The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
  &quot;response&quot;: { # The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="get">get(name, x__xgafv=None)</code>
  <pre>Gets a PersistentResource.

Args:
  name: string, Required. The name of the PersistentResource resource. Format: `projects/{project_id_or_number}/locations/{location_id}/persistentResources/{persistent_resource_id}` (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Represents long-lasting resources that are dedicated to users to runs custom workloads. A PersistentResource can have multiple node pools and each node pool can have its own machine spec.
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Time when the PersistentResource was created.
  &quot;displayName&quot;: &quot;A String&quot;, # Optional. The display name of the PersistentResource. The name can be up to 128 characters long and can consist of any UTF-8 characters.
  &quot;encryptionSpec&quot;: { # Represents a customer-managed encryption key spec that can be applied to a top-level resource. # Optional. Customer-managed encryption key spec for a PersistentResource. If set, this PersistentResource and all sub-resources of this PersistentResource will be secured by this key.
    &quot;kmsKeyName&quot;: &quot;A String&quot;, # Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
  },
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. Only populated when persistent resource&#x27;s state is `STOPPING` or `ERROR`.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;labels&quot;: { # Optional. The labels with user-defined metadata to organize PersistentResource. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels.
    &quot;a_key&quot;: &quot;A String&quot;,
  },
  &quot;name&quot;: &quot;A String&quot;, # Immutable. Resource name of a PersistentResource.
  &quot;network&quot;: &quot;A String&quot;, # Optional. The full name of the Compute Engine [network](/compute/docs/networks-and-firewalls#networks) to peered with Vertex AI to host the persistent resources. For example, `projects/12345/global/networks/myVPC`. [Format](/compute/docs/reference/rest/v1/networks/insert) is of the form `projects/{project}/global/networks/{network}`. Where {project} is a project number, as in `12345`, and {network} is a network name. To specify this field, you must have already [configured VPC Network Peering for Vertex AI](https://cloud.google.com/vertex-ai/docs/general/vpc-peering). If this field is left unspecified, the resources aren&#x27;t peered with any network.
  &quot;reservedIpRanges&quot;: [ # Optional. A list of names for the reserved IP ranges under the VPC network that can be used for this persistent resource. If set, we will deploy the persistent resource within the provided IP ranges. Otherwise, the persistent resource is deployed to any IP ranges under the provided VPC network. Example: [&#x27;vertex-ai-ip-range&#x27;].
    &quot;A String&quot;,
  ],
  &quot;resourcePools&quot;: [ # Required. The spec of the pools of different resources.
    { # Represents the spec of a group of resources of the same type, for example machine type, disk, and accelerators, in a PersistentResource.
      &quot;autoscalingSpec&quot;: { # The min/max number of replicas allowed if enabling autoscaling # Optional. Optional spec to configure GKE or Ray-on-Vertex autoscaling
        &quot;maxReplicaCount&quot;: &quot;A String&quot;, # Optional. max replicas in the node pool, must be ≥ replica_count and &gt; min_replica_count or will throw error
        &quot;minReplicaCount&quot;: &quot;A String&quot;, # Optional. min replicas in the node pool, must be ≤ replica_count and &lt; max_replica_count or will throw error. For autoscaling enabled Ray-on-Vertex, we allow min_replica_count of a resource_pool to be 0 to match the OSS Ray behavior(https://docs.ray.io/en/latest/cluster/vms/user-guides/configuring-autoscaling.html#cluster-config-parameters). As for Persistent Resource, the min_replica_count must be &gt; 0, we added a corresponding validation inside CreatePersistentResourceRequestValidator.java.
      },
      &quot;diskSpec&quot;: { # Represents the spec of disk options. # Optional. Disk spec for the machine in this node pool.
        &quot;bootDiskSizeGb&quot;: 42, # Size in GB of the boot disk (default is 100GB).
        &quot;bootDiskType&quot;: &quot;A String&quot;, # Type of the boot disk (default is &quot;pd-ssd&quot;). Valid values: &quot;pd-ssd&quot; (Persistent Disk Solid State Drive) or &quot;pd-standard&quot; (Persistent Disk Hard Disk Drive).
      },
      &quot;id&quot;: &quot;A String&quot;, # Immutable. The unique ID in a PersistentResource for referring to this resource pool. User can specify it if necessary. Otherwise, it&#x27;s generated automatically.
      &quot;machineSpec&quot;: { # Specification of a single machine. # Required. Immutable. The specification of a single machine.
        &quot;acceleratorCount&quot;: 42, # The number of accelerators to attach to the machine.
        &quot;acceleratorType&quot;: &quot;A String&quot;, # Immutable. The type of accelerator(s) that may be attached to the machine as per accelerator_count.
        &quot;machineType&quot;: &quot;A String&quot;, # Immutable. The type of the machine. See the [list of machine types supported for prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types) See the [list of machine types supported for custom training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types). For DeployedModel this field is optional, and the default value is `n1-standard-2`. For BatchPredictionJob or as part of WorkerPoolSpec this field is required.
        &quot;reservationAffinity&quot;: { # A ReservationAffinity can be used to configure a Vertex AI resource (e.g., a DeployedModel) to draw its Compute Engine resources from a Shared Reservation, or exclusively from on-demand capacity. # Optional. Immutable. Configuration controlling how this resource pool consumes reservation.
          &quot;key&quot;: &quot;A String&quot;, # Optional. Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, use `compute.googleapis.com/reservation-name` as the key and specify the name of your reservation as its value.
          &quot;reservationAffinityType&quot;: &quot;A String&quot;, # Required. Specifies the reservation affinity type.
          &quot;values&quot;: [ # Optional. Corresponds to the label values of a reservation resource. This must be the full resource name of the reservation.
            &quot;A String&quot;,
          ],
        },
        &quot;tpuTopology&quot;: &quot;A String&quot;, # Immutable. The topology of the TPUs. Corresponds to the TPU topologies available from GKE. (Example: tpu_topology: &quot;2x2x1&quot;).
      },
      &quot;replicaCount&quot;: &quot;A String&quot;, # Optional. The total number of machines to use for this resource pool.
      &quot;usedReplicaCount&quot;: &quot;A String&quot;, # Output only. The number of machines currently in use by training jobs for this resource pool. Will replace idle_replica_count.
    },
  ],
  &quot;resourceRuntime&quot;: { # Persistent Cluster runtime information as output # Output only. Runtime information of the Persistent Resource.
    &quot;accessUris&quot;: { # Output only. URIs for user to connect to the Cluster. Example: { &quot;RAY_HEAD_NODE_INTERNAL_IP&quot;: &quot;head-node-IP:10001&quot; &quot;RAY_DASHBOARD_URI&quot;: &quot;ray-dashboard-address:8888&quot; }
      &quot;a_key&quot;: &quot;A String&quot;,
    },
  },
  &quot;resourceRuntimeSpec&quot;: { # Configuration for the runtime on a PersistentResource instance, including but not limited to: * Service accounts used to run the workloads. * Whether to make it a dedicated Ray Cluster. # Optional. Persistent Resource runtime spec. For example, used for Ray cluster configuration.
    &quot;raySpec&quot;: { # Configuration information for the Ray cluster. For experimental launch, Ray cluster creation and Persistent cluster creation are 1:1 mapping: We will provision all the nodes within the Persistent cluster as Ray nodes. # Optional. Ray cluster configuration. Required when creating a dedicated RayCluster on the PersistentResource.
      &quot;headNodeResourcePoolId&quot;: &quot;A String&quot;, # Optional. This will be used to indicate which resource pool will serve as the Ray head node(the first node within that pool). Will use the machine from the first workerpool as the head node by default if this field isn&#x27;t set.
      &quot;imageUri&quot;: &quot;A String&quot;, # Optional. Default image for user to choose a preferred ML framework (for example, TensorFlow or Pytorch) by choosing from [Vertex prebuilt images](https://cloud.google.com/vertex-ai/docs/training/pre-built-containers). Either this or the resource_pool_images is required. Use this field if you need all the resource pools to have the same Ray image. Otherwise, use the {@code resource_pool_images} field.
      &quot;rayLogsSpec&quot;: { # Configuration for the Ray OSS Logs. # Optional. OSS Ray logging configurations.
        &quot;disabled&quot;: True or False, # Optional. Flag to disable the export of Ray OSS logs to Cloud Logging.
      },
      &quot;rayMetricSpec&quot;: { # Configuration for the Ray metrics. # Optional. Ray metrics configurations.
        &quot;disabled&quot;: True or False, # Optional. Flag to disable the Ray metrics collection.
      },
      &quot;resourcePoolImages&quot;: { # Optional. Required if image_uri isn&#x27;t set. A map of resource_pool_id to prebuild Ray image if user need to use different images for different head/worker pools. This map needs to cover all the resource pool ids. Example: { &quot;ray_head_node_pool&quot;: &quot;head image&quot; &quot;ray_worker_node_pool1&quot;: &quot;worker image&quot; &quot;ray_worker_node_pool2&quot;: &quot;another worker image&quot; }
        &quot;a_key&quot;: &quot;A String&quot;,
      },
    },
    &quot;serviceAccountSpec&quot;: { # Configuration for the use of custom service account to run the workloads. # Optional. Configure the use of workload identity on the PersistentResource
      &quot;enableCustomServiceAccount&quot;: True or False, # Required. If true, custom user-managed service account is enforced to run any workloads (for example, Vertex Jobs) on the resource. Otherwise, uses the [Vertex AI Custom Code Service Agent](https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents).
      &quot;serviceAccount&quot;: &quot;A String&quot;, # Optional. Required when all below conditions are met * `enable_custom_service_account` is true; * any runtime is specified via `ResourceRuntimeSpec` on creation time, for example, Ray The users must have `iam.serviceAccounts.actAs` permission on this service account and then the specified runtime containers will run as it. Do not set this field if you want to submit jobs using custom service account to this PersistentResource after creation, but only specify the `service_account` inside the job.
    },
  },
  &quot;startTime&quot;: &quot;A String&quot;, # Output only. Time when the PersistentResource for the first time entered the `RUNNING` state.
  &quot;state&quot;: &quot;A String&quot;, # Output only. The detailed state of a Study.
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Time when the PersistentResource was most recently updated.
}</pre>
</div>

<div class="method">
    <code class="details" id="list">list(parent, pageSize=None, pageToken=None, x__xgafv=None)</code>
  <pre>Lists PersistentResources in a Location.

Args:
  parent: string, Required. The resource name of the Location to list the PersistentResources from. Format: `projects/{project}/locations/{location}` (required)
  pageSize: integer, Optional. The standard list page size.
  pageToken: string, Optional. The standard list page token. Typically obtained via ListPersistentResourceResponse.next_page_token of the previous PersistentResourceService.ListPersistentResource call.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response message for PersistentResourceService.ListPersistentResources
  &quot;nextPageToken&quot;: &quot;A String&quot;, # A token to retrieve next page of results. Pass to ListPersistentResourcesRequest.page_token to obtain that page.
  &quot;persistentResources&quot;: [
    { # Represents long-lasting resources that are dedicated to users to runs custom workloads. A PersistentResource can have multiple node pools and each node pool can have its own machine spec.
      &quot;createTime&quot;: &quot;A String&quot;, # Output only. Time when the PersistentResource was created.
      &quot;displayName&quot;: &quot;A String&quot;, # Optional. The display name of the PersistentResource. The name can be up to 128 characters long and can consist of any UTF-8 characters.
      &quot;encryptionSpec&quot;: { # Represents a customer-managed encryption key spec that can be applied to a top-level resource. # Optional. Customer-managed encryption key spec for a PersistentResource. If set, this PersistentResource and all sub-resources of this PersistentResource will be secured by this key.
        &quot;kmsKeyName&quot;: &quot;A String&quot;, # Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
      },
      &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. Only populated when persistent resource&#x27;s state is `STOPPING` or `ERROR`.
        &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
        &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
          {
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
          },
        ],
        &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
      },
      &quot;labels&quot;: { # Optional. The labels with user-defined metadata to organize PersistentResource. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
      &quot;name&quot;: &quot;A String&quot;, # Immutable. Resource name of a PersistentResource.
      &quot;network&quot;: &quot;A String&quot;, # Optional. The full name of the Compute Engine [network](/compute/docs/networks-and-firewalls#networks) to peered with Vertex AI to host the persistent resources. For example, `projects/12345/global/networks/myVPC`. [Format](/compute/docs/reference/rest/v1/networks/insert) is of the form `projects/{project}/global/networks/{network}`. Where {project} is a project number, as in `12345`, and {network} is a network name. To specify this field, you must have already [configured VPC Network Peering for Vertex AI](https://cloud.google.com/vertex-ai/docs/general/vpc-peering). If this field is left unspecified, the resources aren&#x27;t peered with any network.
      &quot;reservedIpRanges&quot;: [ # Optional. A list of names for the reserved IP ranges under the VPC network that can be used for this persistent resource. If set, we will deploy the persistent resource within the provided IP ranges. Otherwise, the persistent resource is deployed to any IP ranges under the provided VPC network. Example: [&#x27;vertex-ai-ip-range&#x27;].
        &quot;A String&quot;,
      ],
      &quot;resourcePools&quot;: [ # Required. The spec of the pools of different resources.
        { # Represents the spec of a group of resources of the same type, for example machine type, disk, and accelerators, in a PersistentResource.
          &quot;autoscalingSpec&quot;: { # The min/max number of replicas allowed if enabling autoscaling # Optional. Optional spec to configure GKE or Ray-on-Vertex autoscaling
            &quot;maxReplicaCount&quot;: &quot;A String&quot;, # Optional. max replicas in the node pool, must be ≥ replica_count and &gt; min_replica_count or will throw error
            &quot;minReplicaCount&quot;: &quot;A String&quot;, # Optional. min replicas in the node pool, must be ≤ replica_count and &lt; max_replica_count or will throw error. For autoscaling enabled Ray-on-Vertex, we allow min_replica_count of a resource_pool to be 0 to match the OSS Ray behavior(https://docs.ray.io/en/latest/cluster/vms/user-guides/configuring-autoscaling.html#cluster-config-parameters). As for Persistent Resource, the min_replica_count must be &gt; 0, we added a corresponding validation inside CreatePersistentResourceRequestValidator.java.
          },
          &quot;diskSpec&quot;: { # Represents the spec of disk options. # Optional. Disk spec for the machine in this node pool.
            &quot;bootDiskSizeGb&quot;: 42, # Size in GB of the boot disk (default is 100GB).
            &quot;bootDiskType&quot;: &quot;A String&quot;, # Type of the boot disk (default is &quot;pd-ssd&quot;). Valid values: &quot;pd-ssd&quot; (Persistent Disk Solid State Drive) or &quot;pd-standard&quot; (Persistent Disk Hard Disk Drive).
          },
          &quot;id&quot;: &quot;A String&quot;, # Immutable. The unique ID in a PersistentResource for referring to this resource pool. User can specify it if necessary. Otherwise, it&#x27;s generated automatically.
          &quot;machineSpec&quot;: { # Specification of a single machine. # Required. Immutable. The specification of a single machine.
            &quot;acceleratorCount&quot;: 42, # The number of accelerators to attach to the machine.
            &quot;acceleratorType&quot;: &quot;A String&quot;, # Immutable. The type of accelerator(s) that may be attached to the machine as per accelerator_count.
            &quot;machineType&quot;: &quot;A String&quot;, # Immutable. The type of the machine. See the [list of machine types supported for prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types) See the [list of machine types supported for custom training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types). For DeployedModel this field is optional, and the default value is `n1-standard-2`. For BatchPredictionJob or as part of WorkerPoolSpec this field is required.
            &quot;reservationAffinity&quot;: { # A ReservationAffinity can be used to configure a Vertex AI resource (e.g., a DeployedModel) to draw its Compute Engine resources from a Shared Reservation, or exclusively from on-demand capacity. # Optional. Immutable. Configuration controlling how this resource pool consumes reservation.
              &quot;key&quot;: &quot;A String&quot;, # Optional. Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, use `compute.googleapis.com/reservation-name` as the key and specify the name of your reservation as its value.
              &quot;reservationAffinityType&quot;: &quot;A String&quot;, # Required. Specifies the reservation affinity type.
              &quot;values&quot;: [ # Optional. Corresponds to the label values of a reservation resource. This must be the full resource name of the reservation.
                &quot;A String&quot;,
              ],
            },
            &quot;tpuTopology&quot;: &quot;A String&quot;, # Immutable. The topology of the TPUs. Corresponds to the TPU topologies available from GKE. (Example: tpu_topology: &quot;2x2x1&quot;).
          },
          &quot;replicaCount&quot;: &quot;A String&quot;, # Optional. The total number of machines to use for this resource pool.
          &quot;usedReplicaCount&quot;: &quot;A String&quot;, # Output only. The number of machines currently in use by training jobs for this resource pool. Will replace idle_replica_count.
        },
      ],
      &quot;resourceRuntime&quot;: { # Persistent Cluster runtime information as output # Output only. Runtime information of the Persistent Resource.
        &quot;accessUris&quot;: { # Output only. URIs for user to connect to the Cluster. Example: { &quot;RAY_HEAD_NODE_INTERNAL_IP&quot;: &quot;head-node-IP:10001&quot; &quot;RAY_DASHBOARD_URI&quot;: &quot;ray-dashboard-address:8888&quot; }
          &quot;a_key&quot;: &quot;A String&quot;,
        },
      },
      &quot;resourceRuntimeSpec&quot;: { # Configuration for the runtime on a PersistentResource instance, including but not limited to: * Service accounts used to run the workloads. * Whether to make it a dedicated Ray Cluster. # Optional. Persistent Resource runtime spec. For example, used for Ray cluster configuration.
        &quot;raySpec&quot;: { # Configuration information for the Ray cluster. For experimental launch, Ray cluster creation and Persistent cluster creation are 1:1 mapping: We will provision all the nodes within the Persistent cluster as Ray nodes. # Optional. Ray cluster configuration. Required when creating a dedicated RayCluster on the PersistentResource.
          &quot;headNodeResourcePoolId&quot;: &quot;A String&quot;, # Optional. This will be used to indicate which resource pool will serve as the Ray head node(the first node within that pool). Will use the machine from the first workerpool as the head node by default if this field isn&#x27;t set.
          &quot;imageUri&quot;: &quot;A String&quot;, # Optional. Default image for user to choose a preferred ML framework (for example, TensorFlow or Pytorch) by choosing from [Vertex prebuilt images](https://cloud.google.com/vertex-ai/docs/training/pre-built-containers). Either this or the resource_pool_images is required. Use this field if you need all the resource pools to have the same Ray image. Otherwise, use the {@code resource_pool_images} field.
          &quot;rayLogsSpec&quot;: { # Configuration for the Ray OSS Logs. # Optional. OSS Ray logging configurations.
            &quot;disabled&quot;: True or False, # Optional. Flag to disable the export of Ray OSS logs to Cloud Logging.
          },
          &quot;rayMetricSpec&quot;: { # Configuration for the Ray metrics. # Optional. Ray metrics configurations.
            &quot;disabled&quot;: True or False, # Optional. Flag to disable the Ray metrics collection.
          },
          &quot;resourcePoolImages&quot;: { # Optional. Required if image_uri isn&#x27;t set. A map of resource_pool_id to prebuild Ray image if user need to use different images for different head/worker pools. This map needs to cover all the resource pool ids. Example: { &quot;ray_head_node_pool&quot;: &quot;head image&quot; &quot;ray_worker_node_pool1&quot;: &quot;worker image&quot; &quot;ray_worker_node_pool2&quot;: &quot;another worker image&quot; }
            &quot;a_key&quot;: &quot;A String&quot;,
          },
        },
        &quot;serviceAccountSpec&quot;: { # Configuration for the use of custom service account to run the workloads. # Optional. Configure the use of workload identity on the PersistentResource
          &quot;enableCustomServiceAccount&quot;: True or False, # Required. If true, custom user-managed service account is enforced to run any workloads (for example, Vertex Jobs) on the resource. Otherwise, uses the [Vertex AI Custom Code Service Agent](https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents).
          &quot;serviceAccount&quot;: &quot;A String&quot;, # Optional. Required when all below conditions are met * `enable_custom_service_account` is true; * any runtime is specified via `ResourceRuntimeSpec` on creation time, for example, Ray The users must have `iam.serviceAccounts.actAs` permission on this service account and then the specified runtime containers will run as it. Do not set this field if you want to submit jobs using custom service account to this PersistentResource after creation, but only specify the `service_account` inside the job.
        },
      },
      &quot;startTime&quot;: &quot;A String&quot;, # Output only. Time when the PersistentResource for the first time entered the `RUNNING` state.
      &quot;state&quot;: &quot;A String&quot;, # Output only. The detailed state of a Study.
      &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Time when the PersistentResource was most recently updated.
    },
  ],
}</pre>
</div>

<div class="method">
    <code class="details" id="list_next">list_next()</code>
  <pre>Retrieves the next page of results.

        Args:
          previous_request: The request for the previous page. (required)
          previous_response: The response from the request for the previous page. (required)

        Returns:
          A request object that you can call &#x27;execute()&#x27; on to request the next
          page. Returns None if there are no more items in the collection.
        </pre>
</div>

<div class="method">
    <code class="details" id="patch">patch(name, body=None, updateMask=None, x__xgafv=None)</code>
  <pre>Updates a PersistentResource.

Args:
  name: string, Immutable. Resource name of a PersistentResource. (required)
  body: object, The request body.
    The object takes the form of:

{ # Represents long-lasting resources that are dedicated to users to runs custom workloads. A PersistentResource can have multiple node pools and each node pool can have its own machine spec.
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Time when the PersistentResource was created.
  &quot;displayName&quot;: &quot;A String&quot;, # Optional. The display name of the PersistentResource. The name can be up to 128 characters long and can consist of any UTF-8 characters.
  &quot;encryptionSpec&quot;: { # Represents a customer-managed encryption key spec that can be applied to a top-level resource. # Optional. Customer-managed encryption key spec for a PersistentResource. If set, this PersistentResource and all sub-resources of this PersistentResource will be secured by this key.
    &quot;kmsKeyName&quot;: &quot;A String&quot;, # Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
  },
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. Only populated when persistent resource&#x27;s state is `STOPPING` or `ERROR`.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;labels&quot;: { # Optional. The labels with user-defined metadata to organize PersistentResource. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels.
    &quot;a_key&quot;: &quot;A String&quot;,
  },
  &quot;name&quot;: &quot;A String&quot;, # Immutable. Resource name of a PersistentResource.
  &quot;network&quot;: &quot;A String&quot;, # Optional. The full name of the Compute Engine [network](/compute/docs/networks-and-firewalls#networks) to peered with Vertex AI to host the persistent resources. For example, `projects/12345/global/networks/myVPC`. [Format](/compute/docs/reference/rest/v1/networks/insert) is of the form `projects/{project}/global/networks/{network}`. Where {project} is a project number, as in `12345`, and {network} is a network name. To specify this field, you must have already [configured VPC Network Peering for Vertex AI](https://cloud.google.com/vertex-ai/docs/general/vpc-peering). If this field is left unspecified, the resources aren&#x27;t peered with any network.
  &quot;reservedIpRanges&quot;: [ # Optional. A list of names for the reserved IP ranges under the VPC network that can be used for this persistent resource. If set, we will deploy the persistent resource within the provided IP ranges. Otherwise, the persistent resource is deployed to any IP ranges under the provided VPC network. Example: [&#x27;vertex-ai-ip-range&#x27;].
    &quot;A String&quot;,
  ],
  &quot;resourcePools&quot;: [ # Required. The spec of the pools of different resources.
    { # Represents the spec of a group of resources of the same type, for example machine type, disk, and accelerators, in a PersistentResource.
      &quot;autoscalingSpec&quot;: { # The min/max number of replicas allowed if enabling autoscaling # Optional. Optional spec to configure GKE or Ray-on-Vertex autoscaling
        &quot;maxReplicaCount&quot;: &quot;A String&quot;, # Optional. max replicas in the node pool, must be ≥ replica_count and &gt; min_replica_count or will throw error
        &quot;minReplicaCount&quot;: &quot;A String&quot;, # Optional. min replicas in the node pool, must be ≤ replica_count and &lt; max_replica_count or will throw error. For autoscaling enabled Ray-on-Vertex, we allow min_replica_count of a resource_pool to be 0 to match the OSS Ray behavior(https://docs.ray.io/en/latest/cluster/vms/user-guides/configuring-autoscaling.html#cluster-config-parameters). As for Persistent Resource, the min_replica_count must be &gt; 0, we added a corresponding validation inside CreatePersistentResourceRequestValidator.java.
      },
      &quot;diskSpec&quot;: { # Represents the spec of disk options. # Optional. Disk spec for the machine in this node pool.
        &quot;bootDiskSizeGb&quot;: 42, # Size in GB of the boot disk (default is 100GB).
        &quot;bootDiskType&quot;: &quot;A String&quot;, # Type of the boot disk (default is &quot;pd-ssd&quot;). Valid values: &quot;pd-ssd&quot; (Persistent Disk Solid State Drive) or &quot;pd-standard&quot; (Persistent Disk Hard Disk Drive).
      },
      &quot;id&quot;: &quot;A String&quot;, # Immutable. The unique ID in a PersistentResource for referring to this resource pool. User can specify it if necessary. Otherwise, it&#x27;s generated automatically.
      &quot;machineSpec&quot;: { # Specification of a single machine. # Required. Immutable. The specification of a single machine.
        &quot;acceleratorCount&quot;: 42, # The number of accelerators to attach to the machine.
        &quot;acceleratorType&quot;: &quot;A String&quot;, # Immutable. The type of accelerator(s) that may be attached to the machine as per accelerator_count.
        &quot;machineType&quot;: &quot;A String&quot;, # Immutable. The type of the machine. See the [list of machine types supported for prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types) See the [list of machine types supported for custom training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types). For DeployedModel this field is optional, and the default value is `n1-standard-2`. For BatchPredictionJob or as part of WorkerPoolSpec this field is required.
        &quot;reservationAffinity&quot;: { # A ReservationAffinity can be used to configure a Vertex AI resource (e.g., a DeployedModel) to draw its Compute Engine resources from a Shared Reservation, or exclusively from on-demand capacity. # Optional. Immutable. Configuration controlling how this resource pool consumes reservation.
          &quot;key&quot;: &quot;A String&quot;, # Optional. Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, use `compute.googleapis.com/reservation-name` as the key and specify the name of your reservation as its value.
          &quot;reservationAffinityType&quot;: &quot;A String&quot;, # Required. Specifies the reservation affinity type.
          &quot;values&quot;: [ # Optional. Corresponds to the label values of a reservation resource. This must be the full resource name of the reservation.
            &quot;A String&quot;,
          ],
        },
        &quot;tpuTopology&quot;: &quot;A String&quot;, # Immutable. The topology of the TPUs. Corresponds to the TPU topologies available from GKE. (Example: tpu_topology: &quot;2x2x1&quot;).
      },
      &quot;replicaCount&quot;: &quot;A String&quot;, # Optional. The total number of machines to use for this resource pool.
      &quot;usedReplicaCount&quot;: &quot;A String&quot;, # Output only. The number of machines currently in use by training jobs for this resource pool. Will replace idle_replica_count.
    },
  ],
  &quot;resourceRuntime&quot;: { # Persistent Cluster runtime information as output # Output only. Runtime information of the Persistent Resource.
    &quot;accessUris&quot;: { # Output only. URIs for user to connect to the Cluster. Example: { &quot;RAY_HEAD_NODE_INTERNAL_IP&quot;: &quot;head-node-IP:10001&quot; &quot;RAY_DASHBOARD_URI&quot;: &quot;ray-dashboard-address:8888&quot; }
      &quot;a_key&quot;: &quot;A String&quot;,
    },
  },
  &quot;resourceRuntimeSpec&quot;: { # Configuration for the runtime on a PersistentResource instance, including but not limited to: * Service accounts used to run the workloads. * Whether to make it a dedicated Ray Cluster. # Optional. Persistent Resource runtime spec. For example, used for Ray cluster configuration.
    &quot;raySpec&quot;: { # Configuration information for the Ray cluster. For experimental launch, Ray cluster creation and Persistent cluster creation are 1:1 mapping: We will provision all the nodes within the Persistent cluster as Ray nodes. # Optional. Ray cluster configuration. Required when creating a dedicated RayCluster on the PersistentResource.
      &quot;headNodeResourcePoolId&quot;: &quot;A String&quot;, # Optional. This will be used to indicate which resource pool will serve as the Ray head node(the first node within that pool). Will use the machine from the first workerpool as the head node by default if this field isn&#x27;t set.
      &quot;imageUri&quot;: &quot;A String&quot;, # Optional. Default image for user to choose a preferred ML framework (for example, TensorFlow or Pytorch) by choosing from [Vertex prebuilt images](https://cloud.google.com/vertex-ai/docs/training/pre-built-containers). Either this or the resource_pool_images is required. Use this field if you need all the resource pools to have the same Ray image. Otherwise, use the {@code resource_pool_images} field.
      &quot;rayLogsSpec&quot;: { # Configuration for the Ray OSS Logs. # Optional. OSS Ray logging configurations.
        &quot;disabled&quot;: True or False, # Optional. Flag to disable the export of Ray OSS logs to Cloud Logging.
      },
      &quot;rayMetricSpec&quot;: { # Configuration for the Ray metrics. # Optional. Ray metrics configurations.
        &quot;disabled&quot;: True or False, # Optional. Flag to disable the Ray metrics collection.
      },
      &quot;resourcePoolImages&quot;: { # Optional. Required if image_uri isn&#x27;t set. A map of resource_pool_id to prebuild Ray image if user need to use different images for different head/worker pools. This map needs to cover all the resource pool ids. Example: { &quot;ray_head_node_pool&quot;: &quot;head image&quot; &quot;ray_worker_node_pool1&quot;: &quot;worker image&quot; &quot;ray_worker_node_pool2&quot;: &quot;another worker image&quot; }
        &quot;a_key&quot;: &quot;A String&quot;,
      },
    },
    &quot;serviceAccountSpec&quot;: { # Configuration for the use of custom service account to run the workloads. # Optional. Configure the use of workload identity on the PersistentResource
      &quot;enableCustomServiceAccount&quot;: True or False, # Required. If true, custom user-managed service account is enforced to run any workloads (for example, Vertex Jobs) on the resource. Otherwise, uses the [Vertex AI Custom Code Service Agent](https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents).
      &quot;serviceAccount&quot;: &quot;A String&quot;, # Optional. Required when all below conditions are met * `enable_custom_service_account` is true; * any runtime is specified via `ResourceRuntimeSpec` on creation time, for example, Ray The users must have `iam.serviceAccounts.actAs` permission on this service account and then the specified runtime containers will run as it. Do not set this field if you want to submit jobs using custom service account to this PersistentResource after creation, but only specify the `service_account` inside the job.
    },
  },
  &quot;startTime&quot;: &quot;A String&quot;, # Output only. Time when the PersistentResource for the first time entered the `RUNNING` state.
  &quot;state&quot;: &quot;A String&quot;, # Output only. The detailed state of a Study.
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Time when the PersistentResource was most recently updated.
}

  updateMask: string, Required. Specify the fields to be overwritten in the PersistentResource by the update method.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # This resource represents a long-running operation that is the result of a network API call.
  &quot;done&quot;: True or False, # If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The error result of the operation in case of failure or cancellation.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;metadata&quot;: { # Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
  &quot;name&quot;: &quot;A String&quot;, # The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
  &quot;response&quot;: { # The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="reboot">reboot(name, body=None, x__xgafv=None)</code>
  <pre>Reboots a PersistentResource.

Args:
  name: string, Required. The name of the PersistentResource resource. Format: `projects/{project_id_or_number}/locations/{location_id}/persistentResources/{persistent_resource_id}` (required)
  body: object, The request body.
    The object takes the form of:

{ # Request message for PersistentResourceService.RebootPersistentResource.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # This resource represents a long-running operation that is the result of a network API call.
  &quot;done&quot;: True or False, # If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The error result of the operation in case of failure or cancellation.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;metadata&quot;: { # Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
  &quot;name&quot;: &quot;A String&quot;, # The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
  &quot;response&quot;: { # The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
}</pre>
</div>

</body></html>