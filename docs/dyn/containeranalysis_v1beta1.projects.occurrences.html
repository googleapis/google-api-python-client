<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="containeranalysis_v1beta1.html">Container Analysis API</a> . <a href="containeranalysis_v1beta1.projects.html">projects</a> . <a href="containeranalysis_v1beta1.projects.occurrences.html">occurrences</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#batchCreate">batchCreate(parent, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Creates new occurrences in batch.</p>
<p class="toc_element">
  <code><a href="#create">create(parent, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Creates a new occurrence.</p>
<p class="toc_element">
  <code><a href="#delete">delete(name, x__xgafv=None)</a></code></p>
<p class="firstline">Deletes the specified occurrence. For example, use this method to delete an</p>
<p class="toc_element">
  <code><a href="#get">get(name, x__xgafv=None)</a></code></p>
<p class="firstline">Gets the specified occurrence.</p>
<p class="toc_element">
  <code><a href="#getIamPolicy">getIamPolicy(resource, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Gets the access control policy for a note or an occurrence resource.</p>
<p class="toc_element">
  <code><a href="#getNotes">getNotes(name, x__xgafv=None)</a></code></p>
<p class="firstline">Gets the note attached to the specified occurrence. Consumer projects can</p>
<p class="toc_element">
  <code><a href="#getVulnerabilitySummary">getVulnerabilitySummary(parent, filter=None, x__xgafv=None)</a></code></p>
<p class="firstline">Gets a summary of the number and severity of occurrences.</p>
<p class="toc_element">
  <code><a href="#list">list(parent, filter=None, pageToken=None, pageSize=None, x__xgafv=None)</a></code></p>
<p class="firstline">Lists occurrences for the specified project.</p>
<p class="toc_element">
  <code><a href="#list_next">list_next(previous_request, previous_response)</a></code></p>
<p class="firstline">Retrieves the next page of results.</p>
<p class="toc_element">
  <code><a href="#patch">patch(name, body=None, updateMask=None, x__xgafv=None)</a></code></p>
<p class="firstline">Updates the specified occurrence.</p>
<p class="toc_element">
  <code><a href="#setIamPolicy">setIamPolicy(resource, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Sets the access control policy on the specified note or occurrence.</p>
<p class="toc_element">
  <code><a href="#testIamPermissions">testIamPermissions(resource, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Returns the permissions that a caller has on the specified note or</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="batchCreate">batchCreate(parent, body=None, x__xgafv=None)</code>
  <pre>Creates new occurrences in batch.

Args:
  parent: string, Required. The name of the project in the form of `projects/[PROJECT_ID]`, under which
the occurrences are to be created. (required)
  body: object, The request body.
    The object takes the form of:

{ # Request to create occurrences in batch.
    &quot;occurrences&quot;: [ # Required. The occurrences to create. Max allowed length is 1000.
      { # An instance of an analysis type that has been found on a resource.
        &quot;kind&quot;: &quot;A String&quot;, # Output only. This explicitly denotes which of the occurrence details are
            # specified. This field can be used as a filter in list requests.
        &quot;resource&quot;: { # An entity that can have metadata. For example, a Docker image. # Required. Immutable. The resource for which the occurrence applies.
          &quot;name&quot;: &quot;A String&quot;, # Deprecated, do not use. Use uri instead.
              #
              # The name of the resource. For example, the name of a Docker image -
              # &quot;Debian&quot;.
          &quot;contentHash&quot;: { # Container message for hash values. # Deprecated, do not use. Use uri instead.
              #
              # The hash of the resource content. For example, the Docker digest.
            &quot;type&quot;: &quot;A String&quot;, # Required. The type of hash that was performed.
            &quot;value&quot;: &quot;A String&quot;, # Required. The hash value.
          },
          &quot;uri&quot;: &quot;A String&quot;, # Required. The unique URI of the resource. For example,
              # `https://gcr.io/project/image@sha256:foo` for a Docker image.
        },
        &quot;attestation&quot;: { # Details of an attestation occurrence. # Describes an attestation of an artifact.
          &quot;attestation&quot;: { # Occurrence that represents a single &quot;attestation&quot;. The authenticity of an # Required. Attestation for the resource.
              # attestation can be verified using the attached signature. If the verifier
              # trusts the public key of the signer, then verifying the signature is
              # sufficient to establish trust. In this circumstance, the authority to which
              # this attestation is attached is primarily useful for look-up (how to find
              # this attestation if you already know the authority and artifact to be
              # verified) and intent (which authority was this attestation intended to sign
              # for).
            &quot;pgpSignedAttestation&quot;: { # An attestation wrapper with a PGP-compatible signature. This message only # A PGP signed attestation.
                # supports `ATTACHED` signatures, where the payload that is signed is included
                # alongside the signature itself in the same file.
              &quot;contentType&quot;: &quot;A String&quot;, # Type (for example schema) of the attestation payload that was signed.
                  # The verifier must ensure that the provided type is one that the verifier
                  # supports, and that the attestation payload is a valid instantiation of that
                  # type (for example by validating a JSON schema).
              &quot;signature&quot;: &quot;A String&quot;, # Required. The raw content of the signature, as output by GNU Privacy Guard
                  # (GPG) or equivalent. Since this message only supports attached signatures,
                  # the payload that was signed must be attached. While the signature format
                  # supported is dependent on the verification implementation, currently only
                  # ASCII-armored (`--armor` to gpg), non-clearsigned (`--sign` rather than
                  # `--clearsign` to gpg) are supported. Concretely, `gpg --sign --armor
                  # --output=signature.gpg payload.json` will create the signature content
                  # expected in this field in `signature.gpg` for the `payload.json`
                  # attestation payload.
              &quot;pgpKeyId&quot;: &quot;A String&quot;, # The cryptographic fingerprint of the key used to generate the signature,
                  # as output by, e.g. `gpg --list-keys`. This should be the version 4, full
                  # 160-bit fingerprint, expressed as a 40 character hexidecimal string. See
                  # https://tools.ietf.org/html/rfc4880#section-12.2 for details.
                  # Implementations may choose to acknowledge &quot;LONG&quot;, &quot;SHORT&quot;, or other
                  # abbreviated key IDs, but only the full fingerprint is guaranteed to work.
                  # In gpg, the full fingerprint can be retrieved from the `fpr` field
                  # returned when calling --list-keys with --with-colons.  For example:
                  # ```
                  # gpg --with-colons --with-fingerprint --force-v4-certs \
                  #     --list-keys attester@example.com
                  # tru::1:1513631572:0:3:1:5
                  # pub:...&lt;SNIP&gt;...
                  # fpr:::::::::24FF6481B76AC91E66A00AC657A93A81EF3AE6FB:
                  # ```
                  # Above, the fingerprint is `24FF6481B76AC91E66A00AC657A93A81EF3AE6FB`.
            },
            &quot;genericSignedAttestation&quot;: { # An attestation wrapper that uses the Grafeas `Signature` message.
                # This attestation must define the `serialized_payload` that the `signatures`
                # verify and any metadata necessary to interpret that plaintext.  The
                # signatures should always be over the `serialized_payload` bytestring.
              &quot;contentType&quot;: &quot;A String&quot;, # Type (for example schema) of the attestation payload that was signed.
                  # The verifier must ensure that the provided type is one that the verifier
                  # supports, and that the attestation payload is a valid instantiation of that
                  # type (for example by validating a JSON schema).
              &quot;signatures&quot;: [ # One or more signatures over `serialized_payload`.  Verifier implementations
                  # should consider this attestation message verified if at least one
                  # `signature` verifies `serialized_payload`.  See `Signature` in common.proto
                  # for more details on signature structure and verification.
                { # Verifiers (e.g. Kritis implementations) MUST verify signatures
                    # with respect to the trust anchors defined in policy (e.g. a Kritis policy).
                    # Typically this means that the verifier has been configured with a map from
                    # `public_key_id` to public key material (and any required parameters, e.g.
                    # signing algorithm).
                    #
                    # In particular, verification implementations MUST NOT treat the signature
                    # `public_key_id` as anything more than a key lookup hint. The `public_key_id`
                    # DOES NOT validate or authenticate a public key; it only provides a mechanism
                    # for quickly selecting a public key ALREADY CONFIGURED on the verifier through
                    # a trusted channel. Verification implementations MUST reject signatures in any
                    # of the following circumstances:
                    #   * The `public_key_id` is not recognized by the verifier.
                    #   * The public key that `public_key_id` refers to does not verify the
                    #     signature with respect to the payload.
                    #
                    # The `signature` contents SHOULD NOT be &quot;attached&quot; (where the payload is
                    # included with the serialized `signature` bytes). Verifiers MUST ignore any
                    # &quot;attached&quot; payload and only verify signatures with respect to explicitly
                    # provided payload (e.g. a `payload` field on the proto message that holds
                    # this Signature, or the canonical serialization of the proto message that
                    # holds this signature).
                  &quot;publicKeyId&quot;: &quot;A String&quot;, # The identifier for the public key that verifies this signature.
                      #   * The `public_key_id` is required.
                      #   * The `public_key_id` MUST be an RFC3986 conformant URI.
                      #   * When possible, the `public_key_id` SHOULD be an immutable reference,
                      #     such as a cryptographic digest.
                      #
                      # Examples of valid `public_key_id`s:
                      #
                      # OpenPGP V4 public key fingerprint:
                      #   * &quot;openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA&quot;
                      # See https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr for more
                      # details on this scheme.
                      #
                      # RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER
                      # serialization):
                      #   * &quot;ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU&quot;
                      #   * &quot;nih:///sha-256;703f68f42aba2c6de30f488a5ea122fef76324679c9bf89791ba95a1271589a5&quot;
                  &quot;signature&quot;: &quot;A String&quot;, # The content of the signature, an opaque bytestring.
                      # The payload that this signature verifies MUST be unambiguously provided
                      # with the Signature during verification. A wrapper message might provide
                      # the payload explicitly. Alternatively, a message might have a canonical
                      # serialization that can always be unambiguously computed to derive the
                      # payload.
                },
              ],
              &quot;serializedPayload&quot;: &quot;A String&quot;, # The serialized payload that is verified by one or more `signatures`.
                  # The encoding and semantic meaning of this payload must match what is set in
                  # `content_type`.
            },
          },
        },
        &quot;name&quot;: &quot;A String&quot;, # Output only. The name of the occurrence in the form of
            # `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
        &quot;vulnerability&quot;: { # Details of a vulnerability Occurrence. # Describes a security vulnerability.
          &quot;longDescription&quot;: &quot;A String&quot;, # Output only. A detailed description of this vulnerability.
          &quot;shortDescription&quot;: &quot;A String&quot;, # Output only. A one sentence description of this vulnerability.
          &quot;effectiveSeverity&quot;: &quot;A String&quot;, # The distro assigned severity for this vulnerability when it is
              # available, and note provider assigned severity when distro has not yet
              # assigned a severity for this vulnerability.
          &quot;severity&quot;: &quot;A String&quot;, # Output only. The note provider assigned Severity of the vulnerability.
          &quot;cvssScore&quot;: 3.14, # Output only. The CVSS score of this vulnerability. CVSS score is on a
              # scale of 0-10 where 0 indicates low severity and 10 indicates high
              # severity.
          &quot;relatedUrls&quot;: [ # Output only. URLs related to this vulnerability.
            { # Metadata for any related URL information.
              &quot;url&quot;: &quot;A String&quot;, # Specific URL associated with the resource.
              &quot;label&quot;: &quot;A String&quot;, # Label to describe usage of the URL.
            },
          ],
          &quot;type&quot;: &quot;A String&quot;, # The type of package; whether native or non native(ruby gems, node.js
              # packages etc)
          &quot;packageIssue&quot;: [ # Required. The set of affected locations and their fixes (if available)
              # within the associated resource.
            { # This message wraps a location affected by a vulnerability and its
                # associated fix (if one is available).
              &quot;severityName&quot;: &quot;A String&quot;, # Deprecated, use Details.effective_severity instead
                  # The severity (e.g., distro assigned severity) for this vulnerability.
              &quot;affectedLocation&quot;: { # The location of the vulnerability. # Required. The location of the vulnerability.
                &quot;package&quot;: &quot;A String&quot;, # Required. The package being described.
                &quot;version&quot;: { # Version contains structured information about the version of a package. # Required. The version of the package being described.
                  &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
                  &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                      # name.
                  &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                      # versions.
                  &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
                },
                &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in [cpe format](https://cpe.mitre.org/specification/)
                    # format. Examples include distro or storage location for vulnerable jar.
              },
              &quot;fixedLocation&quot;: { # The location of the vulnerability. # The location of the available fix for vulnerability.
                &quot;package&quot;: &quot;A String&quot;, # Required. The package being described.
                &quot;version&quot;: { # Version contains structured information about the version of a package. # Required. The version of the package being described.
                  &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
                  &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                      # name.
                  &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                      # versions.
                  &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
                },
                &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in [cpe format](https://cpe.mitre.org/specification/)
                    # format. Examples include distro or storage location for vulnerable jar.
              },
            },
          ],
        },
        &quot;installation&quot;: { # Details of a package occurrence. # Describes the installation of a package on the linked resource.
          &quot;installation&quot;: { # This represents how a particular software package may be installed on a # Required. Where the package was installed.
              # system.
            &quot;location&quot;: [ # Required. All of the places within the filesystem versions of this package
                # have been found.
              { # An occurrence of a particular package installation found within a system&#x27;s
                  # filesystem. E.g., glibc was found in `/var/lib/dpkg/status`.
                &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in [CPE format](https://cpe.mitre.org/specification/)
                    # denoting the package manager version distributing a package.
                &quot;version&quot;: { # Version contains structured information about the version of a package. # The version installed at this location.
                  &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
                  &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                      # name.
                  &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                      # versions.
                  &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
                },
                &quot;path&quot;: &quot;A String&quot;, # The path from which we gathered that this package/version is installed.
              },
            ],
            &quot;name&quot;: &quot;A String&quot;, # Output only. The name of the installed package.
          },
        },
        &quot;build&quot;: { # Details of a build occurrence. # Describes a verifiable build.
          &quot;provenanceBytes&quot;: &quot;A String&quot;, # Serialized JSON representation of the provenance, used in generating the
              # build signature in the corresponding build note. After verifying the
              # signature, `provenance_bytes` can be unmarshalled and compared to the
              # provenance to confirm that it is unchanged. A base64-encoded string
              # representation of the provenance bytes is used for the signature in order
              # to interoperate with openssl which expects this format for signature
              # verification.
              #
              # The serialized form is captured both to avoid ambiguity in how the
              # provenance is marshalled to json as well to prevent incompatibilities with
              # future changes.
          &quot;provenance&quot;: { # Provenance of a build. Contains all information needed to verify the full # Required. The actual provenance for the build.
              # details about the build from source to completion.
            &quot;endTime&quot;: &quot;A String&quot;, # Time at which execution of the build was finished.
            &quot;startTime&quot;: &quot;A String&quot;, # Time at which execution of the build was started.
            &quot;triggerId&quot;: &quot;A String&quot;, # Trigger identifier if the build was triggered automatically; empty if not.
            &quot;sourceProvenance&quot;: { # Source describes the location of the source used for the build. # Details of the Source input to the build.
              &quot;artifactStorageSourceUri&quot;: &quot;A String&quot;, # If provided, the input binary artifacts for the build came from this
                  # location.
              &quot;additionalContexts&quot;: [ # If provided, some of the source code used for the build may be found in
                  # these locations, in the case where the source repository had multiple
                  # remotes or submodules. This list will not include the context specified in
                  # the context field.
                { # A SourceContext is a reference to a tree of files. A SourceContext together
                    # with a path point to a unique revision of a single file or directory.
                  &quot;labels&quot;: { # Labels with user defined metadata.
                    &quot;a_key&quot;: &quot;A String&quot;,
                  },
                  &quot;git&quot;: { # A GitSourceContext denotes a particular revision in a third party Git # A SourceContext referring to any third party Git repo (e.g., GitHub).
                      # repository (e.g., GitHub).
                    &quot;url&quot;: &quot;A String&quot;, # Git repository URL.
                    &quot;revisionId&quot;: &quot;A String&quot;, # Git commit hash.
                  },
                  &quot;gerrit&quot;: { # A SourceContext referring to a Gerrit project. # A SourceContext referring to a Gerrit project.
                    &quot;hostUri&quot;: &quot;A String&quot;, # The URI of a running Gerrit instance.
                    &quot;revisionId&quot;: &quot;A String&quot;, # A revision (commit) ID.
                    &quot;gerritProject&quot;: &quot;A String&quot;, # The full project name within the host. Projects may be nested, so
                        # &quot;project/subproject&quot; is a valid project name. The &quot;repo name&quot; is the
                        # hostURI/project.
                    &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                      &quot;name&quot;: &quot;A String&quot;, # The alias name.
                      &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
                    },
                  },
                  &quot;cloudRepo&quot;: { # A CloudRepoSourceContext denotes a particular revision in a Google Cloud # A SourceContext referring to a revision in a Google Cloud Source Repo.
                      # Source Repo.
                    &quot;revisionId&quot;: &quot;A String&quot;, # A revision ID.
                    &quot;repoId&quot;: { # A unique identifier for a Cloud Repo. # The ID of the repo.
                      &quot;projectRepoId&quot;: { # Selects a repo using a Google Cloud Platform project ID (e.g., # A combination of a project ID and a repo name.
                          # winged-cargo-31) and a repo name within that project.
                        &quot;projectId&quot;: &quot;A String&quot;, # The ID of the project.
                        &quot;repoName&quot;: &quot;A String&quot;, # The name of the repo. Leave empty for the default repo.
                      },
                      &quot;uid&quot;: &quot;A String&quot;, # A server-assigned, globally unique identifier.
                    },
                    &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                      &quot;name&quot;: &quot;A String&quot;, # The alias name.
                      &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
                    },
                  },
                },
              ],
              &quot;fileHashes&quot;: { # Hash(es) of the build source, which can be used to verify that the original
                  # source integrity was maintained in the build.
                  #
                  # The keys to this map are file paths used as build source and the values
                  # contain the hash values for those files.
                  #
                  # If the build source came in a single package such as a gzipped tarfile
                  # (.tar.gz), the FileHash will be for the single path to that file.
                &quot;a_key&quot;: { # Container message for hashes of byte content of files, used in source
                    # messages to verify integrity of source input to the build.
                  &quot;fileHash&quot;: [ # Required. Collection of file hashes.
                    { # Container message for hash values.
                      &quot;type&quot;: &quot;A String&quot;, # Required. The type of hash that was performed.
                      &quot;value&quot;: &quot;A String&quot;, # Required. The hash value.
                    },
                  ],
                },
              },
              &quot;context&quot;: { # A SourceContext is a reference to a tree of files. A SourceContext together # If provided, the source code used for the build came from this location.
                  # with a path point to a unique revision of a single file or directory.
                &quot;labels&quot;: { # Labels with user defined metadata.
                  &quot;a_key&quot;: &quot;A String&quot;,
                },
                &quot;git&quot;: { # A GitSourceContext denotes a particular revision in a third party Git # A SourceContext referring to any third party Git repo (e.g., GitHub).
                    # repository (e.g., GitHub).
                  &quot;url&quot;: &quot;A String&quot;, # Git repository URL.
                  &quot;revisionId&quot;: &quot;A String&quot;, # Git commit hash.
                },
                &quot;gerrit&quot;: { # A SourceContext referring to a Gerrit project. # A SourceContext referring to a Gerrit project.
                  &quot;hostUri&quot;: &quot;A String&quot;, # The URI of a running Gerrit instance.
                  &quot;revisionId&quot;: &quot;A String&quot;, # A revision (commit) ID.
                  &quot;gerritProject&quot;: &quot;A String&quot;, # The full project name within the host. Projects may be nested, so
                      # &quot;project/subproject&quot; is a valid project name. The &quot;repo name&quot; is the
                      # hostURI/project.
                  &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                    &quot;name&quot;: &quot;A String&quot;, # The alias name.
                    &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
                  },
                },
                &quot;cloudRepo&quot;: { # A CloudRepoSourceContext denotes a particular revision in a Google Cloud # A SourceContext referring to a revision in a Google Cloud Source Repo.
                    # Source Repo.
                  &quot;revisionId&quot;: &quot;A String&quot;, # A revision ID.
                  &quot;repoId&quot;: { # A unique identifier for a Cloud Repo. # The ID of the repo.
                    &quot;projectRepoId&quot;: { # Selects a repo using a Google Cloud Platform project ID (e.g., # A combination of a project ID and a repo name.
                        # winged-cargo-31) and a repo name within that project.
                      &quot;projectId&quot;: &quot;A String&quot;, # The ID of the project.
                      &quot;repoName&quot;: &quot;A String&quot;, # The name of the repo. Leave empty for the default repo.
                    },
                    &quot;uid&quot;: &quot;A String&quot;, # A server-assigned, globally unique identifier.
                  },
                  &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                    &quot;name&quot;: &quot;A String&quot;, # The alias name.
                    &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
                  },
                },
              },
            },
            &quot;createTime&quot;: &quot;A String&quot;, # Time at which the build was created.
            &quot;projectId&quot;: &quot;A String&quot;, # ID of the project.
            &quot;logsUri&quot;: &quot;A String&quot;, # URI where any logs for this provenance were written.
            &quot;creator&quot;: &quot;A String&quot;, # E-mail address of the user who initiated this build. Note that this was the
                # user&#x27;s e-mail address at the time the build was initiated; this address may
                # not represent the same end-user for all time.
            &quot;builderVersion&quot;: &quot;A String&quot;, # Version string of the builder at the time this build was executed.
            &quot;commands&quot;: [ # Commands requested by the build.
              { # Command describes a step performed as part of the build pipeline.
                &quot;dir&quot;: &quot;A String&quot;, # Working directory (relative to project source root) used when running this
                    # command.
                &quot;waitFor&quot;: [ # The ID(s) of the command(s) that this command depends on.
                  &quot;A String&quot;,
                ],
                &quot;env&quot;: [ # Environment variables set before running this command.
                  &quot;A String&quot;,
                ],
                &quot;args&quot;: [ # Command-line arguments used when executing this command.
                  &quot;A String&quot;,
                ],
                &quot;name&quot;: &quot;A String&quot;, # Required. Name of the command, as presented on the command line, or if the
                    # command is packaged as a Docker container, as presented to `docker pull`.
                &quot;id&quot;: &quot;A String&quot;, # Optional unique identifier for this command, used in wait_for to reference
                    # this command as a dependency.
              },
            ],
            &quot;builtArtifacts&quot;: [ # Output of the build.
              { # Artifact describes a build product.
                &quot;checksum&quot;: &quot;A String&quot;, # Hash or checksum value of a binary, or Docker Registry 2.0 digest of a
                    # container.
                &quot;id&quot;: &quot;A String&quot;, # Artifact ID, if any; for container images, this will be a URL by digest
                    # like `gcr.io/projectID/imagename@sha256:123456`.
                &quot;names&quot;: [ # Related artifact names. This may be the path to a binary or jar file, or in
                    # the case of a container build, the name used to push the container image to
                    # Google Container Registry, as presented to `docker push`. Note that a
                    # single Artifact ID can have multiple names, for example if two tags are
                    # applied to one image.
                  &quot;A String&quot;,
                ],
              },
            ],
            &quot;id&quot;: &quot;A String&quot;, # Required. Unique identifier of the build.
            &quot;buildOptions&quot;: { # Special options applied to this build. This is a catch-all field where
                # build providers can enter any desired additional details.
              &quot;a_key&quot;: &quot;A String&quot;,
            },
          },
        },
        &quot;discovered&quot;: { # Details of a discovery occurrence. # Describes when a resource was discovered.
          &quot;discovered&quot;: { # Provides information about the analysis status of a discovered resource. # Required. Analysis status for the discovered resource.
            &quot;analysisStatusError&quot;: { # The `Status` type defines a logical error model that is suitable for # When an error is encountered this will contain a LocalizedMessage under
                # details to show to the user. The LocalizedMessage is output only and
                # populated by the API.
                # different programming environments, including REST APIs and RPC APIs. It is
                # used by [gRPC](https://github.com/grpc). Each `Status` message contains
                # three pieces of data: error code, error message, and error details.
                #
                # You can find out more about this error model and how to work with it in the
                # [API Design Guide](https://cloud.google.com/apis/design/errors).
              &quot;details&quot;: [ # A list of messages that carry the error details.  There is a common set of
                  # message types for APIs to use.
                {
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
                },
              ],
              &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
              &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any
                  # user-facing error message should be localized and sent in the
                  # google.rpc.Status.details field, or localized by the client.
            },
            &quot;analysisStatus&quot;: &quot;A String&quot;, # The status of discovery for the resource.
            &quot;continuousAnalysis&quot;: &quot;A String&quot;, # Whether the resource is continuously analyzed.
            &quot;lastAnalysisTime&quot;: &quot;A String&quot;, # The last time continuous analysis was done for this resource.
                # Deprecated, do not use.
          },
        },
        &quot;noteName&quot;: &quot;A String&quot;, # Required. Immutable. The analysis note associated with this occurrence, in
            # the form of `projects/[PROVIDER_ID]/notes/[NOTE_ID]`. This field can be
            # used as a filter in list requests.
        &quot;deployment&quot;: { # Details of a deployment occurrence. # Describes the deployment of an artifact on a runtime.
          &quot;deployment&quot;: { # The period during which some deployable was active in a runtime. # Required. Deployment history for the resource.
            &quot;userEmail&quot;: &quot;A String&quot;, # Identity of the user that triggered this deployment.
            &quot;config&quot;: &quot;A String&quot;, # Configuration used to create this deployment.
            &quot;undeployTime&quot;: &quot;A String&quot;, # End of the lifetime of this deployment.
            &quot;platform&quot;: &quot;A String&quot;, # Platform hosting this deployment.
            &quot;deployTime&quot;: &quot;A String&quot;, # Required. Beginning of the lifetime of this deployment.
            &quot;address&quot;: &quot;A String&quot;, # Address of the runtime element hosting this deployment.
            &quot;resourceUri&quot;: [ # Output only. Resource URI for the artifact being deployed taken from
                # the deployable field with the same name.
              &quot;A String&quot;,
            ],
          },
        },
        &quot;createTime&quot;: &quot;A String&quot;, # Output only. The time this occurrence was created.
        &quot;updateTime&quot;: &quot;A String&quot;, # Output only. The time this occurrence was last updated.
        &quot;remediation&quot;: &quot;A String&quot;, # A description of actions that can be taken to remedy the note.
        &quot;intoto&quot;: { # This corresponds to a signed in-toto link - it is made up of one or more # Describes a specific in-toto link.
            # signatures and the in-toto link itself. This is used for occurrences of a
            # Grafeas in-toto note.
          &quot;signed&quot;: { # This corresponds to an in-toto link.
            &quot;command&quot;: [ # This field contains the full command executed for the step. This can also
                # be empty if links are generated for operations that aren&#x27;t directly mapped
                # to a specific command. Each term in the command is an independent string
                # in the list. An example of a command in the in-toto metadata field is:
                # &quot;command&quot;: [&quot;git&quot;, &quot;clone&quot;, &quot;https://github.com/in-toto/demo-project.git&quot;]
              &quot;A String&quot;,
            ],
            &quot;byproducts&quot;: { # Defines an object for the byproducts field in in-toto links. The suggested # ByProducts are data generated as part of a software supply chain step, but
                # are not the actual result of the step.
                # fields are &quot;stderr&quot;, &quot;stdout&quot;, and &quot;return-value&quot;.
              &quot;customValues&quot;: {
                &quot;a_key&quot;: &quot;A String&quot;,
              },
            },
            &quot;environment&quot;: { # Defines an object for the environment field in in-toto links. The suggested # This is a field that can be used to capture information about the
                # environment. It is suggested for this field to contain information that
                # details environment variables, filesystem information, and the present
                # working directory. The recommended structure of this field is:
                # &quot;environment&quot;: {
                #   &quot;custom_values&quot;: {
                #     &quot;variables&quot;: &quot;&lt;ENV&gt;&quot;,
                #     &quot;filesystem&quot;: &quot;&lt;FS&gt;&quot;,
                #     &quot;workdir&quot;: &quot;&lt;CWD&gt;&quot;,
                #     &quot;&lt;ANY OTHER RELEVANT FIELDS&gt;&quot;: &quot;...&quot;
                #   }
                # }
                # fields are &quot;variables&quot;, &quot;filesystem&quot;, and &quot;workdir&quot;.
              &quot;customValues&quot;: {
                &quot;a_key&quot;: &quot;A String&quot;,
              },
            },
            &quot;materials&quot;: [ # Materials are the supply chain artifacts that go into the step and are used
                # for the operation performed. The key of the map is the path of the artifact
                # and the structure contains the recorded hash information. An example is:
                # &quot;materials&quot;: [
                #   {
                #     &quot;resource_uri&quot;: &quot;foo/bar&quot;,
                #     &quot;hashes&quot;: {
                #       &quot;sha256&quot;: &quot;ebebf...&quot;,
                #       &lt;OTHER HASH ALGORITHMS&gt;: &lt;HASH VALUE&gt;
                #     }
                #   }
                # ]
              {
                &quot;hashes&quot;: { # Defines a hash object for use in Materials and Products.
                  &quot;sha256&quot;: &quot;A String&quot;,
                },
                &quot;resourceUri&quot;: &quot;A String&quot;,
              },
            ],
            &quot;products&quot;: [ # Products are the supply chain artifacts generated as a result of the step.
                # The structure is identical to that of materials.
              {
                &quot;hashes&quot;: { # Defines a hash object for use in Materials and Products.
                  &quot;sha256&quot;: &quot;A String&quot;,
                },
                &quot;resourceUri&quot;: &quot;A String&quot;,
              },
            ],
          },
          &quot;signatures&quot;: [
            { # A signature object consists of the KeyID used and the signature itself.
              &quot;sig&quot;: &quot;A String&quot;,
              &quot;keyid&quot;: &quot;A String&quot;,
            },
          ],
        },
        &quot;derivedImage&quot;: { # Details of an image occurrence. # Describes how this resource derives from the basis in the associated
            # note.
          &quot;derivedImage&quot;: { # Derived describes the derived image portion (Occurrence) of the DockerImage # Required. Immutable. The child image derived from the base image.
              # relationship. This image would be produced from a Dockerfile with FROM
              # &lt;DockerImage.Basis in attached Note&gt;.
            &quot;fingerprint&quot;: { # A set of properties that uniquely identify a given Docker image. # Required. The fingerprint of the derived image.
              &quot;v2Blob&quot;: [ # Required. The ordered list of v2 blobs that represent a given image.
                &quot;A String&quot;,
              ],
              &quot;v1Name&quot;: &quot;A String&quot;, # Required. The layer ID of the final layer in the Docker image&#x27;s v1
                  # representation.
              &quot;v2Name&quot;: &quot;A String&quot;, # Output only. The name of the image&#x27;s v2 blobs computed via:
                  #   [bottom] := v2_blobbottom := sha256(v2_blob[N] + &quot; &quot; + v2_name[N+1])
                  # Only the name of the final blob is kept.
            },
            &quot;layerInfo&quot;: [ # This contains layer-specific metadata, if populated it has length
                # &quot;distance&quot; and is ordered with [distance] being the layer immediately
                # following the base image and [1] being the final layer.
              { # Layer holds metadata specific to a layer of a Docker image.
                &quot;directive&quot;: &quot;A String&quot;, # Required. The recovered Dockerfile directive used to construct this layer.
                &quot;arguments&quot;: &quot;A String&quot;, # The recovered arguments to the Dockerfile directive.
              },
            ],
            &quot;distance&quot;: 42, # Output only. The number of layers by which this image differs from the
                # associated image basis.
            &quot;baseResourceUrl&quot;: &quot;A String&quot;, # Output only. This contains the base image URL for the derived image
                # occurrence.
          },
        },
      },
    ],
  }

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response for creating occurrences in batch.
    &quot;occurrences&quot;: [ # The occurrences that were created.
      { # An instance of an analysis type that has been found on a resource.
        &quot;kind&quot;: &quot;A String&quot;, # Output only. This explicitly denotes which of the occurrence details are
            # specified. This field can be used as a filter in list requests.
        &quot;resource&quot;: { # An entity that can have metadata. For example, a Docker image. # Required. Immutable. The resource for which the occurrence applies.
          &quot;name&quot;: &quot;A String&quot;, # Deprecated, do not use. Use uri instead.
              #
              # The name of the resource. For example, the name of a Docker image -
              # &quot;Debian&quot;.
          &quot;contentHash&quot;: { # Container message for hash values. # Deprecated, do not use. Use uri instead.
              #
              # The hash of the resource content. For example, the Docker digest.
            &quot;type&quot;: &quot;A String&quot;, # Required. The type of hash that was performed.
            &quot;value&quot;: &quot;A String&quot;, # Required. The hash value.
          },
          &quot;uri&quot;: &quot;A String&quot;, # Required. The unique URI of the resource. For example,
              # `https://gcr.io/project/image@sha256:foo` for a Docker image.
        },
        &quot;attestation&quot;: { # Details of an attestation occurrence. # Describes an attestation of an artifact.
          &quot;attestation&quot;: { # Occurrence that represents a single &quot;attestation&quot;. The authenticity of an # Required. Attestation for the resource.
              # attestation can be verified using the attached signature. If the verifier
              # trusts the public key of the signer, then verifying the signature is
              # sufficient to establish trust. In this circumstance, the authority to which
              # this attestation is attached is primarily useful for look-up (how to find
              # this attestation if you already know the authority and artifact to be
              # verified) and intent (which authority was this attestation intended to sign
              # for).
            &quot;pgpSignedAttestation&quot;: { # An attestation wrapper with a PGP-compatible signature. This message only # A PGP signed attestation.
                # supports `ATTACHED` signatures, where the payload that is signed is included
                # alongside the signature itself in the same file.
              &quot;contentType&quot;: &quot;A String&quot;, # Type (for example schema) of the attestation payload that was signed.
                  # The verifier must ensure that the provided type is one that the verifier
                  # supports, and that the attestation payload is a valid instantiation of that
                  # type (for example by validating a JSON schema).
              &quot;signature&quot;: &quot;A String&quot;, # Required. The raw content of the signature, as output by GNU Privacy Guard
                  # (GPG) or equivalent. Since this message only supports attached signatures,
                  # the payload that was signed must be attached. While the signature format
                  # supported is dependent on the verification implementation, currently only
                  # ASCII-armored (`--armor` to gpg), non-clearsigned (`--sign` rather than
                  # `--clearsign` to gpg) are supported. Concretely, `gpg --sign --armor
                  # --output=signature.gpg payload.json` will create the signature content
                  # expected in this field in `signature.gpg` for the `payload.json`
                  # attestation payload.
              &quot;pgpKeyId&quot;: &quot;A String&quot;, # The cryptographic fingerprint of the key used to generate the signature,
                  # as output by, e.g. `gpg --list-keys`. This should be the version 4, full
                  # 160-bit fingerprint, expressed as a 40 character hexidecimal string. See
                  # https://tools.ietf.org/html/rfc4880#section-12.2 for details.
                  # Implementations may choose to acknowledge &quot;LONG&quot;, &quot;SHORT&quot;, or other
                  # abbreviated key IDs, but only the full fingerprint is guaranteed to work.
                  # In gpg, the full fingerprint can be retrieved from the `fpr` field
                  # returned when calling --list-keys with --with-colons.  For example:
                  # ```
                  # gpg --with-colons --with-fingerprint --force-v4-certs \
                  #     --list-keys attester@example.com
                  # tru::1:1513631572:0:3:1:5
                  # pub:...&lt;SNIP&gt;...
                  # fpr:::::::::24FF6481B76AC91E66A00AC657A93A81EF3AE6FB:
                  # ```
                  # Above, the fingerprint is `24FF6481B76AC91E66A00AC657A93A81EF3AE6FB`.
            },
            &quot;genericSignedAttestation&quot;: { # An attestation wrapper that uses the Grafeas `Signature` message.
                # This attestation must define the `serialized_payload` that the `signatures`
                # verify and any metadata necessary to interpret that plaintext.  The
                # signatures should always be over the `serialized_payload` bytestring.
              &quot;contentType&quot;: &quot;A String&quot;, # Type (for example schema) of the attestation payload that was signed.
                  # The verifier must ensure that the provided type is one that the verifier
                  # supports, and that the attestation payload is a valid instantiation of that
                  # type (for example by validating a JSON schema).
              &quot;signatures&quot;: [ # One or more signatures over `serialized_payload`.  Verifier implementations
                  # should consider this attestation message verified if at least one
                  # `signature` verifies `serialized_payload`.  See `Signature` in common.proto
                  # for more details on signature structure and verification.
                { # Verifiers (e.g. Kritis implementations) MUST verify signatures
                    # with respect to the trust anchors defined in policy (e.g. a Kritis policy).
                    # Typically this means that the verifier has been configured with a map from
                    # `public_key_id` to public key material (and any required parameters, e.g.
                    # signing algorithm).
                    #
                    # In particular, verification implementations MUST NOT treat the signature
                    # `public_key_id` as anything more than a key lookup hint. The `public_key_id`
                    # DOES NOT validate or authenticate a public key; it only provides a mechanism
                    # for quickly selecting a public key ALREADY CONFIGURED on the verifier through
                    # a trusted channel. Verification implementations MUST reject signatures in any
                    # of the following circumstances:
                    #   * The `public_key_id` is not recognized by the verifier.
                    #   * The public key that `public_key_id` refers to does not verify the
                    #     signature with respect to the payload.
                    #
                    # The `signature` contents SHOULD NOT be &quot;attached&quot; (where the payload is
                    # included with the serialized `signature` bytes). Verifiers MUST ignore any
                    # &quot;attached&quot; payload and only verify signatures with respect to explicitly
                    # provided payload (e.g. a `payload` field on the proto message that holds
                    # this Signature, or the canonical serialization of the proto message that
                    # holds this signature).
                  &quot;publicKeyId&quot;: &quot;A String&quot;, # The identifier for the public key that verifies this signature.
                      #   * The `public_key_id` is required.
                      #   * The `public_key_id` MUST be an RFC3986 conformant URI.
                      #   * When possible, the `public_key_id` SHOULD be an immutable reference,
                      #     such as a cryptographic digest.
                      #
                      # Examples of valid `public_key_id`s:
                      #
                      # OpenPGP V4 public key fingerprint:
                      #   * &quot;openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA&quot;
                      # See https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr for more
                      # details on this scheme.
                      #
                      # RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER
                      # serialization):
                      #   * &quot;ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU&quot;
                      #   * &quot;nih:///sha-256;703f68f42aba2c6de30f488a5ea122fef76324679c9bf89791ba95a1271589a5&quot;
                  &quot;signature&quot;: &quot;A String&quot;, # The content of the signature, an opaque bytestring.
                      # The payload that this signature verifies MUST be unambiguously provided
                      # with the Signature during verification. A wrapper message might provide
                      # the payload explicitly. Alternatively, a message might have a canonical
                      # serialization that can always be unambiguously computed to derive the
                      # payload.
                },
              ],
              &quot;serializedPayload&quot;: &quot;A String&quot;, # The serialized payload that is verified by one or more `signatures`.
                  # The encoding and semantic meaning of this payload must match what is set in
                  # `content_type`.
            },
          },
        },
        &quot;name&quot;: &quot;A String&quot;, # Output only. The name of the occurrence in the form of
            # `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
        &quot;vulnerability&quot;: { # Details of a vulnerability Occurrence. # Describes a security vulnerability.
          &quot;longDescription&quot;: &quot;A String&quot;, # Output only. A detailed description of this vulnerability.
          &quot;shortDescription&quot;: &quot;A String&quot;, # Output only. A one sentence description of this vulnerability.
          &quot;effectiveSeverity&quot;: &quot;A String&quot;, # The distro assigned severity for this vulnerability when it is
              # available, and note provider assigned severity when distro has not yet
              # assigned a severity for this vulnerability.
          &quot;severity&quot;: &quot;A String&quot;, # Output only. The note provider assigned Severity of the vulnerability.
          &quot;cvssScore&quot;: 3.14, # Output only. The CVSS score of this vulnerability. CVSS score is on a
              # scale of 0-10 where 0 indicates low severity and 10 indicates high
              # severity.
          &quot;relatedUrls&quot;: [ # Output only. URLs related to this vulnerability.
            { # Metadata for any related URL information.
              &quot;url&quot;: &quot;A String&quot;, # Specific URL associated with the resource.
              &quot;label&quot;: &quot;A String&quot;, # Label to describe usage of the URL.
            },
          ],
          &quot;type&quot;: &quot;A String&quot;, # The type of package; whether native or non native(ruby gems, node.js
              # packages etc)
          &quot;packageIssue&quot;: [ # Required. The set of affected locations and their fixes (if available)
              # within the associated resource.
            { # This message wraps a location affected by a vulnerability and its
                # associated fix (if one is available).
              &quot;severityName&quot;: &quot;A String&quot;, # Deprecated, use Details.effective_severity instead
                  # The severity (e.g., distro assigned severity) for this vulnerability.
              &quot;affectedLocation&quot;: { # The location of the vulnerability. # Required. The location of the vulnerability.
                &quot;package&quot;: &quot;A String&quot;, # Required. The package being described.
                &quot;version&quot;: { # Version contains structured information about the version of a package. # Required. The version of the package being described.
                  &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
                  &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                      # name.
                  &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                      # versions.
                  &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
                },
                &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in [cpe format](https://cpe.mitre.org/specification/)
                    # format. Examples include distro or storage location for vulnerable jar.
              },
              &quot;fixedLocation&quot;: { # The location of the vulnerability. # The location of the available fix for vulnerability.
                &quot;package&quot;: &quot;A String&quot;, # Required. The package being described.
                &quot;version&quot;: { # Version contains structured information about the version of a package. # Required. The version of the package being described.
                  &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
                  &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                      # name.
                  &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                      # versions.
                  &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
                },
                &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in [cpe format](https://cpe.mitre.org/specification/)
                    # format. Examples include distro or storage location for vulnerable jar.
              },
            },
          ],
        },
        &quot;installation&quot;: { # Details of a package occurrence. # Describes the installation of a package on the linked resource.
          &quot;installation&quot;: { # This represents how a particular software package may be installed on a # Required. Where the package was installed.
              # system.
            &quot;location&quot;: [ # Required. All of the places within the filesystem versions of this package
                # have been found.
              { # An occurrence of a particular package installation found within a system&#x27;s
                  # filesystem. E.g., glibc was found in `/var/lib/dpkg/status`.
                &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in [CPE format](https://cpe.mitre.org/specification/)
                    # denoting the package manager version distributing a package.
                &quot;version&quot;: { # Version contains structured information about the version of a package. # The version installed at this location.
                  &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
                  &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                      # name.
                  &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                      # versions.
                  &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
                },
                &quot;path&quot;: &quot;A String&quot;, # The path from which we gathered that this package/version is installed.
              },
            ],
            &quot;name&quot;: &quot;A String&quot;, # Output only. The name of the installed package.
          },
        },
        &quot;build&quot;: { # Details of a build occurrence. # Describes a verifiable build.
          &quot;provenanceBytes&quot;: &quot;A String&quot;, # Serialized JSON representation of the provenance, used in generating the
              # build signature in the corresponding build note. After verifying the
              # signature, `provenance_bytes` can be unmarshalled and compared to the
              # provenance to confirm that it is unchanged. A base64-encoded string
              # representation of the provenance bytes is used for the signature in order
              # to interoperate with openssl which expects this format for signature
              # verification.
              #
              # The serialized form is captured both to avoid ambiguity in how the
              # provenance is marshalled to json as well to prevent incompatibilities with
              # future changes.
          &quot;provenance&quot;: { # Provenance of a build. Contains all information needed to verify the full # Required. The actual provenance for the build.
              # details about the build from source to completion.
            &quot;endTime&quot;: &quot;A String&quot;, # Time at which execution of the build was finished.
            &quot;startTime&quot;: &quot;A String&quot;, # Time at which execution of the build was started.
            &quot;triggerId&quot;: &quot;A String&quot;, # Trigger identifier if the build was triggered automatically; empty if not.
            &quot;sourceProvenance&quot;: { # Source describes the location of the source used for the build. # Details of the Source input to the build.
              &quot;artifactStorageSourceUri&quot;: &quot;A String&quot;, # If provided, the input binary artifacts for the build came from this
                  # location.
              &quot;additionalContexts&quot;: [ # If provided, some of the source code used for the build may be found in
                  # these locations, in the case where the source repository had multiple
                  # remotes or submodules. This list will not include the context specified in
                  # the context field.
                { # A SourceContext is a reference to a tree of files. A SourceContext together
                    # with a path point to a unique revision of a single file or directory.
                  &quot;labels&quot;: { # Labels with user defined metadata.
                    &quot;a_key&quot;: &quot;A String&quot;,
                  },
                  &quot;git&quot;: { # A GitSourceContext denotes a particular revision in a third party Git # A SourceContext referring to any third party Git repo (e.g., GitHub).
                      # repository (e.g., GitHub).
                    &quot;url&quot;: &quot;A String&quot;, # Git repository URL.
                    &quot;revisionId&quot;: &quot;A String&quot;, # Git commit hash.
                  },
                  &quot;gerrit&quot;: { # A SourceContext referring to a Gerrit project. # A SourceContext referring to a Gerrit project.
                    &quot;hostUri&quot;: &quot;A String&quot;, # The URI of a running Gerrit instance.
                    &quot;revisionId&quot;: &quot;A String&quot;, # A revision (commit) ID.
                    &quot;gerritProject&quot;: &quot;A String&quot;, # The full project name within the host. Projects may be nested, so
                        # &quot;project/subproject&quot; is a valid project name. The &quot;repo name&quot; is the
                        # hostURI/project.
                    &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                      &quot;name&quot;: &quot;A String&quot;, # The alias name.
                      &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
                    },
                  },
                  &quot;cloudRepo&quot;: { # A CloudRepoSourceContext denotes a particular revision in a Google Cloud # A SourceContext referring to a revision in a Google Cloud Source Repo.
                      # Source Repo.
                    &quot;revisionId&quot;: &quot;A String&quot;, # A revision ID.
                    &quot;repoId&quot;: { # A unique identifier for a Cloud Repo. # The ID of the repo.
                      &quot;projectRepoId&quot;: { # Selects a repo using a Google Cloud Platform project ID (e.g., # A combination of a project ID and a repo name.
                          # winged-cargo-31) and a repo name within that project.
                        &quot;projectId&quot;: &quot;A String&quot;, # The ID of the project.
                        &quot;repoName&quot;: &quot;A String&quot;, # The name of the repo. Leave empty for the default repo.
                      },
                      &quot;uid&quot;: &quot;A String&quot;, # A server-assigned, globally unique identifier.
                    },
                    &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                      &quot;name&quot;: &quot;A String&quot;, # The alias name.
                      &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
                    },
                  },
                },
              ],
              &quot;fileHashes&quot;: { # Hash(es) of the build source, which can be used to verify that the original
                  # source integrity was maintained in the build.
                  #
                  # The keys to this map are file paths used as build source and the values
                  # contain the hash values for those files.
                  #
                  # If the build source came in a single package such as a gzipped tarfile
                  # (.tar.gz), the FileHash will be for the single path to that file.
                &quot;a_key&quot;: { # Container message for hashes of byte content of files, used in source
                    # messages to verify integrity of source input to the build.
                  &quot;fileHash&quot;: [ # Required. Collection of file hashes.
                    { # Container message for hash values.
                      &quot;type&quot;: &quot;A String&quot;, # Required. The type of hash that was performed.
                      &quot;value&quot;: &quot;A String&quot;, # Required. The hash value.
                    },
                  ],
                },
              },
              &quot;context&quot;: { # A SourceContext is a reference to a tree of files. A SourceContext together # If provided, the source code used for the build came from this location.
                  # with a path point to a unique revision of a single file or directory.
                &quot;labels&quot;: { # Labels with user defined metadata.
                  &quot;a_key&quot;: &quot;A String&quot;,
                },
                &quot;git&quot;: { # A GitSourceContext denotes a particular revision in a third party Git # A SourceContext referring to any third party Git repo (e.g., GitHub).
                    # repository (e.g., GitHub).
                  &quot;url&quot;: &quot;A String&quot;, # Git repository URL.
                  &quot;revisionId&quot;: &quot;A String&quot;, # Git commit hash.
                },
                &quot;gerrit&quot;: { # A SourceContext referring to a Gerrit project. # A SourceContext referring to a Gerrit project.
                  &quot;hostUri&quot;: &quot;A String&quot;, # The URI of a running Gerrit instance.
                  &quot;revisionId&quot;: &quot;A String&quot;, # A revision (commit) ID.
                  &quot;gerritProject&quot;: &quot;A String&quot;, # The full project name within the host. Projects may be nested, so
                      # &quot;project/subproject&quot; is a valid project name. The &quot;repo name&quot; is the
                      # hostURI/project.
                  &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                    &quot;name&quot;: &quot;A String&quot;, # The alias name.
                    &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
                  },
                },
                &quot;cloudRepo&quot;: { # A CloudRepoSourceContext denotes a particular revision in a Google Cloud # A SourceContext referring to a revision in a Google Cloud Source Repo.
                    # Source Repo.
                  &quot;revisionId&quot;: &quot;A String&quot;, # A revision ID.
                  &quot;repoId&quot;: { # A unique identifier for a Cloud Repo. # The ID of the repo.
                    &quot;projectRepoId&quot;: { # Selects a repo using a Google Cloud Platform project ID (e.g., # A combination of a project ID and a repo name.
                        # winged-cargo-31) and a repo name within that project.
                      &quot;projectId&quot;: &quot;A String&quot;, # The ID of the project.
                      &quot;repoName&quot;: &quot;A String&quot;, # The name of the repo. Leave empty for the default repo.
                    },
                    &quot;uid&quot;: &quot;A String&quot;, # A server-assigned, globally unique identifier.
                  },
                  &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                    &quot;name&quot;: &quot;A String&quot;, # The alias name.
                    &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
                  },
                },
              },
            },
            &quot;createTime&quot;: &quot;A String&quot;, # Time at which the build was created.
            &quot;projectId&quot;: &quot;A String&quot;, # ID of the project.
            &quot;logsUri&quot;: &quot;A String&quot;, # URI where any logs for this provenance were written.
            &quot;creator&quot;: &quot;A String&quot;, # E-mail address of the user who initiated this build. Note that this was the
                # user&#x27;s e-mail address at the time the build was initiated; this address may
                # not represent the same end-user for all time.
            &quot;builderVersion&quot;: &quot;A String&quot;, # Version string of the builder at the time this build was executed.
            &quot;commands&quot;: [ # Commands requested by the build.
              { # Command describes a step performed as part of the build pipeline.
                &quot;dir&quot;: &quot;A String&quot;, # Working directory (relative to project source root) used when running this
                    # command.
                &quot;waitFor&quot;: [ # The ID(s) of the command(s) that this command depends on.
                  &quot;A String&quot;,
                ],
                &quot;env&quot;: [ # Environment variables set before running this command.
                  &quot;A String&quot;,
                ],
                &quot;args&quot;: [ # Command-line arguments used when executing this command.
                  &quot;A String&quot;,
                ],
                &quot;name&quot;: &quot;A String&quot;, # Required. Name of the command, as presented on the command line, or if the
                    # command is packaged as a Docker container, as presented to `docker pull`.
                &quot;id&quot;: &quot;A String&quot;, # Optional unique identifier for this command, used in wait_for to reference
                    # this command as a dependency.
              },
            ],
            &quot;builtArtifacts&quot;: [ # Output of the build.
              { # Artifact describes a build product.
                &quot;checksum&quot;: &quot;A String&quot;, # Hash or checksum value of a binary, or Docker Registry 2.0 digest of a
                    # container.
                &quot;id&quot;: &quot;A String&quot;, # Artifact ID, if any; for container images, this will be a URL by digest
                    # like `gcr.io/projectID/imagename@sha256:123456`.
                &quot;names&quot;: [ # Related artifact names. This may be the path to a binary or jar file, or in
                    # the case of a container build, the name used to push the container image to
                    # Google Container Registry, as presented to `docker push`. Note that a
                    # single Artifact ID can have multiple names, for example if two tags are
                    # applied to one image.
                  &quot;A String&quot;,
                ],
              },
            ],
            &quot;id&quot;: &quot;A String&quot;, # Required. Unique identifier of the build.
            &quot;buildOptions&quot;: { # Special options applied to this build. This is a catch-all field where
                # build providers can enter any desired additional details.
              &quot;a_key&quot;: &quot;A String&quot;,
            },
          },
        },
        &quot;discovered&quot;: { # Details of a discovery occurrence. # Describes when a resource was discovered.
          &quot;discovered&quot;: { # Provides information about the analysis status of a discovered resource. # Required. Analysis status for the discovered resource.
            &quot;analysisStatusError&quot;: { # The `Status` type defines a logical error model that is suitable for # When an error is encountered this will contain a LocalizedMessage under
                # details to show to the user. The LocalizedMessage is output only and
                # populated by the API.
                # different programming environments, including REST APIs and RPC APIs. It is
                # used by [gRPC](https://github.com/grpc). Each `Status` message contains
                # three pieces of data: error code, error message, and error details.
                #
                # You can find out more about this error model and how to work with it in the
                # [API Design Guide](https://cloud.google.com/apis/design/errors).
              &quot;details&quot;: [ # A list of messages that carry the error details.  There is a common set of
                  # message types for APIs to use.
                {
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
                },
              ],
              &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
              &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any
                  # user-facing error message should be localized and sent in the
                  # google.rpc.Status.details field, or localized by the client.
            },
            &quot;analysisStatus&quot;: &quot;A String&quot;, # The status of discovery for the resource.
            &quot;continuousAnalysis&quot;: &quot;A String&quot;, # Whether the resource is continuously analyzed.
            &quot;lastAnalysisTime&quot;: &quot;A String&quot;, # The last time continuous analysis was done for this resource.
                # Deprecated, do not use.
          },
        },
        &quot;noteName&quot;: &quot;A String&quot;, # Required. Immutable. The analysis note associated with this occurrence, in
            # the form of `projects/[PROVIDER_ID]/notes/[NOTE_ID]`. This field can be
            # used as a filter in list requests.
        &quot;deployment&quot;: { # Details of a deployment occurrence. # Describes the deployment of an artifact on a runtime.
          &quot;deployment&quot;: { # The period during which some deployable was active in a runtime. # Required. Deployment history for the resource.
            &quot;userEmail&quot;: &quot;A String&quot;, # Identity of the user that triggered this deployment.
            &quot;config&quot;: &quot;A String&quot;, # Configuration used to create this deployment.
            &quot;undeployTime&quot;: &quot;A String&quot;, # End of the lifetime of this deployment.
            &quot;platform&quot;: &quot;A String&quot;, # Platform hosting this deployment.
            &quot;deployTime&quot;: &quot;A String&quot;, # Required. Beginning of the lifetime of this deployment.
            &quot;address&quot;: &quot;A String&quot;, # Address of the runtime element hosting this deployment.
            &quot;resourceUri&quot;: [ # Output only. Resource URI for the artifact being deployed taken from
                # the deployable field with the same name.
              &quot;A String&quot;,
            ],
          },
        },
        &quot;createTime&quot;: &quot;A String&quot;, # Output only. The time this occurrence was created.
        &quot;updateTime&quot;: &quot;A String&quot;, # Output only. The time this occurrence was last updated.
        &quot;remediation&quot;: &quot;A String&quot;, # A description of actions that can be taken to remedy the note.
        &quot;intoto&quot;: { # This corresponds to a signed in-toto link - it is made up of one or more # Describes a specific in-toto link.
            # signatures and the in-toto link itself. This is used for occurrences of a
            # Grafeas in-toto note.
          &quot;signed&quot;: { # This corresponds to an in-toto link.
            &quot;command&quot;: [ # This field contains the full command executed for the step. This can also
                # be empty if links are generated for operations that aren&#x27;t directly mapped
                # to a specific command. Each term in the command is an independent string
                # in the list. An example of a command in the in-toto metadata field is:
                # &quot;command&quot;: [&quot;git&quot;, &quot;clone&quot;, &quot;https://github.com/in-toto/demo-project.git&quot;]
              &quot;A String&quot;,
            ],
            &quot;byproducts&quot;: { # Defines an object for the byproducts field in in-toto links. The suggested # ByProducts are data generated as part of a software supply chain step, but
                # are not the actual result of the step.
                # fields are &quot;stderr&quot;, &quot;stdout&quot;, and &quot;return-value&quot;.
              &quot;customValues&quot;: {
                &quot;a_key&quot;: &quot;A String&quot;,
              },
            },
            &quot;environment&quot;: { # Defines an object for the environment field in in-toto links. The suggested # This is a field that can be used to capture information about the
                # environment. It is suggested for this field to contain information that
                # details environment variables, filesystem information, and the present
                # working directory. The recommended structure of this field is:
                # &quot;environment&quot;: {
                #   &quot;custom_values&quot;: {
                #     &quot;variables&quot;: &quot;&lt;ENV&gt;&quot;,
                #     &quot;filesystem&quot;: &quot;&lt;FS&gt;&quot;,
                #     &quot;workdir&quot;: &quot;&lt;CWD&gt;&quot;,
                #     &quot;&lt;ANY OTHER RELEVANT FIELDS&gt;&quot;: &quot;...&quot;
                #   }
                # }
                # fields are &quot;variables&quot;, &quot;filesystem&quot;, and &quot;workdir&quot;.
              &quot;customValues&quot;: {
                &quot;a_key&quot;: &quot;A String&quot;,
              },
            },
            &quot;materials&quot;: [ # Materials are the supply chain artifacts that go into the step and are used
                # for the operation performed. The key of the map is the path of the artifact
                # and the structure contains the recorded hash information. An example is:
                # &quot;materials&quot;: [
                #   {
                #     &quot;resource_uri&quot;: &quot;foo/bar&quot;,
                #     &quot;hashes&quot;: {
                #       &quot;sha256&quot;: &quot;ebebf...&quot;,
                #       &lt;OTHER HASH ALGORITHMS&gt;: &lt;HASH VALUE&gt;
                #     }
                #   }
                # ]
              {
                &quot;hashes&quot;: { # Defines a hash object for use in Materials and Products.
                  &quot;sha256&quot;: &quot;A String&quot;,
                },
                &quot;resourceUri&quot;: &quot;A String&quot;,
              },
            ],
            &quot;products&quot;: [ # Products are the supply chain artifacts generated as a result of the step.
                # The structure is identical to that of materials.
              {
                &quot;hashes&quot;: { # Defines a hash object for use in Materials and Products.
                  &quot;sha256&quot;: &quot;A String&quot;,
                },
                &quot;resourceUri&quot;: &quot;A String&quot;,
              },
            ],
          },
          &quot;signatures&quot;: [
            { # A signature object consists of the KeyID used and the signature itself.
              &quot;sig&quot;: &quot;A String&quot;,
              &quot;keyid&quot;: &quot;A String&quot;,
            },
          ],
        },
        &quot;derivedImage&quot;: { # Details of an image occurrence. # Describes how this resource derives from the basis in the associated
            # note.
          &quot;derivedImage&quot;: { # Derived describes the derived image portion (Occurrence) of the DockerImage # Required. Immutable. The child image derived from the base image.
              # relationship. This image would be produced from a Dockerfile with FROM
              # &lt;DockerImage.Basis in attached Note&gt;.
            &quot;fingerprint&quot;: { # A set of properties that uniquely identify a given Docker image. # Required. The fingerprint of the derived image.
              &quot;v2Blob&quot;: [ # Required. The ordered list of v2 blobs that represent a given image.
                &quot;A String&quot;,
              ],
              &quot;v1Name&quot;: &quot;A String&quot;, # Required. The layer ID of the final layer in the Docker image&#x27;s v1
                  # representation.
              &quot;v2Name&quot;: &quot;A String&quot;, # Output only. The name of the image&#x27;s v2 blobs computed via:
                  #   [bottom] := v2_blobbottom := sha256(v2_blob[N] + &quot; &quot; + v2_name[N+1])
                  # Only the name of the final blob is kept.
            },
            &quot;layerInfo&quot;: [ # This contains layer-specific metadata, if populated it has length
                # &quot;distance&quot; and is ordered with [distance] being the layer immediately
                # following the base image and [1] being the final layer.
              { # Layer holds metadata specific to a layer of a Docker image.
                &quot;directive&quot;: &quot;A String&quot;, # Required. The recovered Dockerfile directive used to construct this layer.
                &quot;arguments&quot;: &quot;A String&quot;, # The recovered arguments to the Dockerfile directive.
              },
            ],
            &quot;distance&quot;: 42, # Output only. The number of layers by which this image differs from the
                # associated image basis.
            &quot;baseResourceUrl&quot;: &quot;A String&quot;, # Output only. This contains the base image URL for the derived image
                # occurrence.
          },
        },
      },
    ],
  }</pre>
</div>

<div class="method">
    <code class="details" id="create">create(parent, body=None, x__xgafv=None)</code>
  <pre>Creates a new occurrence.

Args:
  parent: string, Required. The name of the project in the form of `projects/[PROJECT_ID]`, under which
the occurrence is to be created. (required)
  body: object, The request body.
    The object takes the form of:

{ # An instance of an analysis type that has been found on a resource.
  &quot;kind&quot;: &quot;A String&quot;, # Output only. This explicitly denotes which of the occurrence details are
      # specified. This field can be used as a filter in list requests.
  &quot;resource&quot;: { # An entity that can have metadata. For example, a Docker image. # Required. Immutable. The resource for which the occurrence applies.
    &quot;name&quot;: &quot;A String&quot;, # Deprecated, do not use. Use uri instead.
        #
        # The name of the resource. For example, the name of a Docker image -
        # &quot;Debian&quot;.
    &quot;contentHash&quot;: { # Container message for hash values. # Deprecated, do not use. Use uri instead.
        #
        # The hash of the resource content. For example, the Docker digest.
      &quot;type&quot;: &quot;A String&quot;, # Required. The type of hash that was performed.
      &quot;value&quot;: &quot;A String&quot;, # Required. The hash value.
    },
    &quot;uri&quot;: &quot;A String&quot;, # Required. The unique URI of the resource. For example,
        # `https://gcr.io/project/image@sha256:foo` for a Docker image.
  },
  &quot;attestation&quot;: { # Details of an attestation occurrence. # Describes an attestation of an artifact.
    &quot;attestation&quot;: { # Occurrence that represents a single &quot;attestation&quot;. The authenticity of an # Required. Attestation for the resource.
        # attestation can be verified using the attached signature. If the verifier
        # trusts the public key of the signer, then verifying the signature is
        # sufficient to establish trust. In this circumstance, the authority to which
        # this attestation is attached is primarily useful for look-up (how to find
        # this attestation if you already know the authority and artifact to be
        # verified) and intent (which authority was this attestation intended to sign
        # for).
      &quot;pgpSignedAttestation&quot;: { # An attestation wrapper with a PGP-compatible signature. This message only # A PGP signed attestation.
          # supports `ATTACHED` signatures, where the payload that is signed is included
          # alongside the signature itself in the same file.
        &quot;contentType&quot;: &quot;A String&quot;, # Type (for example schema) of the attestation payload that was signed.
            # The verifier must ensure that the provided type is one that the verifier
            # supports, and that the attestation payload is a valid instantiation of that
            # type (for example by validating a JSON schema).
        &quot;signature&quot;: &quot;A String&quot;, # Required. The raw content of the signature, as output by GNU Privacy Guard
            # (GPG) or equivalent. Since this message only supports attached signatures,
            # the payload that was signed must be attached. While the signature format
            # supported is dependent on the verification implementation, currently only
            # ASCII-armored (`--armor` to gpg), non-clearsigned (`--sign` rather than
            # `--clearsign` to gpg) are supported. Concretely, `gpg --sign --armor
            # --output=signature.gpg payload.json` will create the signature content
            # expected in this field in `signature.gpg` for the `payload.json`
            # attestation payload.
        &quot;pgpKeyId&quot;: &quot;A String&quot;, # The cryptographic fingerprint of the key used to generate the signature,
            # as output by, e.g. `gpg --list-keys`. This should be the version 4, full
            # 160-bit fingerprint, expressed as a 40 character hexidecimal string. See
            # https://tools.ietf.org/html/rfc4880#section-12.2 for details.
            # Implementations may choose to acknowledge &quot;LONG&quot;, &quot;SHORT&quot;, or other
            # abbreviated key IDs, but only the full fingerprint is guaranteed to work.
            # In gpg, the full fingerprint can be retrieved from the `fpr` field
            # returned when calling --list-keys with --with-colons.  For example:
            # ```
            # gpg --with-colons --with-fingerprint --force-v4-certs \
            #     --list-keys attester@example.com
            # tru::1:1513631572:0:3:1:5
            # pub:...&lt;SNIP&gt;...
            # fpr:::::::::24FF6481B76AC91E66A00AC657A93A81EF3AE6FB:
            # ```
            # Above, the fingerprint is `24FF6481B76AC91E66A00AC657A93A81EF3AE6FB`.
      },
      &quot;genericSignedAttestation&quot;: { # An attestation wrapper that uses the Grafeas `Signature` message.
          # This attestation must define the `serialized_payload` that the `signatures`
          # verify and any metadata necessary to interpret that plaintext.  The
          # signatures should always be over the `serialized_payload` bytestring.
        &quot;contentType&quot;: &quot;A String&quot;, # Type (for example schema) of the attestation payload that was signed.
            # The verifier must ensure that the provided type is one that the verifier
            # supports, and that the attestation payload is a valid instantiation of that
            # type (for example by validating a JSON schema).
        &quot;signatures&quot;: [ # One or more signatures over `serialized_payload`.  Verifier implementations
            # should consider this attestation message verified if at least one
            # `signature` verifies `serialized_payload`.  See `Signature` in common.proto
            # for more details on signature structure and verification.
          { # Verifiers (e.g. Kritis implementations) MUST verify signatures
              # with respect to the trust anchors defined in policy (e.g. a Kritis policy).
              # Typically this means that the verifier has been configured with a map from
              # `public_key_id` to public key material (and any required parameters, e.g.
              # signing algorithm).
              #
              # In particular, verification implementations MUST NOT treat the signature
              # `public_key_id` as anything more than a key lookup hint. The `public_key_id`
              # DOES NOT validate or authenticate a public key; it only provides a mechanism
              # for quickly selecting a public key ALREADY CONFIGURED on the verifier through
              # a trusted channel. Verification implementations MUST reject signatures in any
              # of the following circumstances:
              #   * The `public_key_id` is not recognized by the verifier.
              #   * The public key that `public_key_id` refers to does not verify the
              #     signature with respect to the payload.
              #
              # The `signature` contents SHOULD NOT be &quot;attached&quot; (where the payload is
              # included with the serialized `signature` bytes). Verifiers MUST ignore any
              # &quot;attached&quot; payload and only verify signatures with respect to explicitly
              # provided payload (e.g. a `payload` field on the proto message that holds
              # this Signature, or the canonical serialization of the proto message that
              # holds this signature).
            &quot;publicKeyId&quot;: &quot;A String&quot;, # The identifier for the public key that verifies this signature.
                #   * The `public_key_id` is required.
                #   * The `public_key_id` MUST be an RFC3986 conformant URI.
                #   * When possible, the `public_key_id` SHOULD be an immutable reference,
                #     such as a cryptographic digest.
                #
                # Examples of valid `public_key_id`s:
                #
                # OpenPGP V4 public key fingerprint:
                #   * &quot;openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA&quot;
                # See https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr for more
                # details on this scheme.
                #
                # RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER
                # serialization):
                #   * &quot;ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU&quot;
                #   * &quot;nih:///sha-256;703f68f42aba2c6de30f488a5ea122fef76324679c9bf89791ba95a1271589a5&quot;
            &quot;signature&quot;: &quot;A String&quot;, # The content of the signature, an opaque bytestring.
                # The payload that this signature verifies MUST be unambiguously provided
                # with the Signature during verification. A wrapper message might provide
                # the payload explicitly. Alternatively, a message might have a canonical
                # serialization that can always be unambiguously computed to derive the
                # payload.
          },
        ],
        &quot;serializedPayload&quot;: &quot;A String&quot;, # The serialized payload that is verified by one or more `signatures`.
            # The encoding and semantic meaning of this payload must match what is set in
            # `content_type`.
      },
    },
  },
  &quot;name&quot;: &quot;A String&quot;, # Output only. The name of the occurrence in the form of
      # `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
  &quot;vulnerability&quot;: { # Details of a vulnerability Occurrence. # Describes a security vulnerability.
    &quot;longDescription&quot;: &quot;A String&quot;, # Output only. A detailed description of this vulnerability.
    &quot;shortDescription&quot;: &quot;A String&quot;, # Output only. A one sentence description of this vulnerability.
    &quot;effectiveSeverity&quot;: &quot;A String&quot;, # The distro assigned severity for this vulnerability when it is
        # available, and note provider assigned severity when distro has not yet
        # assigned a severity for this vulnerability.
    &quot;severity&quot;: &quot;A String&quot;, # Output only. The note provider assigned Severity of the vulnerability.
    &quot;cvssScore&quot;: 3.14, # Output only. The CVSS score of this vulnerability. CVSS score is on a
        # scale of 0-10 where 0 indicates low severity and 10 indicates high
        # severity.
    &quot;relatedUrls&quot;: [ # Output only. URLs related to this vulnerability.
      { # Metadata for any related URL information.
        &quot;url&quot;: &quot;A String&quot;, # Specific URL associated with the resource.
        &quot;label&quot;: &quot;A String&quot;, # Label to describe usage of the URL.
      },
    ],
    &quot;type&quot;: &quot;A String&quot;, # The type of package; whether native or non native(ruby gems, node.js
        # packages etc)
    &quot;packageIssue&quot;: [ # Required. The set of affected locations and their fixes (if available)
        # within the associated resource.
      { # This message wraps a location affected by a vulnerability and its
          # associated fix (if one is available).
        &quot;severityName&quot;: &quot;A String&quot;, # Deprecated, use Details.effective_severity instead
            # The severity (e.g., distro assigned severity) for this vulnerability.
        &quot;affectedLocation&quot;: { # The location of the vulnerability. # Required. The location of the vulnerability.
          &quot;package&quot;: &quot;A String&quot;, # Required. The package being described.
          &quot;version&quot;: { # Version contains structured information about the version of a package. # Required. The version of the package being described.
            &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
            &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                # name.
            &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                # versions.
            &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
          },
          &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in [cpe format](https://cpe.mitre.org/specification/)
              # format. Examples include distro or storage location for vulnerable jar.
        },
        &quot;fixedLocation&quot;: { # The location of the vulnerability. # The location of the available fix for vulnerability.
          &quot;package&quot;: &quot;A String&quot;, # Required. The package being described.
          &quot;version&quot;: { # Version contains structured information about the version of a package. # Required. The version of the package being described.
            &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
            &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                # name.
            &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                # versions.
            &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
          },
          &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in [cpe format](https://cpe.mitre.org/specification/)
              # format. Examples include distro or storage location for vulnerable jar.
        },
      },
    ],
  },
  &quot;installation&quot;: { # Details of a package occurrence. # Describes the installation of a package on the linked resource.
    &quot;installation&quot;: { # This represents how a particular software package may be installed on a # Required. Where the package was installed.
        # system.
      &quot;location&quot;: [ # Required. All of the places within the filesystem versions of this package
          # have been found.
        { # An occurrence of a particular package installation found within a system&#x27;s
            # filesystem. E.g., glibc was found in `/var/lib/dpkg/status`.
          &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in [CPE format](https://cpe.mitre.org/specification/)
              # denoting the package manager version distributing a package.
          &quot;version&quot;: { # Version contains structured information about the version of a package. # The version installed at this location.
            &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
            &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                # name.
            &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                # versions.
            &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
          },
          &quot;path&quot;: &quot;A String&quot;, # The path from which we gathered that this package/version is installed.
        },
      ],
      &quot;name&quot;: &quot;A String&quot;, # Output only. The name of the installed package.
    },
  },
  &quot;build&quot;: { # Details of a build occurrence. # Describes a verifiable build.
    &quot;provenanceBytes&quot;: &quot;A String&quot;, # Serialized JSON representation of the provenance, used in generating the
        # build signature in the corresponding build note. After verifying the
        # signature, `provenance_bytes` can be unmarshalled and compared to the
        # provenance to confirm that it is unchanged. A base64-encoded string
        # representation of the provenance bytes is used for the signature in order
        # to interoperate with openssl which expects this format for signature
        # verification.
        #
        # The serialized form is captured both to avoid ambiguity in how the
        # provenance is marshalled to json as well to prevent incompatibilities with
        # future changes.
    &quot;provenance&quot;: { # Provenance of a build. Contains all information needed to verify the full # Required. The actual provenance for the build.
        # details about the build from source to completion.
      &quot;endTime&quot;: &quot;A String&quot;, # Time at which execution of the build was finished.
      &quot;startTime&quot;: &quot;A String&quot;, # Time at which execution of the build was started.
      &quot;triggerId&quot;: &quot;A String&quot;, # Trigger identifier if the build was triggered automatically; empty if not.
      &quot;sourceProvenance&quot;: { # Source describes the location of the source used for the build. # Details of the Source input to the build.
        &quot;artifactStorageSourceUri&quot;: &quot;A String&quot;, # If provided, the input binary artifacts for the build came from this
            # location.
        &quot;additionalContexts&quot;: [ # If provided, some of the source code used for the build may be found in
            # these locations, in the case where the source repository had multiple
            # remotes or submodules. This list will not include the context specified in
            # the context field.
          { # A SourceContext is a reference to a tree of files. A SourceContext together
              # with a path point to a unique revision of a single file or directory.
            &quot;labels&quot;: { # Labels with user defined metadata.
              &quot;a_key&quot;: &quot;A String&quot;,
            },
            &quot;git&quot;: { # A GitSourceContext denotes a particular revision in a third party Git # A SourceContext referring to any third party Git repo (e.g., GitHub).
                # repository (e.g., GitHub).
              &quot;url&quot;: &quot;A String&quot;, # Git repository URL.
              &quot;revisionId&quot;: &quot;A String&quot;, # Git commit hash.
            },
            &quot;gerrit&quot;: { # A SourceContext referring to a Gerrit project. # A SourceContext referring to a Gerrit project.
              &quot;hostUri&quot;: &quot;A String&quot;, # The URI of a running Gerrit instance.
              &quot;revisionId&quot;: &quot;A String&quot;, # A revision (commit) ID.
              &quot;gerritProject&quot;: &quot;A String&quot;, # The full project name within the host. Projects may be nested, so
                  # &quot;project/subproject&quot; is a valid project name. The &quot;repo name&quot; is the
                  # hostURI/project.
              &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                &quot;name&quot;: &quot;A String&quot;, # The alias name.
                &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
              },
            },
            &quot;cloudRepo&quot;: { # A CloudRepoSourceContext denotes a particular revision in a Google Cloud # A SourceContext referring to a revision in a Google Cloud Source Repo.
                # Source Repo.
              &quot;revisionId&quot;: &quot;A String&quot;, # A revision ID.
              &quot;repoId&quot;: { # A unique identifier for a Cloud Repo. # The ID of the repo.
                &quot;projectRepoId&quot;: { # Selects a repo using a Google Cloud Platform project ID (e.g., # A combination of a project ID and a repo name.
                    # winged-cargo-31) and a repo name within that project.
                  &quot;projectId&quot;: &quot;A String&quot;, # The ID of the project.
                  &quot;repoName&quot;: &quot;A String&quot;, # The name of the repo. Leave empty for the default repo.
                },
                &quot;uid&quot;: &quot;A String&quot;, # A server-assigned, globally unique identifier.
              },
              &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                &quot;name&quot;: &quot;A String&quot;, # The alias name.
                &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
              },
            },
          },
        ],
        &quot;fileHashes&quot;: { # Hash(es) of the build source, which can be used to verify that the original
            # source integrity was maintained in the build.
            #
            # The keys to this map are file paths used as build source and the values
            # contain the hash values for those files.
            #
            # If the build source came in a single package such as a gzipped tarfile
            # (.tar.gz), the FileHash will be for the single path to that file.
          &quot;a_key&quot;: { # Container message for hashes of byte content of files, used in source
              # messages to verify integrity of source input to the build.
            &quot;fileHash&quot;: [ # Required. Collection of file hashes.
              { # Container message for hash values.
                &quot;type&quot;: &quot;A String&quot;, # Required. The type of hash that was performed.
                &quot;value&quot;: &quot;A String&quot;, # Required. The hash value.
              },
            ],
          },
        },
        &quot;context&quot;: { # A SourceContext is a reference to a tree of files. A SourceContext together # If provided, the source code used for the build came from this location.
            # with a path point to a unique revision of a single file or directory.
          &quot;labels&quot;: { # Labels with user defined metadata.
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;git&quot;: { # A GitSourceContext denotes a particular revision in a third party Git # A SourceContext referring to any third party Git repo (e.g., GitHub).
              # repository (e.g., GitHub).
            &quot;url&quot;: &quot;A String&quot;, # Git repository URL.
            &quot;revisionId&quot;: &quot;A String&quot;, # Git commit hash.
          },
          &quot;gerrit&quot;: { # A SourceContext referring to a Gerrit project. # A SourceContext referring to a Gerrit project.
            &quot;hostUri&quot;: &quot;A String&quot;, # The URI of a running Gerrit instance.
            &quot;revisionId&quot;: &quot;A String&quot;, # A revision (commit) ID.
            &quot;gerritProject&quot;: &quot;A String&quot;, # The full project name within the host. Projects may be nested, so
                # &quot;project/subproject&quot; is a valid project name. The &quot;repo name&quot; is the
                # hostURI/project.
            &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
              &quot;name&quot;: &quot;A String&quot;, # The alias name.
              &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
            },
          },
          &quot;cloudRepo&quot;: { # A CloudRepoSourceContext denotes a particular revision in a Google Cloud # A SourceContext referring to a revision in a Google Cloud Source Repo.
              # Source Repo.
            &quot;revisionId&quot;: &quot;A String&quot;, # A revision ID.
            &quot;repoId&quot;: { # A unique identifier for a Cloud Repo. # The ID of the repo.
              &quot;projectRepoId&quot;: { # Selects a repo using a Google Cloud Platform project ID (e.g., # A combination of a project ID and a repo name.
                  # winged-cargo-31) and a repo name within that project.
                &quot;projectId&quot;: &quot;A String&quot;, # The ID of the project.
                &quot;repoName&quot;: &quot;A String&quot;, # The name of the repo. Leave empty for the default repo.
              },
              &quot;uid&quot;: &quot;A String&quot;, # A server-assigned, globally unique identifier.
            },
            &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
              &quot;name&quot;: &quot;A String&quot;, # The alias name.
              &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
            },
          },
        },
      },
      &quot;createTime&quot;: &quot;A String&quot;, # Time at which the build was created.
      &quot;projectId&quot;: &quot;A String&quot;, # ID of the project.
      &quot;logsUri&quot;: &quot;A String&quot;, # URI where any logs for this provenance were written.
      &quot;creator&quot;: &quot;A String&quot;, # E-mail address of the user who initiated this build. Note that this was the
          # user&#x27;s e-mail address at the time the build was initiated; this address may
          # not represent the same end-user for all time.
      &quot;builderVersion&quot;: &quot;A String&quot;, # Version string of the builder at the time this build was executed.
      &quot;commands&quot;: [ # Commands requested by the build.
        { # Command describes a step performed as part of the build pipeline.
          &quot;dir&quot;: &quot;A String&quot;, # Working directory (relative to project source root) used when running this
              # command.
          &quot;waitFor&quot;: [ # The ID(s) of the command(s) that this command depends on.
            &quot;A String&quot;,
          ],
          &quot;env&quot;: [ # Environment variables set before running this command.
            &quot;A String&quot;,
          ],
          &quot;args&quot;: [ # Command-line arguments used when executing this command.
            &quot;A String&quot;,
          ],
          &quot;name&quot;: &quot;A String&quot;, # Required. Name of the command, as presented on the command line, or if the
              # command is packaged as a Docker container, as presented to `docker pull`.
          &quot;id&quot;: &quot;A String&quot;, # Optional unique identifier for this command, used in wait_for to reference
              # this command as a dependency.
        },
      ],
      &quot;builtArtifacts&quot;: [ # Output of the build.
        { # Artifact describes a build product.
          &quot;checksum&quot;: &quot;A String&quot;, # Hash or checksum value of a binary, or Docker Registry 2.0 digest of a
              # container.
          &quot;id&quot;: &quot;A String&quot;, # Artifact ID, if any; for container images, this will be a URL by digest
              # like `gcr.io/projectID/imagename@sha256:123456`.
          &quot;names&quot;: [ # Related artifact names. This may be the path to a binary or jar file, or in
              # the case of a container build, the name used to push the container image to
              # Google Container Registry, as presented to `docker push`. Note that a
              # single Artifact ID can have multiple names, for example if two tags are
              # applied to one image.
            &quot;A String&quot;,
          ],
        },
      ],
      &quot;id&quot;: &quot;A String&quot;, # Required. Unique identifier of the build.
      &quot;buildOptions&quot;: { # Special options applied to this build. This is a catch-all field where
          # build providers can enter any desired additional details.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
    },
  },
  &quot;discovered&quot;: { # Details of a discovery occurrence. # Describes when a resource was discovered.
    &quot;discovered&quot;: { # Provides information about the analysis status of a discovered resource. # Required. Analysis status for the discovered resource.
      &quot;analysisStatusError&quot;: { # The `Status` type defines a logical error model that is suitable for # When an error is encountered this will contain a LocalizedMessage under
          # details to show to the user. The LocalizedMessage is output only and
          # populated by the API.
          # different programming environments, including REST APIs and RPC APIs. It is
          # used by [gRPC](https://github.com/grpc). Each `Status` message contains
          # three pieces of data: error code, error message, and error details.
          #
          # You can find out more about this error model and how to work with it in the
          # [API Design Guide](https://cloud.google.com/apis/design/errors).
        &quot;details&quot;: [ # A list of messages that carry the error details.  There is a common set of
            # message types for APIs to use.
          {
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
          },
        ],
        &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
        &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any
            # user-facing error message should be localized and sent in the
            # google.rpc.Status.details field, or localized by the client.
      },
      &quot;analysisStatus&quot;: &quot;A String&quot;, # The status of discovery for the resource.
      &quot;continuousAnalysis&quot;: &quot;A String&quot;, # Whether the resource is continuously analyzed.
      &quot;lastAnalysisTime&quot;: &quot;A String&quot;, # The last time continuous analysis was done for this resource.
          # Deprecated, do not use.
    },
  },
  &quot;noteName&quot;: &quot;A String&quot;, # Required. Immutable. The analysis note associated with this occurrence, in
      # the form of `projects/[PROVIDER_ID]/notes/[NOTE_ID]`. This field can be
      # used as a filter in list requests.
  &quot;deployment&quot;: { # Details of a deployment occurrence. # Describes the deployment of an artifact on a runtime.
    &quot;deployment&quot;: { # The period during which some deployable was active in a runtime. # Required. Deployment history for the resource.
      &quot;userEmail&quot;: &quot;A String&quot;, # Identity of the user that triggered this deployment.
      &quot;config&quot;: &quot;A String&quot;, # Configuration used to create this deployment.
      &quot;undeployTime&quot;: &quot;A String&quot;, # End of the lifetime of this deployment.
      &quot;platform&quot;: &quot;A String&quot;, # Platform hosting this deployment.
      &quot;deployTime&quot;: &quot;A String&quot;, # Required. Beginning of the lifetime of this deployment.
      &quot;address&quot;: &quot;A String&quot;, # Address of the runtime element hosting this deployment.
      &quot;resourceUri&quot;: [ # Output only. Resource URI for the artifact being deployed taken from
          # the deployable field with the same name.
        &quot;A String&quot;,
      ],
    },
  },
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. The time this occurrence was created.
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. The time this occurrence was last updated.
  &quot;remediation&quot;: &quot;A String&quot;, # A description of actions that can be taken to remedy the note.
  &quot;intoto&quot;: { # This corresponds to a signed in-toto link - it is made up of one or more # Describes a specific in-toto link.
      # signatures and the in-toto link itself. This is used for occurrences of a
      # Grafeas in-toto note.
    &quot;signed&quot;: { # This corresponds to an in-toto link.
      &quot;command&quot;: [ # This field contains the full command executed for the step. This can also
          # be empty if links are generated for operations that aren&#x27;t directly mapped
          # to a specific command. Each term in the command is an independent string
          # in the list. An example of a command in the in-toto metadata field is:
          # &quot;command&quot;: [&quot;git&quot;, &quot;clone&quot;, &quot;https://github.com/in-toto/demo-project.git&quot;]
        &quot;A String&quot;,
      ],
      &quot;byproducts&quot;: { # Defines an object for the byproducts field in in-toto links. The suggested # ByProducts are data generated as part of a software supply chain step, but
          # are not the actual result of the step.
          # fields are &quot;stderr&quot;, &quot;stdout&quot;, and &quot;return-value&quot;.
        &quot;customValues&quot;: {
          &quot;a_key&quot;: &quot;A String&quot;,
        },
      },
      &quot;environment&quot;: { # Defines an object for the environment field in in-toto links. The suggested # This is a field that can be used to capture information about the
          # environment. It is suggested for this field to contain information that
          # details environment variables, filesystem information, and the present
          # working directory. The recommended structure of this field is:
          # &quot;environment&quot;: {
          #   &quot;custom_values&quot;: {
          #     &quot;variables&quot;: &quot;&lt;ENV&gt;&quot;,
          #     &quot;filesystem&quot;: &quot;&lt;FS&gt;&quot;,
          #     &quot;workdir&quot;: &quot;&lt;CWD&gt;&quot;,
          #     &quot;&lt;ANY OTHER RELEVANT FIELDS&gt;&quot;: &quot;...&quot;
          #   }
          # }
          # fields are &quot;variables&quot;, &quot;filesystem&quot;, and &quot;workdir&quot;.
        &quot;customValues&quot;: {
          &quot;a_key&quot;: &quot;A String&quot;,
        },
      },
      &quot;materials&quot;: [ # Materials are the supply chain artifacts that go into the step and are used
          # for the operation performed. The key of the map is the path of the artifact
          # and the structure contains the recorded hash information. An example is:
          # &quot;materials&quot;: [
          #   {
          #     &quot;resource_uri&quot;: &quot;foo/bar&quot;,
          #     &quot;hashes&quot;: {
          #       &quot;sha256&quot;: &quot;ebebf...&quot;,
          #       &lt;OTHER HASH ALGORITHMS&gt;: &lt;HASH VALUE&gt;
          #     }
          #   }
          # ]
        {
          &quot;hashes&quot;: { # Defines a hash object for use in Materials and Products.
            &quot;sha256&quot;: &quot;A String&quot;,
          },
          &quot;resourceUri&quot;: &quot;A String&quot;,
        },
      ],
      &quot;products&quot;: [ # Products are the supply chain artifacts generated as a result of the step.
          # The structure is identical to that of materials.
        {
          &quot;hashes&quot;: { # Defines a hash object for use in Materials and Products.
            &quot;sha256&quot;: &quot;A String&quot;,
          },
          &quot;resourceUri&quot;: &quot;A String&quot;,
        },
      ],
    },
    &quot;signatures&quot;: [
      { # A signature object consists of the KeyID used and the signature itself.
        &quot;sig&quot;: &quot;A String&quot;,
        &quot;keyid&quot;: &quot;A String&quot;,
      },
    ],
  },
  &quot;derivedImage&quot;: { # Details of an image occurrence. # Describes how this resource derives from the basis in the associated
      # note.
    &quot;derivedImage&quot;: { # Derived describes the derived image portion (Occurrence) of the DockerImage # Required. Immutable. The child image derived from the base image.
        # relationship. This image would be produced from a Dockerfile with FROM
        # &lt;DockerImage.Basis in attached Note&gt;.
      &quot;fingerprint&quot;: { # A set of properties that uniquely identify a given Docker image. # Required. The fingerprint of the derived image.
        &quot;v2Blob&quot;: [ # Required. The ordered list of v2 blobs that represent a given image.
          &quot;A String&quot;,
        ],
        &quot;v1Name&quot;: &quot;A String&quot;, # Required. The layer ID of the final layer in the Docker image&#x27;s v1
            # representation.
        &quot;v2Name&quot;: &quot;A String&quot;, # Output only. The name of the image&#x27;s v2 blobs computed via:
            #   [bottom] := v2_blobbottom := sha256(v2_blob[N] + &quot; &quot; + v2_name[N+1])
            # Only the name of the final blob is kept.
      },
      &quot;layerInfo&quot;: [ # This contains layer-specific metadata, if populated it has length
          # &quot;distance&quot; and is ordered with [distance] being the layer immediately
          # following the base image and [1] being the final layer.
        { # Layer holds metadata specific to a layer of a Docker image.
          &quot;directive&quot;: &quot;A String&quot;, # Required. The recovered Dockerfile directive used to construct this layer.
          &quot;arguments&quot;: &quot;A String&quot;, # The recovered arguments to the Dockerfile directive.
        },
      ],
      &quot;distance&quot;: 42, # Output only. The number of layers by which this image differs from the
          # associated image basis.
      &quot;baseResourceUrl&quot;: &quot;A String&quot;, # Output only. This contains the base image URL for the derived image
          # occurrence.
    },
  },
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # An instance of an analysis type that has been found on a resource.
    &quot;kind&quot;: &quot;A String&quot;, # Output only. This explicitly denotes which of the occurrence details are
        # specified. This field can be used as a filter in list requests.
    &quot;resource&quot;: { # An entity that can have metadata. For example, a Docker image. # Required. Immutable. The resource for which the occurrence applies.
      &quot;name&quot;: &quot;A String&quot;, # Deprecated, do not use. Use uri instead.
          #
          # The name of the resource. For example, the name of a Docker image -
          # &quot;Debian&quot;.
      &quot;contentHash&quot;: { # Container message for hash values. # Deprecated, do not use. Use uri instead.
          #
          # The hash of the resource content. For example, the Docker digest.
        &quot;type&quot;: &quot;A String&quot;, # Required. The type of hash that was performed.
        &quot;value&quot;: &quot;A String&quot;, # Required. The hash value.
      },
      &quot;uri&quot;: &quot;A String&quot;, # Required. The unique URI of the resource. For example,
          # `https://gcr.io/project/image@sha256:foo` for a Docker image.
    },
    &quot;attestation&quot;: { # Details of an attestation occurrence. # Describes an attestation of an artifact.
      &quot;attestation&quot;: { # Occurrence that represents a single &quot;attestation&quot;. The authenticity of an # Required. Attestation for the resource.
          # attestation can be verified using the attached signature. If the verifier
          # trusts the public key of the signer, then verifying the signature is
          # sufficient to establish trust. In this circumstance, the authority to which
          # this attestation is attached is primarily useful for look-up (how to find
          # this attestation if you already know the authority and artifact to be
          # verified) and intent (which authority was this attestation intended to sign
          # for).
        &quot;pgpSignedAttestation&quot;: { # An attestation wrapper with a PGP-compatible signature. This message only # A PGP signed attestation.
            # supports `ATTACHED` signatures, where the payload that is signed is included
            # alongside the signature itself in the same file.
          &quot;contentType&quot;: &quot;A String&quot;, # Type (for example schema) of the attestation payload that was signed.
              # The verifier must ensure that the provided type is one that the verifier
              # supports, and that the attestation payload is a valid instantiation of that
              # type (for example by validating a JSON schema).
          &quot;signature&quot;: &quot;A String&quot;, # Required. The raw content of the signature, as output by GNU Privacy Guard
              # (GPG) or equivalent. Since this message only supports attached signatures,
              # the payload that was signed must be attached. While the signature format
              # supported is dependent on the verification implementation, currently only
              # ASCII-armored (`--armor` to gpg), non-clearsigned (`--sign` rather than
              # `--clearsign` to gpg) are supported. Concretely, `gpg --sign --armor
              # --output=signature.gpg payload.json` will create the signature content
              # expected in this field in `signature.gpg` for the `payload.json`
              # attestation payload.
          &quot;pgpKeyId&quot;: &quot;A String&quot;, # The cryptographic fingerprint of the key used to generate the signature,
              # as output by, e.g. `gpg --list-keys`. This should be the version 4, full
              # 160-bit fingerprint, expressed as a 40 character hexidecimal string. See
              # https://tools.ietf.org/html/rfc4880#section-12.2 for details.
              # Implementations may choose to acknowledge &quot;LONG&quot;, &quot;SHORT&quot;, or other
              # abbreviated key IDs, but only the full fingerprint is guaranteed to work.
              # In gpg, the full fingerprint can be retrieved from the `fpr` field
              # returned when calling --list-keys with --with-colons.  For example:
              # ```
              # gpg --with-colons --with-fingerprint --force-v4-certs \
              #     --list-keys attester@example.com
              # tru::1:1513631572:0:3:1:5
              # pub:...&lt;SNIP&gt;...
              # fpr:::::::::24FF6481B76AC91E66A00AC657A93A81EF3AE6FB:
              # ```
              # Above, the fingerprint is `24FF6481B76AC91E66A00AC657A93A81EF3AE6FB`.
        },
        &quot;genericSignedAttestation&quot;: { # An attestation wrapper that uses the Grafeas `Signature` message.
            # This attestation must define the `serialized_payload` that the `signatures`
            # verify and any metadata necessary to interpret that plaintext.  The
            # signatures should always be over the `serialized_payload` bytestring.
          &quot;contentType&quot;: &quot;A String&quot;, # Type (for example schema) of the attestation payload that was signed.
              # The verifier must ensure that the provided type is one that the verifier
              # supports, and that the attestation payload is a valid instantiation of that
              # type (for example by validating a JSON schema).
          &quot;signatures&quot;: [ # One or more signatures over `serialized_payload`.  Verifier implementations
              # should consider this attestation message verified if at least one
              # `signature` verifies `serialized_payload`.  See `Signature` in common.proto
              # for more details on signature structure and verification.
            { # Verifiers (e.g. Kritis implementations) MUST verify signatures
                # with respect to the trust anchors defined in policy (e.g. a Kritis policy).
                # Typically this means that the verifier has been configured with a map from
                # `public_key_id` to public key material (and any required parameters, e.g.
                # signing algorithm).
                #
                # In particular, verification implementations MUST NOT treat the signature
                # `public_key_id` as anything more than a key lookup hint. The `public_key_id`
                # DOES NOT validate or authenticate a public key; it only provides a mechanism
                # for quickly selecting a public key ALREADY CONFIGURED on the verifier through
                # a trusted channel. Verification implementations MUST reject signatures in any
                # of the following circumstances:
                #   * The `public_key_id` is not recognized by the verifier.
                #   * The public key that `public_key_id` refers to does not verify the
                #     signature with respect to the payload.
                #
                # The `signature` contents SHOULD NOT be &quot;attached&quot; (where the payload is
                # included with the serialized `signature` bytes). Verifiers MUST ignore any
                # &quot;attached&quot; payload and only verify signatures with respect to explicitly
                # provided payload (e.g. a `payload` field on the proto message that holds
                # this Signature, or the canonical serialization of the proto message that
                # holds this signature).
              &quot;publicKeyId&quot;: &quot;A String&quot;, # The identifier for the public key that verifies this signature.
                  #   * The `public_key_id` is required.
                  #   * The `public_key_id` MUST be an RFC3986 conformant URI.
                  #   * When possible, the `public_key_id` SHOULD be an immutable reference,
                  #     such as a cryptographic digest.
                  #
                  # Examples of valid `public_key_id`s:
                  #
                  # OpenPGP V4 public key fingerprint:
                  #   * &quot;openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA&quot;
                  # See https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr for more
                  # details on this scheme.
                  #
                  # RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER
                  # serialization):
                  #   * &quot;ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU&quot;
                  #   * &quot;nih:///sha-256;703f68f42aba2c6de30f488a5ea122fef76324679c9bf89791ba95a1271589a5&quot;
              &quot;signature&quot;: &quot;A String&quot;, # The content of the signature, an opaque bytestring.
                  # The payload that this signature verifies MUST be unambiguously provided
                  # with the Signature during verification. A wrapper message might provide
                  # the payload explicitly. Alternatively, a message might have a canonical
                  # serialization that can always be unambiguously computed to derive the
                  # payload.
            },
          ],
          &quot;serializedPayload&quot;: &quot;A String&quot;, # The serialized payload that is verified by one or more `signatures`.
              # The encoding and semantic meaning of this payload must match what is set in
              # `content_type`.
        },
      },
    },
    &quot;name&quot;: &quot;A String&quot;, # Output only. The name of the occurrence in the form of
        # `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
    &quot;vulnerability&quot;: { # Details of a vulnerability Occurrence. # Describes a security vulnerability.
      &quot;longDescription&quot;: &quot;A String&quot;, # Output only. A detailed description of this vulnerability.
      &quot;shortDescription&quot;: &quot;A String&quot;, # Output only. A one sentence description of this vulnerability.
      &quot;effectiveSeverity&quot;: &quot;A String&quot;, # The distro assigned severity for this vulnerability when it is
          # available, and note provider assigned severity when distro has not yet
          # assigned a severity for this vulnerability.
      &quot;severity&quot;: &quot;A String&quot;, # Output only. The note provider assigned Severity of the vulnerability.
      &quot;cvssScore&quot;: 3.14, # Output only. The CVSS score of this vulnerability. CVSS score is on a
          # scale of 0-10 where 0 indicates low severity and 10 indicates high
          # severity.
      &quot;relatedUrls&quot;: [ # Output only. URLs related to this vulnerability.
        { # Metadata for any related URL information.
          &quot;url&quot;: &quot;A String&quot;, # Specific URL associated with the resource.
          &quot;label&quot;: &quot;A String&quot;, # Label to describe usage of the URL.
        },
      ],
      &quot;type&quot;: &quot;A String&quot;, # The type of package; whether native or non native(ruby gems, node.js
          # packages etc)
      &quot;packageIssue&quot;: [ # Required. The set of affected locations and their fixes (if available)
          # within the associated resource.
        { # This message wraps a location affected by a vulnerability and its
            # associated fix (if one is available).
          &quot;severityName&quot;: &quot;A String&quot;, # Deprecated, use Details.effective_severity instead
              # The severity (e.g., distro assigned severity) for this vulnerability.
          &quot;affectedLocation&quot;: { # The location of the vulnerability. # Required. The location of the vulnerability.
            &quot;package&quot;: &quot;A String&quot;, # Required. The package being described.
            &quot;version&quot;: { # Version contains structured information about the version of a package. # Required. The version of the package being described.
              &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
              &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                  # name.
              &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                  # versions.
              &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
            },
            &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in [cpe format](https://cpe.mitre.org/specification/)
                # format. Examples include distro or storage location for vulnerable jar.
          },
          &quot;fixedLocation&quot;: { # The location of the vulnerability. # The location of the available fix for vulnerability.
            &quot;package&quot;: &quot;A String&quot;, # Required. The package being described.
            &quot;version&quot;: { # Version contains structured information about the version of a package. # Required. The version of the package being described.
              &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
              &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                  # name.
              &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                  # versions.
              &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
            },
            &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in [cpe format](https://cpe.mitre.org/specification/)
                # format. Examples include distro or storage location for vulnerable jar.
          },
        },
      ],
    },
    &quot;installation&quot;: { # Details of a package occurrence. # Describes the installation of a package on the linked resource.
      &quot;installation&quot;: { # This represents how a particular software package may be installed on a # Required. Where the package was installed.
          # system.
        &quot;location&quot;: [ # Required. All of the places within the filesystem versions of this package
            # have been found.
          { # An occurrence of a particular package installation found within a system&#x27;s
              # filesystem. E.g., glibc was found in `/var/lib/dpkg/status`.
            &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in [CPE format](https://cpe.mitre.org/specification/)
                # denoting the package manager version distributing a package.
            &quot;version&quot;: { # Version contains structured information about the version of a package. # The version installed at this location.
              &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
              &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                  # name.
              &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                  # versions.
              &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
            },
            &quot;path&quot;: &quot;A String&quot;, # The path from which we gathered that this package/version is installed.
          },
        ],
        &quot;name&quot;: &quot;A String&quot;, # Output only. The name of the installed package.
      },
    },
    &quot;build&quot;: { # Details of a build occurrence. # Describes a verifiable build.
      &quot;provenanceBytes&quot;: &quot;A String&quot;, # Serialized JSON representation of the provenance, used in generating the
          # build signature in the corresponding build note. After verifying the
          # signature, `provenance_bytes` can be unmarshalled and compared to the
          # provenance to confirm that it is unchanged. A base64-encoded string
          # representation of the provenance bytes is used for the signature in order
          # to interoperate with openssl which expects this format for signature
          # verification.
          #
          # The serialized form is captured both to avoid ambiguity in how the
          # provenance is marshalled to json as well to prevent incompatibilities with
          # future changes.
      &quot;provenance&quot;: { # Provenance of a build. Contains all information needed to verify the full # Required. The actual provenance for the build.
          # details about the build from source to completion.
        &quot;endTime&quot;: &quot;A String&quot;, # Time at which execution of the build was finished.
        &quot;startTime&quot;: &quot;A String&quot;, # Time at which execution of the build was started.
        &quot;triggerId&quot;: &quot;A String&quot;, # Trigger identifier if the build was triggered automatically; empty if not.
        &quot;sourceProvenance&quot;: { # Source describes the location of the source used for the build. # Details of the Source input to the build.
          &quot;artifactStorageSourceUri&quot;: &quot;A String&quot;, # If provided, the input binary artifacts for the build came from this
              # location.
          &quot;additionalContexts&quot;: [ # If provided, some of the source code used for the build may be found in
              # these locations, in the case where the source repository had multiple
              # remotes or submodules. This list will not include the context specified in
              # the context field.
            { # A SourceContext is a reference to a tree of files. A SourceContext together
                # with a path point to a unique revision of a single file or directory.
              &quot;labels&quot;: { # Labels with user defined metadata.
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;git&quot;: { # A GitSourceContext denotes a particular revision in a third party Git # A SourceContext referring to any third party Git repo (e.g., GitHub).
                  # repository (e.g., GitHub).
                &quot;url&quot;: &quot;A String&quot;, # Git repository URL.
                &quot;revisionId&quot;: &quot;A String&quot;, # Git commit hash.
              },
              &quot;gerrit&quot;: { # A SourceContext referring to a Gerrit project. # A SourceContext referring to a Gerrit project.
                &quot;hostUri&quot;: &quot;A String&quot;, # The URI of a running Gerrit instance.
                &quot;revisionId&quot;: &quot;A String&quot;, # A revision (commit) ID.
                &quot;gerritProject&quot;: &quot;A String&quot;, # The full project name within the host. Projects may be nested, so
                    # &quot;project/subproject&quot; is a valid project name. The &quot;repo name&quot; is the
                    # hostURI/project.
                &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                  &quot;name&quot;: &quot;A String&quot;, # The alias name.
                  &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
                },
              },
              &quot;cloudRepo&quot;: { # A CloudRepoSourceContext denotes a particular revision in a Google Cloud # A SourceContext referring to a revision in a Google Cloud Source Repo.
                  # Source Repo.
                &quot;revisionId&quot;: &quot;A String&quot;, # A revision ID.
                &quot;repoId&quot;: { # A unique identifier for a Cloud Repo. # The ID of the repo.
                  &quot;projectRepoId&quot;: { # Selects a repo using a Google Cloud Platform project ID (e.g., # A combination of a project ID and a repo name.
                      # winged-cargo-31) and a repo name within that project.
                    &quot;projectId&quot;: &quot;A String&quot;, # The ID of the project.
                    &quot;repoName&quot;: &quot;A String&quot;, # The name of the repo. Leave empty for the default repo.
                  },
                  &quot;uid&quot;: &quot;A String&quot;, # A server-assigned, globally unique identifier.
                },
                &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                  &quot;name&quot;: &quot;A String&quot;, # The alias name.
                  &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
                },
              },
            },
          ],
          &quot;fileHashes&quot;: { # Hash(es) of the build source, which can be used to verify that the original
              # source integrity was maintained in the build.
              #
              # The keys to this map are file paths used as build source and the values
              # contain the hash values for those files.
              #
              # If the build source came in a single package such as a gzipped tarfile
              # (.tar.gz), the FileHash will be for the single path to that file.
            &quot;a_key&quot;: { # Container message for hashes of byte content of files, used in source
                # messages to verify integrity of source input to the build.
              &quot;fileHash&quot;: [ # Required. Collection of file hashes.
                { # Container message for hash values.
                  &quot;type&quot;: &quot;A String&quot;, # Required. The type of hash that was performed.
                  &quot;value&quot;: &quot;A String&quot;, # Required. The hash value.
                },
              ],
            },
          },
          &quot;context&quot;: { # A SourceContext is a reference to a tree of files. A SourceContext together # If provided, the source code used for the build came from this location.
              # with a path point to a unique revision of a single file or directory.
            &quot;labels&quot;: { # Labels with user defined metadata.
              &quot;a_key&quot;: &quot;A String&quot;,
            },
            &quot;git&quot;: { # A GitSourceContext denotes a particular revision in a third party Git # A SourceContext referring to any third party Git repo (e.g., GitHub).
                # repository (e.g., GitHub).
              &quot;url&quot;: &quot;A String&quot;, # Git repository URL.
              &quot;revisionId&quot;: &quot;A String&quot;, # Git commit hash.
            },
            &quot;gerrit&quot;: { # A SourceContext referring to a Gerrit project. # A SourceContext referring to a Gerrit project.
              &quot;hostUri&quot;: &quot;A String&quot;, # The URI of a running Gerrit instance.
              &quot;revisionId&quot;: &quot;A String&quot;, # A revision (commit) ID.
              &quot;gerritProject&quot;: &quot;A String&quot;, # The full project name within the host. Projects may be nested, so
                  # &quot;project/subproject&quot; is a valid project name. The &quot;repo name&quot; is the
                  # hostURI/project.
              &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                &quot;name&quot;: &quot;A String&quot;, # The alias name.
                &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
              },
            },
            &quot;cloudRepo&quot;: { # A CloudRepoSourceContext denotes a particular revision in a Google Cloud # A SourceContext referring to a revision in a Google Cloud Source Repo.
                # Source Repo.
              &quot;revisionId&quot;: &quot;A String&quot;, # A revision ID.
              &quot;repoId&quot;: { # A unique identifier for a Cloud Repo. # The ID of the repo.
                &quot;projectRepoId&quot;: { # Selects a repo using a Google Cloud Platform project ID (e.g., # A combination of a project ID and a repo name.
                    # winged-cargo-31) and a repo name within that project.
                  &quot;projectId&quot;: &quot;A String&quot;, # The ID of the project.
                  &quot;repoName&quot;: &quot;A String&quot;, # The name of the repo. Leave empty for the default repo.
                },
                &quot;uid&quot;: &quot;A String&quot;, # A server-assigned, globally unique identifier.
              },
              &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                &quot;name&quot;: &quot;A String&quot;, # The alias name.
                &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
              },
            },
          },
        },
        &quot;createTime&quot;: &quot;A String&quot;, # Time at which the build was created.
        &quot;projectId&quot;: &quot;A String&quot;, # ID of the project.
        &quot;logsUri&quot;: &quot;A String&quot;, # URI where any logs for this provenance were written.
        &quot;creator&quot;: &quot;A String&quot;, # E-mail address of the user who initiated this build. Note that this was the
            # user&#x27;s e-mail address at the time the build was initiated; this address may
            # not represent the same end-user for all time.
        &quot;builderVersion&quot;: &quot;A String&quot;, # Version string of the builder at the time this build was executed.
        &quot;commands&quot;: [ # Commands requested by the build.
          { # Command describes a step performed as part of the build pipeline.
            &quot;dir&quot;: &quot;A String&quot;, # Working directory (relative to project source root) used when running this
                # command.
            &quot;waitFor&quot;: [ # The ID(s) of the command(s) that this command depends on.
              &quot;A String&quot;,
            ],
            &quot;env&quot;: [ # Environment variables set before running this command.
              &quot;A String&quot;,
            ],
            &quot;args&quot;: [ # Command-line arguments used when executing this command.
              &quot;A String&quot;,
            ],
            &quot;name&quot;: &quot;A String&quot;, # Required. Name of the command, as presented on the command line, or if the
                # command is packaged as a Docker container, as presented to `docker pull`.
            &quot;id&quot;: &quot;A String&quot;, # Optional unique identifier for this command, used in wait_for to reference
                # this command as a dependency.
          },
        ],
        &quot;builtArtifacts&quot;: [ # Output of the build.
          { # Artifact describes a build product.
            &quot;checksum&quot;: &quot;A String&quot;, # Hash or checksum value of a binary, or Docker Registry 2.0 digest of a
                # container.
            &quot;id&quot;: &quot;A String&quot;, # Artifact ID, if any; for container images, this will be a URL by digest
                # like `gcr.io/projectID/imagename@sha256:123456`.
            &quot;names&quot;: [ # Related artifact names. This may be the path to a binary or jar file, or in
                # the case of a container build, the name used to push the container image to
                # Google Container Registry, as presented to `docker push`. Note that a
                # single Artifact ID can have multiple names, for example if two tags are
                # applied to one image.
              &quot;A String&quot;,
            ],
          },
        ],
        &quot;id&quot;: &quot;A String&quot;, # Required. Unique identifier of the build.
        &quot;buildOptions&quot;: { # Special options applied to this build. This is a catch-all field where
            # build providers can enter any desired additional details.
          &quot;a_key&quot;: &quot;A String&quot;,
        },
      },
    },
    &quot;discovered&quot;: { # Details of a discovery occurrence. # Describes when a resource was discovered.
      &quot;discovered&quot;: { # Provides information about the analysis status of a discovered resource. # Required. Analysis status for the discovered resource.
        &quot;analysisStatusError&quot;: { # The `Status` type defines a logical error model that is suitable for # When an error is encountered this will contain a LocalizedMessage under
            # details to show to the user. The LocalizedMessage is output only and
            # populated by the API.
            # different programming environments, including REST APIs and RPC APIs. It is
            # used by [gRPC](https://github.com/grpc). Each `Status` message contains
            # three pieces of data: error code, error message, and error details.
            #
            # You can find out more about this error model and how to work with it in the
            # [API Design Guide](https://cloud.google.com/apis/design/errors).
          &quot;details&quot;: [ # A list of messages that carry the error details.  There is a common set of
              # message types for APIs to use.
            {
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
            },
          ],
          &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
          &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any
              # user-facing error message should be localized and sent in the
              # google.rpc.Status.details field, or localized by the client.
        },
        &quot;analysisStatus&quot;: &quot;A String&quot;, # The status of discovery for the resource.
        &quot;continuousAnalysis&quot;: &quot;A String&quot;, # Whether the resource is continuously analyzed.
        &quot;lastAnalysisTime&quot;: &quot;A String&quot;, # The last time continuous analysis was done for this resource.
            # Deprecated, do not use.
      },
    },
    &quot;noteName&quot;: &quot;A String&quot;, # Required. Immutable. The analysis note associated with this occurrence, in
        # the form of `projects/[PROVIDER_ID]/notes/[NOTE_ID]`. This field can be
        # used as a filter in list requests.
    &quot;deployment&quot;: { # Details of a deployment occurrence. # Describes the deployment of an artifact on a runtime.
      &quot;deployment&quot;: { # The period during which some deployable was active in a runtime. # Required. Deployment history for the resource.
        &quot;userEmail&quot;: &quot;A String&quot;, # Identity of the user that triggered this deployment.
        &quot;config&quot;: &quot;A String&quot;, # Configuration used to create this deployment.
        &quot;undeployTime&quot;: &quot;A String&quot;, # End of the lifetime of this deployment.
        &quot;platform&quot;: &quot;A String&quot;, # Platform hosting this deployment.
        &quot;deployTime&quot;: &quot;A String&quot;, # Required. Beginning of the lifetime of this deployment.
        &quot;address&quot;: &quot;A String&quot;, # Address of the runtime element hosting this deployment.
        &quot;resourceUri&quot;: [ # Output only. Resource URI for the artifact being deployed taken from
            # the deployable field with the same name.
          &quot;A String&quot;,
        ],
      },
    },
    &quot;createTime&quot;: &quot;A String&quot;, # Output only. The time this occurrence was created.
    &quot;updateTime&quot;: &quot;A String&quot;, # Output only. The time this occurrence was last updated.
    &quot;remediation&quot;: &quot;A String&quot;, # A description of actions that can be taken to remedy the note.
    &quot;intoto&quot;: { # This corresponds to a signed in-toto link - it is made up of one or more # Describes a specific in-toto link.
        # signatures and the in-toto link itself. This is used for occurrences of a
        # Grafeas in-toto note.
      &quot;signed&quot;: { # This corresponds to an in-toto link.
        &quot;command&quot;: [ # This field contains the full command executed for the step. This can also
            # be empty if links are generated for operations that aren&#x27;t directly mapped
            # to a specific command. Each term in the command is an independent string
            # in the list. An example of a command in the in-toto metadata field is:
            # &quot;command&quot;: [&quot;git&quot;, &quot;clone&quot;, &quot;https://github.com/in-toto/demo-project.git&quot;]
          &quot;A String&quot;,
        ],
        &quot;byproducts&quot;: { # Defines an object for the byproducts field in in-toto links. The suggested # ByProducts are data generated as part of a software supply chain step, but
            # are not the actual result of the step.
            # fields are &quot;stderr&quot;, &quot;stdout&quot;, and &quot;return-value&quot;.
          &quot;customValues&quot;: {
            &quot;a_key&quot;: &quot;A String&quot;,
          },
        },
        &quot;environment&quot;: { # Defines an object for the environment field in in-toto links. The suggested # This is a field that can be used to capture information about the
            # environment. It is suggested for this field to contain information that
            # details environment variables, filesystem information, and the present
            # working directory. The recommended structure of this field is:
            # &quot;environment&quot;: {
            #   &quot;custom_values&quot;: {
            #     &quot;variables&quot;: &quot;&lt;ENV&gt;&quot;,
            #     &quot;filesystem&quot;: &quot;&lt;FS&gt;&quot;,
            #     &quot;workdir&quot;: &quot;&lt;CWD&gt;&quot;,
            #     &quot;&lt;ANY OTHER RELEVANT FIELDS&gt;&quot;: &quot;...&quot;
            #   }
            # }
            # fields are &quot;variables&quot;, &quot;filesystem&quot;, and &quot;workdir&quot;.
          &quot;customValues&quot;: {
            &quot;a_key&quot;: &quot;A String&quot;,
          },
        },
        &quot;materials&quot;: [ # Materials are the supply chain artifacts that go into the step and are used
            # for the operation performed. The key of the map is the path of the artifact
            # and the structure contains the recorded hash information. An example is:
            # &quot;materials&quot;: [
            #   {
            #     &quot;resource_uri&quot;: &quot;foo/bar&quot;,
            #     &quot;hashes&quot;: {
            #       &quot;sha256&quot;: &quot;ebebf...&quot;,
            #       &lt;OTHER HASH ALGORITHMS&gt;: &lt;HASH VALUE&gt;
            #     }
            #   }
            # ]
          {
            &quot;hashes&quot;: { # Defines a hash object for use in Materials and Products.
              &quot;sha256&quot;: &quot;A String&quot;,
            },
            &quot;resourceUri&quot;: &quot;A String&quot;,
          },
        ],
        &quot;products&quot;: [ # Products are the supply chain artifacts generated as a result of the step.
            # The structure is identical to that of materials.
          {
            &quot;hashes&quot;: { # Defines a hash object for use in Materials and Products.
              &quot;sha256&quot;: &quot;A String&quot;,
            },
            &quot;resourceUri&quot;: &quot;A String&quot;,
          },
        ],
      },
      &quot;signatures&quot;: [
        { # A signature object consists of the KeyID used and the signature itself.
          &quot;sig&quot;: &quot;A String&quot;,
          &quot;keyid&quot;: &quot;A String&quot;,
        },
      ],
    },
    &quot;derivedImage&quot;: { # Details of an image occurrence. # Describes how this resource derives from the basis in the associated
        # note.
      &quot;derivedImage&quot;: { # Derived describes the derived image portion (Occurrence) of the DockerImage # Required. Immutable. The child image derived from the base image.
          # relationship. This image would be produced from a Dockerfile with FROM
          # &lt;DockerImage.Basis in attached Note&gt;.
        &quot;fingerprint&quot;: { # A set of properties that uniquely identify a given Docker image. # Required. The fingerprint of the derived image.
          &quot;v2Blob&quot;: [ # Required. The ordered list of v2 blobs that represent a given image.
            &quot;A String&quot;,
          ],
          &quot;v1Name&quot;: &quot;A String&quot;, # Required. The layer ID of the final layer in the Docker image&#x27;s v1
              # representation.
          &quot;v2Name&quot;: &quot;A String&quot;, # Output only. The name of the image&#x27;s v2 blobs computed via:
              #   [bottom] := v2_blobbottom := sha256(v2_blob[N] + &quot; &quot; + v2_name[N+1])
              # Only the name of the final blob is kept.
        },
        &quot;layerInfo&quot;: [ # This contains layer-specific metadata, if populated it has length
            # &quot;distance&quot; and is ordered with [distance] being the layer immediately
            # following the base image and [1] being the final layer.
          { # Layer holds metadata specific to a layer of a Docker image.
            &quot;directive&quot;: &quot;A String&quot;, # Required. The recovered Dockerfile directive used to construct this layer.
            &quot;arguments&quot;: &quot;A String&quot;, # The recovered arguments to the Dockerfile directive.
          },
        ],
        &quot;distance&quot;: 42, # Output only. The number of layers by which this image differs from the
            # associated image basis.
        &quot;baseResourceUrl&quot;: &quot;A String&quot;, # Output only. This contains the base image URL for the derived image
            # occurrence.
      },
    },
  }</pre>
</div>

<div class="method">
    <code class="details" id="delete">delete(name, x__xgafv=None)</code>
  <pre>Deletes the specified occurrence. For example, use this method to delete an
occurrence when the occurrence is no longer applicable for the given
resource.

Args:
  name: string, Required. The name of the occurrence in the form of
`projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`. (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A generic empty message that you can re-use to avoid defining duplicated
      # empty messages in your APIs. A typical example is to use it as the request
      # or the response type of an API method. For instance:
      #
      #     service Foo {
      #       rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
      #     }
      #
      # The JSON representation for `Empty` is empty JSON object `{}`.
  }</pre>
</div>

<div class="method">
    <code class="details" id="get">get(name, x__xgafv=None)</code>
  <pre>Gets the specified occurrence.

Args:
  name: string, Required. The name of the occurrence in the form of
`projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`. (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # An instance of an analysis type that has been found on a resource.
    &quot;kind&quot;: &quot;A String&quot;, # Output only. This explicitly denotes which of the occurrence details are
        # specified. This field can be used as a filter in list requests.
    &quot;resource&quot;: { # An entity that can have metadata. For example, a Docker image. # Required. Immutable. The resource for which the occurrence applies.
      &quot;name&quot;: &quot;A String&quot;, # Deprecated, do not use. Use uri instead.
          #
          # The name of the resource. For example, the name of a Docker image -
          # &quot;Debian&quot;.
      &quot;contentHash&quot;: { # Container message for hash values. # Deprecated, do not use. Use uri instead.
          #
          # The hash of the resource content. For example, the Docker digest.
        &quot;type&quot;: &quot;A String&quot;, # Required. The type of hash that was performed.
        &quot;value&quot;: &quot;A String&quot;, # Required. The hash value.
      },
      &quot;uri&quot;: &quot;A String&quot;, # Required. The unique URI of the resource. For example,
          # `https://gcr.io/project/image@sha256:foo` for a Docker image.
    },
    &quot;attestation&quot;: { # Details of an attestation occurrence. # Describes an attestation of an artifact.
      &quot;attestation&quot;: { # Occurrence that represents a single &quot;attestation&quot;. The authenticity of an # Required. Attestation for the resource.
          # attestation can be verified using the attached signature. If the verifier
          # trusts the public key of the signer, then verifying the signature is
          # sufficient to establish trust. In this circumstance, the authority to which
          # this attestation is attached is primarily useful for look-up (how to find
          # this attestation if you already know the authority and artifact to be
          # verified) and intent (which authority was this attestation intended to sign
          # for).
        &quot;pgpSignedAttestation&quot;: { # An attestation wrapper with a PGP-compatible signature. This message only # A PGP signed attestation.
            # supports `ATTACHED` signatures, where the payload that is signed is included
            # alongside the signature itself in the same file.
          &quot;contentType&quot;: &quot;A String&quot;, # Type (for example schema) of the attestation payload that was signed.
              # The verifier must ensure that the provided type is one that the verifier
              # supports, and that the attestation payload is a valid instantiation of that
              # type (for example by validating a JSON schema).
          &quot;signature&quot;: &quot;A String&quot;, # Required. The raw content of the signature, as output by GNU Privacy Guard
              # (GPG) or equivalent. Since this message only supports attached signatures,
              # the payload that was signed must be attached. While the signature format
              # supported is dependent on the verification implementation, currently only
              # ASCII-armored (`--armor` to gpg), non-clearsigned (`--sign` rather than
              # `--clearsign` to gpg) are supported. Concretely, `gpg --sign --armor
              # --output=signature.gpg payload.json` will create the signature content
              # expected in this field in `signature.gpg` for the `payload.json`
              # attestation payload.
          &quot;pgpKeyId&quot;: &quot;A String&quot;, # The cryptographic fingerprint of the key used to generate the signature,
              # as output by, e.g. `gpg --list-keys`. This should be the version 4, full
              # 160-bit fingerprint, expressed as a 40 character hexidecimal string. See
              # https://tools.ietf.org/html/rfc4880#section-12.2 for details.
              # Implementations may choose to acknowledge &quot;LONG&quot;, &quot;SHORT&quot;, or other
              # abbreviated key IDs, but only the full fingerprint is guaranteed to work.
              # In gpg, the full fingerprint can be retrieved from the `fpr` field
              # returned when calling --list-keys with --with-colons.  For example:
              # ```
              # gpg --with-colons --with-fingerprint --force-v4-certs \
              #     --list-keys attester@example.com
              # tru::1:1513631572:0:3:1:5
              # pub:...&lt;SNIP&gt;...
              # fpr:::::::::24FF6481B76AC91E66A00AC657A93A81EF3AE6FB:
              # ```
              # Above, the fingerprint is `24FF6481B76AC91E66A00AC657A93A81EF3AE6FB`.
        },
        &quot;genericSignedAttestation&quot;: { # An attestation wrapper that uses the Grafeas `Signature` message.
            # This attestation must define the `serialized_payload` that the `signatures`
            # verify and any metadata necessary to interpret that plaintext.  The
            # signatures should always be over the `serialized_payload` bytestring.
          &quot;contentType&quot;: &quot;A String&quot;, # Type (for example schema) of the attestation payload that was signed.
              # The verifier must ensure that the provided type is one that the verifier
              # supports, and that the attestation payload is a valid instantiation of that
              # type (for example by validating a JSON schema).
          &quot;signatures&quot;: [ # One or more signatures over `serialized_payload`.  Verifier implementations
              # should consider this attestation message verified if at least one
              # `signature` verifies `serialized_payload`.  See `Signature` in common.proto
              # for more details on signature structure and verification.
            { # Verifiers (e.g. Kritis implementations) MUST verify signatures
                # with respect to the trust anchors defined in policy (e.g. a Kritis policy).
                # Typically this means that the verifier has been configured with a map from
                # `public_key_id` to public key material (and any required parameters, e.g.
                # signing algorithm).
                #
                # In particular, verification implementations MUST NOT treat the signature
                # `public_key_id` as anything more than a key lookup hint. The `public_key_id`
                # DOES NOT validate or authenticate a public key; it only provides a mechanism
                # for quickly selecting a public key ALREADY CONFIGURED on the verifier through
                # a trusted channel. Verification implementations MUST reject signatures in any
                # of the following circumstances:
                #   * The `public_key_id` is not recognized by the verifier.
                #   * The public key that `public_key_id` refers to does not verify the
                #     signature with respect to the payload.
                #
                # The `signature` contents SHOULD NOT be &quot;attached&quot; (where the payload is
                # included with the serialized `signature` bytes). Verifiers MUST ignore any
                # &quot;attached&quot; payload and only verify signatures with respect to explicitly
                # provided payload (e.g. a `payload` field on the proto message that holds
                # this Signature, or the canonical serialization of the proto message that
                # holds this signature).
              &quot;publicKeyId&quot;: &quot;A String&quot;, # The identifier for the public key that verifies this signature.
                  #   * The `public_key_id` is required.
                  #   * The `public_key_id` MUST be an RFC3986 conformant URI.
                  #   * When possible, the `public_key_id` SHOULD be an immutable reference,
                  #     such as a cryptographic digest.
                  #
                  # Examples of valid `public_key_id`s:
                  #
                  # OpenPGP V4 public key fingerprint:
                  #   * &quot;openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA&quot;
                  # See https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr for more
                  # details on this scheme.
                  #
                  # RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER
                  # serialization):
                  #   * &quot;ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU&quot;
                  #   * &quot;nih:///sha-256;703f68f42aba2c6de30f488a5ea122fef76324679c9bf89791ba95a1271589a5&quot;
              &quot;signature&quot;: &quot;A String&quot;, # The content of the signature, an opaque bytestring.
                  # The payload that this signature verifies MUST be unambiguously provided
                  # with the Signature during verification. A wrapper message might provide
                  # the payload explicitly. Alternatively, a message might have a canonical
                  # serialization that can always be unambiguously computed to derive the
                  # payload.
            },
          ],
          &quot;serializedPayload&quot;: &quot;A String&quot;, # The serialized payload that is verified by one or more `signatures`.
              # The encoding and semantic meaning of this payload must match what is set in
              # `content_type`.
        },
      },
    },
    &quot;name&quot;: &quot;A String&quot;, # Output only. The name of the occurrence in the form of
        # `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
    &quot;vulnerability&quot;: { # Details of a vulnerability Occurrence. # Describes a security vulnerability.
      &quot;longDescription&quot;: &quot;A String&quot;, # Output only. A detailed description of this vulnerability.
      &quot;shortDescription&quot;: &quot;A String&quot;, # Output only. A one sentence description of this vulnerability.
      &quot;effectiveSeverity&quot;: &quot;A String&quot;, # The distro assigned severity for this vulnerability when it is
          # available, and note provider assigned severity when distro has not yet
          # assigned a severity for this vulnerability.
      &quot;severity&quot;: &quot;A String&quot;, # Output only. The note provider assigned Severity of the vulnerability.
      &quot;cvssScore&quot;: 3.14, # Output only. The CVSS score of this vulnerability. CVSS score is on a
          # scale of 0-10 where 0 indicates low severity and 10 indicates high
          # severity.
      &quot;relatedUrls&quot;: [ # Output only. URLs related to this vulnerability.
        { # Metadata for any related URL information.
          &quot;url&quot;: &quot;A String&quot;, # Specific URL associated with the resource.
          &quot;label&quot;: &quot;A String&quot;, # Label to describe usage of the URL.
        },
      ],
      &quot;type&quot;: &quot;A String&quot;, # The type of package; whether native or non native(ruby gems, node.js
          # packages etc)
      &quot;packageIssue&quot;: [ # Required. The set of affected locations and their fixes (if available)
          # within the associated resource.
        { # This message wraps a location affected by a vulnerability and its
            # associated fix (if one is available).
          &quot;severityName&quot;: &quot;A String&quot;, # Deprecated, use Details.effective_severity instead
              # The severity (e.g., distro assigned severity) for this vulnerability.
          &quot;affectedLocation&quot;: { # The location of the vulnerability. # Required. The location of the vulnerability.
            &quot;package&quot;: &quot;A String&quot;, # Required. The package being described.
            &quot;version&quot;: { # Version contains structured information about the version of a package. # Required. The version of the package being described.
              &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
              &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                  # name.
              &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                  # versions.
              &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
            },
            &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in [cpe format](https://cpe.mitre.org/specification/)
                # format. Examples include distro or storage location for vulnerable jar.
          },
          &quot;fixedLocation&quot;: { # The location of the vulnerability. # The location of the available fix for vulnerability.
            &quot;package&quot;: &quot;A String&quot;, # Required. The package being described.
            &quot;version&quot;: { # Version contains structured information about the version of a package. # Required. The version of the package being described.
              &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
              &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                  # name.
              &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                  # versions.
              &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
            },
            &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in [cpe format](https://cpe.mitre.org/specification/)
                # format. Examples include distro or storage location for vulnerable jar.
          },
        },
      ],
    },
    &quot;installation&quot;: { # Details of a package occurrence. # Describes the installation of a package on the linked resource.
      &quot;installation&quot;: { # This represents how a particular software package may be installed on a # Required. Where the package was installed.
          # system.
        &quot;location&quot;: [ # Required. All of the places within the filesystem versions of this package
            # have been found.
          { # An occurrence of a particular package installation found within a system&#x27;s
              # filesystem. E.g., glibc was found in `/var/lib/dpkg/status`.
            &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in [CPE format](https://cpe.mitre.org/specification/)
                # denoting the package manager version distributing a package.
            &quot;version&quot;: { # Version contains structured information about the version of a package. # The version installed at this location.
              &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
              &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                  # name.
              &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                  # versions.
              &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
            },
            &quot;path&quot;: &quot;A String&quot;, # The path from which we gathered that this package/version is installed.
          },
        ],
        &quot;name&quot;: &quot;A String&quot;, # Output only. The name of the installed package.
      },
    },
    &quot;build&quot;: { # Details of a build occurrence. # Describes a verifiable build.
      &quot;provenanceBytes&quot;: &quot;A String&quot;, # Serialized JSON representation of the provenance, used in generating the
          # build signature in the corresponding build note. After verifying the
          # signature, `provenance_bytes` can be unmarshalled and compared to the
          # provenance to confirm that it is unchanged. A base64-encoded string
          # representation of the provenance bytes is used for the signature in order
          # to interoperate with openssl which expects this format for signature
          # verification.
          #
          # The serialized form is captured both to avoid ambiguity in how the
          # provenance is marshalled to json as well to prevent incompatibilities with
          # future changes.
      &quot;provenance&quot;: { # Provenance of a build. Contains all information needed to verify the full # Required. The actual provenance for the build.
          # details about the build from source to completion.
        &quot;endTime&quot;: &quot;A String&quot;, # Time at which execution of the build was finished.
        &quot;startTime&quot;: &quot;A String&quot;, # Time at which execution of the build was started.
        &quot;triggerId&quot;: &quot;A String&quot;, # Trigger identifier if the build was triggered automatically; empty if not.
        &quot;sourceProvenance&quot;: { # Source describes the location of the source used for the build. # Details of the Source input to the build.
          &quot;artifactStorageSourceUri&quot;: &quot;A String&quot;, # If provided, the input binary artifacts for the build came from this
              # location.
          &quot;additionalContexts&quot;: [ # If provided, some of the source code used for the build may be found in
              # these locations, in the case where the source repository had multiple
              # remotes or submodules. This list will not include the context specified in
              # the context field.
            { # A SourceContext is a reference to a tree of files. A SourceContext together
                # with a path point to a unique revision of a single file or directory.
              &quot;labels&quot;: { # Labels with user defined metadata.
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;git&quot;: { # A GitSourceContext denotes a particular revision in a third party Git # A SourceContext referring to any third party Git repo (e.g., GitHub).
                  # repository (e.g., GitHub).
                &quot;url&quot;: &quot;A String&quot;, # Git repository URL.
                &quot;revisionId&quot;: &quot;A String&quot;, # Git commit hash.
              },
              &quot;gerrit&quot;: { # A SourceContext referring to a Gerrit project. # A SourceContext referring to a Gerrit project.
                &quot;hostUri&quot;: &quot;A String&quot;, # The URI of a running Gerrit instance.
                &quot;revisionId&quot;: &quot;A String&quot;, # A revision (commit) ID.
                &quot;gerritProject&quot;: &quot;A String&quot;, # The full project name within the host. Projects may be nested, so
                    # &quot;project/subproject&quot; is a valid project name. The &quot;repo name&quot; is the
                    # hostURI/project.
                &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                  &quot;name&quot;: &quot;A String&quot;, # The alias name.
                  &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
                },
              },
              &quot;cloudRepo&quot;: { # A CloudRepoSourceContext denotes a particular revision in a Google Cloud # A SourceContext referring to a revision in a Google Cloud Source Repo.
                  # Source Repo.
                &quot;revisionId&quot;: &quot;A String&quot;, # A revision ID.
                &quot;repoId&quot;: { # A unique identifier for a Cloud Repo. # The ID of the repo.
                  &quot;projectRepoId&quot;: { # Selects a repo using a Google Cloud Platform project ID (e.g., # A combination of a project ID and a repo name.
                      # winged-cargo-31) and a repo name within that project.
                    &quot;projectId&quot;: &quot;A String&quot;, # The ID of the project.
                    &quot;repoName&quot;: &quot;A String&quot;, # The name of the repo. Leave empty for the default repo.
                  },
                  &quot;uid&quot;: &quot;A String&quot;, # A server-assigned, globally unique identifier.
                },
                &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                  &quot;name&quot;: &quot;A String&quot;, # The alias name.
                  &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
                },
              },
            },
          ],
          &quot;fileHashes&quot;: { # Hash(es) of the build source, which can be used to verify that the original
              # source integrity was maintained in the build.
              #
              # The keys to this map are file paths used as build source and the values
              # contain the hash values for those files.
              #
              # If the build source came in a single package such as a gzipped tarfile
              # (.tar.gz), the FileHash will be for the single path to that file.
            &quot;a_key&quot;: { # Container message for hashes of byte content of files, used in source
                # messages to verify integrity of source input to the build.
              &quot;fileHash&quot;: [ # Required. Collection of file hashes.
                { # Container message for hash values.
                  &quot;type&quot;: &quot;A String&quot;, # Required. The type of hash that was performed.
                  &quot;value&quot;: &quot;A String&quot;, # Required. The hash value.
                },
              ],
            },
          },
          &quot;context&quot;: { # A SourceContext is a reference to a tree of files. A SourceContext together # If provided, the source code used for the build came from this location.
              # with a path point to a unique revision of a single file or directory.
            &quot;labels&quot;: { # Labels with user defined metadata.
              &quot;a_key&quot;: &quot;A String&quot;,
            },
            &quot;git&quot;: { # A GitSourceContext denotes a particular revision in a third party Git # A SourceContext referring to any third party Git repo (e.g., GitHub).
                # repository (e.g., GitHub).
              &quot;url&quot;: &quot;A String&quot;, # Git repository URL.
              &quot;revisionId&quot;: &quot;A String&quot;, # Git commit hash.
            },
            &quot;gerrit&quot;: { # A SourceContext referring to a Gerrit project. # A SourceContext referring to a Gerrit project.
              &quot;hostUri&quot;: &quot;A String&quot;, # The URI of a running Gerrit instance.
              &quot;revisionId&quot;: &quot;A String&quot;, # A revision (commit) ID.
              &quot;gerritProject&quot;: &quot;A String&quot;, # The full project name within the host. Projects may be nested, so
                  # &quot;project/subproject&quot; is a valid project name. The &quot;repo name&quot; is the
                  # hostURI/project.
              &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                &quot;name&quot;: &quot;A String&quot;, # The alias name.
                &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
              },
            },
            &quot;cloudRepo&quot;: { # A CloudRepoSourceContext denotes a particular revision in a Google Cloud # A SourceContext referring to a revision in a Google Cloud Source Repo.
                # Source Repo.
              &quot;revisionId&quot;: &quot;A String&quot;, # A revision ID.
              &quot;repoId&quot;: { # A unique identifier for a Cloud Repo. # The ID of the repo.
                &quot;projectRepoId&quot;: { # Selects a repo using a Google Cloud Platform project ID (e.g., # A combination of a project ID and a repo name.
                    # winged-cargo-31) and a repo name within that project.
                  &quot;projectId&quot;: &quot;A String&quot;, # The ID of the project.
                  &quot;repoName&quot;: &quot;A String&quot;, # The name of the repo. Leave empty for the default repo.
                },
                &quot;uid&quot;: &quot;A String&quot;, # A server-assigned, globally unique identifier.
              },
              &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                &quot;name&quot;: &quot;A String&quot;, # The alias name.
                &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
              },
            },
          },
        },
        &quot;createTime&quot;: &quot;A String&quot;, # Time at which the build was created.
        &quot;projectId&quot;: &quot;A String&quot;, # ID of the project.
        &quot;logsUri&quot;: &quot;A String&quot;, # URI where any logs for this provenance were written.
        &quot;creator&quot;: &quot;A String&quot;, # E-mail address of the user who initiated this build. Note that this was the
            # user&#x27;s e-mail address at the time the build was initiated; this address may
            # not represent the same end-user for all time.
        &quot;builderVersion&quot;: &quot;A String&quot;, # Version string of the builder at the time this build was executed.
        &quot;commands&quot;: [ # Commands requested by the build.
          { # Command describes a step performed as part of the build pipeline.
            &quot;dir&quot;: &quot;A String&quot;, # Working directory (relative to project source root) used when running this
                # command.
            &quot;waitFor&quot;: [ # The ID(s) of the command(s) that this command depends on.
              &quot;A String&quot;,
            ],
            &quot;env&quot;: [ # Environment variables set before running this command.
              &quot;A String&quot;,
            ],
            &quot;args&quot;: [ # Command-line arguments used when executing this command.
              &quot;A String&quot;,
            ],
            &quot;name&quot;: &quot;A String&quot;, # Required. Name of the command, as presented on the command line, or if the
                # command is packaged as a Docker container, as presented to `docker pull`.
            &quot;id&quot;: &quot;A String&quot;, # Optional unique identifier for this command, used in wait_for to reference
                # this command as a dependency.
          },
        ],
        &quot;builtArtifacts&quot;: [ # Output of the build.
          { # Artifact describes a build product.
            &quot;checksum&quot;: &quot;A String&quot;, # Hash or checksum value of a binary, or Docker Registry 2.0 digest of a
                # container.
            &quot;id&quot;: &quot;A String&quot;, # Artifact ID, if any; for container images, this will be a URL by digest
                # like `gcr.io/projectID/imagename@sha256:123456`.
            &quot;names&quot;: [ # Related artifact names. This may be the path to a binary or jar file, or in
                # the case of a container build, the name used to push the container image to
                # Google Container Registry, as presented to `docker push`. Note that a
                # single Artifact ID can have multiple names, for example if two tags are
                # applied to one image.
              &quot;A String&quot;,
            ],
          },
        ],
        &quot;id&quot;: &quot;A String&quot;, # Required. Unique identifier of the build.
        &quot;buildOptions&quot;: { # Special options applied to this build. This is a catch-all field where
            # build providers can enter any desired additional details.
          &quot;a_key&quot;: &quot;A String&quot;,
        },
      },
    },
    &quot;discovered&quot;: { # Details of a discovery occurrence. # Describes when a resource was discovered.
      &quot;discovered&quot;: { # Provides information about the analysis status of a discovered resource. # Required. Analysis status for the discovered resource.
        &quot;analysisStatusError&quot;: { # The `Status` type defines a logical error model that is suitable for # When an error is encountered this will contain a LocalizedMessage under
            # details to show to the user. The LocalizedMessage is output only and
            # populated by the API.
            # different programming environments, including REST APIs and RPC APIs. It is
            # used by [gRPC](https://github.com/grpc). Each `Status` message contains
            # three pieces of data: error code, error message, and error details.
            #
            # You can find out more about this error model and how to work with it in the
            # [API Design Guide](https://cloud.google.com/apis/design/errors).
          &quot;details&quot;: [ # A list of messages that carry the error details.  There is a common set of
              # message types for APIs to use.
            {
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
            },
          ],
          &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
          &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any
              # user-facing error message should be localized and sent in the
              # google.rpc.Status.details field, or localized by the client.
        },
        &quot;analysisStatus&quot;: &quot;A String&quot;, # The status of discovery for the resource.
        &quot;continuousAnalysis&quot;: &quot;A String&quot;, # Whether the resource is continuously analyzed.
        &quot;lastAnalysisTime&quot;: &quot;A String&quot;, # The last time continuous analysis was done for this resource.
            # Deprecated, do not use.
      },
    },
    &quot;noteName&quot;: &quot;A String&quot;, # Required. Immutable. The analysis note associated with this occurrence, in
        # the form of `projects/[PROVIDER_ID]/notes/[NOTE_ID]`. This field can be
        # used as a filter in list requests.
    &quot;deployment&quot;: { # Details of a deployment occurrence. # Describes the deployment of an artifact on a runtime.
      &quot;deployment&quot;: { # The period during which some deployable was active in a runtime. # Required. Deployment history for the resource.
        &quot;userEmail&quot;: &quot;A String&quot;, # Identity of the user that triggered this deployment.
        &quot;config&quot;: &quot;A String&quot;, # Configuration used to create this deployment.
        &quot;undeployTime&quot;: &quot;A String&quot;, # End of the lifetime of this deployment.
        &quot;platform&quot;: &quot;A String&quot;, # Platform hosting this deployment.
        &quot;deployTime&quot;: &quot;A String&quot;, # Required. Beginning of the lifetime of this deployment.
        &quot;address&quot;: &quot;A String&quot;, # Address of the runtime element hosting this deployment.
        &quot;resourceUri&quot;: [ # Output only. Resource URI for the artifact being deployed taken from
            # the deployable field with the same name.
          &quot;A String&quot;,
        ],
      },
    },
    &quot;createTime&quot;: &quot;A String&quot;, # Output only. The time this occurrence was created.
    &quot;updateTime&quot;: &quot;A String&quot;, # Output only. The time this occurrence was last updated.
    &quot;remediation&quot;: &quot;A String&quot;, # A description of actions that can be taken to remedy the note.
    &quot;intoto&quot;: { # This corresponds to a signed in-toto link - it is made up of one or more # Describes a specific in-toto link.
        # signatures and the in-toto link itself. This is used for occurrences of a
        # Grafeas in-toto note.
      &quot;signed&quot;: { # This corresponds to an in-toto link.
        &quot;command&quot;: [ # This field contains the full command executed for the step. This can also
            # be empty if links are generated for operations that aren&#x27;t directly mapped
            # to a specific command. Each term in the command is an independent string
            # in the list. An example of a command in the in-toto metadata field is:
            # &quot;command&quot;: [&quot;git&quot;, &quot;clone&quot;, &quot;https://github.com/in-toto/demo-project.git&quot;]
          &quot;A String&quot;,
        ],
        &quot;byproducts&quot;: { # Defines an object for the byproducts field in in-toto links. The suggested # ByProducts are data generated as part of a software supply chain step, but
            # are not the actual result of the step.
            # fields are &quot;stderr&quot;, &quot;stdout&quot;, and &quot;return-value&quot;.
          &quot;customValues&quot;: {
            &quot;a_key&quot;: &quot;A String&quot;,
          },
        },
        &quot;environment&quot;: { # Defines an object for the environment field in in-toto links. The suggested # This is a field that can be used to capture information about the
            # environment. It is suggested for this field to contain information that
            # details environment variables, filesystem information, and the present
            # working directory. The recommended structure of this field is:
            # &quot;environment&quot;: {
            #   &quot;custom_values&quot;: {
            #     &quot;variables&quot;: &quot;&lt;ENV&gt;&quot;,
            #     &quot;filesystem&quot;: &quot;&lt;FS&gt;&quot;,
            #     &quot;workdir&quot;: &quot;&lt;CWD&gt;&quot;,
            #     &quot;&lt;ANY OTHER RELEVANT FIELDS&gt;&quot;: &quot;...&quot;
            #   }
            # }
            # fields are &quot;variables&quot;, &quot;filesystem&quot;, and &quot;workdir&quot;.
          &quot;customValues&quot;: {
            &quot;a_key&quot;: &quot;A String&quot;,
          },
        },
        &quot;materials&quot;: [ # Materials are the supply chain artifacts that go into the step and are used
            # for the operation performed. The key of the map is the path of the artifact
            # and the structure contains the recorded hash information. An example is:
            # &quot;materials&quot;: [
            #   {
            #     &quot;resource_uri&quot;: &quot;foo/bar&quot;,
            #     &quot;hashes&quot;: {
            #       &quot;sha256&quot;: &quot;ebebf...&quot;,
            #       &lt;OTHER HASH ALGORITHMS&gt;: &lt;HASH VALUE&gt;
            #     }
            #   }
            # ]
          {
            &quot;hashes&quot;: { # Defines a hash object for use in Materials and Products.
              &quot;sha256&quot;: &quot;A String&quot;,
            },
            &quot;resourceUri&quot;: &quot;A String&quot;,
          },
        ],
        &quot;products&quot;: [ # Products are the supply chain artifacts generated as a result of the step.
            # The structure is identical to that of materials.
          {
            &quot;hashes&quot;: { # Defines a hash object for use in Materials and Products.
              &quot;sha256&quot;: &quot;A String&quot;,
            },
            &quot;resourceUri&quot;: &quot;A String&quot;,
          },
        ],
      },
      &quot;signatures&quot;: [
        { # A signature object consists of the KeyID used and the signature itself.
          &quot;sig&quot;: &quot;A String&quot;,
          &quot;keyid&quot;: &quot;A String&quot;,
        },
      ],
    },
    &quot;derivedImage&quot;: { # Details of an image occurrence. # Describes how this resource derives from the basis in the associated
        # note.
      &quot;derivedImage&quot;: { # Derived describes the derived image portion (Occurrence) of the DockerImage # Required. Immutable. The child image derived from the base image.
          # relationship. This image would be produced from a Dockerfile with FROM
          # &lt;DockerImage.Basis in attached Note&gt;.
        &quot;fingerprint&quot;: { # A set of properties that uniquely identify a given Docker image. # Required. The fingerprint of the derived image.
          &quot;v2Blob&quot;: [ # Required. The ordered list of v2 blobs that represent a given image.
            &quot;A String&quot;,
          ],
          &quot;v1Name&quot;: &quot;A String&quot;, # Required. The layer ID of the final layer in the Docker image&#x27;s v1
              # representation.
          &quot;v2Name&quot;: &quot;A String&quot;, # Output only. The name of the image&#x27;s v2 blobs computed via:
              #   [bottom] := v2_blobbottom := sha256(v2_blob[N] + &quot; &quot; + v2_name[N+1])
              # Only the name of the final blob is kept.
        },
        &quot;layerInfo&quot;: [ # This contains layer-specific metadata, if populated it has length
            # &quot;distance&quot; and is ordered with [distance] being the layer immediately
            # following the base image and [1] being the final layer.
          { # Layer holds metadata specific to a layer of a Docker image.
            &quot;directive&quot;: &quot;A String&quot;, # Required. The recovered Dockerfile directive used to construct this layer.
            &quot;arguments&quot;: &quot;A String&quot;, # The recovered arguments to the Dockerfile directive.
          },
        ],
        &quot;distance&quot;: 42, # Output only. The number of layers by which this image differs from the
            # associated image basis.
        &quot;baseResourceUrl&quot;: &quot;A String&quot;, # Output only. This contains the base image URL for the derived image
            # occurrence.
      },
    },
  }</pre>
</div>

<div class="method">
    <code class="details" id="getIamPolicy">getIamPolicy(resource, body=None, x__xgafv=None)</code>
  <pre>Gets the access control policy for a note or an occurrence resource.
Requires `containeranalysis.notes.setIamPolicy` or
`containeranalysis.occurrences.setIamPolicy` permission if the resource is
a note or occurrence, respectively.

The resource takes the format `projects/[PROJECT_ID]/notes/[NOTE_ID]` for
notes and `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]` for
occurrences.

Args:
  resource: string, REQUIRED: The resource for which the policy is being requested.
See the operation documentation for the appropriate value for this field. (required)
  body: object, The request body.
    The object takes the form of:

{ # Request message for `GetIamPolicy` method.
    &quot;options&quot;: { # Encapsulates settings provided to GetIamPolicy. # OPTIONAL: A `GetPolicyOptions` object for specifying options to
        # `GetIamPolicy`.
      &quot;requestedPolicyVersion&quot;: 42, # Optional. The policy format version to be returned.
          #
          # Valid values are 0, 1, and 3. Requests specifying an invalid value will be
          # rejected.
          #
          # Requests for policies with any conditional bindings must specify version 3.
          # Policies without any conditional bindings may specify any valid value or
          # leave the field unset.
          #
          # To learn which resources support conditions in their IAM policies, see the
          # [IAM
          # documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
    },
  }

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # An Identity and Access Management (IAM) policy, which specifies access
      # controls for Google Cloud resources.
      #
      #
      # A `Policy` is a collection of `bindings`. A `binding` binds one or more
      # `members` to a single `role`. Members can be user accounts, service accounts,
      # Google groups, and domains (such as G Suite). A `role` is a named list of
      # permissions; each `role` can be an IAM predefined role or a user-created
      # custom role.
      #
      # For some types of Google Cloud resources, a `binding` can also specify a
      # `condition`, which is a logical expression that allows access to a resource
      # only if the expression evaluates to `true`. A condition can add constraints
      # based on attributes of the request, the resource, or both. To learn which
      # resources support conditions in their IAM policies, see the
      # [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
      #
      # **JSON example:**
      #
      #     {
      #       &quot;bindings&quot;: [
      #         {
      #           &quot;role&quot;: &quot;roles/resourcemanager.organizationAdmin&quot;,
      #           &quot;members&quot;: [
      #             &quot;user:mike@example.com&quot;,
      #             &quot;group:admins@example.com&quot;,
      #             &quot;domain:google.com&quot;,
      #             &quot;serviceAccount:my-project-id@appspot.gserviceaccount.com&quot;
      #           ]
      #         },
      #         {
      #           &quot;role&quot;: &quot;roles/resourcemanager.organizationViewer&quot;,
      #           &quot;members&quot;: [
      #             &quot;user:eve@example.com&quot;
      #           ],
      #           &quot;condition&quot;: {
      #             &quot;title&quot;: &quot;expirable access&quot;,
      #             &quot;description&quot;: &quot;Does not grant access after Sep 2020&quot;,
      #             &quot;expression&quot;: &quot;request.time &lt; timestamp(&#x27;2020-10-01T00:00:00.000Z&#x27;)&quot;,
      #           }
      #         }
      #       ],
      #       &quot;etag&quot;: &quot;BwWWja0YfJA=&quot;,
      #       &quot;version&quot;: 3
      #     }
      #
      # **YAML example:**
      #
      #     bindings:
      #     - members:
      #       - user:mike@example.com
      #       - group:admins@example.com
      #       - domain:google.com
      #       - serviceAccount:my-project-id@appspot.gserviceaccount.com
      #       role: roles/resourcemanager.organizationAdmin
      #     - members:
      #       - user:eve@example.com
      #       role: roles/resourcemanager.organizationViewer
      #       condition:
      #         title: expirable access
      #         description: Does not grant access after Sep 2020
      #         expression: request.time &lt; timestamp(&#x27;2020-10-01T00:00:00.000Z&#x27;)
      #     - etag: BwWWja0YfJA=
      #     - version: 3
      #
      # For a description of IAM and its features, see the
      # [IAM documentation](https://cloud.google.com/iam/docs/).
    &quot;etag&quot;: &quot;A String&quot;, # `etag` is used for optimistic concurrency control as a way to help
        # prevent simultaneous updates of a policy from overwriting each other.
        # It is strongly suggested that systems make use of the `etag` in the
        # read-modify-write cycle to perform policy updates in order to avoid race
        # conditions: An `etag` is returned in the response to `getIamPolicy`, and
        # systems are expected to put that etag in the request to `setIamPolicy` to
        # ensure that their change will be applied to the same version of the policy.
        #
        # **Important:** If you use IAM Conditions, you must include the `etag` field
        # whenever you call `setIamPolicy`. If you omit this field, then IAM allows
        # you to overwrite a version `3` policy with a version `1` policy, and all of
        # the conditions in the version `3` policy are lost.
    &quot;version&quot;: 42, # Specifies the format of the policy.
        #
        # Valid values are `0`, `1`, and `3`. Requests that specify an invalid value
        # are rejected.
        #
        # Any operation that affects conditional role bindings must specify version
        # `3`. This requirement applies to the following operations:
        #
        # * Getting a policy that includes a conditional role binding
        # * Adding a conditional role binding to a policy
        # * Changing a conditional role binding in a policy
        # * Removing any role binding, with or without a condition, from a policy
        #   that includes conditions
        #
        # **Important:** If you use IAM Conditions, you must include the `etag` field
        # whenever you call `setIamPolicy`. If you omit this field, then IAM allows
        # you to overwrite a version `3` policy with a version `1` policy, and all of
        # the conditions in the version `3` policy are lost.
        #
        # If a policy does not include any conditions, operations on that policy may
        # specify any valid version or leave the field unset.
        #
        # To learn which resources support conditions in their IAM policies, see the
        # [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
    &quot;bindings&quot;: [ # Associates a list of `members` to a `role`. Optionally, may specify a
        # `condition` that determines how and when the `bindings` are applied. Each
        # of the `bindings` must contain at least one member.
      { # Associates `members` with a `role`.
        &quot;condition&quot;: { # Represents a textual expression in the Common Expression Language (CEL) # The condition that is associated with this binding.
            #
            # If the condition evaluates to `true`, then this binding applies to the
            # current request.
            #
            # If the condition evaluates to `false`, then this binding does not apply to
            # the current request. However, a different role binding might grant the same
            # role to one or more of the members in this binding.
            #
            # To learn which resources support conditions in their IAM policies, see the
            # [IAM
            # documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
            # syntax. CEL is a C-like expression language. The syntax and semantics of CEL
            # are documented at https://github.com/google/cel-spec.
            #
            # Example (Comparison):
            #
            #     title: &quot;Summary size limit&quot;
            #     description: &quot;Determines if a summary is less than 100 chars&quot;
            #     expression: &quot;document.summary.size() &lt; 100&quot;
            #
            # Example (Equality):
            #
            #     title: &quot;Requestor is owner&quot;
            #     description: &quot;Determines if requestor is the document owner&quot;
            #     expression: &quot;document.owner == request.auth.claims.email&quot;
            #
            # Example (Logic):
            #
            #     title: &quot;Public documents&quot;
            #     description: &quot;Determine whether the document should be publicly visible&quot;
            #     expression: &quot;document.type != &#x27;private&#x27; &amp;&amp; document.type != &#x27;internal&#x27;&quot;
            #
            # Example (Data Manipulation):
            #
            #     title: &quot;Notification string&quot;
            #     description: &quot;Create a notification string with a timestamp.&quot;
            #     expression: &quot;&#x27;New message received at &#x27; + string(document.create_time)&quot;
            #
            # The exact variables and functions that may be referenced within an expression
            # are determined by the service that evaluates it. See the service
            # documentation for additional information.
          &quot;description&quot;: &quot;A String&quot;, # Optional. Description of the expression. This is a longer text which
              # describes the expression, e.g. when hovered over it in a UI.
          &quot;expression&quot;: &quot;A String&quot;, # Textual representation of an expression in Common Expression Language
              # syntax.
          &quot;title&quot;: &quot;A String&quot;, # Optional. Title for the expression, i.e. a short string describing
              # its purpose. This can be used e.g. in UIs which allow to enter the
              # expression.
          &quot;location&quot;: &quot;A String&quot;, # Optional. String indicating the location of the expression for error
              # reporting, e.g. a file name and a position in the file.
        },
        &quot;members&quot;: [ # Specifies the identities requesting access for a Cloud Platform resource.
            # `members` can have the following values:
            #
            # * `allUsers`: A special identifier that represents anyone who is
            #    on the internet; with or without a Google account.
            #
            # * `allAuthenticatedUsers`: A special identifier that represents anyone
            #    who is authenticated with a Google account or a service account.
            #
            # * `user:{emailid}`: An email address that represents a specific Google
            #    account. For example, `alice@example.com` .
            #
            #
            # * `serviceAccount:{emailid}`: An email address that represents a service
            #    account. For example, `my-other-app@appspot.gserviceaccount.com`.
            #
            # * `group:{emailid}`: An email address that represents a Google group.
            #    For example, `admins@example.com`.
            #
            # * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique
            #    identifier) representing a user that has been recently deleted. For
            #    example, `alice@example.com?uid=123456789012345678901`. If the user is
            #    recovered, this value reverts to `user:{emailid}` and the recovered user
            #    retains the role in the binding.
            #
            # * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus
            #    unique identifier) representing a service account that has been recently
            #    deleted. For example,
            #    `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`.
            #    If the service account is undeleted, this value reverts to
            #    `serviceAccount:{emailid}` and the undeleted service account retains the
            #    role in the binding.
            #
            # * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique
            #    identifier) representing a Google group that has been recently
            #    deleted. For example, `admins@example.com?uid=123456789012345678901`. If
            #    the group is recovered, this value reverts to `group:{emailid}` and the
            #    recovered group retains the role in the binding.
            #
            #
            # * `domain:{domain}`: The G Suite domain (primary) that represents all the
            #    users of that domain. For example, `google.com` or `example.com`.
            #
          &quot;A String&quot;,
        ],
        &quot;role&quot;: &quot;A String&quot;, # Role that is assigned to `members`.
            # For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
      },
    ],
  }</pre>
</div>

<div class="method">
    <code class="details" id="getNotes">getNotes(name, x__xgafv=None)</code>
  <pre>Gets the note attached to the specified occurrence. Consumer projects can
use this method to get a note that belongs to a provider project.

Args:
  name: string, Required. The name of the occurrence in the form of
`projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`. (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A type of analysis that can be done for a resource.
    &quot;attestationAuthority&quot;: { # Note kind that represents a logical attestation &quot;role&quot; or &quot;authority&quot;. For # A note describing an attestation role.
        # example, an organization might have one `Authority` for &quot;QA&quot; and one for
        # &quot;build&quot;. This note is intended to act strictly as a grouping mechanism for
        # the attached occurrences (Attestations). This grouping mechanism also
        # provides a security boundary, since IAM ACLs gate the ability for a principle
        # to attach an occurrence to a given note. It also provides a single point of
        # lookup to find all attached attestation occurrences, even if they don&#x27;t all
        # live in the same project.
      &quot;hint&quot;: { # This submessage provides human-readable hints about the purpose of the # Hint hints at the purpose of the attestation authority.
          # authority. Because the name of a note acts as its resource reference, it is
          # important to disambiguate the canonical name of the Note (which might be a
          # UUID for security purposes) from &quot;readable&quot; names more suitable for debug
          # output. Note that these hints should not be used to look up authorities in
          # security sensitive contexts, such as when looking up attestations to
          # verify.
        &quot;humanReadableName&quot;: &quot;A String&quot;, # Required. The human readable name of this attestation authority, for
            # example &quot;qa&quot;.
      },
    },
    &quot;name&quot;: &quot;A String&quot;, # Output only. The name of the note in the form of
        # `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
    &quot;vulnerability&quot;: { # Vulnerability provides metadata about a security vulnerability in a Note. # A note describing a package vulnerability.
      &quot;cvssV3&quot;: { # Common Vulnerability Scoring System version 3. # The full description of the CVSSv3.
          # For details, see https://www.first.org/cvss/specification-document
        &quot;baseScore&quot;: 3.14, # The base score is a function of the base metric scores.
        &quot;scope&quot;: &quot;A String&quot;,
        &quot;integrityImpact&quot;: &quot;A String&quot;,
        &quot;exploitabilityScore&quot;: 3.14,
        &quot;impactScore&quot;: 3.14,
        &quot;attackComplexity&quot;: &quot;A String&quot;,
        &quot;availabilityImpact&quot;: &quot;A String&quot;,
        &quot;privilegesRequired&quot;: &quot;A String&quot;,
        &quot;userInteraction&quot;: &quot;A String&quot;,
        &quot;attackVector&quot;: &quot;A String&quot;, # Base Metrics
            # Represents the intrinsic characteristics of a vulnerability that are
            # constant over time and across user environments.
        &quot;confidentialityImpact&quot;: &quot;A String&quot;,
      },
      &quot;sourceUpdateTime&quot;: &quot;A String&quot;, # The time this information was last changed at the source. This is an
          # upstream timestamp from the underlying information source - e.g. Ubuntu
          # security tracker.
      &quot;windowsDetails&quot;: [ # Windows details get their own format because the information format and
          # model don&#x27;t match a normal detail. Specifically Windows updates are done as
          # patches, thus Windows vulnerabilities really are a missing package, rather
          # than a package being at an incorrect version.
        {
          &quot;name&quot;: &quot;A String&quot;, # Required. The name of the vulnerability.
          &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in
              # [cpe format](https://cpe.mitre.org/specification/) in which the
              # vulnerability manifests. Examples include distro or storage location for
              # vulnerable jar.
          &quot;description&quot;: &quot;A String&quot;, # The description of the vulnerability.
          &quot;fixingKbs&quot;: [ # Required. The names of the KBs which have hotfixes to mitigate this
              # vulnerability. Note that there may be multiple hotfixes (and thus
              # multiple KBs) that mitigate a given vulnerability. Currently any listed
              # kb&#x27;s presence is considered a fix.
            {
              &quot;name&quot;: &quot;A String&quot;, # The KB name (generally of the form KB[0-9]+ i.e. KB123456).
              &quot;url&quot;: &quot;A String&quot;, # A link to the KB in the Windows update catalog -
                  # https://www.catalog.update.microsoft.com/
            },
          ],
        },
      ],
      &quot;details&quot;: [ # All information about the package to specifically identify this
          # vulnerability. One entry per (version range and cpe_uri) the package
          # vulnerability has manifested in.
        { # Identifies all appearances of this vulnerability in the package for a
            # specific distro/location. For example: glibc in
            # cpe:/o:debian:debian_linux:8 for versions 2.1 - 2.2
          &quot;isObsolete&quot;: True or False, # Whether this detail is obsolete. Occurrences are expected not to point to
              # obsolete details.
          &quot;sourceUpdateTime&quot;: &quot;A String&quot;, # The time this information was last changed at the source. This is an
              # upstream timestamp from the underlying information source - e.g. Ubuntu
              # security tracker.
          &quot;packageType&quot;: &quot;A String&quot;, # The type of package; whether native or non native(ruby gems, node.js
              # packages etc).
          &quot;fixedLocation&quot;: { # The location of the vulnerability. # The fix for this specific package version.
            &quot;package&quot;: &quot;A String&quot;, # Required. The package being described.
            &quot;version&quot;: { # Version contains structured information about the version of a package. # Required. The version of the package being described.
              &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
              &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                  # name.
              &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                  # versions.
              &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
            },
            &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in [cpe format](https://cpe.mitre.org/specification/)
                # format. Examples include distro or storage location for vulnerable jar.
          },
          &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in
              # [cpe format](https://cpe.mitre.org/specification/) in which the
              # vulnerability manifests. Examples include distro or storage location for
              # vulnerable jar.
          &quot;description&quot;: &quot;A String&quot;, # A vendor-specific description of this note.
          &quot;severityName&quot;: &quot;A String&quot;, # The severity (eg: distro assigned severity) for this vulnerability.
          &quot;minAffectedVersion&quot;: { # Version contains structured information about the version of a package. # The min version of the package in which the vulnerability exists.
            &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
            &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                # name.
            &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                # versions.
            &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
          },
          &quot;maxAffectedVersion&quot;: { # Version contains structured information about the version of a package. # The max version of the package in which the vulnerability exists.
            &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
            &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                # name.
            &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                # versions.
            &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
          },
          &quot;package&quot;: &quot;A String&quot;, # Required. The name of the package where the vulnerability was found.
        },
      ],
      &quot;severity&quot;: &quot;A String&quot;, # Note provider assigned impact of the vulnerability.
      &quot;cvssScore&quot;: 3.14, # The CVSS score for this vulnerability.
    },
    &quot;relatedNoteNames&quot;: [ # Other notes related to this note.
      &quot;A String&quot;,
    ],
    &quot;build&quot;: { # Note holding the version of the provider&#x27;s builder and the signature of the # A note describing build provenance for a verifiable build.
        # provenance message in the build details occurrence.
      &quot;signature&quot;: { # Message encapsulating the signature of the verified build. # Signature of the build in occurrences pointing to this build note
          # containing build details.
        &quot;keyType&quot;: &quot;A String&quot;, # The type of the key, either stored in `public_key` or referenced in
            # `key_id`.
        &quot;signature&quot;: &quot;A String&quot;, # Required. Signature of the related `BuildProvenance`. In JSON, this is
            # base-64 encoded.
        &quot;publicKey&quot;: &quot;A String&quot;, # Public key of the builder which can be used to verify that the related
            # findings are valid and unchanged. If `key_type` is empty, this defaults
            # to PEM encoded public keys.
            #
            # This field may be empty if `key_id` references an external key.
            #
            # For Cloud Build based signatures, this is a PEM encoded public
            # key. To verify the Cloud Build signature, place the contents of
            # this field into a file (public.pem). The signature field is base64-decoded
            # into its binary representation in signature.bin, and the provenance bytes
            # from `BuildDetails` are base64-decoded into a binary representation in
            # signed.bin. OpenSSL can then verify the signature:
            # `openssl sha256 -verify public.pem -signature signature.bin signed.bin`
        &quot;keyId&quot;: &quot;A String&quot;, # An ID for the key used to sign. This could be either an ID for the key
            # stored in `public_key` (such as the ID or fingerprint for a PGP key, or the
            # CN for a cert), or a reference to an external key (such as a reference to a
            # key in Cloud Key Management Service).
      },
      &quot;builderVersion&quot;: &quot;A String&quot;, # Required. Immutable. Version of the builder which produced this build.
    },
    &quot;package&quot;: { # This represents a particular package that is distributed over various # A note describing a package hosted by various package managers.
        # channels. E.g., glibc (aka libc6) is distributed by many, at various
        # versions.
      &quot;name&quot;: &quot;A String&quot;, # Required. Immutable. The name of the package.
      &quot;distribution&quot;: [ # The various channels by which a package is distributed.
        { # This represents a particular channel of distribution for a given package.
            # E.g., Debian&#x27;s jessie-backports dpkg mirror.
          &quot;maintainer&quot;: &quot;A String&quot;, # A freeform string denoting the maintainer of this package.
          &quot;latestVersion&quot;: { # Version contains structured information about the version of a package. # The latest available version of this package in this distribution channel.
            &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
            &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                # name.
            &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                # versions.
            &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
          },
          &quot;description&quot;: &quot;A String&quot;, # The distribution channel-specific description of this package.
          &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The cpe_uri in [CPE format](https://cpe.mitre.org/specification/)
              # denoting the package manager version distributing a package.
          &quot;url&quot;: &quot;A String&quot;, # The distribution channel-specific homepage for this package.
          &quot;architecture&quot;: &quot;A String&quot;, # The CPU architecture for which packages in this distribution channel were
              # built.
        },
      ],
    },
    &quot;createTime&quot;: &quot;A String&quot;, # Output only. The time this note was created. This field can be used as a
        # filter in list requests.
    &quot;discovery&quot;: { # A note that indicates a type of analysis a provider would perform. This note # A note describing the initial analysis of a resource.
        # exists in a provider&#x27;s project. A `Discovery` occurrence is created in a
        # consumer&#x27;s project at the start of analysis.
      &quot;analysisKind&quot;: &quot;A String&quot;, # Required. Immutable. The kind of analysis that is handled by this
          # discovery.
    },
    &quot;updateTime&quot;: &quot;A String&quot;, # Output only. The time this note was last updated. This field can be used as
        # a filter in list requests.
    &quot;intoto&quot;: { # This contains the fields corresponding to the definition of a software supply # A note describing an in-toto link.
        # chain step in an in-toto layout. This information goes into a Grafeas note.
      &quot;expectedProducts&quot;: [
        { # Defines an object to declare an in-toto artifact rule
          &quot;artifactRule&quot;: [
            &quot;A String&quot;,
          ],
        },
      ],
      &quot;stepName&quot;: &quot;A String&quot;, # This field identifies the name of the step in the supply chain.
      &quot;signingKeys&quot;: [ # This field contains the public keys that can be used to verify the
          # signatures on the step metadata.
        { # This defines the format used to record keys used in the software supply
            # chain. An in-toto link is attested using one or more keys defined in the
            # in-toto layout. An example of this is:
            # {
            #   &quot;key_id&quot;: &quot;776a00e29f3559e0141b3b096f696abc6cfb0c657ab40f441132b345b0...&quot;,
            #   &quot;key_type&quot;: &quot;rsa&quot;,
            #   &quot;public_key_value&quot;: &quot;-----BEGIN PUBLIC KEY-----\nMIIBojANBgkqhkiG9w0B...&quot;,
            #   &quot;key_scheme&quot;: &quot;rsassa-pss-sha256&quot;
            # }
            # The format for in-toto&#x27;s key definition can be found in section 4.2 of the
            # in-toto specification.
          &quot;keyId&quot;: &quot;A String&quot;, # key_id is an identifier for the signing key.
          &quot;publicKeyValue&quot;: &quot;A String&quot;, # This field contains the actual public key.
          &quot;keyType&quot;: &quot;A String&quot;, # This field identifies the specific signing method. Eg: &quot;rsa&quot;, &quot;ed25519&quot;,
              # and &quot;ecdsa&quot;.
          &quot;keyScheme&quot;: &quot;A String&quot;, # This field contains the corresponding signature scheme.
              # Eg: &quot;rsassa-pss-sha256&quot;.
        },
      ],
      &quot;threshold&quot;: &quot;A String&quot;, # This field contains a value that indicates the minimum number of keys that
          # need to be used to sign the step&#x27;s in-toto link.
      &quot;expectedMaterials&quot;: [ # The following fields contain in-toto artifact rules identifying the
          # artifacts that enter this supply chain step, and exit the supply chain
          # step, i.e. materials and products of the step.
        { # Defines an object to declare an in-toto artifact rule
          &quot;artifactRule&quot;: [
            &quot;A String&quot;,
          ],
        },
      ],
      &quot;expectedCommand&quot;: [ # This field contains the expected command used to perform the step.
        &quot;A String&quot;,
      ],
    },
    &quot;relatedUrl&quot;: [ # URLs associated with this note.
      { # Metadata for any related URL information.
        &quot;url&quot;: &quot;A String&quot;, # Specific URL associated with the resource.
        &quot;label&quot;: &quot;A String&quot;, # Label to describe usage of the URL.
      },
    ],
    &quot;expirationTime&quot;: &quot;A String&quot;, # Time of expiration for this note. Empty if note does not expire.
    &quot;baseImage&quot;: { # Basis describes the base image portion (Note) of the DockerImage # A note describing a base image.
        # relationship. Linked occurrences are derived from this or an
        # equivalent image via:
        #   FROM &lt;Basis.resource_url&gt;
        # Or an equivalent reference, e.g. a tag of the resource_url.
      &quot;fingerprint&quot;: { # A set of properties that uniquely identify a given Docker image. # Required. Immutable. The fingerprint of the base image.
        &quot;v2Blob&quot;: [ # Required. The ordered list of v2 blobs that represent a given image.
          &quot;A String&quot;,
        ],
        &quot;v1Name&quot;: &quot;A String&quot;, # Required. The layer ID of the final layer in the Docker image&#x27;s v1
            # representation.
        &quot;v2Name&quot;: &quot;A String&quot;, # Output only. The name of the image&#x27;s v2 blobs computed via:
            #   [bottom] := v2_blobbottom := sha256(v2_blob[N] + &quot; &quot; + v2_name[N+1])
            # Only the name of the final blob is kept.
      },
      &quot;resourceUrl&quot;: &quot;A String&quot;, # Required. Immutable. The resource_url for the resource representing the
          # basis of associated occurrence images.
    },
    &quot;kind&quot;: &quot;A String&quot;, # Output only. The type of analysis. This field can be used as a filter in
        # list requests.
    &quot;longDescription&quot;: &quot;A String&quot;, # A detailed description of this note.
    &quot;deployable&quot;: { # An artifact that can be deployed in some runtime. # A note describing something that can be deployed.
      &quot;resourceUri&quot;: [ # Required. Resource URI for the artifact being deployed.
        &quot;A String&quot;,
      ],
    },
    &quot;shortDescription&quot;: &quot;A String&quot;, # A one sentence description of this note.
  }</pre>
</div>

<div class="method">
    <code class="details" id="getVulnerabilitySummary">getVulnerabilitySummary(parent, filter=None, x__xgafv=None)</code>
  <pre>Gets a summary of the number and severity of occurrences.

Args:
  parent: string, Required. The name of the project to get a vulnerability summary for in the form of
`projects/[PROJECT_ID]`. (required)
  filter: string, The filter expression.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A summary of how many vulnerability occurrences there are per resource and
      # severity type.
    &quot;counts&quot;: [ # A listing by resource of the number of fixable and total vulnerabilities.
      { # Per resource and severity counts of fixable and total vulnerabilities.
        &quot;resource&quot;: { # An entity that can have metadata. For example, a Docker image. # The affected resource.
          &quot;name&quot;: &quot;A String&quot;, # Deprecated, do not use. Use uri instead.
              #
              # The name of the resource. For example, the name of a Docker image -
              # &quot;Debian&quot;.
          &quot;contentHash&quot;: { # Container message for hash values. # Deprecated, do not use. Use uri instead.
              #
              # The hash of the resource content. For example, the Docker digest.
            &quot;type&quot;: &quot;A String&quot;, # Required. The type of hash that was performed.
            &quot;value&quot;: &quot;A String&quot;, # Required. The hash value.
          },
          &quot;uri&quot;: &quot;A String&quot;, # Required. The unique URI of the resource. For example,
              # `https://gcr.io/project/image@sha256:foo` for a Docker image.
        },
        &quot;severity&quot;: &quot;A String&quot;, # The severity for this count. SEVERITY_UNSPECIFIED indicates total across
            # all severities.
        &quot;totalCount&quot;: &quot;A String&quot;, # The total number of vulnerabilities associated with this resource.
        &quot;fixableCount&quot;: &quot;A String&quot;, # The number of fixable vulnerabilities associated with this resource.
      },
    ],
  }</pre>
</div>

<div class="method">
    <code class="details" id="list">list(parent, filter=None, pageToken=None, pageSize=None, x__xgafv=None)</code>
  <pre>Lists occurrences for the specified project.

Args:
  parent: string, Required. The name of the project to list occurrences for in the form of
`projects/[PROJECT_ID]`. (required)
  filter: string, The filter expression.
  pageToken: string, Token to provide to skip to a particular spot in the list.
  pageSize: integer, Number of occurrences to return in the list. Must be positive. Max allowed
page size is 1000. If not specified, page size defaults to 20.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response for listing occurrences.
    &quot;occurrences&quot;: [ # The occurrences requested.
      { # An instance of an analysis type that has been found on a resource.
        &quot;kind&quot;: &quot;A String&quot;, # Output only. This explicitly denotes which of the occurrence details are
            # specified. This field can be used as a filter in list requests.
        &quot;resource&quot;: { # An entity that can have metadata. For example, a Docker image. # Required. Immutable. The resource for which the occurrence applies.
          &quot;name&quot;: &quot;A String&quot;, # Deprecated, do not use. Use uri instead.
              #
              # The name of the resource. For example, the name of a Docker image -
              # &quot;Debian&quot;.
          &quot;contentHash&quot;: { # Container message for hash values. # Deprecated, do not use. Use uri instead.
              #
              # The hash of the resource content. For example, the Docker digest.
            &quot;type&quot;: &quot;A String&quot;, # Required. The type of hash that was performed.
            &quot;value&quot;: &quot;A String&quot;, # Required. The hash value.
          },
          &quot;uri&quot;: &quot;A String&quot;, # Required. The unique URI of the resource. For example,
              # `https://gcr.io/project/image@sha256:foo` for a Docker image.
        },
        &quot;attestation&quot;: { # Details of an attestation occurrence. # Describes an attestation of an artifact.
          &quot;attestation&quot;: { # Occurrence that represents a single &quot;attestation&quot;. The authenticity of an # Required. Attestation for the resource.
              # attestation can be verified using the attached signature. If the verifier
              # trusts the public key of the signer, then verifying the signature is
              # sufficient to establish trust. In this circumstance, the authority to which
              # this attestation is attached is primarily useful for look-up (how to find
              # this attestation if you already know the authority and artifact to be
              # verified) and intent (which authority was this attestation intended to sign
              # for).
            &quot;pgpSignedAttestation&quot;: { # An attestation wrapper with a PGP-compatible signature. This message only # A PGP signed attestation.
                # supports `ATTACHED` signatures, where the payload that is signed is included
                # alongside the signature itself in the same file.
              &quot;contentType&quot;: &quot;A String&quot;, # Type (for example schema) of the attestation payload that was signed.
                  # The verifier must ensure that the provided type is one that the verifier
                  # supports, and that the attestation payload is a valid instantiation of that
                  # type (for example by validating a JSON schema).
              &quot;signature&quot;: &quot;A String&quot;, # Required. The raw content of the signature, as output by GNU Privacy Guard
                  # (GPG) or equivalent. Since this message only supports attached signatures,
                  # the payload that was signed must be attached. While the signature format
                  # supported is dependent on the verification implementation, currently only
                  # ASCII-armored (`--armor` to gpg), non-clearsigned (`--sign` rather than
                  # `--clearsign` to gpg) are supported. Concretely, `gpg --sign --armor
                  # --output=signature.gpg payload.json` will create the signature content
                  # expected in this field in `signature.gpg` for the `payload.json`
                  # attestation payload.
              &quot;pgpKeyId&quot;: &quot;A String&quot;, # The cryptographic fingerprint of the key used to generate the signature,
                  # as output by, e.g. `gpg --list-keys`. This should be the version 4, full
                  # 160-bit fingerprint, expressed as a 40 character hexidecimal string. See
                  # https://tools.ietf.org/html/rfc4880#section-12.2 for details.
                  # Implementations may choose to acknowledge &quot;LONG&quot;, &quot;SHORT&quot;, or other
                  # abbreviated key IDs, but only the full fingerprint is guaranteed to work.
                  # In gpg, the full fingerprint can be retrieved from the `fpr` field
                  # returned when calling --list-keys with --with-colons.  For example:
                  # ```
                  # gpg --with-colons --with-fingerprint --force-v4-certs \
                  #     --list-keys attester@example.com
                  # tru::1:1513631572:0:3:1:5
                  # pub:...&lt;SNIP&gt;...
                  # fpr:::::::::24FF6481B76AC91E66A00AC657A93A81EF3AE6FB:
                  # ```
                  # Above, the fingerprint is `24FF6481B76AC91E66A00AC657A93A81EF3AE6FB`.
            },
            &quot;genericSignedAttestation&quot;: { # An attestation wrapper that uses the Grafeas `Signature` message.
                # This attestation must define the `serialized_payload` that the `signatures`
                # verify and any metadata necessary to interpret that plaintext.  The
                # signatures should always be over the `serialized_payload` bytestring.
              &quot;contentType&quot;: &quot;A String&quot;, # Type (for example schema) of the attestation payload that was signed.
                  # The verifier must ensure that the provided type is one that the verifier
                  # supports, and that the attestation payload is a valid instantiation of that
                  # type (for example by validating a JSON schema).
              &quot;signatures&quot;: [ # One or more signatures over `serialized_payload`.  Verifier implementations
                  # should consider this attestation message verified if at least one
                  # `signature` verifies `serialized_payload`.  See `Signature` in common.proto
                  # for more details on signature structure and verification.
                { # Verifiers (e.g. Kritis implementations) MUST verify signatures
                    # with respect to the trust anchors defined in policy (e.g. a Kritis policy).
                    # Typically this means that the verifier has been configured with a map from
                    # `public_key_id` to public key material (and any required parameters, e.g.
                    # signing algorithm).
                    #
                    # In particular, verification implementations MUST NOT treat the signature
                    # `public_key_id` as anything more than a key lookup hint. The `public_key_id`
                    # DOES NOT validate or authenticate a public key; it only provides a mechanism
                    # for quickly selecting a public key ALREADY CONFIGURED on the verifier through
                    # a trusted channel. Verification implementations MUST reject signatures in any
                    # of the following circumstances:
                    #   * The `public_key_id` is not recognized by the verifier.
                    #   * The public key that `public_key_id` refers to does not verify the
                    #     signature with respect to the payload.
                    #
                    # The `signature` contents SHOULD NOT be &quot;attached&quot; (where the payload is
                    # included with the serialized `signature` bytes). Verifiers MUST ignore any
                    # &quot;attached&quot; payload and only verify signatures with respect to explicitly
                    # provided payload (e.g. a `payload` field on the proto message that holds
                    # this Signature, or the canonical serialization of the proto message that
                    # holds this signature).
                  &quot;publicKeyId&quot;: &quot;A String&quot;, # The identifier for the public key that verifies this signature.
                      #   * The `public_key_id` is required.
                      #   * The `public_key_id` MUST be an RFC3986 conformant URI.
                      #   * When possible, the `public_key_id` SHOULD be an immutable reference,
                      #     such as a cryptographic digest.
                      #
                      # Examples of valid `public_key_id`s:
                      #
                      # OpenPGP V4 public key fingerprint:
                      #   * &quot;openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA&quot;
                      # See https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr for more
                      # details on this scheme.
                      #
                      # RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER
                      # serialization):
                      #   * &quot;ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU&quot;
                      #   * &quot;nih:///sha-256;703f68f42aba2c6de30f488a5ea122fef76324679c9bf89791ba95a1271589a5&quot;
                  &quot;signature&quot;: &quot;A String&quot;, # The content of the signature, an opaque bytestring.
                      # The payload that this signature verifies MUST be unambiguously provided
                      # with the Signature during verification. A wrapper message might provide
                      # the payload explicitly. Alternatively, a message might have a canonical
                      # serialization that can always be unambiguously computed to derive the
                      # payload.
                },
              ],
              &quot;serializedPayload&quot;: &quot;A String&quot;, # The serialized payload that is verified by one or more `signatures`.
                  # The encoding and semantic meaning of this payload must match what is set in
                  # `content_type`.
            },
          },
        },
        &quot;name&quot;: &quot;A String&quot;, # Output only. The name of the occurrence in the form of
            # `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
        &quot;vulnerability&quot;: { # Details of a vulnerability Occurrence. # Describes a security vulnerability.
          &quot;longDescription&quot;: &quot;A String&quot;, # Output only. A detailed description of this vulnerability.
          &quot;shortDescription&quot;: &quot;A String&quot;, # Output only. A one sentence description of this vulnerability.
          &quot;effectiveSeverity&quot;: &quot;A String&quot;, # The distro assigned severity for this vulnerability when it is
              # available, and note provider assigned severity when distro has not yet
              # assigned a severity for this vulnerability.
          &quot;severity&quot;: &quot;A String&quot;, # Output only. The note provider assigned Severity of the vulnerability.
          &quot;cvssScore&quot;: 3.14, # Output only. The CVSS score of this vulnerability. CVSS score is on a
              # scale of 0-10 where 0 indicates low severity and 10 indicates high
              # severity.
          &quot;relatedUrls&quot;: [ # Output only. URLs related to this vulnerability.
            { # Metadata for any related URL information.
              &quot;url&quot;: &quot;A String&quot;, # Specific URL associated with the resource.
              &quot;label&quot;: &quot;A String&quot;, # Label to describe usage of the URL.
            },
          ],
          &quot;type&quot;: &quot;A String&quot;, # The type of package; whether native or non native(ruby gems, node.js
              # packages etc)
          &quot;packageIssue&quot;: [ # Required. The set of affected locations and their fixes (if available)
              # within the associated resource.
            { # This message wraps a location affected by a vulnerability and its
                # associated fix (if one is available).
              &quot;severityName&quot;: &quot;A String&quot;, # Deprecated, use Details.effective_severity instead
                  # The severity (e.g., distro assigned severity) for this vulnerability.
              &quot;affectedLocation&quot;: { # The location of the vulnerability. # Required. The location of the vulnerability.
                &quot;package&quot;: &quot;A String&quot;, # Required. The package being described.
                &quot;version&quot;: { # Version contains structured information about the version of a package. # Required. The version of the package being described.
                  &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
                  &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                      # name.
                  &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                      # versions.
                  &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
                },
                &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in [cpe format](https://cpe.mitre.org/specification/)
                    # format. Examples include distro or storage location for vulnerable jar.
              },
              &quot;fixedLocation&quot;: { # The location of the vulnerability. # The location of the available fix for vulnerability.
                &quot;package&quot;: &quot;A String&quot;, # Required. The package being described.
                &quot;version&quot;: { # Version contains structured information about the version of a package. # Required. The version of the package being described.
                  &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
                  &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                      # name.
                  &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                      # versions.
                  &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
                },
                &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in [cpe format](https://cpe.mitre.org/specification/)
                    # format. Examples include distro or storage location for vulnerable jar.
              },
            },
          ],
        },
        &quot;installation&quot;: { # Details of a package occurrence. # Describes the installation of a package on the linked resource.
          &quot;installation&quot;: { # This represents how a particular software package may be installed on a # Required. Where the package was installed.
              # system.
            &quot;location&quot;: [ # Required. All of the places within the filesystem versions of this package
                # have been found.
              { # An occurrence of a particular package installation found within a system&#x27;s
                  # filesystem. E.g., glibc was found in `/var/lib/dpkg/status`.
                &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in [CPE format](https://cpe.mitre.org/specification/)
                    # denoting the package manager version distributing a package.
                &quot;version&quot;: { # Version contains structured information about the version of a package. # The version installed at this location.
                  &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
                  &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                      # name.
                  &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                      # versions.
                  &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
                },
                &quot;path&quot;: &quot;A String&quot;, # The path from which we gathered that this package/version is installed.
              },
            ],
            &quot;name&quot;: &quot;A String&quot;, # Output only. The name of the installed package.
          },
        },
        &quot;build&quot;: { # Details of a build occurrence. # Describes a verifiable build.
          &quot;provenanceBytes&quot;: &quot;A String&quot;, # Serialized JSON representation of the provenance, used in generating the
              # build signature in the corresponding build note. After verifying the
              # signature, `provenance_bytes` can be unmarshalled and compared to the
              # provenance to confirm that it is unchanged. A base64-encoded string
              # representation of the provenance bytes is used for the signature in order
              # to interoperate with openssl which expects this format for signature
              # verification.
              #
              # The serialized form is captured both to avoid ambiguity in how the
              # provenance is marshalled to json as well to prevent incompatibilities with
              # future changes.
          &quot;provenance&quot;: { # Provenance of a build. Contains all information needed to verify the full # Required. The actual provenance for the build.
              # details about the build from source to completion.
            &quot;endTime&quot;: &quot;A String&quot;, # Time at which execution of the build was finished.
            &quot;startTime&quot;: &quot;A String&quot;, # Time at which execution of the build was started.
            &quot;triggerId&quot;: &quot;A String&quot;, # Trigger identifier if the build was triggered automatically; empty if not.
            &quot;sourceProvenance&quot;: { # Source describes the location of the source used for the build. # Details of the Source input to the build.
              &quot;artifactStorageSourceUri&quot;: &quot;A String&quot;, # If provided, the input binary artifacts for the build came from this
                  # location.
              &quot;additionalContexts&quot;: [ # If provided, some of the source code used for the build may be found in
                  # these locations, in the case where the source repository had multiple
                  # remotes or submodules. This list will not include the context specified in
                  # the context field.
                { # A SourceContext is a reference to a tree of files. A SourceContext together
                    # with a path point to a unique revision of a single file or directory.
                  &quot;labels&quot;: { # Labels with user defined metadata.
                    &quot;a_key&quot;: &quot;A String&quot;,
                  },
                  &quot;git&quot;: { # A GitSourceContext denotes a particular revision in a third party Git # A SourceContext referring to any third party Git repo (e.g., GitHub).
                      # repository (e.g., GitHub).
                    &quot;url&quot;: &quot;A String&quot;, # Git repository URL.
                    &quot;revisionId&quot;: &quot;A String&quot;, # Git commit hash.
                  },
                  &quot;gerrit&quot;: { # A SourceContext referring to a Gerrit project. # A SourceContext referring to a Gerrit project.
                    &quot;hostUri&quot;: &quot;A String&quot;, # The URI of a running Gerrit instance.
                    &quot;revisionId&quot;: &quot;A String&quot;, # A revision (commit) ID.
                    &quot;gerritProject&quot;: &quot;A String&quot;, # The full project name within the host. Projects may be nested, so
                        # &quot;project/subproject&quot; is a valid project name. The &quot;repo name&quot; is the
                        # hostURI/project.
                    &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                      &quot;name&quot;: &quot;A String&quot;, # The alias name.
                      &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
                    },
                  },
                  &quot;cloudRepo&quot;: { # A CloudRepoSourceContext denotes a particular revision in a Google Cloud # A SourceContext referring to a revision in a Google Cloud Source Repo.
                      # Source Repo.
                    &quot;revisionId&quot;: &quot;A String&quot;, # A revision ID.
                    &quot;repoId&quot;: { # A unique identifier for a Cloud Repo. # The ID of the repo.
                      &quot;projectRepoId&quot;: { # Selects a repo using a Google Cloud Platform project ID (e.g., # A combination of a project ID and a repo name.
                          # winged-cargo-31) and a repo name within that project.
                        &quot;projectId&quot;: &quot;A String&quot;, # The ID of the project.
                        &quot;repoName&quot;: &quot;A String&quot;, # The name of the repo. Leave empty for the default repo.
                      },
                      &quot;uid&quot;: &quot;A String&quot;, # A server-assigned, globally unique identifier.
                    },
                    &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                      &quot;name&quot;: &quot;A String&quot;, # The alias name.
                      &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
                    },
                  },
                },
              ],
              &quot;fileHashes&quot;: { # Hash(es) of the build source, which can be used to verify that the original
                  # source integrity was maintained in the build.
                  #
                  # The keys to this map are file paths used as build source and the values
                  # contain the hash values for those files.
                  #
                  # If the build source came in a single package such as a gzipped tarfile
                  # (.tar.gz), the FileHash will be for the single path to that file.
                &quot;a_key&quot;: { # Container message for hashes of byte content of files, used in source
                    # messages to verify integrity of source input to the build.
                  &quot;fileHash&quot;: [ # Required. Collection of file hashes.
                    { # Container message for hash values.
                      &quot;type&quot;: &quot;A String&quot;, # Required. The type of hash that was performed.
                      &quot;value&quot;: &quot;A String&quot;, # Required. The hash value.
                    },
                  ],
                },
              },
              &quot;context&quot;: { # A SourceContext is a reference to a tree of files. A SourceContext together # If provided, the source code used for the build came from this location.
                  # with a path point to a unique revision of a single file or directory.
                &quot;labels&quot;: { # Labels with user defined metadata.
                  &quot;a_key&quot;: &quot;A String&quot;,
                },
                &quot;git&quot;: { # A GitSourceContext denotes a particular revision in a third party Git # A SourceContext referring to any third party Git repo (e.g., GitHub).
                    # repository (e.g., GitHub).
                  &quot;url&quot;: &quot;A String&quot;, # Git repository URL.
                  &quot;revisionId&quot;: &quot;A String&quot;, # Git commit hash.
                },
                &quot;gerrit&quot;: { # A SourceContext referring to a Gerrit project. # A SourceContext referring to a Gerrit project.
                  &quot;hostUri&quot;: &quot;A String&quot;, # The URI of a running Gerrit instance.
                  &quot;revisionId&quot;: &quot;A String&quot;, # A revision (commit) ID.
                  &quot;gerritProject&quot;: &quot;A String&quot;, # The full project name within the host. Projects may be nested, so
                      # &quot;project/subproject&quot; is a valid project name. The &quot;repo name&quot; is the
                      # hostURI/project.
                  &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                    &quot;name&quot;: &quot;A String&quot;, # The alias name.
                    &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
                  },
                },
                &quot;cloudRepo&quot;: { # A CloudRepoSourceContext denotes a particular revision in a Google Cloud # A SourceContext referring to a revision in a Google Cloud Source Repo.
                    # Source Repo.
                  &quot;revisionId&quot;: &quot;A String&quot;, # A revision ID.
                  &quot;repoId&quot;: { # A unique identifier for a Cloud Repo. # The ID of the repo.
                    &quot;projectRepoId&quot;: { # Selects a repo using a Google Cloud Platform project ID (e.g., # A combination of a project ID and a repo name.
                        # winged-cargo-31) and a repo name within that project.
                      &quot;projectId&quot;: &quot;A String&quot;, # The ID of the project.
                      &quot;repoName&quot;: &quot;A String&quot;, # The name of the repo. Leave empty for the default repo.
                    },
                    &quot;uid&quot;: &quot;A String&quot;, # A server-assigned, globally unique identifier.
                  },
                  &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                    &quot;name&quot;: &quot;A String&quot;, # The alias name.
                    &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
                  },
                },
              },
            },
            &quot;createTime&quot;: &quot;A String&quot;, # Time at which the build was created.
            &quot;projectId&quot;: &quot;A String&quot;, # ID of the project.
            &quot;logsUri&quot;: &quot;A String&quot;, # URI where any logs for this provenance were written.
            &quot;creator&quot;: &quot;A String&quot;, # E-mail address of the user who initiated this build. Note that this was the
                # user&#x27;s e-mail address at the time the build was initiated; this address may
                # not represent the same end-user for all time.
            &quot;builderVersion&quot;: &quot;A String&quot;, # Version string of the builder at the time this build was executed.
            &quot;commands&quot;: [ # Commands requested by the build.
              { # Command describes a step performed as part of the build pipeline.
                &quot;dir&quot;: &quot;A String&quot;, # Working directory (relative to project source root) used when running this
                    # command.
                &quot;waitFor&quot;: [ # The ID(s) of the command(s) that this command depends on.
                  &quot;A String&quot;,
                ],
                &quot;env&quot;: [ # Environment variables set before running this command.
                  &quot;A String&quot;,
                ],
                &quot;args&quot;: [ # Command-line arguments used when executing this command.
                  &quot;A String&quot;,
                ],
                &quot;name&quot;: &quot;A String&quot;, # Required. Name of the command, as presented on the command line, or if the
                    # command is packaged as a Docker container, as presented to `docker pull`.
                &quot;id&quot;: &quot;A String&quot;, # Optional unique identifier for this command, used in wait_for to reference
                    # this command as a dependency.
              },
            ],
            &quot;builtArtifacts&quot;: [ # Output of the build.
              { # Artifact describes a build product.
                &quot;checksum&quot;: &quot;A String&quot;, # Hash or checksum value of a binary, or Docker Registry 2.0 digest of a
                    # container.
                &quot;id&quot;: &quot;A String&quot;, # Artifact ID, if any; for container images, this will be a URL by digest
                    # like `gcr.io/projectID/imagename@sha256:123456`.
                &quot;names&quot;: [ # Related artifact names. This may be the path to a binary or jar file, or in
                    # the case of a container build, the name used to push the container image to
                    # Google Container Registry, as presented to `docker push`. Note that a
                    # single Artifact ID can have multiple names, for example if two tags are
                    # applied to one image.
                  &quot;A String&quot;,
                ],
              },
            ],
            &quot;id&quot;: &quot;A String&quot;, # Required. Unique identifier of the build.
            &quot;buildOptions&quot;: { # Special options applied to this build. This is a catch-all field where
                # build providers can enter any desired additional details.
              &quot;a_key&quot;: &quot;A String&quot;,
            },
          },
        },
        &quot;discovered&quot;: { # Details of a discovery occurrence. # Describes when a resource was discovered.
          &quot;discovered&quot;: { # Provides information about the analysis status of a discovered resource. # Required. Analysis status for the discovered resource.
            &quot;analysisStatusError&quot;: { # The `Status` type defines a logical error model that is suitable for # When an error is encountered this will contain a LocalizedMessage under
                # details to show to the user. The LocalizedMessage is output only and
                # populated by the API.
                # different programming environments, including REST APIs and RPC APIs. It is
                # used by [gRPC](https://github.com/grpc). Each `Status` message contains
                # three pieces of data: error code, error message, and error details.
                #
                # You can find out more about this error model and how to work with it in the
                # [API Design Guide](https://cloud.google.com/apis/design/errors).
              &quot;details&quot;: [ # A list of messages that carry the error details.  There is a common set of
                  # message types for APIs to use.
                {
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
                },
              ],
              &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
              &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any
                  # user-facing error message should be localized and sent in the
                  # google.rpc.Status.details field, or localized by the client.
            },
            &quot;analysisStatus&quot;: &quot;A String&quot;, # The status of discovery for the resource.
            &quot;continuousAnalysis&quot;: &quot;A String&quot;, # Whether the resource is continuously analyzed.
            &quot;lastAnalysisTime&quot;: &quot;A String&quot;, # The last time continuous analysis was done for this resource.
                # Deprecated, do not use.
          },
        },
        &quot;noteName&quot;: &quot;A String&quot;, # Required. Immutable. The analysis note associated with this occurrence, in
            # the form of `projects/[PROVIDER_ID]/notes/[NOTE_ID]`. This field can be
            # used as a filter in list requests.
        &quot;deployment&quot;: { # Details of a deployment occurrence. # Describes the deployment of an artifact on a runtime.
          &quot;deployment&quot;: { # The period during which some deployable was active in a runtime. # Required. Deployment history for the resource.
            &quot;userEmail&quot;: &quot;A String&quot;, # Identity of the user that triggered this deployment.
            &quot;config&quot;: &quot;A String&quot;, # Configuration used to create this deployment.
            &quot;undeployTime&quot;: &quot;A String&quot;, # End of the lifetime of this deployment.
            &quot;platform&quot;: &quot;A String&quot;, # Platform hosting this deployment.
            &quot;deployTime&quot;: &quot;A String&quot;, # Required. Beginning of the lifetime of this deployment.
            &quot;address&quot;: &quot;A String&quot;, # Address of the runtime element hosting this deployment.
            &quot;resourceUri&quot;: [ # Output only. Resource URI for the artifact being deployed taken from
                # the deployable field with the same name.
              &quot;A String&quot;,
            ],
          },
        },
        &quot;createTime&quot;: &quot;A String&quot;, # Output only. The time this occurrence was created.
        &quot;updateTime&quot;: &quot;A String&quot;, # Output only. The time this occurrence was last updated.
        &quot;remediation&quot;: &quot;A String&quot;, # A description of actions that can be taken to remedy the note.
        &quot;intoto&quot;: { # This corresponds to a signed in-toto link - it is made up of one or more # Describes a specific in-toto link.
            # signatures and the in-toto link itself. This is used for occurrences of a
            # Grafeas in-toto note.
          &quot;signed&quot;: { # This corresponds to an in-toto link.
            &quot;command&quot;: [ # This field contains the full command executed for the step. This can also
                # be empty if links are generated for operations that aren&#x27;t directly mapped
                # to a specific command. Each term in the command is an independent string
                # in the list. An example of a command in the in-toto metadata field is:
                # &quot;command&quot;: [&quot;git&quot;, &quot;clone&quot;, &quot;https://github.com/in-toto/demo-project.git&quot;]
              &quot;A String&quot;,
            ],
            &quot;byproducts&quot;: { # Defines an object for the byproducts field in in-toto links. The suggested # ByProducts are data generated as part of a software supply chain step, but
                # are not the actual result of the step.
                # fields are &quot;stderr&quot;, &quot;stdout&quot;, and &quot;return-value&quot;.
              &quot;customValues&quot;: {
                &quot;a_key&quot;: &quot;A String&quot;,
              },
            },
            &quot;environment&quot;: { # Defines an object for the environment field in in-toto links. The suggested # This is a field that can be used to capture information about the
                # environment. It is suggested for this field to contain information that
                # details environment variables, filesystem information, and the present
                # working directory. The recommended structure of this field is:
                # &quot;environment&quot;: {
                #   &quot;custom_values&quot;: {
                #     &quot;variables&quot;: &quot;&lt;ENV&gt;&quot;,
                #     &quot;filesystem&quot;: &quot;&lt;FS&gt;&quot;,
                #     &quot;workdir&quot;: &quot;&lt;CWD&gt;&quot;,
                #     &quot;&lt;ANY OTHER RELEVANT FIELDS&gt;&quot;: &quot;...&quot;
                #   }
                # }
                # fields are &quot;variables&quot;, &quot;filesystem&quot;, and &quot;workdir&quot;.
              &quot;customValues&quot;: {
                &quot;a_key&quot;: &quot;A String&quot;,
              },
            },
            &quot;materials&quot;: [ # Materials are the supply chain artifacts that go into the step and are used
                # for the operation performed. The key of the map is the path of the artifact
                # and the structure contains the recorded hash information. An example is:
                # &quot;materials&quot;: [
                #   {
                #     &quot;resource_uri&quot;: &quot;foo/bar&quot;,
                #     &quot;hashes&quot;: {
                #       &quot;sha256&quot;: &quot;ebebf...&quot;,
                #       &lt;OTHER HASH ALGORITHMS&gt;: &lt;HASH VALUE&gt;
                #     }
                #   }
                # ]
              {
                &quot;hashes&quot;: { # Defines a hash object for use in Materials and Products.
                  &quot;sha256&quot;: &quot;A String&quot;,
                },
                &quot;resourceUri&quot;: &quot;A String&quot;,
              },
            ],
            &quot;products&quot;: [ # Products are the supply chain artifacts generated as a result of the step.
                # The structure is identical to that of materials.
              {
                &quot;hashes&quot;: { # Defines a hash object for use in Materials and Products.
                  &quot;sha256&quot;: &quot;A String&quot;,
                },
                &quot;resourceUri&quot;: &quot;A String&quot;,
              },
            ],
          },
          &quot;signatures&quot;: [
            { # A signature object consists of the KeyID used and the signature itself.
              &quot;sig&quot;: &quot;A String&quot;,
              &quot;keyid&quot;: &quot;A String&quot;,
            },
          ],
        },
        &quot;derivedImage&quot;: { # Details of an image occurrence. # Describes how this resource derives from the basis in the associated
            # note.
          &quot;derivedImage&quot;: { # Derived describes the derived image portion (Occurrence) of the DockerImage # Required. Immutable. The child image derived from the base image.
              # relationship. This image would be produced from a Dockerfile with FROM
              # &lt;DockerImage.Basis in attached Note&gt;.
            &quot;fingerprint&quot;: { # A set of properties that uniquely identify a given Docker image. # Required. The fingerprint of the derived image.
              &quot;v2Blob&quot;: [ # Required. The ordered list of v2 blobs that represent a given image.
                &quot;A String&quot;,
              ],
              &quot;v1Name&quot;: &quot;A String&quot;, # Required. The layer ID of the final layer in the Docker image&#x27;s v1
                  # representation.
              &quot;v2Name&quot;: &quot;A String&quot;, # Output only. The name of the image&#x27;s v2 blobs computed via:
                  #   [bottom] := v2_blobbottom := sha256(v2_blob[N] + &quot; &quot; + v2_name[N+1])
                  # Only the name of the final blob is kept.
            },
            &quot;layerInfo&quot;: [ # This contains layer-specific metadata, if populated it has length
                # &quot;distance&quot; and is ordered with [distance] being the layer immediately
                # following the base image and [1] being the final layer.
              { # Layer holds metadata specific to a layer of a Docker image.
                &quot;directive&quot;: &quot;A String&quot;, # Required. The recovered Dockerfile directive used to construct this layer.
                &quot;arguments&quot;: &quot;A String&quot;, # The recovered arguments to the Dockerfile directive.
              },
            ],
            &quot;distance&quot;: 42, # Output only. The number of layers by which this image differs from the
                # associated image basis.
            &quot;baseResourceUrl&quot;: &quot;A String&quot;, # Output only. This contains the base image URL for the derived image
                # occurrence.
          },
        },
      },
    ],
    &quot;nextPageToken&quot;: &quot;A String&quot;, # The next pagination token in the list response. It should be used as
        # `page_token` for the following request. An empty value means no more
        # results.
  }</pre>
</div>

<div class="method">
    <code class="details" id="list_next">list_next(previous_request, previous_response)</code>
  <pre>Retrieves the next page of results.

Args:
  previous_request: The request for the previous page. (required)
  previous_response: The response from the request for the previous page. (required)

Returns:
  A request object that you can call &#x27;execute()&#x27; on to request the next
  page. Returns None if there are no more items in the collection.
    </pre>
</div>

<div class="method">
    <code class="details" id="patch">patch(name, body=None, updateMask=None, x__xgafv=None)</code>
  <pre>Updates the specified occurrence.

Args:
  name: string, Required. The name of the occurrence in the form of
`projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`. (required)
  body: object, The request body.
    The object takes the form of:

{ # An instance of an analysis type that has been found on a resource.
  &quot;kind&quot;: &quot;A String&quot;, # Output only. This explicitly denotes which of the occurrence details are
      # specified. This field can be used as a filter in list requests.
  &quot;resource&quot;: { # An entity that can have metadata. For example, a Docker image. # Required. Immutable. The resource for which the occurrence applies.
    &quot;name&quot;: &quot;A String&quot;, # Deprecated, do not use. Use uri instead.
        #
        # The name of the resource. For example, the name of a Docker image -
        # &quot;Debian&quot;.
    &quot;contentHash&quot;: { # Container message for hash values. # Deprecated, do not use. Use uri instead.
        #
        # The hash of the resource content. For example, the Docker digest.
      &quot;type&quot;: &quot;A String&quot;, # Required. The type of hash that was performed.
      &quot;value&quot;: &quot;A String&quot;, # Required. The hash value.
    },
    &quot;uri&quot;: &quot;A String&quot;, # Required. The unique URI of the resource. For example,
        # `https://gcr.io/project/image@sha256:foo` for a Docker image.
  },
  &quot;attestation&quot;: { # Details of an attestation occurrence. # Describes an attestation of an artifact.
    &quot;attestation&quot;: { # Occurrence that represents a single &quot;attestation&quot;. The authenticity of an # Required. Attestation for the resource.
        # attestation can be verified using the attached signature. If the verifier
        # trusts the public key of the signer, then verifying the signature is
        # sufficient to establish trust. In this circumstance, the authority to which
        # this attestation is attached is primarily useful for look-up (how to find
        # this attestation if you already know the authority and artifact to be
        # verified) and intent (which authority was this attestation intended to sign
        # for).
      &quot;pgpSignedAttestation&quot;: { # An attestation wrapper with a PGP-compatible signature. This message only # A PGP signed attestation.
          # supports `ATTACHED` signatures, where the payload that is signed is included
          # alongside the signature itself in the same file.
        &quot;contentType&quot;: &quot;A String&quot;, # Type (for example schema) of the attestation payload that was signed.
            # The verifier must ensure that the provided type is one that the verifier
            # supports, and that the attestation payload is a valid instantiation of that
            # type (for example by validating a JSON schema).
        &quot;signature&quot;: &quot;A String&quot;, # Required. The raw content of the signature, as output by GNU Privacy Guard
            # (GPG) or equivalent. Since this message only supports attached signatures,
            # the payload that was signed must be attached. While the signature format
            # supported is dependent on the verification implementation, currently only
            # ASCII-armored (`--armor` to gpg), non-clearsigned (`--sign` rather than
            # `--clearsign` to gpg) are supported. Concretely, `gpg --sign --armor
            # --output=signature.gpg payload.json` will create the signature content
            # expected in this field in `signature.gpg` for the `payload.json`
            # attestation payload.
        &quot;pgpKeyId&quot;: &quot;A String&quot;, # The cryptographic fingerprint of the key used to generate the signature,
            # as output by, e.g. `gpg --list-keys`. This should be the version 4, full
            # 160-bit fingerprint, expressed as a 40 character hexidecimal string. See
            # https://tools.ietf.org/html/rfc4880#section-12.2 for details.
            # Implementations may choose to acknowledge &quot;LONG&quot;, &quot;SHORT&quot;, or other
            # abbreviated key IDs, but only the full fingerprint is guaranteed to work.
            # In gpg, the full fingerprint can be retrieved from the `fpr` field
            # returned when calling --list-keys with --with-colons.  For example:
            # ```
            # gpg --with-colons --with-fingerprint --force-v4-certs \
            #     --list-keys attester@example.com
            # tru::1:1513631572:0:3:1:5
            # pub:...&lt;SNIP&gt;...
            # fpr:::::::::24FF6481B76AC91E66A00AC657A93A81EF3AE6FB:
            # ```
            # Above, the fingerprint is `24FF6481B76AC91E66A00AC657A93A81EF3AE6FB`.
      },
      &quot;genericSignedAttestation&quot;: { # An attestation wrapper that uses the Grafeas `Signature` message.
          # This attestation must define the `serialized_payload` that the `signatures`
          # verify and any metadata necessary to interpret that plaintext.  The
          # signatures should always be over the `serialized_payload` bytestring.
        &quot;contentType&quot;: &quot;A String&quot;, # Type (for example schema) of the attestation payload that was signed.
            # The verifier must ensure that the provided type is one that the verifier
            # supports, and that the attestation payload is a valid instantiation of that
            # type (for example by validating a JSON schema).
        &quot;signatures&quot;: [ # One or more signatures over `serialized_payload`.  Verifier implementations
            # should consider this attestation message verified if at least one
            # `signature` verifies `serialized_payload`.  See `Signature` in common.proto
            # for more details on signature structure and verification.
          { # Verifiers (e.g. Kritis implementations) MUST verify signatures
              # with respect to the trust anchors defined in policy (e.g. a Kritis policy).
              # Typically this means that the verifier has been configured with a map from
              # `public_key_id` to public key material (and any required parameters, e.g.
              # signing algorithm).
              #
              # In particular, verification implementations MUST NOT treat the signature
              # `public_key_id` as anything more than a key lookup hint. The `public_key_id`
              # DOES NOT validate or authenticate a public key; it only provides a mechanism
              # for quickly selecting a public key ALREADY CONFIGURED on the verifier through
              # a trusted channel. Verification implementations MUST reject signatures in any
              # of the following circumstances:
              #   * The `public_key_id` is not recognized by the verifier.
              #   * The public key that `public_key_id` refers to does not verify the
              #     signature with respect to the payload.
              #
              # The `signature` contents SHOULD NOT be &quot;attached&quot; (where the payload is
              # included with the serialized `signature` bytes). Verifiers MUST ignore any
              # &quot;attached&quot; payload and only verify signatures with respect to explicitly
              # provided payload (e.g. a `payload` field on the proto message that holds
              # this Signature, or the canonical serialization of the proto message that
              # holds this signature).
            &quot;publicKeyId&quot;: &quot;A String&quot;, # The identifier for the public key that verifies this signature.
                #   * The `public_key_id` is required.
                #   * The `public_key_id` MUST be an RFC3986 conformant URI.
                #   * When possible, the `public_key_id` SHOULD be an immutable reference,
                #     such as a cryptographic digest.
                #
                # Examples of valid `public_key_id`s:
                #
                # OpenPGP V4 public key fingerprint:
                #   * &quot;openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA&quot;
                # See https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr for more
                # details on this scheme.
                #
                # RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER
                # serialization):
                #   * &quot;ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU&quot;
                #   * &quot;nih:///sha-256;703f68f42aba2c6de30f488a5ea122fef76324679c9bf89791ba95a1271589a5&quot;
            &quot;signature&quot;: &quot;A String&quot;, # The content of the signature, an opaque bytestring.
                # The payload that this signature verifies MUST be unambiguously provided
                # with the Signature during verification. A wrapper message might provide
                # the payload explicitly. Alternatively, a message might have a canonical
                # serialization that can always be unambiguously computed to derive the
                # payload.
          },
        ],
        &quot;serializedPayload&quot;: &quot;A String&quot;, # The serialized payload that is verified by one or more `signatures`.
            # The encoding and semantic meaning of this payload must match what is set in
            # `content_type`.
      },
    },
  },
  &quot;name&quot;: &quot;A String&quot;, # Output only. The name of the occurrence in the form of
      # `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
  &quot;vulnerability&quot;: { # Details of a vulnerability Occurrence. # Describes a security vulnerability.
    &quot;longDescription&quot;: &quot;A String&quot;, # Output only. A detailed description of this vulnerability.
    &quot;shortDescription&quot;: &quot;A String&quot;, # Output only. A one sentence description of this vulnerability.
    &quot;effectiveSeverity&quot;: &quot;A String&quot;, # The distro assigned severity for this vulnerability when it is
        # available, and note provider assigned severity when distro has not yet
        # assigned a severity for this vulnerability.
    &quot;severity&quot;: &quot;A String&quot;, # Output only. The note provider assigned Severity of the vulnerability.
    &quot;cvssScore&quot;: 3.14, # Output only. The CVSS score of this vulnerability. CVSS score is on a
        # scale of 0-10 where 0 indicates low severity and 10 indicates high
        # severity.
    &quot;relatedUrls&quot;: [ # Output only. URLs related to this vulnerability.
      { # Metadata for any related URL information.
        &quot;url&quot;: &quot;A String&quot;, # Specific URL associated with the resource.
        &quot;label&quot;: &quot;A String&quot;, # Label to describe usage of the URL.
      },
    ],
    &quot;type&quot;: &quot;A String&quot;, # The type of package; whether native or non native(ruby gems, node.js
        # packages etc)
    &quot;packageIssue&quot;: [ # Required. The set of affected locations and their fixes (if available)
        # within the associated resource.
      { # This message wraps a location affected by a vulnerability and its
          # associated fix (if one is available).
        &quot;severityName&quot;: &quot;A String&quot;, # Deprecated, use Details.effective_severity instead
            # The severity (e.g., distro assigned severity) for this vulnerability.
        &quot;affectedLocation&quot;: { # The location of the vulnerability. # Required. The location of the vulnerability.
          &quot;package&quot;: &quot;A String&quot;, # Required. The package being described.
          &quot;version&quot;: { # Version contains structured information about the version of a package. # Required. The version of the package being described.
            &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
            &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                # name.
            &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                # versions.
            &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
          },
          &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in [cpe format](https://cpe.mitre.org/specification/)
              # format. Examples include distro or storage location for vulnerable jar.
        },
        &quot;fixedLocation&quot;: { # The location of the vulnerability. # The location of the available fix for vulnerability.
          &quot;package&quot;: &quot;A String&quot;, # Required. The package being described.
          &quot;version&quot;: { # Version contains structured information about the version of a package. # Required. The version of the package being described.
            &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
            &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                # name.
            &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                # versions.
            &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
          },
          &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in [cpe format](https://cpe.mitre.org/specification/)
              # format. Examples include distro or storage location for vulnerable jar.
        },
      },
    ],
  },
  &quot;installation&quot;: { # Details of a package occurrence. # Describes the installation of a package on the linked resource.
    &quot;installation&quot;: { # This represents how a particular software package may be installed on a # Required. Where the package was installed.
        # system.
      &quot;location&quot;: [ # Required. All of the places within the filesystem versions of this package
          # have been found.
        { # An occurrence of a particular package installation found within a system&#x27;s
            # filesystem. E.g., glibc was found in `/var/lib/dpkg/status`.
          &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in [CPE format](https://cpe.mitre.org/specification/)
              # denoting the package manager version distributing a package.
          &quot;version&quot;: { # Version contains structured information about the version of a package. # The version installed at this location.
            &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
            &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                # name.
            &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                # versions.
            &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
          },
          &quot;path&quot;: &quot;A String&quot;, # The path from which we gathered that this package/version is installed.
        },
      ],
      &quot;name&quot;: &quot;A String&quot;, # Output only. The name of the installed package.
    },
  },
  &quot;build&quot;: { # Details of a build occurrence. # Describes a verifiable build.
    &quot;provenanceBytes&quot;: &quot;A String&quot;, # Serialized JSON representation of the provenance, used in generating the
        # build signature in the corresponding build note. After verifying the
        # signature, `provenance_bytes` can be unmarshalled and compared to the
        # provenance to confirm that it is unchanged. A base64-encoded string
        # representation of the provenance bytes is used for the signature in order
        # to interoperate with openssl which expects this format for signature
        # verification.
        #
        # The serialized form is captured both to avoid ambiguity in how the
        # provenance is marshalled to json as well to prevent incompatibilities with
        # future changes.
    &quot;provenance&quot;: { # Provenance of a build. Contains all information needed to verify the full # Required. The actual provenance for the build.
        # details about the build from source to completion.
      &quot;endTime&quot;: &quot;A String&quot;, # Time at which execution of the build was finished.
      &quot;startTime&quot;: &quot;A String&quot;, # Time at which execution of the build was started.
      &quot;triggerId&quot;: &quot;A String&quot;, # Trigger identifier if the build was triggered automatically; empty if not.
      &quot;sourceProvenance&quot;: { # Source describes the location of the source used for the build. # Details of the Source input to the build.
        &quot;artifactStorageSourceUri&quot;: &quot;A String&quot;, # If provided, the input binary artifacts for the build came from this
            # location.
        &quot;additionalContexts&quot;: [ # If provided, some of the source code used for the build may be found in
            # these locations, in the case where the source repository had multiple
            # remotes or submodules. This list will not include the context specified in
            # the context field.
          { # A SourceContext is a reference to a tree of files. A SourceContext together
              # with a path point to a unique revision of a single file or directory.
            &quot;labels&quot;: { # Labels with user defined metadata.
              &quot;a_key&quot;: &quot;A String&quot;,
            },
            &quot;git&quot;: { # A GitSourceContext denotes a particular revision in a third party Git # A SourceContext referring to any third party Git repo (e.g., GitHub).
                # repository (e.g., GitHub).
              &quot;url&quot;: &quot;A String&quot;, # Git repository URL.
              &quot;revisionId&quot;: &quot;A String&quot;, # Git commit hash.
            },
            &quot;gerrit&quot;: { # A SourceContext referring to a Gerrit project. # A SourceContext referring to a Gerrit project.
              &quot;hostUri&quot;: &quot;A String&quot;, # The URI of a running Gerrit instance.
              &quot;revisionId&quot;: &quot;A String&quot;, # A revision (commit) ID.
              &quot;gerritProject&quot;: &quot;A String&quot;, # The full project name within the host. Projects may be nested, so
                  # &quot;project/subproject&quot; is a valid project name. The &quot;repo name&quot; is the
                  # hostURI/project.
              &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                &quot;name&quot;: &quot;A String&quot;, # The alias name.
                &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
              },
            },
            &quot;cloudRepo&quot;: { # A CloudRepoSourceContext denotes a particular revision in a Google Cloud # A SourceContext referring to a revision in a Google Cloud Source Repo.
                # Source Repo.
              &quot;revisionId&quot;: &quot;A String&quot;, # A revision ID.
              &quot;repoId&quot;: { # A unique identifier for a Cloud Repo. # The ID of the repo.
                &quot;projectRepoId&quot;: { # Selects a repo using a Google Cloud Platform project ID (e.g., # A combination of a project ID and a repo name.
                    # winged-cargo-31) and a repo name within that project.
                  &quot;projectId&quot;: &quot;A String&quot;, # The ID of the project.
                  &quot;repoName&quot;: &quot;A String&quot;, # The name of the repo. Leave empty for the default repo.
                },
                &quot;uid&quot;: &quot;A String&quot;, # A server-assigned, globally unique identifier.
              },
              &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                &quot;name&quot;: &quot;A String&quot;, # The alias name.
                &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
              },
            },
          },
        ],
        &quot;fileHashes&quot;: { # Hash(es) of the build source, which can be used to verify that the original
            # source integrity was maintained in the build.
            #
            # The keys to this map are file paths used as build source and the values
            # contain the hash values for those files.
            #
            # If the build source came in a single package such as a gzipped tarfile
            # (.tar.gz), the FileHash will be for the single path to that file.
          &quot;a_key&quot;: { # Container message for hashes of byte content of files, used in source
              # messages to verify integrity of source input to the build.
            &quot;fileHash&quot;: [ # Required. Collection of file hashes.
              { # Container message for hash values.
                &quot;type&quot;: &quot;A String&quot;, # Required. The type of hash that was performed.
                &quot;value&quot;: &quot;A String&quot;, # Required. The hash value.
              },
            ],
          },
        },
        &quot;context&quot;: { # A SourceContext is a reference to a tree of files. A SourceContext together # If provided, the source code used for the build came from this location.
            # with a path point to a unique revision of a single file or directory.
          &quot;labels&quot;: { # Labels with user defined metadata.
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;git&quot;: { # A GitSourceContext denotes a particular revision in a third party Git # A SourceContext referring to any third party Git repo (e.g., GitHub).
              # repository (e.g., GitHub).
            &quot;url&quot;: &quot;A String&quot;, # Git repository URL.
            &quot;revisionId&quot;: &quot;A String&quot;, # Git commit hash.
          },
          &quot;gerrit&quot;: { # A SourceContext referring to a Gerrit project. # A SourceContext referring to a Gerrit project.
            &quot;hostUri&quot;: &quot;A String&quot;, # The URI of a running Gerrit instance.
            &quot;revisionId&quot;: &quot;A String&quot;, # A revision (commit) ID.
            &quot;gerritProject&quot;: &quot;A String&quot;, # The full project name within the host. Projects may be nested, so
                # &quot;project/subproject&quot; is a valid project name. The &quot;repo name&quot; is the
                # hostURI/project.
            &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
              &quot;name&quot;: &quot;A String&quot;, # The alias name.
              &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
            },
          },
          &quot;cloudRepo&quot;: { # A CloudRepoSourceContext denotes a particular revision in a Google Cloud # A SourceContext referring to a revision in a Google Cloud Source Repo.
              # Source Repo.
            &quot;revisionId&quot;: &quot;A String&quot;, # A revision ID.
            &quot;repoId&quot;: { # A unique identifier for a Cloud Repo. # The ID of the repo.
              &quot;projectRepoId&quot;: { # Selects a repo using a Google Cloud Platform project ID (e.g., # A combination of a project ID and a repo name.
                  # winged-cargo-31) and a repo name within that project.
                &quot;projectId&quot;: &quot;A String&quot;, # The ID of the project.
                &quot;repoName&quot;: &quot;A String&quot;, # The name of the repo. Leave empty for the default repo.
              },
              &quot;uid&quot;: &quot;A String&quot;, # A server-assigned, globally unique identifier.
            },
            &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
              &quot;name&quot;: &quot;A String&quot;, # The alias name.
              &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
            },
          },
        },
      },
      &quot;createTime&quot;: &quot;A String&quot;, # Time at which the build was created.
      &quot;projectId&quot;: &quot;A String&quot;, # ID of the project.
      &quot;logsUri&quot;: &quot;A String&quot;, # URI where any logs for this provenance were written.
      &quot;creator&quot;: &quot;A String&quot;, # E-mail address of the user who initiated this build. Note that this was the
          # user&#x27;s e-mail address at the time the build was initiated; this address may
          # not represent the same end-user for all time.
      &quot;builderVersion&quot;: &quot;A String&quot;, # Version string of the builder at the time this build was executed.
      &quot;commands&quot;: [ # Commands requested by the build.
        { # Command describes a step performed as part of the build pipeline.
          &quot;dir&quot;: &quot;A String&quot;, # Working directory (relative to project source root) used when running this
              # command.
          &quot;waitFor&quot;: [ # The ID(s) of the command(s) that this command depends on.
            &quot;A String&quot;,
          ],
          &quot;env&quot;: [ # Environment variables set before running this command.
            &quot;A String&quot;,
          ],
          &quot;args&quot;: [ # Command-line arguments used when executing this command.
            &quot;A String&quot;,
          ],
          &quot;name&quot;: &quot;A String&quot;, # Required. Name of the command, as presented on the command line, or if the
              # command is packaged as a Docker container, as presented to `docker pull`.
          &quot;id&quot;: &quot;A String&quot;, # Optional unique identifier for this command, used in wait_for to reference
              # this command as a dependency.
        },
      ],
      &quot;builtArtifacts&quot;: [ # Output of the build.
        { # Artifact describes a build product.
          &quot;checksum&quot;: &quot;A String&quot;, # Hash or checksum value of a binary, or Docker Registry 2.0 digest of a
              # container.
          &quot;id&quot;: &quot;A String&quot;, # Artifact ID, if any; for container images, this will be a URL by digest
              # like `gcr.io/projectID/imagename@sha256:123456`.
          &quot;names&quot;: [ # Related artifact names. This may be the path to a binary or jar file, or in
              # the case of a container build, the name used to push the container image to
              # Google Container Registry, as presented to `docker push`. Note that a
              # single Artifact ID can have multiple names, for example if two tags are
              # applied to one image.
            &quot;A String&quot;,
          ],
        },
      ],
      &quot;id&quot;: &quot;A String&quot;, # Required. Unique identifier of the build.
      &quot;buildOptions&quot;: { # Special options applied to this build. This is a catch-all field where
          # build providers can enter any desired additional details.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
    },
  },
  &quot;discovered&quot;: { # Details of a discovery occurrence. # Describes when a resource was discovered.
    &quot;discovered&quot;: { # Provides information about the analysis status of a discovered resource. # Required. Analysis status for the discovered resource.
      &quot;analysisStatusError&quot;: { # The `Status` type defines a logical error model that is suitable for # When an error is encountered this will contain a LocalizedMessage under
          # details to show to the user. The LocalizedMessage is output only and
          # populated by the API.
          # different programming environments, including REST APIs and RPC APIs. It is
          # used by [gRPC](https://github.com/grpc). Each `Status` message contains
          # three pieces of data: error code, error message, and error details.
          #
          # You can find out more about this error model and how to work with it in the
          # [API Design Guide](https://cloud.google.com/apis/design/errors).
        &quot;details&quot;: [ # A list of messages that carry the error details.  There is a common set of
            # message types for APIs to use.
          {
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
          },
        ],
        &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
        &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any
            # user-facing error message should be localized and sent in the
            # google.rpc.Status.details field, or localized by the client.
      },
      &quot;analysisStatus&quot;: &quot;A String&quot;, # The status of discovery for the resource.
      &quot;continuousAnalysis&quot;: &quot;A String&quot;, # Whether the resource is continuously analyzed.
      &quot;lastAnalysisTime&quot;: &quot;A String&quot;, # The last time continuous analysis was done for this resource.
          # Deprecated, do not use.
    },
  },
  &quot;noteName&quot;: &quot;A String&quot;, # Required. Immutable. The analysis note associated with this occurrence, in
      # the form of `projects/[PROVIDER_ID]/notes/[NOTE_ID]`. This field can be
      # used as a filter in list requests.
  &quot;deployment&quot;: { # Details of a deployment occurrence. # Describes the deployment of an artifact on a runtime.
    &quot;deployment&quot;: { # The period during which some deployable was active in a runtime. # Required. Deployment history for the resource.
      &quot;userEmail&quot;: &quot;A String&quot;, # Identity of the user that triggered this deployment.
      &quot;config&quot;: &quot;A String&quot;, # Configuration used to create this deployment.
      &quot;undeployTime&quot;: &quot;A String&quot;, # End of the lifetime of this deployment.
      &quot;platform&quot;: &quot;A String&quot;, # Platform hosting this deployment.
      &quot;deployTime&quot;: &quot;A String&quot;, # Required. Beginning of the lifetime of this deployment.
      &quot;address&quot;: &quot;A String&quot;, # Address of the runtime element hosting this deployment.
      &quot;resourceUri&quot;: [ # Output only. Resource URI for the artifact being deployed taken from
          # the deployable field with the same name.
        &quot;A String&quot;,
      ],
    },
  },
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. The time this occurrence was created.
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. The time this occurrence was last updated.
  &quot;remediation&quot;: &quot;A String&quot;, # A description of actions that can be taken to remedy the note.
  &quot;intoto&quot;: { # This corresponds to a signed in-toto link - it is made up of one or more # Describes a specific in-toto link.
      # signatures and the in-toto link itself. This is used for occurrences of a
      # Grafeas in-toto note.
    &quot;signed&quot;: { # This corresponds to an in-toto link.
      &quot;command&quot;: [ # This field contains the full command executed for the step. This can also
          # be empty if links are generated for operations that aren&#x27;t directly mapped
          # to a specific command. Each term in the command is an independent string
          # in the list. An example of a command in the in-toto metadata field is:
          # &quot;command&quot;: [&quot;git&quot;, &quot;clone&quot;, &quot;https://github.com/in-toto/demo-project.git&quot;]
        &quot;A String&quot;,
      ],
      &quot;byproducts&quot;: { # Defines an object for the byproducts field in in-toto links. The suggested # ByProducts are data generated as part of a software supply chain step, but
          # are not the actual result of the step.
          # fields are &quot;stderr&quot;, &quot;stdout&quot;, and &quot;return-value&quot;.
        &quot;customValues&quot;: {
          &quot;a_key&quot;: &quot;A String&quot;,
        },
      },
      &quot;environment&quot;: { # Defines an object for the environment field in in-toto links. The suggested # This is a field that can be used to capture information about the
          # environment. It is suggested for this field to contain information that
          # details environment variables, filesystem information, and the present
          # working directory. The recommended structure of this field is:
          # &quot;environment&quot;: {
          #   &quot;custom_values&quot;: {
          #     &quot;variables&quot;: &quot;&lt;ENV&gt;&quot;,
          #     &quot;filesystem&quot;: &quot;&lt;FS&gt;&quot;,
          #     &quot;workdir&quot;: &quot;&lt;CWD&gt;&quot;,
          #     &quot;&lt;ANY OTHER RELEVANT FIELDS&gt;&quot;: &quot;...&quot;
          #   }
          # }
          # fields are &quot;variables&quot;, &quot;filesystem&quot;, and &quot;workdir&quot;.
        &quot;customValues&quot;: {
          &quot;a_key&quot;: &quot;A String&quot;,
        },
      },
      &quot;materials&quot;: [ # Materials are the supply chain artifacts that go into the step and are used
          # for the operation performed. The key of the map is the path of the artifact
          # and the structure contains the recorded hash information. An example is:
          # &quot;materials&quot;: [
          #   {
          #     &quot;resource_uri&quot;: &quot;foo/bar&quot;,
          #     &quot;hashes&quot;: {
          #       &quot;sha256&quot;: &quot;ebebf...&quot;,
          #       &lt;OTHER HASH ALGORITHMS&gt;: &lt;HASH VALUE&gt;
          #     }
          #   }
          # ]
        {
          &quot;hashes&quot;: { # Defines a hash object for use in Materials and Products.
            &quot;sha256&quot;: &quot;A String&quot;,
          },
          &quot;resourceUri&quot;: &quot;A String&quot;,
        },
      ],
      &quot;products&quot;: [ # Products are the supply chain artifacts generated as a result of the step.
          # The structure is identical to that of materials.
        {
          &quot;hashes&quot;: { # Defines a hash object for use in Materials and Products.
            &quot;sha256&quot;: &quot;A String&quot;,
          },
          &quot;resourceUri&quot;: &quot;A String&quot;,
        },
      ],
    },
    &quot;signatures&quot;: [
      { # A signature object consists of the KeyID used and the signature itself.
        &quot;sig&quot;: &quot;A String&quot;,
        &quot;keyid&quot;: &quot;A String&quot;,
      },
    ],
  },
  &quot;derivedImage&quot;: { # Details of an image occurrence. # Describes how this resource derives from the basis in the associated
      # note.
    &quot;derivedImage&quot;: { # Derived describes the derived image portion (Occurrence) of the DockerImage # Required. Immutable. The child image derived from the base image.
        # relationship. This image would be produced from a Dockerfile with FROM
        # &lt;DockerImage.Basis in attached Note&gt;.
      &quot;fingerprint&quot;: { # A set of properties that uniquely identify a given Docker image. # Required. The fingerprint of the derived image.
        &quot;v2Blob&quot;: [ # Required. The ordered list of v2 blobs that represent a given image.
          &quot;A String&quot;,
        ],
        &quot;v1Name&quot;: &quot;A String&quot;, # Required. The layer ID of the final layer in the Docker image&#x27;s v1
            # representation.
        &quot;v2Name&quot;: &quot;A String&quot;, # Output only. The name of the image&#x27;s v2 blobs computed via:
            #   [bottom] := v2_blobbottom := sha256(v2_blob[N] + &quot; &quot; + v2_name[N+1])
            # Only the name of the final blob is kept.
      },
      &quot;layerInfo&quot;: [ # This contains layer-specific metadata, if populated it has length
          # &quot;distance&quot; and is ordered with [distance] being the layer immediately
          # following the base image and [1] being the final layer.
        { # Layer holds metadata specific to a layer of a Docker image.
          &quot;directive&quot;: &quot;A String&quot;, # Required. The recovered Dockerfile directive used to construct this layer.
          &quot;arguments&quot;: &quot;A String&quot;, # The recovered arguments to the Dockerfile directive.
        },
      ],
      &quot;distance&quot;: 42, # Output only. The number of layers by which this image differs from the
          # associated image basis.
      &quot;baseResourceUrl&quot;: &quot;A String&quot;, # Output only. This contains the base image URL for the derived image
          # occurrence.
    },
  },
}

  updateMask: string, The fields to update.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # An instance of an analysis type that has been found on a resource.
    &quot;kind&quot;: &quot;A String&quot;, # Output only. This explicitly denotes which of the occurrence details are
        # specified. This field can be used as a filter in list requests.
    &quot;resource&quot;: { # An entity that can have metadata. For example, a Docker image. # Required. Immutable. The resource for which the occurrence applies.
      &quot;name&quot;: &quot;A String&quot;, # Deprecated, do not use. Use uri instead.
          #
          # The name of the resource. For example, the name of a Docker image -
          # &quot;Debian&quot;.
      &quot;contentHash&quot;: { # Container message for hash values. # Deprecated, do not use. Use uri instead.
          #
          # The hash of the resource content. For example, the Docker digest.
        &quot;type&quot;: &quot;A String&quot;, # Required. The type of hash that was performed.
        &quot;value&quot;: &quot;A String&quot;, # Required. The hash value.
      },
      &quot;uri&quot;: &quot;A String&quot;, # Required. The unique URI of the resource. For example,
          # `https://gcr.io/project/image@sha256:foo` for a Docker image.
    },
    &quot;attestation&quot;: { # Details of an attestation occurrence. # Describes an attestation of an artifact.
      &quot;attestation&quot;: { # Occurrence that represents a single &quot;attestation&quot;. The authenticity of an # Required. Attestation for the resource.
          # attestation can be verified using the attached signature. If the verifier
          # trusts the public key of the signer, then verifying the signature is
          # sufficient to establish trust. In this circumstance, the authority to which
          # this attestation is attached is primarily useful for look-up (how to find
          # this attestation if you already know the authority and artifact to be
          # verified) and intent (which authority was this attestation intended to sign
          # for).
        &quot;pgpSignedAttestation&quot;: { # An attestation wrapper with a PGP-compatible signature. This message only # A PGP signed attestation.
            # supports `ATTACHED` signatures, where the payload that is signed is included
            # alongside the signature itself in the same file.
          &quot;contentType&quot;: &quot;A String&quot;, # Type (for example schema) of the attestation payload that was signed.
              # The verifier must ensure that the provided type is one that the verifier
              # supports, and that the attestation payload is a valid instantiation of that
              # type (for example by validating a JSON schema).
          &quot;signature&quot;: &quot;A String&quot;, # Required. The raw content of the signature, as output by GNU Privacy Guard
              # (GPG) or equivalent. Since this message only supports attached signatures,
              # the payload that was signed must be attached. While the signature format
              # supported is dependent on the verification implementation, currently only
              # ASCII-armored (`--armor` to gpg), non-clearsigned (`--sign` rather than
              # `--clearsign` to gpg) are supported. Concretely, `gpg --sign --armor
              # --output=signature.gpg payload.json` will create the signature content
              # expected in this field in `signature.gpg` for the `payload.json`
              # attestation payload.
          &quot;pgpKeyId&quot;: &quot;A String&quot;, # The cryptographic fingerprint of the key used to generate the signature,
              # as output by, e.g. `gpg --list-keys`. This should be the version 4, full
              # 160-bit fingerprint, expressed as a 40 character hexidecimal string. See
              # https://tools.ietf.org/html/rfc4880#section-12.2 for details.
              # Implementations may choose to acknowledge &quot;LONG&quot;, &quot;SHORT&quot;, or other
              # abbreviated key IDs, but only the full fingerprint is guaranteed to work.
              # In gpg, the full fingerprint can be retrieved from the `fpr` field
              # returned when calling --list-keys with --with-colons.  For example:
              # ```
              # gpg --with-colons --with-fingerprint --force-v4-certs \
              #     --list-keys attester@example.com
              # tru::1:1513631572:0:3:1:5
              # pub:...&lt;SNIP&gt;...
              # fpr:::::::::24FF6481B76AC91E66A00AC657A93A81EF3AE6FB:
              # ```
              # Above, the fingerprint is `24FF6481B76AC91E66A00AC657A93A81EF3AE6FB`.
        },
        &quot;genericSignedAttestation&quot;: { # An attestation wrapper that uses the Grafeas `Signature` message.
            # This attestation must define the `serialized_payload` that the `signatures`
            # verify and any metadata necessary to interpret that plaintext.  The
            # signatures should always be over the `serialized_payload` bytestring.
          &quot;contentType&quot;: &quot;A String&quot;, # Type (for example schema) of the attestation payload that was signed.
              # The verifier must ensure that the provided type is one that the verifier
              # supports, and that the attestation payload is a valid instantiation of that
              # type (for example by validating a JSON schema).
          &quot;signatures&quot;: [ # One or more signatures over `serialized_payload`.  Verifier implementations
              # should consider this attestation message verified if at least one
              # `signature` verifies `serialized_payload`.  See `Signature` in common.proto
              # for more details on signature structure and verification.
            { # Verifiers (e.g. Kritis implementations) MUST verify signatures
                # with respect to the trust anchors defined in policy (e.g. a Kritis policy).
                # Typically this means that the verifier has been configured with a map from
                # `public_key_id` to public key material (and any required parameters, e.g.
                # signing algorithm).
                #
                # In particular, verification implementations MUST NOT treat the signature
                # `public_key_id` as anything more than a key lookup hint. The `public_key_id`
                # DOES NOT validate or authenticate a public key; it only provides a mechanism
                # for quickly selecting a public key ALREADY CONFIGURED on the verifier through
                # a trusted channel. Verification implementations MUST reject signatures in any
                # of the following circumstances:
                #   * The `public_key_id` is not recognized by the verifier.
                #   * The public key that `public_key_id` refers to does not verify the
                #     signature with respect to the payload.
                #
                # The `signature` contents SHOULD NOT be &quot;attached&quot; (where the payload is
                # included with the serialized `signature` bytes). Verifiers MUST ignore any
                # &quot;attached&quot; payload and only verify signatures with respect to explicitly
                # provided payload (e.g. a `payload` field on the proto message that holds
                # this Signature, or the canonical serialization of the proto message that
                # holds this signature).
              &quot;publicKeyId&quot;: &quot;A String&quot;, # The identifier for the public key that verifies this signature.
                  #   * The `public_key_id` is required.
                  #   * The `public_key_id` MUST be an RFC3986 conformant URI.
                  #   * When possible, the `public_key_id` SHOULD be an immutable reference,
                  #     such as a cryptographic digest.
                  #
                  # Examples of valid `public_key_id`s:
                  #
                  # OpenPGP V4 public key fingerprint:
                  #   * &quot;openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA&quot;
                  # See https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr for more
                  # details on this scheme.
                  #
                  # RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER
                  # serialization):
                  #   * &quot;ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU&quot;
                  #   * &quot;nih:///sha-256;703f68f42aba2c6de30f488a5ea122fef76324679c9bf89791ba95a1271589a5&quot;
              &quot;signature&quot;: &quot;A String&quot;, # The content of the signature, an opaque bytestring.
                  # The payload that this signature verifies MUST be unambiguously provided
                  # with the Signature during verification. A wrapper message might provide
                  # the payload explicitly. Alternatively, a message might have a canonical
                  # serialization that can always be unambiguously computed to derive the
                  # payload.
            },
          ],
          &quot;serializedPayload&quot;: &quot;A String&quot;, # The serialized payload that is verified by one or more `signatures`.
              # The encoding and semantic meaning of this payload must match what is set in
              # `content_type`.
        },
      },
    },
    &quot;name&quot;: &quot;A String&quot;, # Output only. The name of the occurrence in the form of
        # `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
    &quot;vulnerability&quot;: { # Details of a vulnerability Occurrence. # Describes a security vulnerability.
      &quot;longDescription&quot;: &quot;A String&quot;, # Output only. A detailed description of this vulnerability.
      &quot;shortDescription&quot;: &quot;A String&quot;, # Output only. A one sentence description of this vulnerability.
      &quot;effectiveSeverity&quot;: &quot;A String&quot;, # The distro assigned severity for this vulnerability when it is
          # available, and note provider assigned severity when distro has not yet
          # assigned a severity for this vulnerability.
      &quot;severity&quot;: &quot;A String&quot;, # Output only. The note provider assigned Severity of the vulnerability.
      &quot;cvssScore&quot;: 3.14, # Output only. The CVSS score of this vulnerability. CVSS score is on a
          # scale of 0-10 where 0 indicates low severity and 10 indicates high
          # severity.
      &quot;relatedUrls&quot;: [ # Output only. URLs related to this vulnerability.
        { # Metadata for any related URL information.
          &quot;url&quot;: &quot;A String&quot;, # Specific URL associated with the resource.
          &quot;label&quot;: &quot;A String&quot;, # Label to describe usage of the URL.
        },
      ],
      &quot;type&quot;: &quot;A String&quot;, # The type of package; whether native or non native(ruby gems, node.js
          # packages etc)
      &quot;packageIssue&quot;: [ # Required. The set of affected locations and their fixes (if available)
          # within the associated resource.
        { # This message wraps a location affected by a vulnerability and its
            # associated fix (if one is available).
          &quot;severityName&quot;: &quot;A String&quot;, # Deprecated, use Details.effective_severity instead
              # The severity (e.g., distro assigned severity) for this vulnerability.
          &quot;affectedLocation&quot;: { # The location of the vulnerability. # Required. The location of the vulnerability.
            &quot;package&quot;: &quot;A String&quot;, # Required. The package being described.
            &quot;version&quot;: { # Version contains structured information about the version of a package. # Required. The version of the package being described.
              &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
              &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                  # name.
              &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                  # versions.
              &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
            },
            &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in [cpe format](https://cpe.mitre.org/specification/)
                # format. Examples include distro or storage location for vulnerable jar.
          },
          &quot;fixedLocation&quot;: { # The location of the vulnerability. # The location of the available fix for vulnerability.
            &quot;package&quot;: &quot;A String&quot;, # Required. The package being described.
            &quot;version&quot;: { # Version contains structured information about the version of a package. # Required. The version of the package being described.
              &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
              &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                  # name.
              &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                  # versions.
              &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
            },
            &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in [cpe format](https://cpe.mitre.org/specification/)
                # format. Examples include distro or storage location for vulnerable jar.
          },
        },
      ],
    },
    &quot;installation&quot;: { # Details of a package occurrence. # Describes the installation of a package on the linked resource.
      &quot;installation&quot;: { # This represents how a particular software package may be installed on a # Required. Where the package was installed.
          # system.
        &quot;location&quot;: [ # Required. All of the places within the filesystem versions of this package
            # have been found.
          { # An occurrence of a particular package installation found within a system&#x27;s
              # filesystem. E.g., glibc was found in `/var/lib/dpkg/status`.
            &quot;cpeUri&quot;: &quot;A String&quot;, # Required. The CPE URI in [CPE format](https://cpe.mitre.org/specification/)
                # denoting the package manager version distributing a package.
            &quot;version&quot;: { # Version contains structured information about the version of a package. # The version installed at this location.
              &quot;revision&quot;: &quot;A String&quot;, # The iteration of the package build from the above version.
              &quot;name&quot;: &quot;A String&quot;, # Required only when version kind is NORMAL. The main part of the version
                  # name.
              &quot;kind&quot;: &quot;A String&quot;, # Required. Distinguishes between sentinel MIN/MAX versions and normal
                  # versions.
              &quot;epoch&quot;: 42, # Used to correct mistakes in the version numbering scheme.
            },
            &quot;path&quot;: &quot;A String&quot;, # The path from which we gathered that this package/version is installed.
          },
        ],
        &quot;name&quot;: &quot;A String&quot;, # Output only. The name of the installed package.
      },
    },
    &quot;build&quot;: { # Details of a build occurrence. # Describes a verifiable build.
      &quot;provenanceBytes&quot;: &quot;A String&quot;, # Serialized JSON representation of the provenance, used in generating the
          # build signature in the corresponding build note. After verifying the
          # signature, `provenance_bytes` can be unmarshalled and compared to the
          # provenance to confirm that it is unchanged. A base64-encoded string
          # representation of the provenance bytes is used for the signature in order
          # to interoperate with openssl which expects this format for signature
          # verification.
          #
          # The serialized form is captured both to avoid ambiguity in how the
          # provenance is marshalled to json as well to prevent incompatibilities with
          # future changes.
      &quot;provenance&quot;: { # Provenance of a build. Contains all information needed to verify the full # Required. The actual provenance for the build.
          # details about the build from source to completion.
        &quot;endTime&quot;: &quot;A String&quot;, # Time at which execution of the build was finished.
        &quot;startTime&quot;: &quot;A String&quot;, # Time at which execution of the build was started.
        &quot;triggerId&quot;: &quot;A String&quot;, # Trigger identifier if the build was triggered automatically; empty if not.
        &quot;sourceProvenance&quot;: { # Source describes the location of the source used for the build. # Details of the Source input to the build.
          &quot;artifactStorageSourceUri&quot;: &quot;A String&quot;, # If provided, the input binary artifacts for the build came from this
              # location.
          &quot;additionalContexts&quot;: [ # If provided, some of the source code used for the build may be found in
              # these locations, in the case where the source repository had multiple
              # remotes or submodules. This list will not include the context specified in
              # the context field.
            { # A SourceContext is a reference to a tree of files. A SourceContext together
                # with a path point to a unique revision of a single file or directory.
              &quot;labels&quot;: { # Labels with user defined metadata.
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;git&quot;: { # A GitSourceContext denotes a particular revision in a third party Git # A SourceContext referring to any third party Git repo (e.g., GitHub).
                  # repository (e.g., GitHub).
                &quot;url&quot;: &quot;A String&quot;, # Git repository URL.
                &quot;revisionId&quot;: &quot;A String&quot;, # Git commit hash.
              },
              &quot;gerrit&quot;: { # A SourceContext referring to a Gerrit project. # A SourceContext referring to a Gerrit project.
                &quot;hostUri&quot;: &quot;A String&quot;, # The URI of a running Gerrit instance.
                &quot;revisionId&quot;: &quot;A String&quot;, # A revision (commit) ID.
                &quot;gerritProject&quot;: &quot;A String&quot;, # The full project name within the host. Projects may be nested, so
                    # &quot;project/subproject&quot; is a valid project name. The &quot;repo name&quot; is the
                    # hostURI/project.
                &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                  &quot;name&quot;: &quot;A String&quot;, # The alias name.
                  &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
                },
              },
              &quot;cloudRepo&quot;: { # A CloudRepoSourceContext denotes a particular revision in a Google Cloud # A SourceContext referring to a revision in a Google Cloud Source Repo.
                  # Source Repo.
                &quot;revisionId&quot;: &quot;A String&quot;, # A revision ID.
                &quot;repoId&quot;: { # A unique identifier for a Cloud Repo. # The ID of the repo.
                  &quot;projectRepoId&quot;: { # Selects a repo using a Google Cloud Platform project ID (e.g., # A combination of a project ID and a repo name.
                      # winged-cargo-31) and a repo name within that project.
                    &quot;projectId&quot;: &quot;A String&quot;, # The ID of the project.
                    &quot;repoName&quot;: &quot;A String&quot;, # The name of the repo. Leave empty for the default repo.
                  },
                  &quot;uid&quot;: &quot;A String&quot;, # A server-assigned, globally unique identifier.
                },
                &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                  &quot;name&quot;: &quot;A String&quot;, # The alias name.
                  &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
                },
              },
            },
          ],
          &quot;fileHashes&quot;: { # Hash(es) of the build source, which can be used to verify that the original
              # source integrity was maintained in the build.
              #
              # The keys to this map are file paths used as build source and the values
              # contain the hash values for those files.
              #
              # If the build source came in a single package such as a gzipped tarfile
              # (.tar.gz), the FileHash will be for the single path to that file.
            &quot;a_key&quot;: { # Container message for hashes of byte content of files, used in source
                # messages to verify integrity of source input to the build.
              &quot;fileHash&quot;: [ # Required. Collection of file hashes.
                { # Container message for hash values.
                  &quot;type&quot;: &quot;A String&quot;, # Required. The type of hash that was performed.
                  &quot;value&quot;: &quot;A String&quot;, # Required. The hash value.
                },
              ],
            },
          },
          &quot;context&quot;: { # A SourceContext is a reference to a tree of files. A SourceContext together # If provided, the source code used for the build came from this location.
              # with a path point to a unique revision of a single file or directory.
            &quot;labels&quot;: { # Labels with user defined metadata.
              &quot;a_key&quot;: &quot;A String&quot;,
            },
            &quot;git&quot;: { # A GitSourceContext denotes a particular revision in a third party Git # A SourceContext referring to any third party Git repo (e.g., GitHub).
                # repository (e.g., GitHub).
              &quot;url&quot;: &quot;A String&quot;, # Git repository URL.
              &quot;revisionId&quot;: &quot;A String&quot;, # Git commit hash.
            },
            &quot;gerrit&quot;: { # A SourceContext referring to a Gerrit project. # A SourceContext referring to a Gerrit project.
              &quot;hostUri&quot;: &quot;A String&quot;, # The URI of a running Gerrit instance.
              &quot;revisionId&quot;: &quot;A String&quot;, # A revision (commit) ID.
              &quot;gerritProject&quot;: &quot;A String&quot;, # The full project name within the host. Projects may be nested, so
                  # &quot;project/subproject&quot; is a valid project name. The &quot;repo name&quot; is the
                  # hostURI/project.
              &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                &quot;name&quot;: &quot;A String&quot;, # The alias name.
                &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
              },
            },
            &quot;cloudRepo&quot;: { # A CloudRepoSourceContext denotes a particular revision in a Google Cloud # A SourceContext referring to a revision in a Google Cloud Source Repo.
                # Source Repo.
              &quot;revisionId&quot;: &quot;A String&quot;, # A revision ID.
              &quot;repoId&quot;: { # A unique identifier for a Cloud Repo. # The ID of the repo.
                &quot;projectRepoId&quot;: { # Selects a repo using a Google Cloud Platform project ID (e.g., # A combination of a project ID and a repo name.
                    # winged-cargo-31) and a repo name within that project.
                  &quot;projectId&quot;: &quot;A String&quot;, # The ID of the project.
                  &quot;repoName&quot;: &quot;A String&quot;, # The name of the repo. Leave empty for the default repo.
                },
                &quot;uid&quot;: &quot;A String&quot;, # A server-assigned, globally unique identifier.
              },
              &quot;aliasContext&quot;: { # An alias to a repo revision. # An alias, which may be a branch or tag.
                &quot;name&quot;: &quot;A String&quot;, # The alias name.
                &quot;kind&quot;: &quot;A String&quot;, # The alias kind.
              },
            },
          },
        },
        &quot;createTime&quot;: &quot;A String&quot;, # Time at which the build was created.
        &quot;projectId&quot;: &quot;A String&quot;, # ID of the project.
        &quot;logsUri&quot;: &quot;A String&quot;, # URI where any logs for this provenance were written.
        &quot;creator&quot;: &quot;A String&quot;, # E-mail address of the user who initiated this build. Note that this was the
            # user&#x27;s e-mail address at the time the build was initiated; this address may
            # not represent the same end-user for all time.
        &quot;builderVersion&quot;: &quot;A String&quot;, # Version string of the builder at the time this build was executed.
        &quot;commands&quot;: [ # Commands requested by the build.
          { # Command describes a step performed as part of the build pipeline.
            &quot;dir&quot;: &quot;A String&quot;, # Working directory (relative to project source root) used when running this
                # command.
            &quot;waitFor&quot;: [ # The ID(s) of the command(s) that this command depends on.
              &quot;A String&quot;,
            ],
            &quot;env&quot;: [ # Environment variables set before running this command.
              &quot;A String&quot;,
            ],
            &quot;args&quot;: [ # Command-line arguments used when executing this command.
              &quot;A String&quot;,
            ],
            &quot;name&quot;: &quot;A String&quot;, # Required. Name of the command, as presented on the command line, or if the
                # command is packaged as a Docker container, as presented to `docker pull`.
            &quot;id&quot;: &quot;A String&quot;, # Optional unique identifier for this command, used in wait_for to reference
                # this command as a dependency.
          },
        ],
        &quot;builtArtifacts&quot;: [ # Output of the build.
          { # Artifact describes a build product.
            &quot;checksum&quot;: &quot;A String&quot;, # Hash or checksum value of a binary, or Docker Registry 2.0 digest of a
                # container.
            &quot;id&quot;: &quot;A String&quot;, # Artifact ID, if any; for container images, this will be a URL by digest
                # like `gcr.io/projectID/imagename@sha256:123456`.
            &quot;names&quot;: [ # Related artifact names. This may be the path to a binary or jar file, or in
                # the case of a container build, the name used to push the container image to
                # Google Container Registry, as presented to `docker push`. Note that a
                # single Artifact ID can have multiple names, for example if two tags are
                # applied to one image.
              &quot;A String&quot;,
            ],
          },
        ],
        &quot;id&quot;: &quot;A String&quot;, # Required. Unique identifier of the build.
        &quot;buildOptions&quot;: { # Special options applied to this build. This is a catch-all field where
            # build providers can enter any desired additional details.
          &quot;a_key&quot;: &quot;A String&quot;,
        },
      },
    },
    &quot;discovered&quot;: { # Details of a discovery occurrence. # Describes when a resource was discovered.
      &quot;discovered&quot;: { # Provides information about the analysis status of a discovered resource. # Required. Analysis status for the discovered resource.
        &quot;analysisStatusError&quot;: { # The `Status` type defines a logical error model that is suitable for # When an error is encountered this will contain a LocalizedMessage under
            # details to show to the user. The LocalizedMessage is output only and
            # populated by the API.
            # different programming environments, including REST APIs and RPC APIs. It is
            # used by [gRPC](https://github.com/grpc). Each `Status` message contains
            # three pieces of data: error code, error message, and error details.
            #
            # You can find out more about this error model and how to work with it in the
            # [API Design Guide](https://cloud.google.com/apis/design/errors).
          &quot;details&quot;: [ # A list of messages that carry the error details.  There is a common set of
              # message types for APIs to use.
            {
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
            },
          ],
          &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
          &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any
              # user-facing error message should be localized and sent in the
              # google.rpc.Status.details field, or localized by the client.
        },
        &quot;analysisStatus&quot;: &quot;A String&quot;, # The status of discovery for the resource.
        &quot;continuousAnalysis&quot;: &quot;A String&quot;, # Whether the resource is continuously analyzed.
        &quot;lastAnalysisTime&quot;: &quot;A String&quot;, # The last time continuous analysis was done for this resource.
            # Deprecated, do not use.
      },
    },
    &quot;noteName&quot;: &quot;A String&quot;, # Required. Immutable. The analysis note associated with this occurrence, in
        # the form of `projects/[PROVIDER_ID]/notes/[NOTE_ID]`. This field can be
        # used as a filter in list requests.
    &quot;deployment&quot;: { # Details of a deployment occurrence. # Describes the deployment of an artifact on a runtime.
      &quot;deployment&quot;: { # The period during which some deployable was active in a runtime. # Required. Deployment history for the resource.
        &quot;userEmail&quot;: &quot;A String&quot;, # Identity of the user that triggered this deployment.
        &quot;config&quot;: &quot;A String&quot;, # Configuration used to create this deployment.
        &quot;undeployTime&quot;: &quot;A String&quot;, # End of the lifetime of this deployment.
        &quot;platform&quot;: &quot;A String&quot;, # Platform hosting this deployment.
        &quot;deployTime&quot;: &quot;A String&quot;, # Required. Beginning of the lifetime of this deployment.
        &quot;address&quot;: &quot;A String&quot;, # Address of the runtime element hosting this deployment.
        &quot;resourceUri&quot;: [ # Output only. Resource URI for the artifact being deployed taken from
            # the deployable field with the same name.
          &quot;A String&quot;,
        ],
      },
    },
    &quot;createTime&quot;: &quot;A String&quot;, # Output only. The time this occurrence was created.
    &quot;updateTime&quot;: &quot;A String&quot;, # Output only. The time this occurrence was last updated.
    &quot;remediation&quot;: &quot;A String&quot;, # A description of actions that can be taken to remedy the note.
    &quot;intoto&quot;: { # This corresponds to a signed in-toto link - it is made up of one or more # Describes a specific in-toto link.
        # signatures and the in-toto link itself. This is used for occurrences of a
        # Grafeas in-toto note.
      &quot;signed&quot;: { # This corresponds to an in-toto link.
        &quot;command&quot;: [ # This field contains the full command executed for the step. This can also
            # be empty if links are generated for operations that aren&#x27;t directly mapped
            # to a specific command. Each term in the command is an independent string
            # in the list. An example of a command in the in-toto metadata field is:
            # &quot;command&quot;: [&quot;git&quot;, &quot;clone&quot;, &quot;https://github.com/in-toto/demo-project.git&quot;]
          &quot;A String&quot;,
        ],
        &quot;byproducts&quot;: { # Defines an object for the byproducts field in in-toto links. The suggested # ByProducts are data generated as part of a software supply chain step, but
            # are not the actual result of the step.
            # fields are &quot;stderr&quot;, &quot;stdout&quot;, and &quot;return-value&quot;.
          &quot;customValues&quot;: {
            &quot;a_key&quot;: &quot;A String&quot;,
          },
        },
        &quot;environment&quot;: { # Defines an object for the environment field in in-toto links. The suggested # This is a field that can be used to capture information about the
            # environment. It is suggested for this field to contain information that
            # details environment variables, filesystem information, and the present
            # working directory. The recommended structure of this field is:
            # &quot;environment&quot;: {
            #   &quot;custom_values&quot;: {
            #     &quot;variables&quot;: &quot;&lt;ENV&gt;&quot;,
            #     &quot;filesystem&quot;: &quot;&lt;FS&gt;&quot;,
            #     &quot;workdir&quot;: &quot;&lt;CWD&gt;&quot;,
            #     &quot;&lt;ANY OTHER RELEVANT FIELDS&gt;&quot;: &quot;...&quot;
            #   }
            # }
            # fields are &quot;variables&quot;, &quot;filesystem&quot;, and &quot;workdir&quot;.
          &quot;customValues&quot;: {
            &quot;a_key&quot;: &quot;A String&quot;,
          },
        },
        &quot;materials&quot;: [ # Materials are the supply chain artifacts that go into the step and are used
            # for the operation performed. The key of the map is the path of the artifact
            # and the structure contains the recorded hash information. An example is:
            # &quot;materials&quot;: [
            #   {
            #     &quot;resource_uri&quot;: &quot;foo/bar&quot;,
            #     &quot;hashes&quot;: {
            #       &quot;sha256&quot;: &quot;ebebf...&quot;,
            #       &lt;OTHER HASH ALGORITHMS&gt;: &lt;HASH VALUE&gt;
            #     }
            #   }
            # ]
          {
            &quot;hashes&quot;: { # Defines a hash object for use in Materials and Products.
              &quot;sha256&quot;: &quot;A String&quot;,
            },
            &quot;resourceUri&quot;: &quot;A String&quot;,
          },
        ],
        &quot;products&quot;: [ # Products are the supply chain artifacts generated as a result of the step.
            # The structure is identical to that of materials.
          {
            &quot;hashes&quot;: { # Defines a hash object for use in Materials and Products.
              &quot;sha256&quot;: &quot;A String&quot;,
            },
            &quot;resourceUri&quot;: &quot;A String&quot;,
          },
        ],
      },
      &quot;signatures&quot;: [
        { # A signature object consists of the KeyID used and the signature itself.
          &quot;sig&quot;: &quot;A String&quot;,
          &quot;keyid&quot;: &quot;A String&quot;,
        },
      ],
    },
    &quot;derivedImage&quot;: { # Details of an image occurrence. # Describes how this resource derives from the basis in the associated
        # note.
      &quot;derivedImage&quot;: { # Derived describes the derived image portion (Occurrence) of the DockerImage # Required. Immutable. The child image derived from the base image.
          # relationship. This image would be produced from a Dockerfile with FROM
          # &lt;DockerImage.Basis in attached Note&gt;.
        &quot;fingerprint&quot;: { # A set of properties that uniquely identify a given Docker image. # Required. The fingerprint of the derived image.
          &quot;v2Blob&quot;: [ # Required. The ordered list of v2 blobs that represent a given image.
            &quot;A String&quot;,
          ],
          &quot;v1Name&quot;: &quot;A String&quot;, # Required. The layer ID of the final layer in the Docker image&#x27;s v1
              # representation.
          &quot;v2Name&quot;: &quot;A String&quot;, # Output only. The name of the image&#x27;s v2 blobs computed via:
              #   [bottom] := v2_blobbottom := sha256(v2_blob[N] + &quot; &quot; + v2_name[N+1])
              # Only the name of the final blob is kept.
        },
        &quot;layerInfo&quot;: [ # This contains layer-specific metadata, if populated it has length
            # &quot;distance&quot; and is ordered with [distance] being the layer immediately
            # following the base image and [1] being the final layer.
          { # Layer holds metadata specific to a layer of a Docker image.
            &quot;directive&quot;: &quot;A String&quot;, # Required. The recovered Dockerfile directive used to construct this layer.
            &quot;arguments&quot;: &quot;A String&quot;, # The recovered arguments to the Dockerfile directive.
          },
        ],
        &quot;distance&quot;: 42, # Output only. The number of layers by which this image differs from the
            # associated image basis.
        &quot;baseResourceUrl&quot;: &quot;A String&quot;, # Output only. This contains the base image URL for the derived image
            # occurrence.
      },
    },
  }</pre>
</div>

<div class="method">
    <code class="details" id="setIamPolicy">setIamPolicy(resource, body=None, x__xgafv=None)</code>
  <pre>Sets the access control policy on the specified note or occurrence.
Requires `containeranalysis.notes.setIamPolicy` or
`containeranalysis.occurrences.setIamPolicy` permission if the resource is
a note or an occurrence, respectively.

The resource takes the format `projects/[PROJECT_ID]/notes/[NOTE_ID]` for
notes and `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]` for
occurrences.

Args:
  resource: string, REQUIRED: The resource for which the policy is being specified.
See the operation documentation for the appropriate value for this field. (required)
  body: object, The request body.
    The object takes the form of:

{ # Request message for `SetIamPolicy` method.
    &quot;policy&quot;: { # An Identity and Access Management (IAM) policy, which specifies access # REQUIRED: The complete policy to be applied to the `resource`. The size of
        # the policy is limited to a few 10s of KB. An empty policy is a
        # valid policy but certain Cloud Platform services (such as Projects)
        # might reject them.
        # controls for Google Cloud resources.
        #
        #
        # A `Policy` is a collection of `bindings`. A `binding` binds one or more
        # `members` to a single `role`. Members can be user accounts, service accounts,
        # Google groups, and domains (such as G Suite). A `role` is a named list of
        # permissions; each `role` can be an IAM predefined role or a user-created
        # custom role.
        #
        # For some types of Google Cloud resources, a `binding` can also specify a
        # `condition`, which is a logical expression that allows access to a resource
        # only if the expression evaluates to `true`. A condition can add constraints
        # based on attributes of the request, the resource, or both. To learn which
        # resources support conditions in their IAM policies, see the
        # [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
        #
        # **JSON example:**
        #
        #     {
        #       &quot;bindings&quot;: [
        #         {
        #           &quot;role&quot;: &quot;roles/resourcemanager.organizationAdmin&quot;,
        #           &quot;members&quot;: [
        #             &quot;user:mike@example.com&quot;,
        #             &quot;group:admins@example.com&quot;,
        #             &quot;domain:google.com&quot;,
        #             &quot;serviceAccount:my-project-id@appspot.gserviceaccount.com&quot;
        #           ]
        #         },
        #         {
        #           &quot;role&quot;: &quot;roles/resourcemanager.organizationViewer&quot;,
        #           &quot;members&quot;: [
        #             &quot;user:eve@example.com&quot;
        #           ],
        #           &quot;condition&quot;: {
        #             &quot;title&quot;: &quot;expirable access&quot;,
        #             &quot;description&quot;: &quot;Does not grant access after Sep 2020&quot;,
        #             &quot;expression&quot;: &quot;request.time &lt; timestamp(&#x27;2020-10-01T00:00:00.000Z&#x27;)&quot;,
        #           }
        #         }
        #       ],
        #       &quot;etag&quot;: &quot;BwWWja0YfJA=&quot;,
        #       &quot;version&quot;: 3
        #     }
        #
        # **YAML example:**
        #
        #     bindings:
        #     - members:
        #       - user:mike@example.com
        #       - group:admins@example.com
        #       - domain:google.com
        #       - serviceAccount:my-project-id@appspot.gserviceaccount.com
        #       role: roles/resourcemanager.organizationAdmin
        #     - members:
        #       - user:eve@example.com
        #       role: roles/resourcemanager.organizationViewer
        #       condition:
        #         title: expirable access
        #         description: Does not grant access after Sep 2020
        #         expression: request.time &lt; timestamp(&#x27;2020-10-01T00:00:00.000Z&#x27;)
        #     - etag: BwWWja0YfJA=
        #     - version: 3
        #
        # For a description of IAM and its features, see the
        # [IAM documentation](https://cloud.google.com/iam/docs/).
      &quot;etag&quot;: &quot;A String&quot;, # `etag` is used for optimistic concurrency control as a way to help
          # prevent simultaneous updates of a policy from overwriting each other.
          # It is strongly suggested that systems make use of the `etag` in the
          # read-modify-write cycle to perform policy updates in order to avoid race
          # conditions: An `etag` is returned in the response to `getIamPolicy`, and
          # systems are expected to put that etag in the request to `setIamPolicy` to
          # ensure that their change will be applied to the same version of the policy.
          #
          # **Important:** If you use IAM Conditions, you must include the `etag` field
          # whenever you call `setIamPolicy`. If you omit this field, then IAM allows
          # you to overwrite a version `3` policy with a version `1` policy, and all of
          # the conditions in the version `3` policy are lost.
      &quot;version&quot;: 42, # Specifies the format of the policy.
          #
          # Valid values are `0`, `1`, and `3`. Requests that specify an invalid value
          # are rejected.
          #
          # Any operation that affects conditional role bindings must specify version
          # `3`. This requirement applies to the following operations:
          #
          # * Getting a policy that includes a conditional role binding
          # * Adding a conditional role binding to a policy
          # * Changing a conditional role binding in a policy
          # * Removing any role binding, with or without a condition, from a policy
          #   that includes conditions
          #
          # **Important:** If you use IAM Conditions, you must include the `etag` field
          # whenever you call `setIamPolicy`. If you omit this field, then IAM allows
          # you to overwrite a version `3` policy with a version `1` policy, and all of
          # the conditions in the version `3` policy are lost.
          #
          # If a policy does not include any conditions, operations on that policy may
          # specify any valid version or leave the field unset.
          #
          # To learn which resources support conditions in their IAM policies, see the
          # [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
      &quot;bindings&quot;: [ # Associates a list of `members` to a `role`. Optionally, may specify a
          # `condition` that determines how and when the `bindings` are applied. Each
          # of the `bindings` must contain at least one member.
        { # Associates `members` with a `role`.
          &quot;condition&quot;: { # Represents a textual expression in the Common Expression Language (CEL) # The condition that is associated with this binding.
              #
              # If the condition evaluates to `true`, then this binding applies to the
              # current request.
              #
              # If the condition evaluates to `false`, then this binding does not apply to
              # the current request. However, a different role binding might grant the same
              # role to one or more of the members in this binding.
              #
              # To learn which resources support conditions in their IAM policies, see the
              # [IAM
              # documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
              # syntax. CEL is a C-like expression language. The syntax and semantics of CEL
              # are documented at https://github.com/google/cel-spec.
              #
              # Example (Comparison):
              #
              #     title: &quot;Summary size limit&quot;
              #     description: &quot;Determines if a summary is less than 100 chars&quot;
              #     expression: &quot;document.summary.size() &lt; 100&quot;
              #
              # Example (Equality):
              #
              #     title: &quot;Requestor is owner&quot;
              #     description: &quot;Determines if requestor is the document owner&quot;
              #     expression: &quot;document.owner == request.auth.claims.email&quot;
              #
              # Example (Logic):
              #
              #     title: &quot;Public documents&quot;
              #     description: &quot;Determine whether the document should be publicly visible&quot;
              #     expression: &quot;document.type != &#x27;private&#x27; &amp;&amp; document.type != &#x27;internal&#x27;&quot;
              #
              # Example (Data Manipulation):
              #
              #     title: &quot;Notification string&quot;
              #     description: &quot;Create a notification string with a timestamp.&quot;
              #     expression: &quot;&#x27;New message received at &#x27; + string(document.create_time)&quot;
              #
              # The exact variables and functions that may be referenced within an expression
              # are determined by the service that evaluates it. See the service
              # documentation for additional information.
            &quot;description&quot;: &quot;A String&quot;, # Optional. Description of the expression. This is a longer text which
                # describes the expression, e.g. when hovered over it in a UI.
            &quot;expression&quot;: &quot;A String&quot;, # Textual representation of an expression in Common Expression Language
                # syntax.
            &quot;title&quot;: &quot;A String&quot;, # Optional. Title for the expression, i.e. a short string describing
                # its purpose. This can be used e.g. in UIs which allow to enter the
                # expression.
            &quot;location&quot;: &quot;A String&quot;, # Optional. String indicating the location of the expression for error
                # reporting, e.g. a file name and a position in the file.
          },
          &quot;members&quot;: [ # Specifies the identities requesting access for a Cloud Platform resource.
              # `members` can have the following values:
              #
              # * `allUsers`: A special identifier that represents anyone who is
              #    on the internet; with or without a Google account.
              #
              # * `allAuthenticatedUsers`: A special identifier that represents anyone
              #    who is authenticated with a Google account or a service account.
              #
              # * `user:{emailid}`: An email address that represents a specific Google
              #    account. For example, `alice@example.com` .
              #
              #
              # * `serviceAccount:{emailid}`: An email address that represents a service
              #    account. For example, `my-other-app@appspot.gserviceaccount.com`.
              #
              # * `group:{emailid}`: An email address that represents a Google group.
              #    For example, `admins@example.com`.
              #
              # * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique
              #    identifier) representing a user that has been recently deleted. For
              #    example, `alice@example.com?uid=123456789012345678901`. If the user is
              #    recovered, this value reverts to `user:{emailid}` and the recovered user
              #    retains the role in the binding.
              #
              # * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus
              #    unique identifier) representing a service account that has been recently
              #    deleted. For example,
              #    `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`.
              #    If the service account is undeleted, this value reverts to
              #    `serviceAccount:{emailid}` and the undeleted service account retains the
              #    role in the binding.
              #
              # * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique
              #    identifier) representing a Google group that has been recently
              #    deleted. For example, `admins@example.com?uid=123456789012345678901`. If
              #    the group is recovered, this value reverts to `group:{emailid}` and the
              #    recovered group retains the role in the binding.
              #
              #
              # * `domain:{domain}`: The G Suite domain (primary) that represents all the
              #    users of that domain. For example, `google.com` or `example.com`.
              #
            &quot;A String&quot;,
          ],
          &quot;role&quot;: &quot;A String&quot;, # Role that is assigned to `members`.
              # For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
        },
      ],
    },
  }

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # An Identity and Access Management (IAM) policy, which specifies access
      # controls for Google Cloud resources.
      #
      #
      # A `Policy` is a collection of `bindings`. A `binding` binds one or more
      # `members` to a single `role`. Members can be user accounts, service accounts,
      # Google groups, and domains (such as G Suite). A `role` is a named list of
      # permissions; each `role` can be an IAM predefined role or a user-created
      # custom role.
      #
      # For some types of Google Cloud resources, a `binding` can also specify a
      # `condition`, which is a logical expression that allows access to a resource
      # only if the expression evaluates to `true`. A condition can add constraints
      # based on attributes of the request, the resource, or both. To learn which
      # resources support conditions in their IAM policies, see the
      # [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
      #
      # **JSON example:**
      #
      #     {
      #       &quot;bindings&quot;: [
      #         {
      #           &quot;role&quot;: &quot;roles/resourcemanager.organizationAdmin&quot;,
      #           &quot;members&quot;: [
      #             &quot;user:mike@example.com&quot;,
      #             &quot;group:admins@example.com&quot;,
      #             &quot;domain:google.com&quot;,
      #             &quot;serviceAccount:my-project-id@appspot.gserviceaccount.com&quot;
      #           ]
      #         },
      #         {
      #           &quot;role&quot;: &quot;roles/resourcemanager.organizationViewer&quot;,
      #           &quot;members&quot;: [
      #             &quot;user:eve@example.com&quot;
      #           ],
      #           &quot;condition&quot;: {
      #             &quot;title&quot;: &quot;expirable access&quot;,
      #             &quot;description&quot;: &quot;Does not grant access after Sep 2020&quot;,
      #             &quot;expression&quot;: &quot;request.time &lt; timestamp(&#x27;2020-10-01T00:00:00.000Z&#x27;)&quot;,
      #           }
      #         }
      #       ],
      #       &quot;etag&quot;: &quot;BwWWja0YfJA=&quot;,
      #       &quot;version&quot;: 3
      #     }
      #
      # **YAML example:**
      #
      #     bindings:
      #     - members:
      #       - user:mike@example.com
      #       - group:admins@example.com
      #       - domain:google.com
      #       - serviceAccount:my-project-id@appspot.gserviceaccount.com
      #       role: roles/resourcemanager.organizationAdmin
      #     - members:
      #       - user:eve@example.com
      #       role: roles/resourcemanager.organizationViewer
      #       condition:
      #         title: expirable access
      #         description: Does not grant access after Sep 2020
      #         expression: request.time &lt; timestamp(&#x27;2020-10-01T00:00:00.000Z&#x27;)
      #     - etag: BwWWja0YfJA=
      #     - version: 3
      #
      # For a description of IAM and its features, see the
      # [IAM documentation](https://cloud.google.com/iam/docs/).
    &quot;etag&quot;: &quot;A String&quot;, # `etag` is used for optimistic concurrency control as a way to help
        # prevent simultaneous updates of a policy from overwriting each other.
        # It is strongly suggested that systems make use of the `etag` in the
        # read-modify-write cycle to perform policy updates in order to avoid race
        # conditions: An `etag` is returned in the response to `getIamPolicy`, and
        # systems are expected to put that etag in the request to `setIamPolicy` to
        # ensure that their change will be applied to the same version of the policy.
        #
        # **Important:** If you use IAM Conditions, you must include the `etag` field
        # whenever you call `setIamPolicy`. If you omit this field, then IAM allows
        # you to overwrite a version `3` policy with a version `1` policy, and all of
        # the conditions in the version `3` policy are lost.
    &quot;version&quot;: 42, # Specifies the format of the policy.
        #
        # Valid values are `0`, `1`, and `3`. Requests that specify an invalid value
        # are rejected.
        #
        # Any operation that affects conditional role bindings must specify version
        # `3`. This requirement applies to the following operations:
        #
        # * Getting a policy that includes a conditional role binding
        # * Adding a conditional role binding to a policy
        # * Changing a conditional role binding in a policy
        # * Removing any role binding, with or without a condition, from a policy
        #   that includes conditions
        #
        # **Important:** If you use IAM Conditions, you must include the `etag` field
        # whenever you call `setIamPolicy`. If you omit this field, then IAM allows
        # you to overwrite a version `3` policy with a version `1` policy, and all of
        # the conditions in the version `3` policy are lost.
        #
        # If a policy does not include any conditions, operations on that policy may
        # specify any valid version or leave the field unset.
        #
        # To learn which resources support conditions in their IAM policies, see the
        # [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
    &quot;bindings&quot;: [ # Associates a list of `members` to a `role`. Optionally, may specify a
        # `condition` that determines how and when the `bindings` are applied. Each
        # of the `bindings` must contain at least one member.
      { # Associates `members` with a `role`.
        &quot;condition&quot;: { # Represents a textual expression in the Common Expression Language (CEL) # The condition that is associated with this binding.
            #
            # If the condition evaluates to `true`, then this binding applies to the
            # current request.
            #
            # If the condition evaluates to `false`, then this binding does not apply to
            # the current request. However, a different role binding might grant the same
            # role to one or more of the members in this binding.
            #
            # To learn which resources support conditions in their IAM policies, see the
            # [IAM
            # documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
            # syntax. CEL is a C-like expression language. The syntax and semantics of CEL
            # are documented at https://github.com/google/cel-spec.
            #
            # Example (Comparison):
            #
            #     title: &quot;Summary size limit&quot;
            #     description: &quot;Determines if a summary is less than 100 chars&quot;
            #     expression: &quot;document.summary.size() &lt; 100&quot;
            #
            # Example (Equality):
            #
            #     title: &quot;Requestor is owner&quot;
            #     description: &quot;Determines if requestor is the document owner&quot;
            #     expression: &quot;document.owner == request.auth.claims.email&quot;
            #
            # Example (Logic):
            #
            #     title: &quot;Public documents&quot;
            #     description: &quot;Determine whether the document should be publicly visible&quot;
            #     expression: &quot;document.type != &#x27;private&#x27; &amp;&amp; document.type != &#x27;internal&#x27;&quot;
            #
            # Example (Data Manipulation):
            #
            #     title: &quot;Notification string&quot;
            #     description: &quot;Create a notification string with a timestamp.&quot;
            #     expression: &quot;&#x27;New message received at &#x27; + string(document.create_time)&quot;
            #
            # The exact variables and functions that may be referenced within an expression
            # are determined by the service that evaluates it. See the service
            # documentation for additional information.
          &quot;description&quot;: &quot;A String&quot;, # Optional. Description of the expression. This is a longer text which
              # describes the expression, e.g. when hovered over it in a UI.
          &quot;expression&quot;: &quot;A String&quot;, # Textual representation of an expression in Common Expression Language
              # syntax.
          &quot;title&quot;: &quot;A String&quot;, # Optional. Title for the expression, i.e. a short string describing
              # its purpose. This can be used e.g. in UIs which allow to enter the
              # expression.
          &quot;location&quot;: &quot;A String&quot;, # Optional. String indicating the location of the expression for error
              # reporting, e.g. a file name and a position in the file.
        },
        &quot;members&quot;: [ # Specifies the identities requesting access for a Cloud Platform resource.
            # `members` can have the following values:
            #
            # * `allUsers`: A special identifier that represents anyone who is
            #    on the internet; with or without a Google account.
            #
            # * `allAuthenticatedUsers`: A special identifier that represents anyone
            #    who is authenticated with a Google account or a service account.
            #
            # * `user:{emailid}`: An email address that represents a specific Google
            #    account. For example, `alice@example.com` .
            #
            #
            # * `serviceAccount:{emailid}`: An email address that represents a service
            #    account. For example, `my-other-app@appspot.gserviceaccount.com`.
            #
            # * `group:{emailid}`: An email address that represents a Google group.
            #    For example, `admins@example.com`.
            #
            # * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique
            #    identifier) representing a user that has been recently deleted. For
            #    example, `alice@example.com?uid=123456789012345678901`. If the user is
            #    recovered, this value reverts to `user:{emailid}` and the recovered user
            #    retains the role in the binding.
            #
            # * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus
            #    unique identifier) representing a service account that has been recently
            #    deleted. For example,
            #    `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`.
            #    If the service account is undeleted, this value reverts to
            #    `serviceAccount:{emailid}` and the undeleted service account retains the
            #    role in the binding.
            #
            # * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique
            #    identifier) representing a Google group that has been recently
            #    deleted. For example, `admins@example.com?uid=123456789012345678901`. If
            #    the group is recovered, this value reverts to `group:{emailid}` and the
            #    recovered group retains the role in the binding.
            #
            #
            # * `domain:{domain}`: The G Suite domain (primary) that represents all the
            #    users of that domain. For example, `google.com` or `example.com`.
            #
          &quot;A String&quot;,
        ],
        &quot;role&quot;: &quot;A String&quot;, # Role that is assigned to `members`.
            # For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
      },
    ],
  }</pre>
</div>

<div class="method">
    <code class="details" id="testIamPermissions">testIamPermissions(resource, body=None, x__xgafv=None)</code>
  <pre>Returns the permissions that a caller has on the specified note or
occurrence. Requires list permission on the project (for example,
`containeranalysis.notes.list`).

The resource takes the format `projects/[PROJECT_ID]/notes/[NOTE_ID]` for
notes and `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]` for
occurrences.

Args:
  resource: string, REQUIRED: The resource for which the policy detail is being requested.
See the operation documentation for the appropriate value for this field. (required)
  body: object, The request body.
    The object takes the form of:

{ # Request message for `TestIamPermissions` method.
    &quot;permissions&quot;: [ # The set of permissions to check for the `resource`. Permissions with
        # wildcards (such as &#x27;*&#x27; or &#x27;storage.*&#x27;) are not allowed. For more
        # information see
        # [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
      &quot;A String&quot;,
    ],
  }

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response message for `TestIamPermissions` method.
    &quot;permissions&quot;: [ # A subset of `TestPermissionsRequest.permissions` that the caller is
        # allowed.
      &quot;A String&quot;,
    ],
  }</pre>
</div>

</body></html>