<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="workspaceevents_v1.html">Google Workspace Events API</a> . <a href="workspaceevents_v1.message.html">message</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#stream">stream(body=None, x__xgafv=None)</a></code></p>
<p class="firstline">SendStreamingMessage is a streaming call that will return a stream of task update events until the Task is in an interrupted or terminal state.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="stream">stream(body=None, x__xgafv=None)</code>
  <pre>SendStreamingMessage is a streaming call that will return a stream of task update events until the Task is in an interrupted or terminal state.

Args:
  body: object, The request body.
    The object takes the form of:

{ # /////////// Request Messages ///////////
  &quot;configuration&quot;: { # Configuration of a send message request. # Configuration for the send request.
    &quot;acceptedOutputModes&quot;: [ # The output modes that the agent is expected to respond with.
      &quot;A String&quot;,
    ],
    &quot;blocking&quot;: True or False, # If true, the message will be blocking until the task is completed. If false, the message will be non-blocking and the task will be returned immediately. It is the caller&#x27;s responsibility to check for any task updates.
    &quot;historyLength&quot;: 42, # The maximum number of messages to include in the history. if 0, the history will be unlimited.
    &quot;pushNotification&quot;: { # Configuration for setting up push notifications for task updates. # A configuration of a webhook that can be used to receive updates
      &quot;authentication&quot;: { # Defines authentication details, used for push notifications. # Information about the authentication to sent with the notification
        &quot;credentials&quot;: &quot;A String&quot;, # Optional credentials
        &quot;schemes&quot;: [ # Supported authentication schemes - e.g. Basic, Bearer, etc
          &quot;A String&quot;,
        ],
      },
      &quot;id&quot;: &quot;A String&quot;, # A unique identifier (e.g. UUID) for this push notification.
      &quot;token&quot;: &quot;A String&quot;, # Token unique for this task/session
      &quot;url&quot;: &quot;A String&quot;, # Url to send the notification too
    },
  },
  &quot;message&quot;: { # Message is one unit of communication between client and server. It is associated with a context and optionally a task. Since the server is responsible for the context definition, it must always provide a context_id in its messages. The client can optionally provide the context_id if it knows the context to associate the message to. Similarly for task_id, except the server decides if a task is created and whether to include the task_id. # Required. The message to send to the agent.
    &quot;content&quot;: [ # protolint:disable REPEATED_FIELD_NAMES_PLURALIZED Content is the container of the message content.
      { # Part represents a container for a section of communication content. Parts can be purely textual, some sort of file (image, video, etc) or a structured data blob (i.e. JSON).
        &quot;data&quot;: { # DataPart represents a structured blob. This is most commonly a JSON payload.
          &quot;data&quot;: {
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
        },
        &quot;file&quot;: { # FilePart represents the different ways files can be provided. If files are small, directly feeding the bytes is supported via file_with_bytes. If the file is large, the agent should read the content as appropriate directly from the file_with_uri source.
          &quot;fileWithBytes&quot;: &quot;A String&quot;,
          &quot;fileWithUri&quot;: &quot;A String&quot;,
          &quot;mimeType&quot;: &quot;A String&quot;,
          &quot;name&quot;: &quot;A String&quot;,
        },
        &quot;metadata&quot;: { # Optional metadata associated with this part.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;text&quot;: &quot;A String&quot;,
      },
    ],
    &quot;contextId&quot;: &quot;A String&quot;, # The context id of the message. This is optional and if set, the message will be associated with the given context.
    &quot;extensions&quot;: [ # The URIs of extensions that are present or contributed to this Message.
      &quot;A String&quot;,
    ],
    &quot;messageId&quot;: &quot;A String&quot;, # The unique identifier (e.g. UUID)of the message. This is required and created by the message creator.
    &quot;metadata&quot;: { # protolint:enable REPEATED_FIELD_NAMES_PLURALIZED Any optional metadata to provide along with the message.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;role&quot;: &quot;A String&quot;, # A role for the message.
    &quot;taskId&quot;: &quot;A String&quot;, # The task id of the message. This is optional and if set, the message will be associated with the given task.
  },
  &quot;metadata&quot;: { # Optional metadata for the request.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
  },
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The stream response for a message. The stream should be one of the following sequences: If the response is a message, the stream should contain one, and only one, message and then close If the response is a task lifecycle, the first response should be a Task object followed by zero or more TaskStatusUpdateEvents and TaskArtifactUpdateEvents. The stream should complete when the Task if in an interrupted or terminal state. A stream that ends before these conditions are met are
  &quot;artifactUpdate&quot;: { # TaskArtifactUpdateEvent represents a task delta where an artifact has been generated.
    &quot;append&quot;: True or False, # Whether this should be appended to a prior one produced
    &quot;artifact&quot;: { # Artifacts are the container for task completed results. These are similar to Messages but are intended to be the product of a task, as opposed to point-to-point communication. # The artifact itself
      &quot;artifactId&quot;: &quot;A String&quot;, # Unique identifier (e.g. UUID) for the artifact. It must be at least unique within a task.
      &quot;description&quot;: &quot;A String&quot;, # A human readable description of the artifact, optional.
      &quot;extensions&quot;: [ # The URIs of extensions that are present or contributed to this Artifact.
        &quot;A String&quot;,
      ],
      &quot;metadata&quot;: { # Optional metadata included with the artifact.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;name&quot;: &quot;A String&quot;, # A human readable name for the artifact.
      &quot;parts&quot;: [ # The content of the artifact.
        { # Part represents a container for a section of communication content. Parts can be purely textual, some sort of file (image, video, etc) or a structured data blob (i.e. JSON).
          &quot;data&quot;: { # DataPart represents a structured blob. This is most commonly a JSON payload.
            &quot;data&quot;: {
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
          },
          &quot;file&quot;: { # FilePart represents the different ways files can be provided. If files are small, directly feeding the bytes is supported via file_with_bytes. If the file is large, the agent should read the content as appropriate directly from the file_with_uri source.
            &quot;fileWithBytes&quot;: &quot;A String&quot;,
            &quot;fileWithUri&quot;: &quot;A String&quot;,
            &quot;mimeType&quot;: &quot;A String&quot;,
            &quot;name&quot;: &quot;A String&quot;,
          },
          &quot;metadata&quot;: { # Optional metadata associated with this part.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;text&quot;: &quot;A String&quot;,
        },
      ],
    },
    &quot;contextId&quot;: &quot;A String&quot;, # The id of the context that this task belongs too
    &quot;lastChunk&quot;: True or False, # Whether this represents the last part of an artifact
    &quot;metadata&quot;: { # Optional metadata associated with the artifact update.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;taskId&quot;: &quot;A String&quot;, # The id of the task for this artifact
  },
  &quot;message&quot;: { # Message is one unit of communication between client and server. It is associated with a context and optionally a task. Since the server is responsible for the context definition, it must always provide a context_id in its messages. The client can optionally provide the context_id if it knows the context to associate the message to. Similarly for task_id, except the server decides if a task is created and whether to include the task_id.
    &quot;content&quot;: [ # protolint:disable REPEATED_FIELD_NAMES_PLURALIZED Content is the container of the message content.
      { # Part represents a container for a section of communication content. Parts can be purely textual, some sort of file (image, video, etc) or a structured data blob (i.e. JSON).
        &quot;data&quot;: { # DataPart represents a structured blob. This is most commonly a JSON payload.
          &quot;data&quot;: {
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
        },
        &quot;file&quot;: { # FilePart represents the different ways files can be provided. If files are small, directly feeding the bytes is supported via file_with_bytes. If the file is large, the agent should read the content as appropriate directly from the file_with_uri source.
          &quot;fileWithBytes&quot;: &quot;A String&quot;,
          &quot;fileWithUri&quot;: &quot;A String&quot;,
          &quot;mimeType&quot;: &quot;A String&quot;,
          &quot;name&quot;: &quot;A String&quot;,
        },
        &quot;metadata&quot;: { # Optional metadata associated with this part.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;text&quot;: &quot;A String&quot;,
      },
    ],
    &quot;contextId&quot;: &quot;A String&quot;, # The context id of the message. This is optional and if set, the message will be associated with the given context.
    &quot;extensions&quot;: [ # The URIs of extensions that are present or contributed to this Message.
      &quot;A String&quot;,
    ],
    &quot;messageId&quot;: &quot;A String&quot;, # The unique identifier (e.g. UUID)of the message. This is required and created by the message creator.
    &quot;metadata&quot;: { # protolint:enable REPEATED_FIELD_NAMES_PLURALIZED Any optional metadata to provide along with the message.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;role&quot;: &quot;A String&quot;, # A role for the message.
    &quot;taskId&quot;: &quot;A String&quot;, # The task id of the message. This is optional and if set, the message will be associated with the given task.
  },
  &quot;statusUpdate&quot;: { # TaskStatusUpdateEvent is a delta even on a task indicating that a task has changed.
    &quot;contextId&quot;: &quot;A String&quot;, # The id of the context that the task belongs to
    &quot;final&quot;: True or False, # Whether this is the last status update expected for this task.
    &quot;metadata&quot;: { # Optional metadata to associate with the task update.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;status&quot;: { # A container for the status of a task # The new status of the task.
      &quot;message&quot;: { # Message is one unit of communication between client and server. It is associated with a context and optionally a task. Since the server is responsible for the context definition, it must always provide a context_id in its messages. The client can optionally provide the context_id if it knows the context to associate the message to. Similarly for task_id, except the server decides if a task is created and whether to include the task_id. # A message associated with the status.
        &quot;content&quot;: [ # protolint:disable REPEATED_FIELD_NAMES_PLURALIZED Content is the container of the message content.
          { # Part represents a container for a section of communication content. Parts can be purely textual, some sort of file (image, video, etc) or a structured data blob (i.e. JSON).
            &quot;data&quot;: { # DataPart represents a structured blob. This is most commonly a JSON payload.
              &quot;data&quot;: {
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;file&quot;: { # FilePart represents the different ways files can be provided. If files are small, directly feeding the bytes is supported via file_with_bytes. If the file is large, the agent should read the content as appropriate directly from the file_with_uri source.
              &quot;fileWithBytes&quot;: &quot;A String&quot;,
              &quot;fileWithUri&quot;: &quot;A String&quot;,
              &quot;mimeType&quot;: &quot;A String&quot;,
              &quot;name&quot;: &quot;A String&quot;,
            },
            &quot;metadata&quot;: { # Optional metadata associated with this part.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;text&quot;: &quot;A String&quot;,
          },
        ],
        &quot;contextId&quot;: &quot;A String&quot;, # The context id of the message. This is optional and if set, the message will be associated with the given context.
        &quot;extensions&quot;: [ # The URIs of extensions that are present or contributed to this Message.
          &quot;A String&quot;,
        ],
        &quot;messageId&quot;: &quot;A String&quot;, # The unique identifier (e.g. UUID)of the message. This is required and created by the message creator.
        &quot;metadata&quot;: { # protolint:enable REPEATED_FIELD_NAMES_PLURALIZED Any optional metadata to provide along with the message.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;role&quot;: &quot;A String&quot;, # A role for the message.
        &quot;taskId&quot;: &quot;A String&quot;, # The task id of the message. This is optional and if set, the message will be associated with the given task.
      },
      &quot;state&quot;: &quot;A String&quot;, # The current state of this task
      &quot;timestamp&quot;: &quot;A String&quot;, # Timestamp when the status was recorded. Example: &quot;2023-10-27T10:00:00Z&quot;
    },
    &quot;taskId&quot;: &quot;A String&quot;, # The id of the task that is changed
  },
  &quot;task&quot;: { # Task is the core unit of action for A2A. It has a current status and when results are created for the task they are stored in the artifact. If there are multiple turns for a task, these are stored in history.
    &quot;artifacts&quot;: [ # A set of output artifacts for a Task.
      { # Artifacts are the container for task completed results. These are similar to Messages but are intended to be the product of a task, as opposed to point-to-point communication.
        &quot;artifactId&quot;: &quot;A String&quot;, # Unique identifier (e.g. UUID) for the artifact. It must be at least unique within a task.
        &quot;description&quot;: &quot;A String&quot;, # A human readable description of the artifact, optional.
        &quot;extensions&quot;: [ # The URIs of extensions that are present or contributed to this Artifact.
          &quot;A String&quot;,
        ],
        &quot;metadata&quot;: { # Optional metadata included with the artifact.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;name&quot;: &quot;A String&quot;, # A human readable name for the artifact.
        &quot;parts&quot;: [ # The content of the artifact.
          { # Part represents a container for a section of communication content. Parts can be purely textual, some sort of file (image, video, etc) or a structured data blob (i.e. JSON).
            &quot;data&quot;: { # DataPart represents a structured blob. This is most commonly a JSON payload.
              &quot;data&quot;: {
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;file&quot;: { # FilePart represents the different ways files can be provided. If files are small, directly feeding the bytes is supported via file_with_bytes. If the file is large, the agent should read the content as appropriate directly from the file_with_uri source.
              &quot;fileWithBytes&quot;: &quot;A String&quot;,
              &quot;fileWithUri&quot;: &quot;A String&quot;,
              &quot;mimeType&quot;: &quot;A String&quot;,
              &quot;name&quot;: &quot;A String&quot;,
            },
            &quot;metadata&quot;: { # Optional metadata associated with this part.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;text&quot;: &quot;A String&quot;,
          },
        ],
      },
    ],
    &quot;contextId&quot;: &quot;A String&quot;, # Unique identifier (e.g. UUID) for the contextual collection of interactions (tasks and messages). Created by the A2A server.
    &quot;history&quot;: [ # protolint:disable REPEATED_FIELD_NAMES_PLURALIZED The history of interactions from a task.
      { # Message is one unit of communication between client and server. It is associated with a context and optionally a task. Since the server is responsible for the context definition, it must always provide a context_id in its messages. The client can optionally provide the context_id if it knows the context to associate the message to. Similarly for task_id, except the server decides if a task is created and whether to include the task_id.
        &quot;content&quot;: [ # protolint:disable REPEATED_FIELD_NAMES_PLURALIZED Content is the container of the message content.
          { # Part represents a container for a section of communication content. Parts can be purely textual, some sort of file (image, video, etc) or a structured data blob (i.e. JSON).
            &quot;data&quot;: { # DataPart represents a structured blob. This is most commonly a JSON payload.
              &quot;data&quot;: {
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;file&quot;: { # FilePart represents the different ways files can be provided. If files are small, directly feeding the bytes is supported via file_with_bytes. If the file is large, the agent should read the content as appropriate directly from the file_with_uri source.
              &quot;fileWithBytes&quot;: &quot;A String&quot;,
              &quot;fileWithUri&quot;: &quot;A String&quot;,
              &quot;mimeType&quot;: &quot;A String&quot;,
              &quot;name&quot;: &quot;A String&quot;,
            },
            &quot;metadata&quot;: { # Optional metadata associated with this part.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;text&quot;: &quot;A String&quot;,
          },
        ],
        &quot;contextId&quot;: &quot;A String&quot;, # The context id of the message. This is optional and if set, the message will be associated with the given context.
        &quot;extensions&quot;: [ # The URIs of extensions that are present or contributed to this Message.
          &quot;A String&quot;,
        ],
        &quot;messageId&quot;: &quot;A String&quot;, # The unique identifier (e.g. UUID)of the message. This is required and created by the message creator.
        &quot;metadata&quot;: { # protolint:enable REPEATED_FIELD_NAMES_PLURALIZED Any optional metadata to provide along with the message.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;role&quot;: &quot;A String&quot;, # A role for the message.
        &quot;taskId&quot;: &quot;A String&quot;, # The task id of the message. This is optional and if set, the message will be associated with the given task.
      },
    ],
    &quot;id&quot;: &quot;A String&quot;, # Unique identifier (e.g. UUID) for the task, generated by the server for a new task.
    &quot;metadata&quot;: { # protolint:enable REPEATED_FIELD_NAMES_PLURALIZED A key/value object to store custom metadata about a task.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;status&quot;: { # A container for the status of a task # The current status of a Task, including state and a message.
      &quot;message&quot;: { # Message is one unit of communication between client and server. It is associated with a context and optionally a task. Since the server is responsible for the context definition, it must always provide a context_id in its messages. The client can optionally provide the context_id if it knows the context to associate the message to. Similarly for task_id, except the server decides if a task is created and whether to include the task_id. # A message associated with the status.
        &quot;content&quot;: [ # protolint:disable REPEATED_FIELD_NAMES_PLURALIZED Content is the container of the message content.
          { # Part represents a container for a section of communication content. Parts can be purely textual, some sort of file (image, video, etc) or a structured data blob (i.e. JSON).
            &quot;data&quot;: { # DataPart represents a structured blob. This is most commonly a JSON payload.
              &quot;data&quot;: {
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;file&quot;: { # FilePart represents the different ways files can be provided. If files are small, directly feeding the bytes is supported via file_with_bytes. If the file is large, the agent should read the content as appropriate directly from the file_with_uri source.
              &quot;fileWithBytes&quot;: &quot;A String&quot;,
              &quot;fileWithUri&quot;: &quot;A String&quot;,
              &quot;mimeType&quot;: &quot;A String&quot;,
              &quot;name&quot;: &quot;A String&quot;,
            },
            &quot;metadata&quot;: { # Optional metadata associated with this part.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;text&quot;: &quot;A String&quot;,
          },
        ],
        &quot;contextId&quot;: &quot;A String&quot;, # The context id of the message. This is optional and if set, the message will be associated with the given context.
        &quot;extensions&quot;: [ # The URIs of extensions that are present or contributed to this Message.
          &quot;A String&quot;,
        ],
        &quot;messageId&quot;: &quot;A String&quot;, # The unique identifier (e.g. UUID)of the message. This is required and created by the message creator.
        &quot;metadata&quot;: { # protolint:enable REPEATED_FIELD_NAMES_PLURALIZED Any optional metadata to provide along with the message.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;role&quot;: &quot;A String&quot;, # A role for the message.
        &quot;taskId&quot;: &quot;A String&quot;, # The task id of the message. This is optional and if set, the message will be associated with the given task.
      },
      &quot;state&quot;: &quot;A String&quot;, # The current state of this task
      &quot;timestamp&quot;: &quot;A String&quot;, # Timestamp when the status was recorded. Example: &quot;2023-10-27T10:00:00Z&quot;
    },
  },
}</pre>
</div>

</body></html>