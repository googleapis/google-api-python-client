<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="discoveryengine_v1.html">Discovery Engine API</a> . <a href="discoveryengine_v1.projects.html">projects</a> . <a href="discoveryengine_v1.projects.locations.html">locations</a> . <a href="discoveryengine_v1.projects.locations.collections.html">collections</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="discoveryengine_v1.projects.locations.collections.dataConnector.html">dataConnector()</a></code>
</p>
<p class="firstline">Returns the dataConnector Resource.</p>

<p class="toc_element">
  <code><a href="discoveryengine_v1.projects.locations.collections.dataStores.html">dataStores()</a></code>
</p>
<p class="firstline">Returns the dataStores Resource.</p>

<p class="toc_element">
  <code><a href="discoveryengine_v1.projects.locations.collections.engines.html">engines()</a></code>
</p>
<p class="firstline">Returns the engines Resource.</p>

<p class="toc_element">
  <code><a href="discoveryengine_v1.projects.locations.collections.operations.html">operations()</a></code>
</p>
<p class="firstline">Returns the operations Resource.</p>

<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#delete">delete(name, x__xgafv=None)</a></code></p>
<p class="firstline">Deletes a Collection.</p>
<p class="toc_element">
  <code><a href="#getDataConnector">getDataConnector(name, x__xgafv=None)</a></code></p>
<p class="firstline">Gets the DataConnector. DataConnector is a singleton resource for each Collection.</p>
<p class="toc_element">
  <code><a href="#updateDataConnector">updateDataConnector(name, body=None, updateMask=None, x__xgafv=None)</a></code></p>
<p class="firstline">Updates a DataConnector.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="delete">delete(name, x__xgafv=None)</code>
  <pre>Deletes a Collection.

Args:
  name: string, Required. The full resource name of the Collection, in the format of `projects/{project}/locations/{location}/collections/{collection}`. (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # This resource represents a long-running operation that is the result of a network API call.
  &quot;done&quot;: True or False, # If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The error result of the operation in case of failure or cancellation.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;metadata&quot;: { # Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
  &quot;name&quot;: &quot;A String&quot;, # The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
  &quot;response&quot;: { # The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="getDataConnector">getDataConnector(name, x__xgafv=None)</code>
  <pre>Gets the DataConnector. DataConnector is a singleton resource for each Collection.

Args:
  name: string, Required. Full resource name of DataConnector, such as `projects/{project}/locations/{location}/collections/{collection_id}/dataConnector`. If the caller does not have permission to access the DataConnector, regardless of whether or not it exists, a PERMISSION_DENIED error is returned. If the requested DataConnector does not exist, a NOT_FOUND error is returned. (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Manages the connection to external data sources for all data stores grouped under a Collection. It&#x27;s a singleton resource of Collection. The initialization is only supported through DataConnectorService.SetUpDataConnector method, which will create a new Collection and initialize its DataConnector.
  &quot;aclEnabled&quot;: True or False, # Optional. Whether the connector will be created with an ACL config. Currently this field only affects Cloud Storage and BigQuery connectors.
  &quot;actionConfig&quot;: { # Informations to support actions on the connector. # Optional. Action configurations to make the connector support actions.
    &quot;actionParams&quot;: { # Optional. Action parameters in structured json format.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;isActionConfigured&quot;: True or False, # Output only. The connector contains the necessary parameters and is configured to support actions.
    &quot;jsonActionParams&quot;: &quot;A String&quot;, # Optional. Action parameters in json string format.
    &quot;serviceName&quot;: &quot;A String&quot;, # Optional. The Service Directory resource name (projects/*/locations/*/namespaces/*/services/*) representing a VPC network endpoint used to connect to the data source&#x27;s `instance_uri`, defined in DataConnector.params. Required when VPC Service Controls are enabled.
    &quot;useStaticSecrets&quot;: True or False, # Optional. Whether to use static secrets for the connector. If true, the secrets provided in the action_params will be ignored.
  },
  &quot;actionState&quot;: &quot;A String&quot;, # Output only. State of the action connector. This reflects whether the action connector is initializing, active or has encountered errors.
  &quot;alertPolicyConfigs&quot;: [ # Optional. The connector level alert config.
    { # The connector level alert config.
      &quot;alertEnrollments&quot;: [ # Optional. The enrollment states of each alert.
        { # The alert enrollment status.
          &quot;alertId&quot;: &quot;A String&quot;, # Immutable. The id of an alert.
          &quot;enrollState&quot;: &quot;A String&quot;, # Required. The enrollment status of a customer.
        },
      ],
      &quot;alertPolicyName&quot;: &quot;A String&quot;, # Immutable. The fully qualified resource name of the AlertPolicy.
    },
  ],
  &quot;autoRunDisabled&quot;: True or False, # Optional. Indicates whether the connector is disabled for auto run. It can be used to pause periodical and real time sync. Update: with the introduction of incremental_sync_disabled, auto_run_disabled is used to pause/disable only full syncs
  &quot;bapConfig&quot;: { # The configuration for the BAP connector. # Optional. The configuration for establishing a BAP connection.
    &quot;enabledActions&quot;: [ # Optional. The actions enabled on the associated BAP connection.
      &quot;A String&quot;,
    ],
    &quot;supportedConnectorModes&quot;: [ # Required. The supported connector modes for the associated BAP connection.
      &quot;A String&quot;,
    ],
  },
  &quot;blockingReasons&quot;: [ # Output only. User actions that must be completed before the connector can start syncing data.
    &quot;A String&quot;,
  ],
  &quot;connectorModes&quot;: [ # Optional. The modes enabled for this connector. Default state is CONNECTOR_MODE_UNSPECIFIED.
    &quot;A String&quot;,
  ],
  &quot;connectorType&quot;: &quot;A String&quot;, # Output only. The type of connector. Each source can only map to one type. For example, salesforce, confluence and jira have THIRD_PARTY connector type. It is not mutable once set by system.
  &quot;createEuaSaas&quot;: True or False, # Optional. Whether the END USER AUTHENTICATION connector is created in SaaS.
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp the DataConnector was created at.
  &quot;dataSource&quot;: &quot;A String&quot;, # Required. The name of the data source. Supported values: `salesforce`, `jira`, `confluence`, `bigquery`.
  &quot;destinationConfigs&quot;: [ # Optional. Any target destinations used to connect to third-party services.
    { # Defines target endpoints used to connect to third-party sources.
      &quot;destinations&quot;: [ # Optional. The destinations for the corresponding key.
        { # Defines a target endpoint
          &quot;host&quot;: &quot;A String&quot;, # Publicly routable host.
          &quot;port&quot;: 42, # Optional. Target port number accepted by the destination.
        },
      ],
      &quot;jsonParams&quot;: &quot;A String&quot;, # Additional parameters for this destination config in json string format.
      &quot;key&quot;: &quot;A String&quot;, # Optional. Unique destination identifier that is supported by the connector.
      &quot;params&quot;: { # Optional. Additional parameters for this destination config in structured json format.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
    },
  ],
  &quot;endUserConfig&quot;: { # Any params and credentials used specifically for EUA connectors. # Optional. Any params and credentials used specifically for EUA connectors.
    &quot;additionalParams&quot;: { # Optional. Any additional parameters needed for EUA.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;authParams&quot;: { # Optional. Any authentication parameters specific to EUA connectors.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;jsonAuthParams&quot;: &quot;A String&quot;, # Optional. Any authentication parameters specific to EUA connectors in json string format.
    &quot;tenant&quot;: { # Tenant information for a connector source. This includes some of the same information stored in the Credential message, but is limited to only what is needed to provide a list of accessible tenants to the user. # Optional. The tenant project the connector is connected to.
      &quot;displayName&quot;: &quot;A String&quot;, # Optional display name for the tenant, e.g. &quot;My Slack Team&quot;.
      &quot;id&quot;: &quot;A String&quot;, # The tenant&#x27;s instance ID. Examples: Jira (&quot;8594f221-9797-5f78-1fa4-485e198d7cd0&quot;), Slack (&quot;T123456&quot;).
      &quot;uri&quot;: &quot;A String&quot;, # The URI of the tenant, if applicable. For example, the URI of a Jira instance is https://my-jira-instance.atlassian.net, and a Slack tenant does not have a URI.
    },
  },
  &quot;entities&quot;: [ # List of entities from the connected data source to ingest.
    { # Represents an entity in the data source. For example, the `Account` object in Salesforce.
      &quot;dataStore&quot;: &quot;A String&quot;, # Output only. The full resource name of the associated data store for the source entity. Format: `projects/*/locations/*/collections/*/dataStores/*`. When the connector is initialized by the DataConnectorService.SetUpDataConnector method, a DataStore is automatically created for each source entity.
      &quot;entityName&quot;: &quot;A String&quot;, # The name of the entity. Supported values by data source: * Salesforce: `Lead`, `Opportunity`, `Contact`, `Account`, `Case`, `Contract`, `Campaign` * Jira: `Issue` * Confluence: `Content`, `Space`
      &quot;healthcareFhirConfig&quot;: { # Config to data store for `HEALTHCARE_FHIR` vertical. # Optional. Configuration for `HEALTHCARE_FHIR` vertical.
        &quot;enableConfigurableSchema&quot;: True or False, # Whether to enable configurable schema for `HEALTHCARE_FHIR` vertical. If set to `true`, the predefined healthcare fhir schema can be extended for more customized searching and filtering.
        &quot;enableStaticIndexingForBatchIngestion&quot;: True or False, # Whether to enable static indexing for `HEALTHCARE_FHIR` batch ingestion. If set to `true`, the batch ingestion will be processed in a static indexing mode which is slower but more capable of handling larger volume.
      },
      &quot;jsonParams&quot;: &quot;A String&quot;, # The parameters for the entity to facilitate data ingestion in json string format.
      &quot;keyPropertyMappings&quot;: { # Attributes for indexing. Key: Field name. Value: The key property to map a field to, such as `title`, and `description`. Supported key properties: * `title`: The title for data record. This would be displayed on search results. * `description`: The description for data record. This would be displayed on search results.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
      &quot;params&quot;: { # The parameters for the entity to facilitate data ingestion in structured json format.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;startingSchema&quot;: { # Defines the structure and layout of a type of document data. # Optional. The start schema to use for the DataStore created from this SourceEntity. If unset, a default vertical specialized schema will be used. This field is only used by SetUpDataConnector API, and will be ignored if used in other APIs. This field will be omitted from all API responses including GetDataConnector API. To retrieve a schema of a DataStore, use SchemaService.GetSchema API instead. The provided schema will be validated against certain rules on schema. Learn more from [this doc](https://cloud.google.com/generative-ai-app-builder/docs/provide-schema).
        &quot;jsonSchema&quot;: &quot;A String&quot;, # The JSON representation of the schema.
        &quot;name&quot;: &quot;A String&quot;, # Immutable. The full resource name of the schema, in the format of `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/schemas/{schema}`. This field must be a UTF-8 encoded string with a length limit of 1024 characters.
        &quot;structSchema&quot;: { # The structured representation of the schema.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
      },
    },
  ],
  &quot;errors&quot;: [ # Output only. The errors from initialization or from the latest connector run.
    { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
      &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
      &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
        {
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
        },
      ],
      &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
    },
  ],
  &quot;federatedConfig&quot;: { # Any params and credentials used specifically for hybrid connectors supporting FEDERATED mode. # Optional. Any params and credentials used specifically for hybrid connectors supporting FEDERATED mode. This field should only be set if the connector is a hybrid connector and we want to enable FEDERATED mode.
    &quot;additionalParams&quot;: { # Optional. Any additional parameters needed for FEDERATED.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;authParams&quot;: { # Optional. Any authentication parameters specific to FEDERATED connectors.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;jsonAuthParams&quot;: &quot;A String&quot;, # Optional. Any authentication parameters specific to FEDERATED connectors in json string format.
  },
  &quot;hybridIngestionDisabled&quot;: True or False, # Optional. If the connector is a hybrid connector, determines whether ingestion is enabled and appropriate resources are provisioned during connector creation. If the connector is not a hybrid connector, this field is ignored.
  &quot;identityRefreshInterval&quot;: &quot;A String&quot;, # The refresh interval to sync the Access Control List information for the documents ingested by this connector. If not set, the access control list will be refreshed at the default interval of 30 minutes. The identity refresh interval can be at least 30 minutes and at most 7 days.
  &quot;identityScheduleConfig&quot;: { # The configuration for the identity data synchronization runs. # The configuration for the identity data synchronization runs. This contains the refresh interval to sync the Access Control List information for the documents ingested by this connector.
    &quot;nextSyncTime&quot;: { # Represents civil time (or occasionally physical time). This type can represent a civil time in one of a few possible ways: * When utc_offset is set and time_zone is unset: a civil time on a calendar day with a particular offset from UTC. * When time_zone is set and utc_offset is unset: a civil time on a calendar day in a particular time zone. * When neither time_zone nor utc_offset is set: a civil time on a calendar day in local time. The date is relative to the Proleptic Gregorian Calendar. If year, month, or day are 0, the DateTime is considered not to have a specific year, month, or day respectively. This type may also be used to represent a physical time if all the date and time fields are set and either case of the `time_offset` oneof is set. Consider using `Timestamp` message for physical time instead. If your use case also would like to store the user&#x27;s timezone, that can be done in another field. This type is more flexible than some applications may want. Make sure to document and validate your application&#x27;s limitations. # Optional. The UTC time when the next data sync is expected to start for the Data Connector. Customers are only able to specify the hour and minute to schedule the data sync. This is utilized when the data connector has a refresh interval greater than 1 day.
      &quot;day&quot;: 42, # Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
      &quot;hours&quot;: 42, # Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value &quot;24:00:00&quot; for scenarios like business closing time.
      &quot;minutes&quot;: 42, # Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
      &quot;month&quot;: 42, # Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
      &quot;nanos&quot;: 42, # Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
      &quot;seconds&quot;: 42, # Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
      &quot;timeZone&quot;: { # Represents a time zone from the [IANA Time Zone Database](https://www.iana.org/time-zones). # Time zone.
        &quot;id&quot;: &quot;A String&quot;, # IANA Time Zone Database time zone. For example &quot;America/New_York&quot;.
        &quot;version&quot;: &quot;A String&quot;, # Optional. IANA Time Zone Database version number. For example &quot;2019a&quot;.
      },
      &quot;utcOffset&quot;: &quot;A String&quot;, # UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
      &quot;year&quot;: 42, # Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
    },
    &quot;refreshInterval&quot;: &quot;A String&quot;, # Optional. The refresh interval to sync the Access Control List information for the documents ingested by this connector. If not set, the access control list will be refreshed at the default interval of 30 minutes. The identity refresh interval can be at least 30 minutes and at most 7 days.
  },
  &quot;incrementalRefreshInterval&quot;: &quot;A String&quot;, # Optional. The refresh interval specifically for incremental data syncs. If unset, incremental syncs will use the default from env, set to 3hrs. The minimum is 30 minutes and maximum is 7 days. Applicable to only 3P connectors. When the refresh interval is set to the same value as the incremental refresh interval, incremental sync will be disabled.
  &quot;incrementalSyncDisabled&quot;: True or False, # Optional. Indicates whether incremental syncs are paused for this connector. This is independent of auto_run_disabled. Applicable to only 3P connectors. When the refresh interval is set to the same value as the incremental refresh interval, incremental sync will be disabled, i.e. set to true.
  &quot;jsonParams&quot;: &quot;A String&quot;, # Required data connector parameters in json string format.
  &quot;kmsKeyName&quot;: &quot;A String&quot;, # Input only. The KMS key to be used to protect the DataStores managed by this connector. Must be set for requests that need to comply with CMEK Org Policy protections. If this field is set and processed successfully, the DataStores created by this connector will be protected by the KMS key.
  &quot;lastSyncTime&quot;: &quot;A String&quot;, # Output only. For periodic connectors only, the last time a data sync was completed.
  &quot;latestPauseTime&quot;: &quot;A String&quot;, # Output only. The most recent timestamp when this DataConnector was paused, affecting all functionalities such as data synchronization. Pausing a connector has the following effects: - All functionalities, including data synchronization, are halted. - Any ongoing data synchronization job will be canceled. - No future data synchronization runs will be scheduled nor can be triggered.
  &quot;name&quot;: &quot;A String&quot;, # Output only. The full resource name of the Data Connector. Format: `projects/*/locations/*/collections/*/dataConnector`.
  &quot;nextSyncTime&quot;: { # Represents civil time (or occasionally physical time). This type can represent a civil time in one of a few possible ways: * When utc_offset is set and time_zone is unset: a civil time on a calendar day with a particular offset from UTC. * When time_zone is set and utc_offset is unset: a civil time on a calendar day in a particular time zone. * When neither time_zone nor utc_offset is set: a civil time on a calendar day in local time. The date is relative to the Proleptic Gregorian Calendar. If year, month, or day are 0, the DateTime is considered not to have a specific year, month, or day respectively. This type may also be used to represent a physical time if all the date and time fields are set and either case of the `time_offset` oneof is set. Consider using `Timestamp` message for physical time instead. If your use case also would like to store the user&#x27;s timezone, that can be done in another field. This type is more flexible than some applications may want. Make sure to document and validate your application&#x27;s limitations. # Defines the scheduled time for the next data synchronization. This field requires hour , minute, and time_zone from the [IANA Time Zone Database](https://www.iana.org/time-zones). This is utilized when the data connector has a refresh interval greater than 1 day. When the hours or minutes are not specified, we will assume a sync time of 0:00. The user must provide a time zone to avoid ambiguity.
    &quot;day&quot;: 42, # Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
    &quot;hours&quot;: 42, # Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value &quot;24:00:00&quot; for scenarios like business closing time.
    &quot;minutes&quot;: 42, # Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
    &quot;month&quot;: 42, # Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
    &quot;nanos&quot;: 42, # Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
    &quot;seconds&quot;: 42, # Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
    &quot;timeZone&quot;: { # Represents a time zone from the [IANA Time Zone Database](https://www.iana.org/time-zones). # Time zone.
      &quot;id&quot;: &quot;A String&quot;, # IANA Time Zone Database time zone. For example &quot;America/New_York&quot;.
      &quot;version&quot;: &quot;A String&quot;, # Optional. IANA Time Zone Database version number. For example &quot;2019a&quot;.
    },
    &quot;utcOffset&quot;: &quot;A String&quot;, # UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
    &quot;year&quot;: 42, # Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
  },
  &quot;params&quot;: { # Required data connector parameters in structured json format.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
  },
  &quot;privateConnectivityProjectId&quot;: &quot;A String&quot;, # Output only. The tenant project ID associated with private connectivity connectors. This project must be allowlisted by in order for the connector to function.
  &quot;realtimeState&quot;: &quot;A String&quot;, # Output only. real-time sync state
  &quot;realtimeSyncConfig&quot;: { # The configuration for realtime sync to store additional params for realtime sync. # Optional. The configuration for realtime sync.
    &quot;realtimeSyncSecret&quot;: &quot;A String&quot;, # Optional. The ID of the Secret Manager secret used for webhook secret.
    &quot;streamingError&quot;: { # Streaming error details. # Optional. Streaming error details.
      &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Optional. Error details.
        &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
        &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
          {
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
          },
        ],
        &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
      },
      &quot;streamingErrorReason&quot;: &quot;A String&quot;, # Optional. Streaming error.
    },
    &quot;webhookUri&quot;: &quot;A String&quot;, # Optional. Webhook url for the connector to specify additional params for realtime sync.
  },
  &quot;refreshInterval&quot;: &quot;A String&quot;, # Required. The refresh interval for data sync. If duration is set to 0, the data will be synced in real time. The streaming feature is not supported yet. The minimum is 30 minutes and maximum is 7 days. When the refresh interval is set to the same value as the incremental refresh interval, incremental sync will be disabled.
  &quot;removeParamKeys&quot;: [ # Optional. Specifies keys to be removed from the &#x27;params&#x27; field. This is only active when &#x27;params&#x27; is included in the &#x27;update_mask&#x27; in an UpdateDataConnectorRequest. Deletion takes precedence if a key is both in &#x27;remove_param_keys&#x27; and present in the &#x27;params&#x27; field of the request.
    &quot;A String&quot;,
  ],
  &quot;state&quot;: &quot;A String&quot;, # Output only. State of the connector.
  &quot;staticIpAddresses&quot;: [ # Output only. The static IP addresses used by this connector.
    &quot;A String&quot;,
  ],
  &quot;staticIpEnabled&quot;: True or False, # Optional. Whether customer has enabled static IP addresses for this connector.
  &quot;syncMode&quot;: &quot;A String&quot;, # The data synchronization mode supported by the data connector.
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp the DataConnector was last updated.
}</pre>
</div>

<div class="method">
    <code class="details" id="updateDataConnector">updateDataConnector(name, body=None, updateMask=None, x__xgafv=None)</code>
  <pre>Updates a DataConnector.

Args:
  name: string, Output only. The full resource name of the Data Connector. Format: `projects/*/locations/*/collections/*/dataConnector`. (required)
  body: object, The request body.
    The object takes the form of:

{ # Manages the connection to external data sources for all data stores grouped under a Collection. It&#x27;s a singleton resource of Collection. The initialization is only supported through DataConnectorService.SetUpDataConnector method, which will create a new Collection and initialize its DataConnector.
  &quot;aclEnabled&quot;: True or False, # Optional. Whether the connector will be created with an ACL config. Currently this field only affects Cloud Storage and BigQuery connectors.
  &quot;actionConfig&quot;: { # Informations to support actions on the connector. # Optional. Action configurations to make the connector support actions.
    &quot;actionParams&quot;: { # Optional. Action parameters in structured json format.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;isActionConfigured&quot;: True or False, # Output only. The connector contains the necessary parameters and is configured to support actions.
    &quot;jsonActionParams&quot;: &quot;A String&quot;, # Optional. Action parameters in json string format.
    &quot;serviceName&quot;: &quot;A String&quot;, # Optional. The Service Directory resource name (projects/*/locations/*/namespaces/*/services/*) representing a VPC network endpoint used to connect to the data source&#x27;s `instance_uri`, defined in DataConnector.params. Required when VPC Service Controls are enabled.
    &quot;useStaticSecrets&quot;: True or False, # Optional. Whether to use static secrets for the connector. If true, the secrets provided in the action_params will be ignored.
  },
  &quot;actionState&quot;: &quot;A String&quot;, # Output only. State of the action connector. This reflects whether the action connector is initializing, active or has encountered errors.
  &quot;alertPolicyConfigs&quot;: [ # Optional. The connector level alert config.
    { # The connector level alert config.
      &quot;alertEnrollments&quot;: [ # Optional. The enrollment states of each alert.
        { # The alert enrollment status.
          &quot;alertId&quot;: &quot;A String&quot;, # Immutable. The id of an alert.
          &quot;enrollState&quot;: &quot;A String&quot;, # Required. The enrollment status of a customer.
        },
      ],
      &quot;alertPolicyName&quot;: &quot;A String&quot;, # Immutable. The fully qualified resource name of the AlertPolicy.
    },
  ],
  &quot;autoRunDisabled&quot;: True or False, # Optional. Indicates whether the connector is disabled for auto run. It can be used to pause periodical and real time sync. Update: with the introduction of incremental_sync_disabled, auto_run_disabled is used to pause/disable only full syncs
  &quot;bapConfig&quot;: { # The configuration for the BAP connector. # Optional. The configuration for establishing a BAP connection.
    &quot;enabledActions&quot;: [ # Optional. The actions enabled on the associated BAP connection.
      &quot;A String&quot;,
    ],
    &quot;supportedConnectorModes&quot;: [ # Required. The supported connector modes for the associated BAP connection.
      &quot;A String&quot;,
    ],
  },
  &quot;blockingReasons&quot;: [ # Output only. User actions that must be completed before the connector can start syncing data.
    &quot;A String&quot;,
  ],
  &quot;connectorModes&quot;: [ # Optional. The modes enabled for this connector. Default state is CONNECTOR_MODE_UNSPECIFIED.
    &quot;A String&quot;,
  ],
  &quot;connectorType&quot;: &quot;A String&quot;, # Output only. The type of connector. Each source can only map to one type. For example, salesforce, confluence and jira have THIRD_PARTY connector type. It is not mutable once set by system.
  &quot;createEuaSaas&quot;: True or False, # Optional. Whether the END USER AUTHENTICATION connector is created in SaaS.
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp the DataConnector was created at.
  &quot;dataSource&quot;: &quot;A String&quot;, # Required. The name of the data source. Supported values: `salesforce`, `jira`, `confluence`, `bigquery`.
  &quot;destinationConfigs&quot;: [ # Optional. Any target destinations used to connect to third-party services.
    { # Defines target endpoints used to connect to third-party sources.
      &quot;destinations&quot;: [ # Optional. The destinations for the corresponding key.
        { # Defines a target endpoint
          &quot;host&quot;: &quot;A String&quot;, # Publicly routable host.
          &quot;port&quot;: 42, # Optional. Target port number accepted by the destination.
        },
      ],
      &quot;jsonParams&quot;: &quot;A String&quot;, # Additional parameters for this destination config in json string format.
      &quot;key&quot;: &quot;A String&quot;, # Optional. Unique destination identifier that is supported by the connector.
      &quot;params&quot;: { # Optional. Additional parameters for this destination config in structured json format.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
    },
  ],
  &quot;endUserConfig&quot;: { # Any params and credentials used specifically for EUA connectors. # Optional. Any params and credentials used specifically for EUA connectors.
    &quot;additionalParams&quot;: { # Optional. Any additional parameters needed for EUA.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;authParams&quot;: { # Optional. Any authentication parameters specific to EUA connectors.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;jsonAuthParams&quot;: &quot;A String&quot;, # Optional. Any authentication parameters specific to EUA connectors in json string format.
    &quot;tenant&quot;: { # Tenant information for a connector source. This includes some of the same information stored in the Credential message, but is limited to only what is needed to provide a list of accessible tenants to the user. # Optional. The tenant project the connector is connected to.
      &quot;displayName&quot;: &quot;A String&quot;, # Optional display name for the tenant, e.g. &quot;My Slack Team&quot;.
      &quot;id&quot;: &quot;A String&quot;, # The tenant&#x27;s instance ID. Examples: Jira (&quot;8594f221-9797-5f78-1fa4-485e198d7cd0&quot;), Slack (&quot;T123456&quot;).
      &quot;uri&quot;: &quot;A String&quot;, # The URI of the tenant, if applicable. For example, the URI of a Jira instance is https://my-jira-instance.atlassian.net, and a Slack tenant does not have a URI.
    },
  },
  &quot;entities&quot;: [ # List of entities from the connected data source to ingest.
    { # Represents an entity in the data source. For example, the `Account` object in Salesforce.
      &quot;dataStore&quot;: &quot;A String&quot;, # Output only. The full resource name of the associated data store for the source entity. Format: `projects/*/locations/*/collections/*/dataStores/*`. When the connector is initialized by the DataConnectorService.SetUpDataConnector method, a DataStore is automatically created for each source entity.
      &quot;entityName&quot;: &quot;A String&quot;, # The name of the entity. Supported values by data source: * Salesforce: `Lead`, `Opportunity`, `Contact`, `Account`, `Case`, `Contract`, `Campaign` * Jira: `Issue` * Confluence: `Content`, `Space`
      &quot;healthcareFhirConfig&quot;: { # Config to data store for `HEALTHCARE_FHIR` vertical. # Optional. Configuration for `HEALTHCARE_FHIR` vertical.
        &quot;enableConfigurableSchema&quot;: True or False, # Whether to enable configurable schema for `HEALTHCARE_FHIR` vertical. If set to `true`, the predefined healthcare fhir schema can be extended for more customized searching and filtering.
        &quot;enableStaticIndexingForBatchIngestion&quot;: True or False, # Whether to enable static indexing for `HEALTHCARE_FHIR` batch ingestion. If set to `true`, the batch ingestion will be processed in a static indexing mode which is slower but more capable of handling larger volume.
      },
      &quot;jsonParams&quot;: &quot;A String&quot;, # The parameters for the entity to facilitate data ingestion in json string format.
      &quot;keyPropertyMappings&quot;: { # Attributes for indexing. Key: Field name. Value: The key property to map a field to, such as `title`, and `description`. Supported key properties: * `title`: The title for data record. This would be displayed on search results. * `description`: The description for data record. This would be displayed on search results.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
      &quot;params&quot;: { # The parameters for the entity to facilitate data ingestion in structured json format.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;startingSchema&quot;: { # Defines the structure and layout of a type of document data. # Optional. The start schema to use for the DataStore created from this SourceEntity. If unset, a default vertical specialized schema will be used. This field is only used by SetUpDataConnector API, and will be ignored if used in other APIs. This field will be omitted from all API responses including GetDataConnector API. To retrieve a schema of a DataStore, use SchemaService.GetSchema API instead. The provided schema will be validated against certain rules on schema. Learn more from [this doc](https://cloud.google.com/generative-ai-app-builder/docs/provide-schema).
        &quot;jsonSchema&quot;: &quot;A String&quot;, # The JSON representation of the schema.
        &quot;name&quot;: &quot;A String&quot;, # Immutable. The full resource name of the schema, in the format of `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/schemas/{schema}`. This field must be a UTF-8 encoded string with a length limit of 1024 characters.
        &quot;structSchema&quot;: { # The structured representation of the schema.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
      },
    },
  ],
  &quot;errors&quot;: [ # Output only. The errors from initialization or from the latest connector run.
    { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
      &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
      &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
        {
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
        },
      ],
      &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
    },
  ],
  &quot;federatedConfig&quot;: { # Any params and credentials used specifically for hybrid connectors supporting FEDERATED mode. # Optional. Any params and credentials used specifically for hybrid connectors supporting FEDERATED mode. This field should only be set if the connector is a hybrid connector and we want to enable FEDERATED mode.
    &quot;additionalParams&quot;: { # Optional. Any additional parameters needed for FEDERATED.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;authParams&quot;: { # Optional. Any authentication parameters specific to FEDERATED connectors.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;jsonAuthParams&quot;: &quot;A String&quot;, # Optional. Any authentication parameters specific to FEDERATED connectors in json string format.
  },
  &quot;hybridIngestionDisabled&quot;: True or False, # Optional. If the connector is a hybrid connector, determines whether ingestion is enabled and appropriate resources are provisioned during connector creation. If the connector is not a hybrid connector, this field is ignored.
  &quot;identityRefreshInterval&quot;: &quot;A String&quot;, # The refresh interval to sync the Access Control List information for the documents ingested by this connector. If not set, the access control list will be refreshed at the default interval of 30 minutes. The identity refresh interval can be at least 30 minutes and at most 7 days.
  &quot;identityScheduleConfig&quot;: { # The configuration for the identity data synchronization runs. # The configuration for the identity data synchronization runs. This contains the refresh interval to sync the Access Control List information for the documents ingested by this connector.
    &quot;nextSyncTime&quot;: { # Represents civil time (or occasionally physical time). This type can represent a civil time in one of a few possible ways: * When utc_offset is set and time_zone is unset: a civil time on a calendar day with a particular offset from UTC. * When time_zone is set and utc_offset is unset: a civil time on a calendar day in a particular time zone. * When neither time_zone nor utc_offset is set: a civil time on a calendar day in local time. The date is relative to the Proleptic Gregorian Calendar. If year, month, or day are 0, the DateTime is considered not to have a specific year, month, or day respectively. This type may also be used to represent a physical time if all the date and time fields are set and either case of the `time_offset` oneof is set. Consider using `Timestamp` message for physical time instead. If your use case also would like to store the user&#x27;s timezone, that can be done in another field. This type is more flexible than some applications may want. Make sure to document and validate your application&#x27;s limitations. # Optional. The UTC time when the next data sync is expected to start for the Data Connector. Customers are only able to specify the hour and minute to schedule the data sync. This is utilized when the data connector has a refresh interval greater than 1 day.
      &quot;day&quot;: 42, # Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
      &quot;hours&quot;: 42, # Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value &quot;24:00:00&quot; for scenarios like business closing time.
      &quot;minutes&quot;: 42, # Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
      &quot;month&quot;: 42, # Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
      &quot;nanos&quot;: 42, # Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
      &quot;seconds&quot;: 42, # Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
      &quot;timeZone&quot;: { # Represents a time zone from the [IANA Time Zone Database](https://www.iana.org/time-zones). # Time zone.
        &quot;id&quot;: &quot;A String&quot;, # IANA Time Zone Database time zone. For example &quot;America/New_York&quot;.
        &quot;version&quot;: &quot;A String&quot;, # Optional. IANA Time Zone Database version number. For example &quot;2019a&quot;.
      },
      &quot;utcOffset&quot;: &quot;A String&quot;, # UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
      &quot;year&quot;: 42, # Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
    },
    &quot;refreshInterval&quot;: &quot;A String&quot;, # Optional. The refresh interval to sync the Access Control List information for the documents ingested by this connector. If not set, the access control list will be refreshed at the default interval of 30 minutes. The identity refresh interval can be at least 30 minutes and at most 7 days.
  },
  &quot;incrementalRefreshInterval&quot;: &quot;A String&quot;, # Optional. The refresh interval specifically for incremental data syncs. If unset, incremental syncs will use the default from env, set to 3hrs. The minimum is 30 minutes and maximum is 7 days. Applicable to only 3P connectors. When the refresh interval is set to the same value as the incremental refresh interval, incremental sync will be disabled.
  &quot;incrementalSyncDisabled&quot;: True or False, # Optional. Indicates whether incremental syncs are paused for this connector. This is independent of auto_run_disabled. Applicable to only 3P connectors. When the refresh interval is set to the same value as the incremental refresh interval, incremental sync will be disabled, i.e. set to true.
  &quot;jsonParams&quot;: &quot;A String&quot;, # Required data connector parameters in json string format.
  &quot;kmsKeyName&quot;: &quot;A String&quot;, # Input only. The KMS key to be used to protect the DataStores managed by this connector. Must be set for requests that need to comply with CMEK Org Policy protections. If this field is set and processed successfully, the DataStores created by this connector will be protected by the KMS key.
  &quot;lastSyncTime&quot;: &quot;A String&quot;, # Output only. For periodic connectors only, the last time a data sync was completed.
  &quot;latestPauseTime&quot;: &quot;A String&quot;, # Output only. The most recent timestamp when this DataConnector was paused, affecting all functionalities such as data synchronization. Pausing a connector has the following effects: - All functionalities, including data synchronization, are halted. - Any ongoing data synchronization job will be canceled. - No future data synchronization runs will be scheduled nor can be triggered.
  &quot;name&quot;: &quot;A String&quot;, # Output only. The full resource name of the Data Connector. Format: `projects/*/locations/*/collections/*/dataConnector`.
  &quot;nextSyncTime&quot;: { # Represents civil time (or occasionally physical time). This type can represent a civil time in one of a few possible ways: * When utc_offset is set and time_zone is unset: a civil time on a calendar day with a particular offset from UTC. * When time_zone is set and utc_offset is unset: a civil time on a calendar day in a particular time zone. * When neither time_zone nor utc_offset is set: a civil time on a calendar day in local time. The date is relative to the Proleptic Gregorian Calendar. If year, month, or day are 0, the DateTime is considered not to have a specific year, month, or day respectively. This type may also be used to represent a physical time if all the date and time fields are set and either case of the `time_offset` oneof is set. Consider using `Timestamp` message for physical time instead. If your use case also would like to store the user&#x27;s timezone, that can be done in another field. This type is more flexible than some applications may want. Make sure to document and validate your application&#x27;s limitations. # Defines the scheduled time for the next data synchronization. This field requires hour , minute, and time_zone from the [IANA Time Zone Database](https://www.iana.org/time-zones). This is utilized when the data connector has a refresh interval greater than 1 day. When the hours or minutes are not specified, we will assume a sync time of 0:00. The user must provide a time zone to avoid ambiguity.
    &quot;day&quot;: 42, # Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
    &quot;hours&quot;: 42, # Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value &quot;24:00:00&quot; for scenarios like business closing time.
    &quot;minutes&quot;: 42, # Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
    &quot;month&quot;: 42, # Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
    &quot;nanos&quot;: 42, # Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
    &quot;seconds&quot;: 42, # Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
    &quot;timeZone&quot;: { # Represents a time zone from the [IANA Time Zone Database](https://www.iana.org/time-zones). # Time zone.
      &quot;id&quot;: &quot;A String&quot;, # IANA Time Zone Database time zone. For example &quot;America/New_York&quot;.
      &quot;version&quot;: &quot;A String&quot;, # Optional. IANA Time Zone Database version number. For example &quot;2019a&quot;.
    },
    &quot;utcOffset&quot;: &quot;A String&quot;, # UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
    &quot;year&quot;: 42, # Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
  },
  &quot;params&quot;: { # Required data connector parameters in structured json format.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
  },
  &quot;privateConnectivityProjectId&quot;: &quot;A String&quot;, # Output only. The tenant project ID associated with private connectivity connectors. This project must be allowlisted by in order for the connector to function.
  &quot;realtimeState&quot;: &quot;A String&quot;, # Output only. real-time sync state
  &quot;realtimeSyncConfig&quot;: { # The configuration for realtime sync to store additional params for realtime sync. # Optional. The configuration for realtime sync.
    &quot;realtimeSyncSecret&quot;: &quot;A String&quot;, # Optional. The ID of the Secret Manager secret used for webhook secret.
    &quot;streamingError&quot;: { # Streaming error details. # Optional. Streaming error details.
      &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Optional. Error details.
        &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
        &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
          {
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
          },
        ],
        &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
      },
      &quot;streamingErrorReason&quot;: &quot;A String&quot;, # Optional. Streaming error.
    },
    &quot;webhookUri&quot;: &quot;A String&quot;, # Optional. Webhook url for the connector to specify additional params for realtime sync.
  },
  &quot;refreshInterval&quot;: &quot;A String&quot;, # Required. The refresh interval for data sync. If duration is set to 0, the data will be synced in real time. The streaming feature is not supported yet. The minimum is 30 minutes and maximum is 7 days. When the refresh interval is set to the same value as the incremental refresh interval, incremental sync will be disabled.
  &quot;removeParamKeys&quot;: [ # Optional. Specifies keys to be removed from the &#x27;params&#x27; field. This is only active when &#x27;params&#x27; is included in the &#x27;update_mask&#x27; in an UpdateDataConnectorRequest. Deletion takes precedence if a key is both in &#x27;remove_param_keys&#x27; and present in the &#x27;params&#x27; field of the request.
    &quot;A String&quot;,
  ],
  &quot;state&quot;: &quot;A String&quot;, # Output only. State of the connector.
  &quot;staticIpAddresses&quot;: [ # Output only. The static IP addresses used by this connector.
    &quot;A String&quot;,
  ],
  &quot;staticIpEnabled&quot;: True or False, # Optional. Whether customer has enabled static IP addresses for this connector.
  &quot;syncMode&quot;: &quot;A String&quot;, # The data synchronization mode supported by the data connector.
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp the DataConnector was last updated.
}

  updateMask: string, Indicates which fields in the provided DataConnector to update. Supported field paths include: - refresh_interval - params - auto_run_disabled - action_config - action_config.action_params - action_config.service_name - destination_configs - blocking_reasons - sync_mode - incremental_sync_disabled - incremental_refresh_interval Note: Support for these fields may vary depending on the connector type. For example, not all connectors support `destination_configs`. If an unsupported or unknown field path is provided, the request will return an INVALID_ARGUMENT error.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Manages the connection to external data sources for all data stores grouped under a Collection. It&#x27;s a singleton resource of Collection. The initialization is only supported through DataConnectorService.SetUpDataConnector method, which will create a new Collection and initialize its DataConnector.
  &quot;aclEnabled&quot;: True or False, # Optional. Whether the connector will be created with an ACL config. Currently this field only affects Cloud Storage and BigQuery connectors.
  &quot;actionConfig&quot;: { # Informations to support actions on the connector. # Optional. Action configurations to make the connector support actions.
    &quot;actionParams&quot;: { # Optional. Action parameters in structured json format.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;isActionConfigured&quot;: True or False, # Output only. The connector contains the necessary parameters and is configured to support actions.
    &quot;jsonActionParams&quot;: &quot;A String&quot;, # Optional. Action parameters in json string format.
    &quot;serviceName&quot;: &quot;A String&quot;, # Optional. The Service Directory resource name (projects/*/locations/*/namespaces/*/services/*) representing a VPC network endpoint used to connect to the data source&#x27;s `instance_uri`, defined in DataConnector.params. Required when VPC Service Controls are enabled.
    &quot;useStaticSecrets&quot;: True or False, # Optional. Whether to use static secrets for the connector. If true, the secrets provided in the action_params will be ignored.
  },
  &quot;actionState&quot;: &quot;A String&quot;, # Output only. State of the action connector. This reflects whether the action connector is initializing, active or has encountered errors.
  &quot;alertPolicyConfigs&quot;: [ # Optional. The connector level alert config.
    { # The connector level alert config.
      &quot;alertEnrollments&quot;: [ # Optional. The enrollment states of each alert.
        { # The alert enrollment status.
          &quot;alertId&quot;: &quot;A String&quot;, # Immutable. The id of an alert.
          &quot;enrollState&quot;: &quot;A String&quot;, # Required. The enrollment status of a customer.
        },
      ],
      &quot;alertPolicyName&quot;: &quot;A String&quot;, # Immutable. The fully qualified resource name of the AlertPolicy.
    },
  ],
  &quot;autoRunDisabled&quot;: True or False, # Optional. Indicates whether the connector is disabled for auto run. It can be used to pause periodical and real time sync. Update: with the introduction of incremental_sync_disabled, auto_run_disabled is used to pause/disable only full syncs
  &quot;bapConfig&quot;: { # The configuration for the BAP connector. # Optional. The configuration for establishing a BAP connection.
    &quot;enabledActions&quot;: [ # Optional. The actions enabled on the associated BAP connection.
      &quot;A String&quot;,
    ],
    &quot;supportedConnectorModes&quot;: [ # Required. The supported connector modes for the associated BAP connection.
      &quot;A String&quot;,
    ],
  },
  &quot;blockingReasons&quot;: [ # Output only. User actions that must be completed before the connector can start syncing data.
    &quot;A String&quot;,
  ],
  &quot;connectorModes&quot;: [ # Optional. The modes enabled for this connector. Default state is CONNECTOR_MODE_UNSPECIFIED.
    &quot;A String&quot;,
  ],
  &quot;connectorType&quot;: &quot;A String&quot;, # Output only. The type of connector. Each source can only map to one type. For example, salesforce, confluence and jira have THIRD_PARTY connector type. It is not mutable once set by system.
  &quot;createEuaSaas&quot;: True or False, # Optional. Whether the END USER AUTHENTICATION connector is created in SaaS.
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp the DataConnector was created at.
  &quot;dataSource&quot;: &quot;A String&quot;, # Required. The name of the data source. Supported values: `salesforce`, `jira`, `confluence`, `bigquery`.
  &quot;destinationConfigs&quot;: [ # Optional. Any target destinations used to connect to third-party services.
    { # Defines target endpoints used to connect to third-party sources.
      &quot;destinations&quot;: [ # Optional. The destinations for the corresponding key.
        { # Defines a target endpoint
          &quot;host&quot;: &quot;A String&quot;, # Publicly routable host.
          &quot;port&quot;: 42, # Optional. Target port number accepted by the destination.
        },
      ],
      &quot;jsonParams&quot;: &quot;A String&quot;, # Additional parameters for this destination config in json string format.
      &quot;key&quot;: &quot;A String&quot;, # Optional. Unique destination identifier that is supported by the connector.
      &quot;params&quot;: { # Optional. Additional parameters for this destination config in structured json format.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
    },
  ],
  &quot;endUserConfig&quot;: { # Any params and credentials used specifically for EUA connectors. # Optional. Any params and credentials used specifically for EUA connectors.
    &quot;additionalParams&quot;: { # Optional. Any additional parameters needed for EUA.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;authParams&quot;: { # Optional. Any authentication parameters specific to EUA connectors.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;jsonAuthParams&quot;: &quot;A String&quot;, # Optional. Any authentication parameters specific to EUA connectors in json string format.
    &quot;tenant&quot;: { # Tenant information for a connector source. This includes some of the same information stored in the Credential message, but is limited to only what is needed to provide a list of accessible tenants to the user. # Optional. The tenant project the connector is connected to.
      &quot;displayName&quot;: &quot;A String&quot;, # Optional display name for the tenant, e.g. &quot;My Slack Team&quot;.
      &quot;id&quot;: &quot;A String&quot;, # The tenant&#x27;s instance ID. Examples: Jira (&quot;8594f221-9797-5f78-1fa4-485e198d7cd0&quot;), Slack (&quot;T123456&quot;).
      &quot;uri&quot;: &quot;A String&quot;, # The URI of the tenant, if applicable. For example, the URI of a Jira instance is https://my-jira-instance.atlassian.net, and a Slack tenant does not have a URI.
    },
  },
  &quot;entities&quot;: [ # List of entities from the connected data source to ingest.
    { # Represents an entity in the data source. For example, the `Account` object in Salesforce.
      &quot;dataStore&quot;: &quot;A String&quot;, # Output only. The full resource name of the associated data store for the source entity. Format: `projects/*/locations/*/collections/*/dataStores/*`. When the connector is initialized by the DataConnectorService.SetUpDataConnector method, a DataStore is automatically created for each source entity.
      &quot;entityName&quot;: &quot;A String&quot;, # The name of the entity. Supported values by data source: * Salesforce: `Lead`, `Opportunity`, `Contact`, `Account`, `Case`, `Contract`, `Campaign` * Jira: `Issue` * Confluence: `Content`, `Space`
      &quot;healthcareFhirConfig&quot;: { # Config to data store for `HEALTHCARE_FHIR` vertical. # Optional. Configuration for `HEALTHCARE_FHIR` vertical.
        &quot;enableConfigurableSchema&quot;: True or False, # Whether to enable configurable schema for `HEALTHCARE_FHIR` vertical. If set to `true`, the predefined healthcare fhir schema can be extended for more customized searching and filtering.
        &quot;enableStaticIndexingForBatchIngestion&quot;: True or False, # Whether to enable static indexing for `HEALTHCARE_FHIR` batch ingestion. If set to `true`, the batch ingestion will be processed in a static indexing mode which is slower but more capable of handling larger volume.
      },
      &quot;jsonParams&quot;: &quot;A String&quot;, # The parameters for the entity to facilitate data ingestion in json string format.
      &quot;keyPropertyMappings&quot;: { # Attributes for indexing. Key: Field name. Value: The key property to map a field to, such as `title`, and `description`. Supported key properties: * `title`: The title for data record. This would be displayed on search results. * `description`: The description for data record. This would be displayed on search results.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
      &quot;params&quot;: { # The parameters for the entity to facilitate data ingestion in structured json format.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;startingSchema&quot;: { # Defines the structure and layout of a type of document data. # Optional. The start schema to use for the DataStore created from this SourceEntity. If unset, a default vertical specialized schema will be used. This field is only used by SetUpDataConnector API, and will be ignored if used in other APIs. This field will be omitted from all API responses including GetDataConnector API. To retrieve a schema of a DataStore, use SchemaService.GetSchema API instead. The provided schema will be validated against certain rules on schema. Learn more from [this doc](https://cloud.google.com/generative-ai-app-builder/docs/provide-schema).
        &quot;jsonSchema&quot;: &quot;A String&quot;, # The JSON representation of the schema.
        &quot;name&quot;: &quot;A String&quot;, # Immutable. The full resource name of the schema, in the format of `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/schemas/{schema}`. This field must be a UTF-8 encoded string with a length limit of 1024 characters.
        &quot;structSchema&quot;: { # The structured representation of the schema.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
      },
    },
  ],
  &quot;errors&quot;: [ # Output only. The errors from initialization or from the latest connector run.
    { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
      &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
      &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
        {
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
        },
      ],
      &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
    },
  ],
  &quot;federatedConfig&quot;: { # Any params and credentials used specifically for hybrid connectors supporting FEDERATED mode. # Optional. Any params and credentials used specifically for hybrid connectors supporting FEDERATED mode. This field should only be set if the connector is a hybrid connector and we want to enable FEDERATED mode.
    &quot;additionalParams&quot;: { # Optional. Any additional parameters needed for FEDERATED.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;authParams&quot;: { # Optional. Any authentication parameters specific to FEDERATED connectors.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;jsonAuthParams&quot;: &quot;A String&quot;, # Optional. Any authentication parameters specific to FEDERATED connectors in json string format.
  },
  &quot;hybridIngestionDisabled&quot;: True or False, # Optional. If the connector is a hybrid connector, determines whether ingestion is enabled and appropriate resources are provisioned during connector creation. If the connector is not a hybrid connector, this field is ignored.
  &quot;identityRefreshInterval&quot;: &quot;A String&quot;, # The refresh interval to sync the Access Control List information for the documents ingested by this connector. If not set, the access control list will be refreshed at the default interval of 30 minutes. The identity refresh interval can be at least 30 minutes and at most 7 days.
  &quot;identityScheduleConfig&quot;: { # The configuration for the identity data synchronization runs. # The configuration for the identity data synchronization runs. This contains the refresh interval to sync the Access Control List information for the documents ingested by this connector.
    &quot;nextSyncTime&quot;: { # Represents civil time (or occasionally physical time). This type can represent a civil time in one of a few possible ways: * When utc_offset is set and time_zone is unset: a civil time on a calendar day with a particular offset from UTC. * When time_zone is set and utc_offset is unset: a civil time on a calendar day in a particular time zone. * When neither time_zone nor utc_offset is set: a civil time on a calendar day in local time. The date is relative to the Proleptic Gregorian Calendar. If year, month, or day are 0, the DateTime is considered not to have a specific year, month, or day respectively. This type may also be used to represent a physical time if all the date and time fields are set and either case of the `time_offset` oneof is set. Consider using `Timestamp` message for physical time instead. If your use case also would like to store the user&#x27;s timezone, that can be done in another field. This type is more flexible than some applications may want. Make sure to document and validate your application&#x27;s limitations. # Optional. The UTC time when the next data sync is expected to start for the Data Connector. Customers are only able to specify the hour and minute to schedule the data sync. This is utilized when the data connector has a refresh interval greater than 1 day.
      &quot;day&quot;: 42, # Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
      &quot;hours&quot;: 42, # Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value &quot;24:00:00&quot; for scenarios like business closing time.
      &quot;minutes&quot;: 42, # Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
      &quot;month&quot;: 42, # Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
      &quot;nanos&quot;: 42, # Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
      &quot;seconds&quot;: 42, # Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
      &quot;timeZone&quot;: { # Represents a time zone from the [IANA Time Zone Database](https://www.iana.org/time-zones). # Time zone.
        &quot;id&quot;: &quot;A String&quot;, # IANA Time Zone Database time zone. For example &quot;America/New_York&quot;.
        &quot;version&quot;: &quot;A String&quot;, # Optional. IANA Time Zone Database version number. For example &quot;2019a&quot;.
      },
      &quot;utcOffset&quot;: &quot;A String&quot;, # UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
      &quot;year&quot;: 42, # Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
    },
    &quot;refreshInterval&quot;: &quot;A String&quot;, # Optional. The refresh interval to sync the Access Control List information for the documents ingested by this connector. If not set, the access control list will be refreshed at the default interval of 30 minutes. The identity refresh interval can be at least 30 minutes and at most 7 days.
  },
  &quot;incrementalRefreshInterval&quot;: &quot;A String&quot;, # Optional. The refresh interval specifically for incremental data syncs. If unset, incremental syncs will use the default from env, set to 3hrs. The minimum is 30 minutes and maximum is 7 days. Applicable to only 3P connectors. When the refresh interval is set to the same value as the incremental refresh interval, incremental sync will be disabled.
  &quot;incrementalSyncDisabled&quot;: True or False, # Optional. Indicates whether incremental syncs are paused for this connector. This is independent of auto_run_disabled. Applicable to only 3P connectors. When the refresh interval is set to the same value as the incremental refresh interval, incremental sync will be disabled, i.e. set to true.
  &quot;jsonParams&quot;: &quot;A String&quot;, # Required data connector parameters in json string format.
  &quot;kmsKeyName&quot;: &quot;A String&quot;, # Input only. The KMS key to be used to protect the DataStores managed by this connector. Must be set for requests that need to comply with CMEK Org Policy protections. If this field is set and processed successfully, the DataStores created by this connector will be protected by the KMS key.
  &quot;lastSyncTime&quot;: &quot;A String&quot;, # Output only. For periodic connectors only, the last time a data sync was completed.
  &quot;latestPauseTime&quot;: &quot;A String&quot;, # Output only. The most recent timestamp when this DataConnector was paused, affecting all functionalities such as data synchronization. Pausing a connector has the following effects: - All functionalities, including data synchronization, are halted. - Any ongoing data synchronization job will be canceled. - No future data synchronization runs will be scheduled nor can be triggered.
  &quot;name&quot;: &quot;A String&quot;, # Output only. The full resource name of the Data Connector. Format: `projects/*/locations/*/collections/*/dataConnector`.
  &quot;nextSyncTime&quot;: { # Represents civil time (or occasionally physical time). This type can represent a civil time in one of a few possible ways: * When utc_offset is set and time_zone is unset: a civil time on a calendar day with a particular offset from UTC. * When time_zone is set and utc_offset is unset: a civil time on a calendar day in a particular time zone. * When neither time_zone nor utc_offset is set: a civil time on a calendar day in local time. The date is relative to the Proleptic Gregorian Calendar. If year, month, or day are 0, the DateTime is considered not to have a specific year, month, or day respectively. This type may also be used to represent a physical time if all the date and time fields are set and either case of the `time_offset` oneof is set. Consider using `Timestamp` message for physical time instead. If your use case also would like to store the user&#x27;s timezone, that can be done in another field. This type is more flexible than some applications may want. Make sure to document and validate your application&#x27;s limitations. # Defines the scheduled time for the next data synchronization. This field requires hour , minute, and time_zone from the [IANA Time Zone Database](https://www.iana.org/time-zones). This is utilized when the data connector has a refresh interval greater than 1 day. When the hours or minutes are not specified, we will assume a sync time of 0:00. The user must provide a time zone to avoid ambiguity.
    &quot;day&quot;: 42, # Optional. Day of month. Must be from 1 to 31 and valid for the year and month, or 0 if specifying a datetime without a day.
    &quot;hours&quot;: 42, # Optional. Hours of day in 24 hour format. Should be from 0 to 23, defaults to 0 (midnight). An API may choose to allow the value &quot;24:00:00&quot; for scenarios like business closing time.
    &quot;minutes&quot;: 42, # Optional. Minutes of hour of day. Must be from 0 to 59, defaults to 0.
    &quot;month&quot;: 42, # Optional. Month of year. Must be from 1 to 12, or 0 if specifying a datetime without a month.
    &quot;nanos&quot;: 42, # Optional. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999, defaults to 0.
    &quot;seconds&quot;: 42, # Optional. Seconds of minutes of the time. Must normally be from 0 to 59, defaults to 0. An API may allow the value 60 if it allows leap-seconds.
    &quot;timeZone&quot;: { # Represents a time zone from the [IANA Time Zone Database](https://www.iana.org/time-zones). # Time zone.
      &quot;id&quot;: &quot;A String&quot;, # IANA Time Zone Database time zone. For example &quot;America/New_York&quot;.
      &quot;version&quot;: &quot;A String&quot;, # Optional. IANA Time Zone Database version number. For example &quot;2019a&quot;.
    },
    &quot;utcOffset&quot;: &quot;A String&quot;, # UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.
    &quot;year&quot;: 42, # Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.
  },
  &quot;params&quot;: { # Required data connector parameters in structured json format.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
  },
  &quot;privateConnectivityProjectId&quot;: &quot;A String&quot;, # Output only. The tenant project ID associated with private connectivity connectors. This project must be allowlisted by in order for the connector to function.
  &quot;realtimeState&quot;: &quot;A String&quot;, # Output only. real-time sync state
  &quot;realtimeSyncConfig&quot;: { # The configuration for realtime sync to store additional params for realtime sync. # Optional. The configuration for realtime sync.
    &quot;realtimeSyncSecret&quot;: &quot;A String&quot;, # Optional. The ID of the Secret Manager secret used for webhook secret.
    &quot;streamingError&quot;: { # Streaming error details. # Optional. Streaming error details.
      &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Optional. Error details.
        &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
        &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
          {
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
          },
        ],
        &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
      },
      &quot;streamingErrorReason&quot;: &quot;A String&quot;, # Optional. Streaming error.
    },
    &quot;webhookUri&quot;: &quot;A String&quot;, # Optional. Webhook url for the connector to specify additional params for realtime sync.
  },
  &quot;refreshInterval&quot;: &quot;A String&quot;, # Required. The refresh interval for data sync. If duration is set to 0, the data will be synced in real time. The streaming feature is not supported yet. The minimum is 30 minutes and maximum is 7 days. When the refresh interval is set to the same value as the incremental refresh interval, incremental sync will be disabled.
  &quot;removeParamKeys&quot;: [ # Optional. Specifies keys to be removed from the &#x27;params&#x27; field. This is only active when &#x27;params&#x27; is included in the &#x27;update_mask&#x27; in an UpdateDataConnectorRequest. Deletion takes precedence if a key is both in &#x27;remove_param_keys&#x27; and present in the &#x27;params&#x27; field of the request.
    &quot;A String&quot;,
  ],
  &quot;state&quot;: &quot;A String&quot;, # Output only. State of the connector.
  &quot;staticIpAddresses&quot;: [ # Output only. The static IP addresses used by this connector.
    &quot;A String&quot;,
  ],
  &quot;staticIpEnabled&quot;: True or False, # Optional. Whether customer has enabled static IP addresses for this connector.
  &quot;syncMode&quot;: &quot;A String&quot;, # The data synchronization mode supported by the data connector.
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp the DataConnector was last updated.
}</pre>
</div>

</body></html>