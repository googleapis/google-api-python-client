<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="monitoring_v1.html">Cloud Monitoring API</a> . <a href="monitoring_v1.projects.html">projects</a> . <a href="monitoring_v1.projects.dashboards.html">dashboards</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#create">create(parent, body=None, validateOnly=None, x__xgafv=None)</a></code></p>
<p class="firstline">Creates a new custom dashboard. For examples on how you can use this API to create dashboards, see Managing dashboards by API (https://cloud.google.com/monitoring/dashboards/api-dashboard). This method requires the monitoring.dashboards.create permission on the specified project. For more information about permissions, see Cloud Identity and Access Management (https://cloud.google.com/iam).</p>
<p class="toc_element">
  <code><a href="#delete">delete(name, x__xgafv=None)</a></code></p>
<p class="firstline">Deletes an existing custom dashboard.This method requires the monitoring.dashboards.delete permission on the specified dashboard. For more information, see Cloud Identity and Access Management (https://cloud.google.com/iam).</p>
<p class="toc_element">
  <code><a href="#get">get(name, x__xgafv=None)</a></code></p>
<p class="firstline">Fetches a specific dashboard.This method requires the monitoring.dashboards.get permission on the specified dashboard. For more information, see Cloud Identity and Access Management (https://cloud.google.com/iam).</p>
<p class="toc_element">
  <code><a href="#list">list(parent, pageSize=None, pageToken=None, x__xgafv=None)</a></code></p>
<p class="firstline">Lists the existing dashboards.This method requires the monitoring.dashboards.list permission on the specified project. For more information, see Cloud Identity and Access Management (https://cloud.google.com/iam).</p>
<p class="toc_element">
  <code><a href="#list_next">list_next()</a></code></p>
<p class="firstline">Retrieves the next page of results.</p>
<p class="toc_element">
  <code><a href="#patch">patch(name, body=None, validateOnly=None, x__xgafv=None)</a></code></p>
<p class="firstline">Replaces an existing custom dashboard with a new definition.This method requires the monitoring.dashboards.update permission on the specified dashboard. For more information, see Cloud Identity and Access Management (https://cloud.google.com/iam).</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="create">create(parent, body=None, validateOnly=None, x__xgafv=None)</code>
  <pre>Creates a new custom dashboard. For examples on how you can use this API to create dashboards, see Managing dashboards by API (https://cloud.google.com/monitoring/dashboards/api-dashboard). This method requires the monitoring.dashboards.create permission on the specified project. For more information about permissions, see Cloud Identity and Access Management (https://cloud.google.com/iam).

Args:
  parent: string, Required. The project on which to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER] The [PROJECT_ID_OR_NUMBER] must match the dashboard resource name. (required)
  body: object, The request body.
    The object takes the form of:

{ # A Google Stackdriver dashboard. Dashboards define the content and layout of pages in the Stackdriver web application.
  &quot;annotations&quot;: { # Dashboard-level configuration for annotations # Configuration for event annotations to display on this dashboard.
    &quot;defaultResourceNames&quot;: [ # Dashboard level defaults for names of logging resources to search for events. Currently only projects are supported. Each individual EventAnnotation may have its own overrides. If both this field and the per annotation field is empty, then the scoping project is used. Limit: 50 projects. For example: “projects/some-project-id”
      &quot;A String&quot;,
    ],
    &quot;eventAnnotations&quot;: [ # List of annotation configurations for this dashboard. Each entry specifies one event type.
      { # Annotation configuration for one event type on a dashboard
        &quot;displayName&quot;: &quot;A String&quot;, # Solely for UI display. Should not be used programmatically.
        &quot;enabled&quot;: True or False, # Whether or not to show the events on the dashboard by default
        &quot;eventType&quot;: &quot;A String&quot;, # The type of event to display.
        &quot;filter&quot;: &quot;A String&quot;, # string filtering the events - event dependant. Example values: &quot;resource.labels.pod_name = &#x27;pod-1&#x27;&quot; &quot;protoPayload.authenticationInfo.principalEmail=&#x27;user@example.com&#x27;&quot;
        &quot;resourceNames&quot;: [ # Per annotation level override for the names of logging resources to search for events. Currently only projects are supported. If both this field and the per annotation field is empty, it will default to the host project. Limit: 50 projects. For example: “projects/another-project-id”
          &quot;A String&quot;,
        ],
      },
    ],
  },
  &quot;columnLayout&quot;: { # A simplified layout that divides the available space into vertical columns and arranges a set of widgets vertically in each column. # The content is divided into equally spaced columns and the widgets are arranged vertically.
    &quot;columns&quot;: [ # The columns of content to display.
      { # Defines the layout properties and content for a column.
        &quot;weight&quot;: &quot;A String&quot;, # The relative weight of this column. The column weight is used to adjust the width of columns on the screen (relative to peers). Greater the weight, greater the width of the column on the screen. If omitted, a value of 1 is used while rendering.
        &quot;widgets&quot;: [ # The display widgets arranged vertically in this column.
          { # Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
            &quot;alertChart&quot;: { # A chart that displays alert policy data. # A chart of alert policy data.
              &quot;name&quot;: &quot;A String&quot;, # Required. The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
            },
            &quot;blank&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # A blank space.
            },
            &quot;collapsibleGroup&quot;: { # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
              &quot;collapsed&quot;: True or False, # The collapsed state of the widget on first page load.
            },
            &quot;errorReportingPanel&quot;: { # A widget that displays a list of error groups. # A widget that displays a list of error groups.
              &quot;projectNames&quot;: [ # The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
                &quot;A String&quot;,
              ],
              &quot;services&quot;: [ # An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
                &quot;A String&quot;,
              ],
              &quot;versions&quot;: [ # Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
                &quot;A String&quot;,
              ],
            },
            &quot;id&quot;: &quot;A String&quot;, # Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
            &quot;incidentList&quot;: { # A widget that displays a list of incidents # A widget that shows list of incidents.
              &quot;monitoredResources&quot;: [ # Optional. The monitored resource for which incidents are listed. The resource doesn&#x27;t need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
                { # An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource&#x27;s schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for &quot;gce_instance&quot; has labels &quot;project_id&quot;, &quot;instance_id&quot; and &quot;zone&quot;: { &quot;type&quot;: &quot;gce_instance&quot;, &quot;labels&quot;: { &quot;project_id&quot;: &quot;my-project&quot;, &quot;instance_id&quot;: &quot;12345678901234&quot;, &quot;zone&quot;: &quot;us-central1-a&quot; }}
                  &quot;labels&quot;: { # Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels &quot;project_id&quot;, &quot;instance_id&quot;, and &quot;zone&quot;.
                    &quot;a_key&quot;: &quot;A String&quot;,
                  },
                  &quot;type&quot;: &quot;A String&quot;, # Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
                },
              ],
              &quot;policyNames&quot;: [ # Optional. A list of alert policy names to filter the incident list by. Don&#x27;t include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
                &quot;A String&quot;,
              ],
            },
            &quot;logsPanel&quot;: { # A widget that displays a stream of log. # A widget that shows a stream of logs.
              &quot;filter&quot;: &quot;A String&quot;, # A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
              &quot;resourceNames&quot;: [ # The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
                &quot;A String&quot;,
              ],
            },
            &quot;pieChart&quot;: { # A widget that displays timeseries data as a pie or a donut. # A widget that displays timeseries data as a pie chart.
              &quot;chartType&quot;: &quot;A String&quot;, # Required. Indicates the visualization type for the PieChart.
              &quot;dataSets&quot;: [ # Required. The queries for the chart&#x27;s data.
                { # Groups a time series query definition.
                  &quot;dimensions&quot;: [ # A dimension is a structured label, class, or category for a set of measurements in your data.
                    { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                      &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                      &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                      &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                      &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                      &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                      &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                    },
                  ],
                  &quot;measures&quot;: [ # A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                    { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                    },
                  ],
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;sliceNameTemplate&quot;: &quot;A String&quot;, # Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone&#x27;s value will be used for the name instead of the default name.
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;showLabels&quot;: True or False, # Optional. Indicates whether or not the pie chart should show slices&#x27; labels
            },
            &quot;scorecard&quot;: { # A widget showing the latest value of a metric, and how this value relates to one or more thresholds. # A scorecard summarizing time series data.
              &quot;blankView&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
              },
              &quot;dimensions&quot;: [ # Optional. A dimension is a structured label, class, or category for a set of measurements in your data.
                { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                  &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                  &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                  &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                  &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                  &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                  &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                  &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                },
              ],
              &quot;gaugeView&quot;: { # A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard&#x27;s query (inclusive). # Will cause the scorecard to show a gauge chart.
                &quot;lowerBound&quot;: 3.14, # The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
                &quot;upperBound&quot;: 3.14, # The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
              },
              &quot;measures&quot;: [ # Optional. A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                  &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                    &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                      { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                        &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                        &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                      },
                    ],
                    &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                  },
                  &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                },
              ],
              &quot;sparkChartView&quot;: { # A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard&#x27;s timeseries. # Will cause the scorecard to show a spark chart.
                &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
                &quot;sparkChartType&quot;: &quot;A String&quot;, # Required. The type of sparkchart to show in this chartView.
              },
              &quot;thresholds&quot;: [ # The thresholds used to determine the state of the scorecard given the time series&#x27; current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: &#x27;DANGER&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 70, category: &#x27;WARNING&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 10, category: &#x27;DANGER&#x27;, trigger: &#x27;BELOW&#x27;, }, { value: 20, category: &#x27;WARNING&#x27;, trigger: &#x27;BELOW&#x27;, } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
                { # Defines a threshold for categorizing time series values.
                  &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                  &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                  &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                  &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                },
              ],
              &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                  &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                },
                &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                  &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
              },
            },
            &quot;sectionHeader&quot;: { # A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content. # A widget that defines a section header for easier navigation of the dashboard.
              &quot;dividerBelow&quot;: True or False, # Whether to insert a divider below the section in the table of contents
              &quot;subtitle&quot;: &quot;A String&quot;, # The subtitle of the section
            },
            &quot;singleViewGroup&quot;: { # A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets by using a dropdown menu.
            },
            &quot;text&quot;: { # A widget that displays textual content. # A raw string or markdown displaying textual content.
              &quot;content&quot;: &quot;A String&quot;, # The text content to be displayed.
              &quot;format&quot;: &quot;A String&quot;, # How the text content is formatted.
              &quot;style&quot;: { # Properties that determine how the title and content are styled # How the text is styled
                &quot;backgroundColor&quot;: &quot;A String&quot;, # The background color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                &quot;fontSize&quot;: &quot;A String&quot;, # Font sizes for both the title and content. The title will still be larger relative to the content.
                &quot;horizontalAlignment&quot;: &quot;A String&quot;, # The horizontal alignment of both the title and content
                &quot;padding&quot;: &quot;A String&quot;, # The amount of padding around the widget
                &quot;pointerLocation&quot;: &quot;A String&quot;, # The pointer location for this widget (also sometimes called a &quot;tail&quot;)
                &quot;textColor&quot;: &quot;A String&quot;, # The text color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                &quot;verticalAlignment&quot;: &quot;A String&quot;, # The vertical alignment of both the title and content
              },
            },
            &quot;timeSeriesTable&quot;: { # A table that displays time series data. # A widget that displays time series data in a tabular format.
              &quot;columnSettings&quot;: [ # Optional. The list of the persistent column settings for the table.
                { # The persistent settings for a table&#x27;s columns.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The id of the column.
                  &quot;visible&quot;: True or False, # Required. Whether the column should be visible on page load.
                },
              ],
              &quot;dataSets&quot;: [ # Required. The data displayed in this table.
                { # Groups a time series query definition with table options.
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;tableDisplayOptions&quot;: { # Table display options that can be reused. # Optional. Table display options for configuring how the table is rendered.
                    &quot;shownColumns&quot;: [ # Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
                      &quot;A String&quot;,
                    ],
                  },
                  &quot;tableTemplate&quot;: &quot;A String&quot;, # Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value i.e. &quot;${resource.labels.project_id}.&quot;
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;metricVisualization&quot;: &quot;A String&quot;, # Optional. Store rendering strategy
            },
            &quot;title&quot;: &quot;A String&quot;, # Optional. The title of the widget.
            &quot;xyChart&quot;: { # A chart that displays data on a 2D (X and Y axes) plane. # A chart of time series data.
              &quot;chartOptions&quot;: { # Options to control visual rendering of a chart. # Display options for the chart.
                &quot;displayHorizontal&quot;: True or False, # Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
                &quot;mode&quot;: &quot;A String&quot;, # The chart mode.
              },
              &quot;dataSets&quot;: [ # Required. The data displayed in this chart.
                { # Groups a time series query definition with charting options.
                  &quot;breakdowns&quot;: [ # Optional. The collection of breakdowns to be applied to the dataset.
                    { # Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The Aggregation function is applied across all data in each breakdown created.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the dataset containing the breakdown values.
                      &quot;limit&quot;: 42, # Required. A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # Required. The sort order is applied to the values of the breakdown column.
                    },
                  ],
                  &quot;dimensions&quot;: [ # Optional. A collection of dimension columns.
                    { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                      &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                      &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                      &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                      &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                      &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                      &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                    },
                  ],
                  &quot;legendTemplate&quot;: &quot;A String&quot;, # A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value.
                  &quot;measures&quot;: [ # Optional. A collection of measures.
                    { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                    },
                  ],
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;plotType&quot;: &quot;A String&quot;, # How this data should be plotted on the chart.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # Optional. The target axis to use for plotting the metric.
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;thresholds&quot;: [ # Threshold lines drawn horizontally across the chart.
                { # Defines a threshold for categorizing time series values.
                  &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                  &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                  &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                  &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                },
              ],
              &quot;timeshiftDuration&quot;: &quot;A String&quot;, # The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
              &quot;xAxis&quot;: { # A chart axis. # The properties applied to the x-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
              &quot;y2Axis&quot;: { # A chart axis. # The properties applied to the y2-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
              &quot;yAxis&quot;: { # A chart axis. # The properties applied to the y-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
            },
          },
        ],
      },
    ],
  },
  &quot;dashboardFilters&quot;: [ # Filters to reduce the amount of data charted based on the filter criteria.
    { # A filter to reduce the amount of data charted in relevant widgets.
      &quot;filterType&quot;: &quot;A String&quot;, # The specified filter type
      &quot;labelKey&quot;: &quot;A String&quot;, # Required. The key for the label
      &quot;stringValue&quot;: &quot;A String&quot;, # A variable-length string value.
      &quot;templateVariable&quot;: &quot;A String&quot;, # The placeholder text that can be referenced in a filter string or MQL query. If omitted, the dashboard filter will be applied to all relevant widgets in the dashboard.
    },
  ],
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The mutable, human-readable name.
  &quot;etag&quot;: &quot;A String&quot;, # etag is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. An etag is returned in the response to GetDashboard, and users are expected to put that etag in the request to UpdateDashboard to ensure that their change will be applied to the same version of the Dashboard configuration. The field should not be passed during dashboard creation.
  &quot;gridLayout&quot;: { # A basic layout divides the available space into vertical columns of equal width and arranges a list of widgets using a row-first strategy. # Content is arranged with a basic layout that re-flows a simple list of informational elements like widgets or tiles.
    &quot;columns&quot;: &quot;A String&quot;, # The number of columns into which the view&#x27;s width is divided. If omitted or set to zero, a system default will be used while rendering.
    &quot;widgets&quot;: [ # The informational elements that are arranged into the columns row-first.
      { # Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
        &quot;alertChart&quot;: { # A chart that displays alert policy data. # A chart of alert policy data.
          &quot;name&quot;: &quot;A String&quot;, # Required. The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
        },
        &quot;blank&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # A blank space.
        },
        &quot;collapsibleGroup&quot;: { # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
          &quot;collapsed&quot;: True or False, # The collapsed state of the widget on first page load.
        },
        &quot;errorReportingPanel&quot;: { # A widget that displays a list of error groups. # A widget that displays a list of error groups.
          &quot;projectNames&quot;: [ # The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
            &quot;A String&quot;,
          ],
          &quot;services&quot;: [ # An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
            &quot;A String&quot;,
          ],
          &quot;versions&quot;: [ # Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
            &quot;A String&quot;,
          ],
        },
        &quot;id&quot;: &quot;A String&quot;, # Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
        &quot;incidentList&quot;: { # A widget that displays a list of incidents # A widget that shows list of incidents.
          &quot;monitoredResources&quot;: [ # Optional. The monitored resource for which incidents are listed. The resource doesn&#x27;t need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
            { # An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource&#x27;s schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for &quot;gce_instance&quot; has labels &quot;project_id&quot;, &quot;instance_id&quot; and &quot;zone&quot;: { &quot;type&quot;: &quot;gce_instance&quot;, &quot;labels&quot;: { &quot;project_id&quot;: &quot;my-project&quot;, &quot;instance_id&quot;: &quot;12345678901234&quot;, &quot;zone&quot;: &quot;us-central1-a&quot; }}
              &quot;labels&quot;: { # Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels &quot;project_id&quot;, &quot;instance_id&quot;, and &quot;zone&quot;.
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;type&quot;: &quot;A String&quot;, # Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
            },
          ],
          &quot;policyNames&quot;: [ # Optional. A list of alert policy names to filter the incident list by. Don&#x27;t include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
            &quot;A String&quot;,
          ],
        },
        &quot;logsPanel&quot;: { # A widget that displays a stream of log. # A widget that shows a stream of logs.
          &quot;filter&quot;: &quot;A String&quot;, # A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
          &quot;resourceNames&quot;: [ # The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
            &quot;A String&quot;,
          ],
        },
        &quot;pieChart&quot;: { # A widget that displays timeseries data as a pie or a donut. # A widget that displays timeseries data as a pie chart.
          &quot;chartType&quot;: &quot;A String&quot;, # Required. Indicates the visualization type for the PieChart.
          &quot;dataSets&quot;: [ # Required. The queries for the chart&#x27;s data.
            { # Groups a time series query definition.
              &quot;dimensions&quot;: [ # A dimension is a structured label, class, or category for a set of measurements in your data.
                { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                  &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                  &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                  &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                  &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                  &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                  &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                  &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                },
              ],
              &quot;measures&quot;: [ # A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                  &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                    &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                      { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                        &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                        &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                      },
                    ],
                    &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                  },
                  &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                },
              ],
              &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
              &quot;sliceNameTemplate&quot;: &quot;A String&quot;, # Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone&#x27;s value will be used for the name instead of the default name.
              &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
                &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                  &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                },
                &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                  &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
              },
            },
          ],
          &quot;showLabels&quot;: True or False, # Optional. Indicates whether or not the pie chart should show slices&#x27; labels
        },
        &quot;scorecard&quot;: { # A widget showing the latest value of a metric, and how this value relates to one or more thresholds. # A scorecard summarizing time series data.
          &quot;blankView&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
          },
          &quot;dimensions&quot;: [ # Optional. A dimension is a structured label, class, or category for a set of measurements in your data.
            { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
              &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
              &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
              &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
              &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
              &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
              &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
              &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
              &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
            },
          ],
          &quot;gaugeView&quot;: { # A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard&#x27;s query (inclusive). # Will cause the scorecard to show a gauge chart.
            &quot;lowerBound&quot;: 3.14, # The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
            &quot;upperBound&quot;: 3.14, # The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
          },
          &quot;measures&quot;: [ # Optional. A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
            { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
              &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                  { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                    &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                    &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                  },
                ],
                &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
              },
              &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
            },
          ],
          &quot;sparkChartView&quot;: { # A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard&#x27;s timeseries. # Will cause the scorecard to show a spark chart.
            &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
            &quot;sparkChartType&quot;: &quot;A String&quot;, # Required. The type of sparkchart to show in this chartView.
          },
          &quot;thresholds&quot;: [ # The thresholds used to determine the state of the scorecard given the time series&#x27; current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: &#x27;DANGER&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 70, category: &#x27;WARNING&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 10, category: &#x27;DANGER&#x27;, trigger: &#x27;BELOW&#x27;, }, { value: 20, category: &#x27;WARNING&#x27;, trigger: &#x27;BELOW&#x27;, } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
            { # Defines a threshold for categorizing time series values.
              &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
              &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
              &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
              &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
              &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
            },
          ],
          &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
            &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
              &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
            },
            &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
            &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
            &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
              &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                  &quot;A String&quot;,
                ],
                &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
              },
              &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
              &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                  &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                  &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                },
                &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
              },
              &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                  &quot;A String&quot;,
                ],
                &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
              },
              &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                &quot;numTimeSeries&quot;: 42, # How many time series to output.
                &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
              },
            },
            &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
              &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                  &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                  &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                  &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                    &quot;A String&quot;,
                  ],
                  &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                },
                &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
              },
              &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                  &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                  &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                  &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                    &quot;A String&quot;,
                  ],
                  &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                },
                &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
              },
              &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                  &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                  &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                },
                &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
              },
              &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                  &quot;A String&quot;,
                ],
                &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
              },
              &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                &quot;numTimeSeries&quot;: 42, # How many time series to output.
                &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
              },
            },
            &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
            &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
          },
        },
        &quot;sectionHeader&quot;: { # A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content. # A widget that defines a section header for easier navigation of the dashboard.
          &quot;dividerBelow&quot;: True or False, # Whether to insert a divider below the section in the table of contents
          &quot;subtitle&quot;: &quot;A String&quot;, # The subtitle of the section
        },
        &quot;singleViewGroup&quot;: { # A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets by using a dropdown menu.
        },
        &quot;text&quot;: { # A widget that displays textual content. # A raw string or markdown displaying textual content.
          &quot;content&quot;: &quot;A String&quot;, # The text content to be displayed.
          &quot;format&quot;: &quot;A String&quot;, # How the text content is formatted.
          &quot;style&quot;: { # Properties that determine how the title and content are styled # How the text is styled
            &quot;backgroundColor&quot;: &quot;A String&quot;, # The background color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
            &quot;fontSize&quot;: &quot;A String&quot;, # Font sizes for both the title and content. The title will still be larger relative to the content.
            &quot;horizontalAlignment&quot;: &quot;A String&quot;, # The horizontal alignment of both the title and content
            &quot;padding&quot;: &quot;A String&quot;, # The amount of padding around the widget
            &quot;pointerLocation&quot;: &quot;A String&quot;, # The pointer location for this widget (also sometimes called a &quot;tail&quot;)
            &quot;textColor&quot;: &quot;A String&quot;, # The text color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
            &quot;verticalAlignment&quot;: &quot;A String&quot;, # The vertical alignment of both the title and content
          },
        },
        &quot;timeSeriesTable&quot;: { # A table that displays time series data. # A widget that displays time series data in a tabular format.
          &quot;columnSettings&quot;: [ # Optional. The list of the persistent column settings for the table.
            { # The persistent settings for a table&#x27;s columns.
              &quot;column&quot;: &quot;A String&quot;, # Required. The id of the column.
              &quot;visible&quot;: True or False, # Required. Whether the column should be visible on page load.
            },
          ],
          &quot;dataSets&quot;: [ # Required. The data displayed in this table.
            { # Groups a time series query definition with table options.
              &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
              &quot;tableDisplayOptions&quot;: { # Table display options that can be reused. # Optional. Table display options for configuring how the table is rendered.
                &quot;shownColumns&quot;: [ # Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
                  &quot;A String&quot;,
                ],
              },
              &quot;tableTemplate&quot;: &quot;A String&quot;, # Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value i.e. &quot;${resource.labels.project_id}.&quot;
              &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                  &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                },
                &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                  &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
              },
            },
          ],
          &quot;metricVisualization&quot;: &quot;A String&quot;, # Optional. Store rendering strategy
        },
        &quot;title&quot;: &quot;A String&quot;, # Optional. The title of the widget.
        &quot;xyChart&quot;: { # A chart that displays data on a 2D (X and Y axes) plane. # A chart of time series data.
          &quot;chartOptions&quot;: { # Options to control visual rendering of a chart. # Display options for the chart.
            &quot;displayHorizontal&quot;: True or False, # Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
            &quot;mode&quot;: &quot;A String&quot;, # The chart mode.
          },
          &quot;dataSets&quot;: [ # Required. The data displayed in this chart.
            { # Groups a time series query definition with charting options.
              &quot;breakdowns&quot;: [ # Optional. The collection of breakdowns to be applied to the dataset.
                { # Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
                  &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The Aggregation function is applied across all data in each breakdown created.
                    &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                      { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                        &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                        &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                      },
                    ],
                    &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                  },
                  &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the dataset containing the breakdown values.
                  &quot;limit&quot;: 42, # Required. A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
                  &quot;sortOrder&quot;: &quot;A String&quot;, # Required. The sort order is applied to the values of the breakdown column.
                },
              ],
              &quot;dimensions&quot;: [ # Optional. A collection of dimension columns.
                { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                  &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                  &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                  &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                  &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                  &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                  &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                  &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                },
              ],
              &quot;legendTemplate&quot;: &quot;A String&quot;, # A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value.
              &quot;measures&quot;: [ # Optional. A collection of measures.
                { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                  &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                    &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                      { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                        &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                        &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                      },
                    ],
                    &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                  },
                  &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                },
              ],
              &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
              &quot;plotType&quot;: &quot;A String&quot;, # How this data should be plotted on the chart.
              &quot;targetAxis&quot;: &quot;A String&quot;, # Optional. The target axis to use for plotting the metric.
              &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                  &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                },
                &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                  &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
              },
            },
          ],
          &quot;thresholds&quot;: [ # Threshold lines drawn horizontally across the chart.
            { # Defines a threshold for categorizing time series values.
              &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
              &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
              &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
              &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
              &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
            },
          ],
          &quot;timeshiftDuration&quot;: &quot;A String&quot;, # The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
          &quot;xAxis&quot;: { # A chart axis. # The properties applied to the x-axis.
            &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
            &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
          },
          &quot;y2Axis&quot;: { # A chart axis. # The properties applied to the y2-axis.
            &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
            &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
          },
          &quot;yAxis&quot;: { # A chart axis. # The properties applied to the y-axis.
            &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
            &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
          },
        },
      },
    ],
  },
  &quot;labels&quot;: { # Labels applied to the dashboard
    &quot;a_key&quot;: &quot;A String&quot;,
  },
  &quot;mosaicLayout&quot;: { # A mosaic layout divides the available space into a grid of blocks, and overlays the grid with tiles. Unlike GridLayout, tiles may span multiple grid blocks and can be placed at arbitrary locations in the grid. # The content is arranged as a grid of tiles, with each content widget occupying one or more grid blocks.
    &quot;columns&quot;: 42, # The number of columns in the mosaic grid. The number of columns must be between 1 and 12, inclusive.
    &quot;tiles&quot;: [ # The tiles to display.
      { # A single tile in the mosaic. The placement and size of the tile are configurable.
        &quot;height&quot;: 42, # The height of the tile, measured in grid blocks. Tiles must have a minimum height of 1.
        &quot;widget&quot;: { # Widget contains a single dashboard component and configuration of how to present the component in the dashboard. # The informational widget contained in the tile. For example an XyChart.
          &quot;alertChart&quot;: { # A chart that displays alert policy data. # A chart of alert policy data.
            &quot;name&quot;: &quot;A String&quot;, # Required. The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
          },
          &quot;blank&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # A blank space.
          },
          &quot;collapsibleGroup&quot;: { # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
            &quot;collapsed&quot;: True or False, # The collapsed state of the widget on first page load.
          },
          &quot;errorReportingPanel&quot;: { # A widget that displays a list of error groups. # A widget that displays a list of error groups.
            &quot;projectNames&quot;: [ # The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
              &quot;A String&quot;,
            ],
            &quot;services&quot;: [ # An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
              &quot;A String&quot;,
            ],
            &quot;versions&quot;: [ # Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
              &quot;A String&quot;,
            ],
          },
          &quot;id&quot;: &quot;A String&quot;, # Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
          &quot;incidentList&quot;: { # A widget that displays a list of incidents # A widget that shows list of incidents.
            &quot;monitoredResources&quot;: [ # Optional. The monitored resource for which incidents are listed. The resource doesn&#x27;t need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
              { # An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource&#x27;s schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for &quot;gce_instance&quot; has labels &quot;project_id&quot;, &quot;instance_id&quot; and &quot;zone&quot;: { &quot;type&quot;: &quot;gce_instance&quot;, &quot;labels&quot;: { &quot;project_id&quot;: &quot;my-project&quot;, &quot;instance_id&quot;: &quot;12345678901234&quot;, &quot;zone&quot;: &quot;us-central1-a&quot; }}
                &quot;labels&quot;: { # Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels &quot;project_id&quot;, &quot;instance_id&quot;, and &quot;zone&quot;.
                  &quot;a_key&quot;: &quot;A String&quot;,
                },
                &quot;type&quot;: &quot;A String&quot;, # Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
              },
            ],
            &quot;policyNames&quot;: [ # Optional. A list of alert policy names to filter the incident list by. Don&#x27;t include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
              &quot;A String&quot;,
            ],
          },
          &quot;logsPanel&quot;: { # A widget that displays a stream of log. # A widget that shows a stream of logs.
            &quot;filter&quot;: &quot;A String&quot;, # A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
            &quot;resourceNames&quot;: [ # The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
              &quot;A String&quot;,
            ],
          },
          &quot;pieChart&quot;: { # A widget that displays timeseries data as a pie or a donut. # A widget that displays timeseries data as a pie chart.
            &quot;chartType&quot;: &quot;A String&quot;, # Required. Indicates the visualization type for the PieChart.
            &quot;dataSets&quot;: [ # Required. The queries for the chart&#x27;s data.
              { # Groups a time series query definition.
                &quot;dimensions&quot;: [ # A dimension is a structured label, class, or category for a set of measurements in your data.
                  { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                    &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                    &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                    &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                    &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                    &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                    &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                    &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                    &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                  },
                ],
                &quot;measures&quot;: [ # A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                  { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                    &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                      &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                        { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                          &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                          &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                        },
                      ],
                      &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                    },
                    &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                  },
                ],
                &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                &quot;sliceNameTemplate&quot;: &quot;A String&quot;, # Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone&#x27;s value will be used for the name instead of the default name.
                &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
                  &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                    &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                  },
                  &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                  &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                  &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                    &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                  &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                },
              },
            ],
            &quot;showLabels&quot;: True or False, # Optional. Indicates whether or not the pie chart should show slices&#x27; labels
          },
          &quot;scorecard&quot;: { # A widget showing the latest value of a metric, and how this value relates to one or more thresholds. # A scorecard summarizing time series data.
            &quot;blankView&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
            },
            &quot;dimensions&quot;: [ # Optional. A dimension is a structured label, class, or category for a set of measurements in your data.
              { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
              },
            ],
            &quot;gaugeView&quot;: { # A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard&#x27;s query (inclusive). # Will cause the scorecard to show a gauge chart.
              &quot;lowerBound&quot;: 3.14, # The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
              &quot;upperBound&quot;: 3.14, # The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
            },
            &quot;measures&quot;: [ # Optional. A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
              { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                  &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                    { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                      &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                      &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                    },
                  ],
                  &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                },
                &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
              },
            ],
            &quot;sparkChartView&quot;: { # A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard&#x27;s timeseries. # Will cause the scorecard to show a spark chart.
              &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
              &quot;sparkChartType&quot;: &quot;A String&quot;, # Required. The type of sparkchart to show in this chartView.
            },
            &quot;thresholds&quot;: [ # The thresholds used to determine the state of the scorecard given the time series&#x27; current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: &#x27;DANGER&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 70, category: &#x27;WARNING&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 10, category: &#x27;DANGER&#x27;, trigger: &#x27;BELOW&#x27;, }, { value: 20, category: &#x27;WARNING&#x27;, trigger: &#x27;BELOW&#x27;, } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
              { # Defines a threshold for categorizing time series values.
                &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
              },
            ],
            &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
              &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
              },
              &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
              &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
              &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                  &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                  &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                  &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                    &quot;A String&quot;,
                  ],
                  &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                },
                &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                  &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                  &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                    &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                    &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                  },
                  &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                  &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                },
                &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                  &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                  &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                  &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                    &quot;A String&quot;,
                  ],
                  &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                },
                &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                  &quot;numTimeSeries&quot;: 42, # How many time series to output.
                  &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                },
              },
              &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                },
                &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                },
                &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                  &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                  &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                    &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                    &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                  },
                  &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                  &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                },
                &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                  &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                  &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                  &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                    &quot;A String&quot;,
                  ],
                  &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                },
                &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                  &quot;numTimeSeries&quot;: 42, # How many time series to output.
                  &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                },
              },
              &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
              &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
            },
          },
          &quot;sectionHeader&quot;: { # A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content. # A widget that defines a section header for easier navigation of the dashboard.
            &quot;dividerBelow&quot;: True or False, # Whether to insert a divider below the section in the table of contents
            &quot;subtitle&quot;: &quot;A String&quot;, # The subtitle of the section
          },
          &quot;singleViewGroup&quot;: { # A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets by using a dropdown menu.
          },
          &quot;text&quot;: { # A widget that displays textual content. # A raw string or markdown displaying textual content.
            &quot;content&quot;: &quot;A String&quot;, # The text content to be displayed.
            &quot;format&quot;: &quot;A String&quot;, # How the text content is formatted.
            &quot;style&quot;: { # Properties that determine how the title and content are styled # How the text is styled
              &quot;backgroundColor&quot;: &quot;A String&quot;, # The background color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
              &quot;fontSize&quot;: &quot;A String&quot;, # Font sizes for both the title and content. The title will still be larger relative to the content.
              &quot;horizontalAlignment&quot;: &quot;A String&quot;, # The horizontal alignment of both the title and content
              &quot;padding&quot;: &quot;A String&quot;, # The amount of padding around the widget
              &quot;pointerLocation&quot;: &quot;A String&quot;, # The pointer location for this widget (also sometimes called a &quot;tail&quot;)
              &quot;textColor&quot;: &quot;A String&quot;, # The text color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
              &quot;verticalAlignment&quot;: &quot;A String&quot;, # The vertical alignment of both the title and content
            },
          },
          &quot;timeSeriesTable&quot;: { # A table that displays time series data. # A widget that displays time series data in a tabular format.
            &quot;columnSettings&quot;: [ # Optional. The list of the persistent column settings for the table.
              { # The persistent settings for a table&#x27;s columns.
                &quot;column&quot;: &quot;A String&quot;, # Required. The id of the column.
                &quot;visible&quot;: True or False, # Required. Whether the column should be visible on page load.
              },
            ],
            &quot;dataSets&quot;: [ # Required. The data displayed in this table.
              { # Groups a time series query definition with table options.
                &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                &quot;tableDisplayOptions&quot;: { # Table display options that can be reused. # Optional. Table display options for configuring how the table is rendered.
                  &quot;shownColumns&quot;: [ # Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
                    &quot;A String&quot;,
                  ],
                },
                &quot;tableTemplate&quot;: &quot;A String&quot;, # Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value i.e. &quot;${resource.labels.project_id}.&quot;
                &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                  &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                    &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                  },
                  &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                  &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                  &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                    &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                  &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                },
              },
            ],
            &quot;metricVisualization&quot;: &quot;A String&quot;, # Optional. Store rendering strategy
          },
          &quot;title&quot;: &quot;A String&quot;, # Optional. The title of the widget.
          &quot;xyChart&quot;: { # A chart that displays data on a 2D (X and Y axes) plane. # A chart of time series data.
            &quot;chartOptions&quot;: { # Options to control visual rendering of a chart. # Display options for the chart.
              &quot;displayHorizontal&quot;: True or False, # Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
              &quot;mode&quot;: &quot;A String&quot;, # The chart mode.
            },
            &quot;dataSets&quot;: [ # Required. The data displayed in this chart.
              { # Groups a time series query definition with charting options.
                &quot;breakdowns&quot;: [ # Optional. The collection of breakdowns to be applied to the dataset.
                  { # Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
                    &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The Aggregation function is applied across all data in each breakdown created.
                      &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                        { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                          &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                          &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                        },
                      ],
                      &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                    },
                    &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the dataset containing the breakdown values.
                    &quot;limit&quot;: 42, # Required. A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
                    &quot;sortOrder&quot;: &quot;A String&quot;, # Required. The sort order is applied to the values of the breakdown column.
                  },
                ],
                &quot;dimensions&quot;: [ # Optional. A collection of dimension columns.
                  { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                    &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                    &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                    &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                    &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                    &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                    &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                    &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                    &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                  },
                ],
                &quot;legendTemplate&quot;: &quot;A String&quot;, # A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value.
                &quot;measures&quot;: [ # Optional. A collection of measures.
                  { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                    &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                      &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                        { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                          &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                          &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                        },
                      ],
                      &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                    },
                    &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                  },
                ],
                &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                &quot;plotType&quot;: &quot;A String&quot;, # How this data should be plotted on the chart.
                &quot;targetAxis&quot;: &quot;A String&quot;, # Optional. The target axis to use for plotting the metric.
                &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                  &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                    &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                  },
                  &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                  &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                  &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                    &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                  &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                },
              },
            ],
            &quot;thresholds&quot;: [ # Threshold lines drawn horizontally across the chart.
              { # Defines a threshold for categorizing time series values.
                &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
              },
            ],
            &quot;timeshiftDuration&quot;: &quot;A String&quot;, # The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
            &quot;xAxis&quot;: { # A chart axis. # The properties applied to the x-axis.
              &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
              &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
            },
            &quot;y2Axis&quot;: { # A chart axis. # The properties applied to the y2-axis.
              &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
              &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
            },
            &quot;yAxis&quot;: { # A chart axis. # The properties applied to the y-axis.
              &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
              &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
            },
          },
        },
        &quot;width&quot;: 42, # The width of the tile, measured in grid blocks. Tiles must have a minimum width of 1.
        &quot;xPos&quot;: 42, # The zero-indexed position of the tile in grid blocks relative to the left edge of the grid. Tiles must be contained within the specified number of columns. x_pos cannot be negative.
        &quot;yPos&quot;: 42, # The zero-indexed position of the tile in grid blocks relative to the top edge of the grid. y_pos cannot be negative.
      },
    ],
  },
  &quot;name&quot;: &quot;A String&quot;, # Identifier. The resource name of the dashboard.
  &quot;rowLayout&quot;: { # A simplified layout that divides the available space into rows and arranges a set of widgets horizontally in each row. # The content is divided into equally spaced rows and the widgets are arranged horizontally.
    &quot;rows&quot;: [ # The rows of content to display.
      { # Defines the layout properties and content for a row.
        &quot;weight&quot;: &quot;A String&quot;, # The relative weight of this row. The row weight is used to adjust the height of rows on the screen (relative to peers). Greater the weight, greater the height of the row on the screen. If omitted, a value of 1 is used while rendering.
        &quot;widgets&quot;: [ # The display widgets arranged horizontally in this row.
          { # Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
            &quot;alertChart&quot;: { # A chart that displays alert policy data. # A chart of alert policy data.
              &quot;name&quot;: &quot;A String&quot;, # Required. The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
            },
            &quot;blank&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # A blank space.
            },
            &quot;collapsibleGroup&quot;: { # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
              &quot;collapsed&quot;: True or False, # The collapsed state of the widget on first page load.
            },
            &quot;errorReportingPanel&quot;: { # A widget that displays a list of error groups. # A widget that displays a list of error groups.
              &quot;projectNames&quot;: [ # The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
                &quot;A String&quot;,
              ],
              &quot;services&quot;: [ # An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
                &quot;A String&quot;,
              ],
              &quot;versions&quot;: [ # Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
                &quot;A String&quot;,
              ],
            },
            &quot;id&quot;: &quot;A String&quot;, # Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
            &quot;incidentList&quot;: { # A widget that displays a list of incidents # A widget that shows list of incidents.
              &quot;monitoredResources&quot;: [ # Optional. The monitored resource for which incidents are listed. The resource doesn&#x27;t need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
                { # An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource&#x27;s schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for &quot;gce_instance&quot; has labels &quot;project_id&quot;, &quot;instance_id&quot; and &quot;zone&quot;: { &quot;type&quot;: &quot;gce_instance&quot;, &quot;labels&quot;: { &quot;project_id&quot;: &quot;my-project&quot;, &quot;instance_id&quot;: &quot;12345678901234&quot;, &quot;zone&quot;: &quot;us-central1-a&quot; }}
                  &quot;labels&quot;: { # Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels &quot;project_id&quot;, &quot;instance_id&quot;, and &quot;zone&quot;.
                    &quot;a_key&quot;: &quot;A String&quot;,
                  },
                  &quot;type&quot;: &quot;A String&quot;, # Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
                },
              ],
              &quot;policyNames&quot;: [ # Optional. A list of alert policy names to filter the incident list by. Don&#x27;t include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
                &quot;A String&quot;,
              ],
            },
            &quot;logsPanel&quot;: { # A widget that displays a stream of log. # A widget that shows a stream of logs.
              &quot;filter&quot;: &quot;A String&quot;, # A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
              &quot;resourceNames&quot;: [ # The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
                &quot;A String&quot;,
              ],
            },
            &quot;pieChart&quot;: { # A widget that displays timeseries data as a pie or a donut. # A widget that displays timeseries data as a pie chart.
              &quot;chartType&quot;: &quot;A String&quot;, # Required. Indicates the visualization type for the PieChart.
              &quot;dataSets&quot;: [ # Required. The queries for the chart&#x27;s data.
                { # Groups a time series query definition.
                  &quot;dimensions&quot;: [ # A dimension is a structured label, class, or category for a set of measurements in your data.
                    { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                      &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                      &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                      &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                      &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                      &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                      &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                    },
                  ],
                  &quot;measures&quot;: [ # A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                    { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                    },
                  ],
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;sliceNameTemplate&quot;: &quot;A String&quot;, # Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone&#x27;s value will be used for the name instead of the default name.
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;showLabels&quot;: True or False, # Optional. Indicates whether or not the pie chart should show slices&#x27; labels
            },
            &quot;scorecard&quot;: { # A widget showing the latest value of a metric, and how this value relates to one or more thresholds. # A scorecard summarizing time series data.
              &quot;blankView&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
              },
              &quot;dimensions&quot;: [ # Optional. A dimension is a structured label, class, or category for a set of measurements in your data.
                { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                  &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                  &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                  &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                  &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                  &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                  &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                  &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                },
              ],
              &quot;gaugeView&quot;: { # A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard&#x27;s query (inclusive). # Will cause the scorecard to show a gauge chart.
                &quot;lowerBound&quot;: 3.14, # The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
                &quot;upperBound&quot;: 3.14, # The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
              },
              &quot;measures&quot;: [ # Optional. A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                  &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                    &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                      { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                        &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                        &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                      },
                    ],
                    &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                  },
                  &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                },
              ],
              &quot;sparkChartView&quot;: { # A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard&#x27;s timeseries. # Will cause the scorecard to show a spark chart.
                &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
                &quot;sparkChartType&quot;: &quot;A String&quot;, # Required. The type of sparkchart to show in this chartView.
              },
              &quot;thresholds&quot;: [ # The thresholds used to determine the state of the scorecard given the time series&#x27; current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: &#x27;DANGER&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 70, category: &#x27;WARNING&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 10, category: &#x27;DANGER&#x27;, trigger: &#x27;BELOW&#x27;, }, { value: 20, category: &#x27;WARNING&#x27;, trigger: &#x27;BELOW&#x27;, } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
                { # Defines a threshold for categorizing time series values.
                  &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                  &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                  &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                  &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                },
              ],
              &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                  &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                },
                &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                  &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
              },
            },
            &quot;sectionHeader&quot;: { # A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content. # A widget that defines a section header for easier navigation of the dashboard.
              &quot;dividerBelow&quot;: True or False, # Whether to insert a divider below the section in the table of contents
              &quot;subtitle&quot;: &quot;A String&quot;, # The subtitle of the section
            },
            &quot;singleViewGroup&quot;: { # A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets by using a dropdown menu.
            },
            &quot;text&quot;: { # A widget that displays textual content. # A raw string or markdown displaying textual content.
              &quot;content&quot;: &quot;A String&quot;, # The text content to be displayed.
              &quot;format&quot;: &quot;A String&quot;, # How the text content is formatted.
              &quot;style&quot;: { # Properties that determine how the title and content are styled # How the text is styled
                &quot;backgroundColor&quot;: &quot;A String&quot;, # The background color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                &quot;fontSize&quot;: &quot;A String&quot;, # Font sizes for both the title and content. The title will still be larger relative to the content.
                &quot;horizontalAlignment&quot;: &quot;A String&quot;, # The horizontal alignment of both the title and content
                &quot;padding&quot;: &quot;A String&quot;, # The amount of padding around the widget
                &quot;pointerLocation&quot;: &quot;A String&quot;, # The pointer location for this widget (also sometimes called a &quot;tail&quot;)
                &quot;textColor&quot;: &quot;A String&quot;, # The text color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                &quot;verticalAlignment&quot;: &quot;A String&quot;, # The vertical alignment of both the title and content
              },
            },
            &quot;timeSeriesTable&quot;: { # A table that displays time series data. # A widget that displays time series data in a tabular format.
              &quot;columnSettings&quot;: [ # Optional. The list of the persistent column settings for the table.
                { # The persistent settings for a table&#x27;s columns.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The id of the column.
                  &quot;visible&quot;: True or False, # Required. Whether the column should be visible on page load.
                },
              ],
              &quot;dataSets&quot;: [ # Required. The data displayed in this table.
                { # Groups a time series query definition with table options.
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;tableDisplayOptions&quot;: { # Table display options that can be reused. # Optional. Table display options for configuring how the table is rendered.
                    &quot;shownColumns&quot;: [ # Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
                      &quot;A String&quot;,
                    ],
                  },
                  &quot;tableTemplate&quot;: &quot;A String&quot;, # Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value i.e. &quot;${resource.labels.project_id}.&quot;
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;metricVisualization&quot;: &quot;A String&quot;, # Optional. Store rendering strategy
            },
            &quot;title&quot;: &quot;A String&quot;, # Optional. The title of the widget.
            &quot;xyChart&quot;: { # A chart that displays data on a 2D (X and Y axes) plane. # A chart of time series data.
              &quot;chartOptions&quot;: { # Options to control visual rendering of a chart. # Display options for the chart.
                &quot;displayHorizontal&quot;: True or False, # Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
                &quot;mode&quot;: &quot;A String&quot;, # The chart mode.
              },
              &quot;dataSets&quot;: [ # Required. The data displayed in this chart.
                { # Groups a time series query definition with charting options.
                  &quot;breakdowns&quot;: [ # Optional. The collection of breakdowns to be applied to the dataset.
                    { # Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The Aggregation function is applied across all data in each breakdown created.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the dataset containing the breakdown values.
                      &quot;limit&quot;: 42, # Required. A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # Required. The sort order is applied to the values of the breakdown column.
                    },
                  ],
                  &quot;dimensions&quot;: [ # Optional. A collection of dimension columns.
                    { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                      &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                      &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                      &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                      &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                      &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                      &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                    },
                  ],
                  &quot;legendTemplate&quot;: &quot;A String&quot;, # A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value.
                  &quot;measures&quot;: [ # Optional. A collection of measures.
                    { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                    },
                  ],
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;plotType&quot;: &quot;A String&quot;, # How this data should be plotted on the chart.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # Optional. The target axis to use for plotting the metric.
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;thresholds&quot;: [ # Threshold lines drawn horizontally across the chart.
                { # Defines a threshold for categorizing time series values.
                  &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                  &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                  &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                  &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                },
              ],
              &quot;timeshiftDuration&quot;: &quot;A String&quot;, # The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
              &quot;xAxis&quot;: { # A chart axis. # The properties applied to the x-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
              &quot;y2Axis&quot;: { # A chart axis. # The properties applied to the y2-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
              &quot;yAxis&quot;: { # A chart axis. # The properties applied to the y-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
            },
          },
        ],
      },
    ],
  },
}

  validateOnly: boolean, If set, validate the request and preview the review, but do not actually save it.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A Google Stackdriver dashboard. Dashboards define the content and layout of pages in the Stackdriver web application.
  &quot;annotations&quot;: { # Dashboard-level configuration for annotations # Configuration for event annotations to display on this dashboard.
    &quot;defaultResourceNames&quot;: [ # Dashboard level defaults for names of logging resources to search for events. Currently only projects are supported. Each individual EventAnnotation may have its own overrides. If both this field and the per annotation field is empty, then the scoping project is used. Limit: 50 projects. For example: “projects/some-project-id”
      &quot;A String&quot;,
    ],
    &quot;eventAnnotations&quot;: [ # List of annotation configurations for this dashboard. Each entry specifies one event type.
      { # Annotation configuration for one event type on a dashboard
        &quot;displayName&quot;: &quot;A String&quot;, # Solely for UI display. Should not be used programmatically.
        &quot;enabled&quot;: True or False, # Whether or not to show the events on the dashboard by default
        &quot;eventType&quot;: &quot;A String&quot;, # The type of event to display.
        &quot;filter&quot;: &quot;A String&quot;, # string filtering the events - event dependant. Example values: &quot;resource.labels.pod_name = &#x27;pod-1&#x27;&quot; &quot;protoPayload.authenticationInfo.principalEmail=&#x27;user@example.com&#x27;&quot;
        &quot;resourceNames&quot;: [ # Per annotation level override for the names of logging resources to search for events. Currently only projects are supported. If both this field and the per annotation field is empty, it will default to the host project. Limit: 50 projects. For example: “projects/another-project-id”
          &quot;A String&quot;,
        ],
      },
    ],
  },
  &quot;columnLayout&quot;: { # A simplified layout that divides the available space into vertical columns and arranges a set of widgets vertically in each column. # The content is divided into equally spaced columns and the widgets are arranged vertically.
    &quot;columns&quot;: [ # The columns of content to display.
      { # Defines the layout properties and content for a column.
        &quot;weight&quot;: &quot;A String&quot;, # The relative weight of this column. The column weight is used to adjust the width of columns on the screen (relative to peers). Greater the weight, greater the width of the column on the screen. If omitted, a value of 1 is used while rendering.
        &quot;widgets&quot;: [ # The display widgets arranged vertically in this column.
          { # Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
            &quot;alertChart&quot;: { # A chart that displays alert policy data. # A chart of alert policy data.
              &quot;name&quot;: &quot;A String&quot;, # Required. The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
            },
            &quot;blank&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # A blank space.
            },
            &quot;collapsibleGroup&quot;: { # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
              &quot;collapsed&quot;: True or False, # The collapsed state of the widget on first page load.
            },
            &quot;errorReportingPanel&quot;: { # A widget that displays a list of error groups. # A widget that displays a list of error groups.
              &quot;projectNames&quot;: [ # The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
                &quot;A String&quot;,
              ],
              &quot;services&quot;: [ # An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
                &quot;A String&quot;,
              ],
              &quot;versions&quot;: [ # Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
                &quot;A String&quot;,
              ],
            },
            &quot;id&quot;: &quot;A String&quot;, # Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
            &quot;incidentList&quot;: { # A widget that displays a list of incidents # A widget that shows list of incidents.
              &quot;monitoredResources&quot;: [ # Optional. The monitored resource for which incidents are listed. The resource doesn&#x27;t need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
                { # An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource&#x27;s schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for &quot;gce_instance&quot; has labels &quot;project_id&quot;, &quot;instance_id&quot; and &quot;zone&quot;: { &quot;type&quot;: &quot;gce_instance&quot;, &quot;labels&quot;: { &quot;project_id&quot;: &quot;my-project&quot;, &quot;instance_id&quot;: &quot;12345678901234&quot;, &quot;zone&quot;: &quot;us-central1-a&quot; }}
                  &quot;labels&quot;: { # Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels &quot;project_id&quot;, &quot;instance_id&quot;, and &quot;zone&quot;.
                    &quot;a_key&quot;: &quot;A String&quot;,
                  },
                  &quot;type&quot;: &quot;A String&quot;, # Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
                },
              ],
              &quot;policyNames&quot;: [ # Optional. A list of alert policy names to filter the incident list by. Don&#x27;t include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
                &quot;A String&quot;,
              ],
            },
            &quot;logsPanel&quot;: { # A widget that displays a stream of log. # A widget that shows a stream of logs.
              &quot;filter&quot;: &quot;A String&quot;, # A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
              &quot;resourceNames&quot;: [ # The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
                &quot;A String&quot;,
              ],
            },
            &quot;pieChart&quot;: { # A widget that displays timeseries data as a pie or a donut. # A widget that displays timeseries data as a pie chart.
              &quot;chartType&quot;: &quot;A String&quot;, # Required. Indicates the visualization type for the PieChart.
              &quot;dataSets&quot;: [ # Required. The queries for the chart&#x27;s data.
                { # Groups a time series query definition.
                  &quot;dimensions&quot;: [ # A dimension is a structured label, class, or category for a set of measurements in your data.
                    { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                      &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                      &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                      &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                      &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                      &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                      &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                    },
                  ],
                  &quot;measures&quot;: [ # A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                    { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                    },
                  ],
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;sliceNameTemplate&quot;: &quot;A String&quot;, # Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone&#x27;s value will be used for the name instead of the default name.
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;showLabels&quot;: True or False, # Optional. Indicates whether or not the pie chart should show slices&#x27; labels
            },
            &quot;scorecard&quot;: { # A widget showing the latest value of a metric, and how this value relates to one or more thresholds. # A scorecard summarizing time series data.
              &quot;blankView&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
              },
              &quot;dimensions&quot;: [ # Optional. A dimension is a structured label, class, or category for a set of measurements in your data.
                { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                  &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                  &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                  &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                  &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                  &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                  &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                  &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                },
              ],
              &quot;gaugeView&quot;: { # A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard&#x27;s query (inclusive). # Will cause the scorecard to show a gauge chart.
                &quot;lowerBound&quot;: 3.14, # The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
                &quot;upperBound&quot;: 3.14, # The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
              },
              &quot;measures&quot;: [ # Optional. A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                  &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                    &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                      { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                        &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                        &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                      },
                    ],
                    &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                  },
                  &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                },
              ],
              &quot;sparkChartView&quot;: { # A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard&#x27;s timeseries. # Will cause the scorecard to show a spark chart.
                &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
                &quot;sparkChartType&quot;: &quot;A String&quot;, # Required. The type of sparkchart to show in this chartView.
              },
              &quot;thresholds&quot;: [ # The thresholds used to determine the state of the scorecard given the time series&#x27; current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: &#x27;DANGER&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 70, category: &#x27;WARNING&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 10, category: &#x27;DANGER&#x27;, trigger: &#x27;BELOW&#x27;, }, { value: 20, category: &#x27;WARNING&#x27;, trigger: &#x27;BELOW&#x27;, } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
                { # Defines a threshold for categorizing time series values.
                  &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                  &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                  &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                  &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                },
              ],
              &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                  &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                },
                &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                  &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
              },
            },
            &quot;sectionHeader&quot;: { # A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content. # A widget that defines a section header for easier navigation of the dashboard.
              &quot;dividerBelow&quot;: True or False, # Whether to insert a divider below the section in the table of contents
              &quot;subtitle&quot;: &quot;A String&quot;, # The subtitle of the section
            },
            &quot;singleViewGroup&quot;: { # A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets by using a dropdown menu.
            },
            &quot;text&quot;: { # A widget that displays textual content. # A raw string or markdown displaying textual content.
              &quot;content&quot;: &quot;A String&quot;, # The text content to be displayed.
              &quot;format&quot;: &quot;A String&quot;, # How the text content is formatted.
              &quot;style&quot;: { # Properties that determine how the title and content are styled # How the text is styled
                &quot;backgroundColor&quot;: &quot;A String&quot;, # The background color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                &quot;fontSize&quot;: &quot;A String&quot;, # Font sizes for both the title and content. The title will still be larger relative to the content.
                &quot;horizontalAlignment&quot;: &quot;A String&quot;, # The horizontal alignment of both the title and content
                &quot;padding&quot;: &quot;A String&quot;, # The amount of padding around the widget
                &quot;pointerLocation&quot;: &quot;A String&quot;, # The pointer location for this widget (also sometimes called a &quot;tail&quot;)
                &quot;textColor&quot;: &quot;A String&quot;, # The text color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                &quot;verticalAlignment&quot;: &quot;A String&quot;, # The vertical alignment of both the title and content
              },
            },
            &quot;timeSeriesTable&quot;: { # A table that displays time series data. # A widget that displays time series data in a tabular format.
              &quot;columnSettings&quot;: [ # Optional. The list of the persistent column settings for the table.
                { # The persistent settings for a table&#x27;s columns.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The id of the column.
                  &quot;visible&quot;: True or False, # Required. Whether the column should be visible on page load.
                },
              ],
              &quot;dataSets&quot;: [ # Required. The data displayed in this table.
                { # Groups a time series query definition with table options.
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;tableDisplayOptions&quot;: { # Table display options that can be reused. # Optional. Table display options for configuring how the table is rendered.
                    &quot;shownColumns&quot;: [ # Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
                      &quot;A String&quot;,
                    ],
                  },
                  &quot;tableTemplate&quot;: &quot;A String&quot;, # Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value i.e. &quot;${resource.labels.project_id}.&quot;
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;metricVisualization&quot;: &quot;A String&quot;, # Optional. Store rendering strategy
            },
            &quot;title&quot;: &quot;A String&quot;, # Optional. The title of the widget.
            &quot;xyChart&quot;: { # A chart that displays data on a 2D (X and Y axes) plane. # A chart of time series data.
              &quot;chartOptions&quot;: { # Options to control visual rendering of a chart. # Display options for the chart.
                &quot;displayHorizontal&quot;: True or False, # Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
                &quot;mode&quot;: &quot;A String&quot;, # The chart mode.
              },
              &quot;dataSets&quot;: [ # Required. The data displayed in this chart.
                { # Groups a time series query definition with charting options.
                  &quot;breakdowns&quot;: [ # Optional. The collection of breakdowns to be applied to the dataset.
                    { # Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The Aggregation function is applied across all data in each breakdown created.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the dataset containing the breakdown values.
                      &quot;limit&quot;: 42, # Required. A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # Required. The sort order is applied to the values of the breakdown column.
                    },
                  ],
                  &quot;dimensions&quot;: [ # Optional. A collection of dimension columns.
                    { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                      &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                      &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                      &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                      &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                      &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                      &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                    },
                  ],
                  &quot;legendTemplate&quot;: &quot;A String&quot;, # A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value.
                  &quot;measures&quot;: [ # Optional. A collection of measures.
                    { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                    },
                  ],
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;plotType&quot;: &quot;A String&quot;, # How this data should be plotted on the chart.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # Optional. The target axis to use for plotting the metric.
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;thresholds&quot;: [ # Threshold lines drawn horizontally across the chart.
                { # Defines a threshold for categorizing time series values.
                  &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                  &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                  &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                  &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                },
              ],
              &quot;timeshiftDuration&quot;: &quot;A String&quot;, # The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
              &quot;xAxis&quot;: { # A chart axis. # The properties applied to the x-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
              &quot;y2Axis&quot;: { # A chart axis. # The properties applied to the y2-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
              &quot;yAxis&quot;: { # A chart axis. # The properties applied to the y-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
            },
          },
        ],
      },
    ],
  },
  &quot;dashboardFilters&quot;: [ # Filters to reduce the amount of data charted based on the filter criteria.
    { # A filter to reduce the amount of data charted in relevant widgets.
      &quot;filterType&quot;: &quot;A String&quot;, # The specified filter type
      &quot;labelKey&quot;: &quot;A String&quot;, # Required. The key for the label
      &quot;stringValue&quot;: &quot;A String&quot;, # A variable-length string value.
      &quot;templateVariable&quot;: &quot;A String&quot;, # The placeholder text that can be referenced in a filter string or MQL query. If omitted, the dashboard filter will be applied to all relevant widgets in the dashboard.
    },
  ],
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The mutable, human-readable name.
  &quot;etag&quot;: &quot;A String&quot;, # etag is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. An etag is returned in the response to GetDashboard, and users are expected to put that etag in the request to UpdateDashboard to ensure that their change will be applied to the same version of the Dashboard configuration. The field should not be passed during dashboard creation.
  &quot;gridLayout&quot;: { # A basic layout divides the available space into vertical columns of equal width and arranges a list of widgets using a row-first strategy. # Content is arranged with a basic layout that re-flows a simple list of informational elements like widgets or tiles.
    &quot;columns&quot;: &quot;A String&quot;, # The number of columns into which the view&#x27;s width is divided. If omitted or set to zero, a system default will be used while rendering.
    &quot;widgets&quot;: [ # The informational elements that are arranged into the columns row-first.
      { # Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
        &quot;alertChart&quot;: { # A chart that displays alert policy data. # A chart of alert policy data.
          &quot;name&quot;: &quot;A String&quot;, # Required. The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
        },
        &quot;blank&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # A blank space.
        },
        &quot;collapsibleGroup&quot;: { # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
          &quot;collapsed&quot;: True or False, # The collapsed state of the widget on first page load.
        },
        &quot;errorReportingPanel&quot;: { # A widget that displays a list of error groups. # A widget that displays a list of error groups.
          &quot;projectNames&quot;: [ # The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
            &quot;A String&quot;,
          ],
          &quot;services&quot;: [ # An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
            &quot;A String&quot;,
          ],
          &quot;versions&quot;: [ # Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
            &quot;A String&quot;,
          ],
        },
        &quot;id&quot;: &quot;A String&quot;, # Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
        &quot;incidentList&quot;: { # A widget that displays a list of incidents # A widget that shows list of incidents.
          &quot;monitoredResources&quot;: [ # Optional. The monitored resource for which incidents are listed. The resource doesn&#x27;t need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
            { # An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource&#x27;s schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for &quot;gce_instance&quot; has labels &quot;project_id&quot;, &quot;instance_id&quot; and &quot;zone&quot;: { &quot;type&quot;: &quot;gce_instance&quot;, &quot;labels&quot;: { &quot;project_id&quot;: &quot;my-project&quot;, &quot;instance_id&quot;: &quot;12345678901234&quot;, &quot;zone&quot;: &quot;us-central1-a&quot; }}
              &quot;labels&quot;: { # Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels &quot;project_id&quot;, &quot;instance_id&quot;, and &quot;zone&quot;.
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;type&quot;: &quot;A String&quot;, # Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
            },
          ],
          &quot;policyNames&quot;: [ # Optional. A list of alert policy names to filter the incident list by. Don&#x27;t include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
            &quot;A String&quot;,
          ],
        },
        &quot;logsPanel&quot;: { # A widget that displays a stream of log. # A widget that shows a stream of logs.
          &quot;filter&quot;: &quot;A String&quot;, # A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
          &quot;resourceNames&quot;: [ # The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
            &quot;A String&quot;,
          ],
        },
        &quot;pieChart&quot;: { # A widget that displays timeseries data as a pie or a donut. # A widget that displays timeseries data as a pie chart.
          &quot;chartType&quot;: &quot;A String&quot;, # Required. Indicates the visualization type for the PieChart.
          &quot;dataSets&quot;: [ # Required. The queries for the chart&#x27;s data.
            { # Groups a time series query definition.
              &quot;dimensions&quot;: [ # A dimension is a structured label, class, or category for a set of measurements in your data.
                { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                  &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                  &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                  &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                  &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                  &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                  &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                  &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                },
              ],
              &quot;measures&quot;: [ # A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                  &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                    &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                      { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                        &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                        &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                      },
                    ],
                    &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                  },
                  &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                },
              ],
              &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
              &quot;sliceNameTemplate&quot;: &quot;A String&quot;, # Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone&#x27;s value will be used for the name instead of the default name.
              &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
                &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                  &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                },
                &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                  &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
              },
            },
          ],
          &quot;showLabels&quot;: True or False, # Optional. Indicates whether or not the pie chart should show slices&#x27; labels
        },
        &quot;scorecard&quot;: { # A widget showing the latest value of a metric, and how this value relates to one or more thresholds. # A scorecard summarizing time series data.
          &quot;blankView&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
          },
          &quot;dimensions&quot;: [ # Optional. A dimension is a structured label, class, or category for a set of measurements in your data.
            { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
              &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
              &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
              &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
              &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
              &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
              &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
              &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
              &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
            },
          ],
          &quot;gaugeView&quot;: { # A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard&#x27;s query (inclusive). # Will cause the scorecard to show a gauge chart.
            &quot;lowerBound&quot;: 3.14, # The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
            &quot;upperBound&quot;: 3.14, # The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
          },
          &quot;measures&quot;: [ # Optional. A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
            { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
              &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                  { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                    &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                    &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                  },
                ],
                &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
              },
              &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
            },
          ],
          &quot;sparkChartView&quot;: { # A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard&#x27;s timeseries. # Will cause the scorecard to show a spark chart.
            &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
            &quot;sparkChartType&quot;: &quot;A String&quot;, # Required. The type of sparkchart to show in this chartView.
          },
          &quot;thresholds&quot;: [ # The thresholds used to determine the state of the scorecard given the time series&#x27; current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: &#x27;DANGER&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 70, category: &#x27;WARNING&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 10, category: &#x27;DANGER&#x27;, trigger: &#x27;BELOW&#x27;, }, { value: 20, category: &#x27;WARNING&#x27;, trigger: &#x27;BELOW&#x27;, } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
            { # Defines a threshold for categorizing time series values.
              &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
              &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
              &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
              &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
              &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
            },
          ],
          &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
            &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
              &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
            },
            &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
            &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
            &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
              &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                  &quot;A String&quot;,
                ],
                &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
              },
              &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
              &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                  &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                  &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                },
                &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
              },
              &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                  &quot;A String&quot;,
                ],
                &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
              },
              &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                &quot;numTimeSeries&quot;: 42, # How many time series to output.
                &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
              },
            },
            &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
              &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                  &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                  &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                  &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                    &quot;A String&quot;,
                  ],
                  &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                },
                &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
              },
              &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                  &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                  &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                  &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                    &quot;A String&quot;,
                  ],
                  &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                },
                &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
              },
              &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                  &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                  &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                },
                &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
              },
              &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                  &quot;A String&quot;,
                ],
                &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
              },
              &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                &quot;numTimeSeries&quot;: 42, # How many time series to output.
                &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
              },
            },
            &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
            &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
          },
        },
        &quot;sectionHeader&quot;: { # A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content. # A widget that defines a section header for easier navigation of the dashboard.
          &quot;dividerBelow&quot;: True or False, # Whether to insert a divider below the section in the table of contents
          &quot;subtitle&quot;: &quot;A String&quot;, # The subtitle of the section
        },
        &quot;singleViewGroup&quot;: { # A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets by using a dropdown menu.
        },
        &quot;text&quot;: { # A widget that displays textual content. # A raw string or markdown displaying textual content.
          &quot;content&quot;: &quot;A String&quot;, # The text content to be displayed.
          &quot;format&quot;: &quot;A String&quot;, # How the text content is formatted.
          &quot;style&quot;: { # Properties that determine how the title and content are styled # How the text is styled
            &quot;backgroundColor&quot;: &quot;A String&quot;, # The background color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
            &quot;fontSize&quot;: &quot;A String&quot;, # Font sizes for both the title and content. The title will still be larger relative to the content.
            &quot;horizontalAlignment&quot;: &quot;A String&quot;, # The horizontal alignment of both the title and content
            &quot;padding&quot;: &quot;A String&quot;, # The amount of padding around the widget
            &quot;pointerLocation&quot;: &quot;A String&quot;, # The pointer location for this widget (also sometimes called a &quot;tail&quot;)
            &quot;textColor&quot;: &quot;A String&quot;, # The text color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
            &quot;verticalAlignment&quot;: &quot;A String&quot;, # The vertical alignment of both the title and content
          },
        },
        &quot;timeSeriesTable&quot;: { # A table that displays time series data. # A widget that displays time series data in a tabular format.
          &quot;columnSettings&quot;: [ # Optional. The list of the persistent column settings for the table.
            { # The persistent settings for a table&#x27;s columns.
              &quot;column&quot;: &quot;A String&quot;, # Required. The id of the column.
              &quot;visible&quot;: True or False, # Required. Whether the column should be visible on page load.
            },
          ],
          &quot;dataSets&quot;: [ # Required. The data displayed in this table.
            { # Groups a time series query definition with table options.
              &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
              &quot;tableDisplayOptions&quot;: { # Table display options that can be reused. # Optional. Table display options for configuring how the table is rendered.
                &quot;shownColumns&quot;: [ # Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
                  &quot;A String&quot;,
                ],
              },
              &quot;tableTemplate&quot;: &quot;A String&quot;, # Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value i.e. &quot;${resource.labels.project_id}.&quot;
              &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                  &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                },
                &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                  &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
              },
            },
          ],
          &quot;metricVisualization&quot;: &quot;A String&quot;, # Optional. Store rendering strategy
        },
        &quot;title&quot;: &quot;A String&quot;, # Optional. The title of the widget.
        &quot;xyChart&quot;: { # A chart that displays data on a 2D (X and Y axes) plane. # A chart of time series data.
          &quot;chartOptions&quot;: { # Options to control visual rendering of a chart. # Display options for the chart.
            &quot;displayHorizontal&quot;: True or False, # Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
            &quot;mode&quot;: &quot;A String&quot;, # The chart mode.
          },
          &quot;dataSets&quot;: [ # Required. The data displayed in this chart.
            { # Groups a time series query definition with charting options.
              &quot;breakdowns&quot;: [ # Optional. The collection of breakdowns to be applied to the dataset.
                { # Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
                  &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The Aggregation function is applied across all data in each breakdown created.
                    &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                      { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                        &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                        &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                      },
                    ],
                    &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                  },
                  &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the dataset containing the breakdown values.
                  &quot;limit&quot;: 42, # Required. A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
                  &quot;sortOrder&quot;: &quot;A String&quot;, # Required. The sort order is applied to the values of the breakdown column.
                },
              ],
              &quot;dimensions&quot;: [ # Optional. A collection of dimension columns.
                { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                  &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                  &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                  &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                  &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                  &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                  &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                  &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                },
              ],
              &quot;legendTemplate&quot;: &quot;A String&quot;, # A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value.
              &quot;measures&quot;: [ # Optional. A collection of measures.
                { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                  &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                    &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                      { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                        &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                        &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                      },
                    ],
                    &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                  },
                  &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                },
              ],
              &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
              &quot;plotType&quot;: &quot;A String&quot;, # How this data should be plotted on the chart.
              &quot;targetAxis&quot;: &quot;A String&quot;, # Optional. The target axis to use for plotting the metric.
              &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                  &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                },
                &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                  &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
              },
            },
          ],
          &quot;thresholds&quot;: [ # Threshold lines drawn horizontally across the chart.
            { # Defines a threshold for categorizing time series values.
              &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
              &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
              &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
              &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
              &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
            },
          ],
          &quot;timeshiftDuration&quot;: &quot;A String&quot;, # The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
          &quot;xAxis&quot;: { # A chart axis. # The properties applied to the x-axis.
            &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
            &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
          },
          &quot;y2Axis&quot;: { # A chart axis. # The properties applied to the y2-axis.
            &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
            &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
          },
          &quot;yAxis&quot;: { # A chart axis. # The properties applied to the y-axis.
            &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
            &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
          },
        },
      },
    ],
  },
  &quot;labels&quot;: { # Labels applied to the dashboard
    &quot;a_key&quot;: &quot;A String&quot;,
  },
  &quot;mosaicLayout&quot;: { # A mosaic layout divides the available space into a grid of blocks, and overlays the grid with tiles. Unlike GridLayout, tiles may span multiple grid blocks and can be placed at arbitrary locations in the grid. # The content is arranged as a grid of tiles, with each content widget occupying one or more grid blocks.
    &quot;columns&quot;: 42, # The number of columns in the mosaic grid. The number of columns must be between 1 and 12, inclusive.
    &quot;tiles&quot;: [ # The tiles to display.
      { # A single tile in the mosaic. The placement and size of the tile are configurable.
        &quot;height&quot;: 42, # The height of the tile, measured in grid blocks. Tiles must have a minimum height of 1.
        &quot;widget&quot;: { # Widget contains a single dashboard component and configuration of how to present the component in the dashboard. # The informational widget contained in the tile. For example an XyChart.
          &quot;alertChart&quot;: { # A chart that displays alert policy data. # A chart of alert policy data.
            &quot;name&quot;: &quot;A String&quot;, # Required. The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
          },
          &quot;blank&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # A blank space.
          },
          &quot;collapsibleGroup&quot;: { # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
            &quot;collapsed&quot;: True or False, # The collapsed state of the widget on first page load.
          },
          &quot;errorReportingPanel&quot;: { # A widget that displays a list of error groups. # A widget that displays a list of error groups.
            &quot;projectNames&quot;: [ # The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
              &quot;A String&quot;,
            ],
            &quot;services&quot;: [ # An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
              &quot;A String&quot;,
            ],
            &quot;versions&quot;: [ # Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
              &quot;A String&quot;,
            ],
          },
          &quot;id&quot;: &quot;A String&quot;, # Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
          &quot;incidentList&quot;: { # A widget that displays a list of incidents # A widget that shows list of incidents.
            &quot;monitoredResources&quot;: [ # Optional. The monitored resource for which incidents are listed. The resource doesn&#x27;t need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
              { # An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource&#x27;s schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for &quot;gce_instance&quot; has labels &quot;project_id&quot;, &quot;instance_id&quot; and &quot;zone&quot;: { &quot;type&quot;: &quot;gce_instance&quot;, &quot;labels&quot;: { &quot;project_id&quot;: &quot;my-project&quot;, &quot;instance_id&quot;: &quot;12345678901234&quot;, &quot;zone&quot;: &quot;us-central1-a&quot; }}
                &quot;labels&quot;: { # Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels &quot;project_id&quot;, &quot;instance_id&quot;, and &quot;zone&quot;.
                  &quot;a_key&quot;: &quot;A String&quot;,
                },
                &quot;type&quot;: &quot;A String&quot;, # Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
              },
            ],
            &quot;policyNames&quot;: [ # Optional. A list of alert policy names to filter the incident list by. Don&#x27;t include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
              &quot;A String&quot;,
            ],
          },
          &quot;logsPanel&quot;: { # A widget that displays a stream of log. # A widget that shows a stream of logs.
            &quot;filter&quot;: &quot;A String&quot;, # A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
            &quot;resourceNames&quot;: [ # The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
              &quot;A String&quot;,
            ],
          },
          &quot;pieChart&quot;: { # A widget that displays timeseries data as a pie or a donut. # A widget that displays timeseries data as a pie chart.
            &quot;chartType&quot;: &quot;A String&quot;, # Required. Indicates the visualization type for the PieChart.
            &quot;dataSets&quot;: [ # Required. The queries for the chart&#x27;s data.
              { # Groups a time series query definition.
                &quot;dimensions&quot;: [ # A dimension is a structured label, class, or category for a set of measurements in your data.
                  { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                    &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                    &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                    &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                    &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                    &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                    &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                    &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                    &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                  },
                ],
                &quot;measures&quot;: [ # A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                  { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                    &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                      &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                        { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                          &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                          &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                        },
                      ],
                      &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                    },
                    &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                  },
                ],
                &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                &quot;sliceNameTemplate&quot;: &quot;A String&quot;, # Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone&#x27;s value will be used for the name instead of the default name.
                &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
                  &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                    &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                  },
                  &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                  &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                  &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                    &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                  &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                },
              },
            ],
            &quot;showLabels&quot;: True or False, # Optional. Indicates whether or not the pie chart should show slices&#x27; labels
          },
          &quot;scorecard&quot;: { # A widget showing the latest value of a metric, and how this value relates to one or more thresholds. # A scorecard summarizing time series data.
            &quot;blankView&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
            },
            &quot;dimensions&quot;: [ # Optional. A dimension is a structured label, class, or category for a set of measurements in your data.
              { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
              },
            ],
            &quot;gaugeView&quot;: { # A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard&#x27;s query (inclusive). # Will cause the scorecard to show a gauge chart.
              &quot;lowerBound&quot;: 3.14, # The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
              &quot;upperBound&quot;: 3.14, # The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
            },
            &quot;measures&quot;: [ # Optional. A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
              { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                  &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                    { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                      &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                      &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                    },
                  ],
                  &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                },
                &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
              },
            ],
            &quot;sparkChartView&quot;: { # A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard&#x27;s timeseries. # Will cause the scorecard to show a spark chart.
              &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
              &quot;sparkChartType&quot;: &quot;A String&quot;, # Required. The type of sparkchart to show in this chartView.
            },
            &quot;thresholds&quot;: [ # The thresholds used to determine the state of the scorecard given the time series&#x27; current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: &#x27;DANGER&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 70, category: &#x27;WARNING&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 10, category: &#x27;DANGER&#x27;, trigger: &#x27;BELOW&#x27;, }, { value: 20, category: &#x27;WARNING&#x27;, trigger: &#x27;BELOW&#x27;, } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
              { # Defines a threshold for categorizing time series values.
                &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
              },
            ],
            &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
              &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
              },
              &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
              &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
              &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                  &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                  &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                  &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                    &quot;A String&quot;,
                  ],
                  &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                },
                &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                  &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                  &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                    &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                    &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                  },
                  &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                  &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                },
                &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                  &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                  &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                  &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                    &quot;A String&quot;,
                  ],
                  &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                },
                &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                  &quot;numTimeSeries&quot;: 42, # How many time series to output.
                  &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                },
              },
              &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                },
                &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                },
                &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                  &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                  &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                    &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                    &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                  },
                  &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                  &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                },
                &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                  &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                  &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                  &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                    &quot;A String&quot;,
                  ],
                  &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                },
                &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                  &quot;numTimeSeries&quot;: 42, # How many time series to output.
                  &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                },
              },
              &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
              &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
            },
          },
          &quot;sectionHeader&quot;: { # A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content. # A widget that defines a section header for easier navigation of the dashboard.
            &quot;dividerBelow&quot;: True or False, # Whether to insert a divider below the section in the table of contents
            &quot;subtitle&quot;: &quot;A String&quot;, # The subtitle of the section
          },
          &quot;singleViewGroup&quot;: { # A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets by using a dropdown menu.
          },
          &quot;text&quot;: { # A widget that displays textual content. # A raw string or markdown displaying textual content.
            &quot;content&quot;: &quot;A String&quot;, # The text content to be displayed.
            &quot;format&quot;: &quot;A String&quot;, # How the text content is formatted.
            &quot;style&quot;: { # Properties that determine how the title and content are styled # How the text is styled
              &quot;backgroundColor&quot;: &quot;A String&quot;, # The background color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
              &quot;fontSize&quot;: &quot;A String&quot;, # Font sizes for both the title and content. The title will still be larger relative to the content.
              &quot;horizontalAlignment&quot;: &quot;A String&quot;, # The horizontal alignment of both the title and content
              &quot;padding&quot;: &quot;A String&quot;, # The amount of padding around the widget
              &quot;pointerLocation&quot;: &quot;A String&quot;, # The pointer location for this widget (also sometimes called a &quot;tail&quot;)
              &quot;textColor&quot;: &quot;A String&quot;, # The text color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
              &quot;verticalAlignment&quot;: &quot;A String&quot;, # The vertical alignment of both the title and content
            },
          },
          &quot;timeSeriesTable&quot;: { # A table that displays time series data. # A widget that displays time series data in a tabular format.
            &quot;columnSettings&quot;: [ # Optional. The list of the persistent column settings for the table.
              { # The persistent settings for a table&#x27;s columns.
                &quot;column&quot;: &quot;A String&quot;, # Required. The id of the column.
                &quot;visible&quot;: True or False, # Required. Whether the column should be visible on page load.
              },
            ],
            &quot;dataSets&quot;: [ # Required. The data displayed in this table.
              { # Groups a time series query definition with table options.
                &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                &quot;tableDisplayOptions&quot;: { # Table display options that can be reused. # Optional. Table display options for configuring how the table is rendered.
                  &quot;shownColumns&quot;: [ # Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
                    &quot;A String&quot;,
                  ],
                },
                &quot;tableTemplate&quot;: &quot;A String&quot;, # Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value i.e. &quot;${resource.labels.project_id}.&quot;
                &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                  &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                    &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                  },
                  &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                  &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                  &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                    &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                  &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                },
              },
            ],
            &quot;metricVisualization&quot;: &quot;A String&quot;, # Optional. Store rendering strategy
          },
          &quot;title&quot;: &quot;A String&quot;, # Optional. The title of the widget.
          &quot;xyChart&quot;: { # A chart that displays data on a 2D (X and Y axes) plane. # A chart of time series data.
            &quot;chartOptions&quot;: { # Options to control visual rendering of a chart. # Display options for the chart.
              &quot;displayHorizontal&quot;: True or False, # Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
              &quot;mode&quot;: &quot;A String&quot;, # The chart mode.
            },
            &quot;dataSets&quot;: [ # Required. The data displayed in this chart.
              { # Groups a time series query definition with charting options.
                &quot;breakdowns&quot;: [ # Optional. The collection of breakdowns to be applied to the dataset.
                  { # Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
                    &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The Aggregation function is applied across all data in each breakdown created.
                      &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                        { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                          &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                          &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                        },
                      ],
                      &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                    },
                    &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the dataset containing the breakdown values.
                    &quot;limit&quot;: 42, # Required. A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
                    &quot;sortOrder&quot;: &quot;A String&quot;, # Required. The sort order is applied to the values of the breakdown column.
                  },
                ],
                &quot;dimensions&quot;: [ # Optional. A collection of dimension columns.
                  { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                    &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                    &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                    &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                    &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                    &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                    &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                    &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                    &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                  },
                ],
                &quot;legendTemplate&quot;: &quot;A String&quot;, # A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value.
                &quot;measures&quot;: [ # Optional. A collection of measures.
                  { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                    &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                      &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                        { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                          &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                          &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                        },
                      ],
                      &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                    },
                    &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                  },
                ],
                &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                &quot;plotType&quot;: &quot;A String&quot;, # How this data should be plotted on the chart.
                &quot;targetAxis&quot;: &quot;A String&quot;, # Optional. The target axis to use for plotting the metric.
                &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                  &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                    &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                  },
                  &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                  &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                  &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                    &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                  &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                },
              },
            ],
            &quot;thresholds&quot;: [ # Threshold lines drawn horizontally across the chart.
              { # Defines a threshold for categorizing time series values.
                &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
              },
            ],
            &quot;timeshiftDuration&quot;: &quot;A String&quot;, # The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
            &quot;xAxis&quot;: { # A chart axis. # The properties applied to the x-axis.
              &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
              &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
            },
            &quot;y2Axis&quot;: { # A chart axis. # The properties applied to the y2-axis.
              &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
              &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
            },
            &quot;yAxis&quot;: { # A chart axis. # The properties applied to the y-axis.
              &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
              &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
            },
          },
        },
        &quot;width&quot;: 42, # The width of the tile, measured in grid blocks. Tiles must have a minimum width of 1.
        &quot;xPos&quot;: 42, # The zero-indexed position of the tile in grid blocks relative to the left edge of the grid. Tiles must be contained within the specified number of columns. x_pos cannot be negative.
        &quot;yPos&quot;: 42, # The zero-indexed position of the tile in grid blocks relative to the top edge of the grid. y_pos cannot be negative.
      },
    ],
  },
  &quot;name&quot;: &quot;A String&quot;, # Identifier. The resource name of the dashboard.
  &quot;rowLayout&quot;: { # A simplified layout that divides the available space into rows and arranges a set of widgets horizontally in each row. # The content is divided into equally spaced rows and the widgets are arranged horizontally.
    &quot;rows&quot;: [ # The rows of content to display.
      { # Defines the layout properties and content for a row.
        &quot;weight&quot;: &quot;A String&quot;, # The relative weight of this row. The row weight is used to adjust the height of rows on the screen (relative to peers). Greater the weight, greater the height of the row on the screen. If omitted, a value of 1 is used while rendering.
        &quot;widgets&quot;: [ # The display widgets arranged horizontally in this row.
          { # Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
            &quot;alertChart&quot;: { # A chart that displays alert policy data. # A chart of alert policy data.
              &quot;name&quot;: &quot;A String&quot;, # Required. The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
            },
            &quot;blank&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # A blank space.
            },
            &quot;collapsibleGroup&quot;: { # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
              &quot;collapsed&quot;: True or False, # The collapsed state of the widget on first page load.
            },
            &quot;errorReportingPanel&quot;: { # A widget that displays a list of error groups. # A widget that displays a list of error groups.
              &quot;projectNames&quot;: [ # The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
                &quot;A String&quot;,
              ],
              &quot;services&quot;: [ # An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
                &quot;A String&quot;,
              ],
              &quot;versions&quot;: [ # Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
                &quot;A String&quot;,
              ],
            },
            &quot;id&quot;: &quot;A String&quot;, # Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
            &quot;incidentList&quot;: { # A widget that displays a list of incidents # A widget that shows list of incidents.
              &quot;monitoredResources&quot;: [ # Optional. The monitored resource for which incidents are listed. The resource doesn&#x27;t need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
                { # An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource&#x27;s schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for &quot;gce_instance&quot; has labels &quot;project_id&quot;, &quot;instance_id&quot; and &quot;zone&quot;: { &quot;type&quot;: &quot;gce_instance&quot;, &quot;labels&quot;: { &quot;project_id&quot;: &quot;my-project&quot;, &quot;instance_id&quot;: &quot;12345678901234&quot;, &quot;zone&quot;: &quot;us-central1-a&quot; }}
                  &quot;labels&quot;: { # Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels &quot;project_id&quot;, &quot;instance_id&quot;, and &quot;zone&quot;.
                    &quot;a_key&quot;: &quot;A String&quot;,
                  },
                  &quot;type&quot;: &quot;A String&quot;, # Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
                },
              ],
              &quot;policyNames&quot;: [ # Optional. A list of alert policy names to filter the incident list by. Don&#x27;t include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
                &quot;A String&quot;,
              ],
            },
            &quot;logsPanel&quot;: { # A widget that displays a stream of log. # A widget that shows a stream of logs.
              &quot;filter&quot;: &quot;A String&quot;, # A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
              &quot;resourceNames&quot;: [ # The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
                &quot;A String&quot;,
              ],
            },
            &quot;pieChart&quot;: { # A widget that displays timeseries data as a pie or a donut. # A widget that displays timeseries data as a pie chart.
              &quot;chartType&quot;: &quot;A String&quot;, # Required. Indicates the visualization type for the PieChart.
              &quot;dataSets&quot;: [ # Required. The queries for the chart&#x27;s data.
                { # Groups a time series query definition.
                  &quot;dimensions&quot;: [ # A dimension is a structured label, class, or category for a set of measurements in your data.
                    { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                      &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                      &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                      &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                      &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                      &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                      &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                    },
                  ],
                  &quot;measures&quot;: [ # A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                    { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                    },
                  ],
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;sliceNameTemplate&quot;: &quot;A String&quot;, # Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone&#x27;s value will be used for the name instead of the default name.
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;showLabels&quot;: True or False, # Optional. Indicates whether or not the pie chart should show slices&#x27; labels
            },
            &quot;scorecard&quot;: { # A widget showing the latest value of a metric, and how this value relates to one or more thresholds. # A scorecard summarizing time series data.
              &quot;blankView&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
              },
              &quot;dimensions&quot;: [ # Optional. A dimension is a structured label, class, or category for a set of measurements in your data.
                { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                  &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                  &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                  &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                  &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                  &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                  &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                  &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                },
              ],
              &quot;gaugeView&quot;: { # A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard&#x27;s query (inclusive). # Will cause the scorecard to show a gauge chart.
                &quot;lowerBound&quot;: 3.14, # The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
                &quot;upperBound&quot;: 3.14, # The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
              },
              &quot;measures&quot;: [ # Optional. A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                  &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                    &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                      { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                        &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                        &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                      },
                    ],
                    &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                  },
                  &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                },
              ],
              &quot;sparkChartView&quot;: { # A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard&#x27;s timeseries. # Will cause the scorecard to show a spark chart.
                &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
                &quot;sparkChartType&quot;: &quot;A String&quot;, # Required. The type of sparkchart to show in this chartView.
              },
              &quot;thresholds&quot;: [ # The thresholds used to determine the state of the scorecard given the time series&#x27; current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: &#x27;DANGER&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 70, category: &#x27;WARNING&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 10, category: &#x27;DANGER&#x27;, trigger: &#x27;BELOW&#x27;, }, { value: 20, category: &#x27;WARNING&#x27;, trigger: &#x27;BELOW&#x27;, } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
                { # Defines a threshold for categorizing time series values.
                  &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                  &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                  &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                  &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                },
              ],
              &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                  &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                },
                &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                  &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
              },
            },
            &quot;sectionHeader&quot;: { # A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content. # A widget that defines a section header for easier navigation of the dashboard.
              &quot;dividerBelow&quot;: True or False, # Whether to insert a divider below the section in the table of contents
              &quot;subtitle&quot;: &quot;A String&quot;, # The subtitle of the section
            },
            &quot;singleViewGroup&quot;: { # A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets by using a dropdown menu.
            },
            &quot;text&quot;: { # A widget that displays textual content. # A raw string or markdown displaying textual content.
              &quot;content&quot;: &quot;A String&quot;, # The text content to be displayed.
              &quot;format&quot;: &quot;A String&quot;, # How the text content is formatted.
              &quot;style&quot;: { # Properties that determine how the title and content are styled # How the text is styled
                &quot;backgroundColor&quot;: &quot;A String&quot;, # The background color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                &quot;fontSize&quot;: &quot;A String&quot;, # Font sizes for both the title and content. The title will still be larger relative to the content.
                &quot;horizontalAlignment&quot;: &quot;A String&quot;, # The horizontal alignment of both the title and content
                &quot;padding&quot;: &quot;A String&quot;, # The amount of padding around the widget
                &quot;pointerLocation&quot;: &quot;A String&quot;, # The pointer location for this widget (also sometimes called a &quot;tail&quot;)
                &quot;textColor&quot;: &quot;A String&quot;, # The text color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                &quot;verticalAlignment&quot;: &quot;A String&quot;, # The vertical alignment of both the title and content
              },
            },
            &quot;timeSeriesTable&quot;: { # A table that displays time series data. # A widget that displays time series data in a tabular format.
              &quot;columnSettings&quot;: [ # Optional. The list of the persistent column settings for the table.
                { # The persistent settings for a table&#x27;s columns.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The id of the column.
                  &quot;visible&quot;: True or False, # Required. Whether the column should be visible on page load.
                },
              ],
              &quot;dataSets&quot;: [ # Required. The data displayed in this table.
                { # Groups a time series query definition with table options.
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;tableDisplayOptions&quot;: { # Table display options that can be reused. # Optional. Table display options for configuring how the table is rendered.
                    &quot;shownColumns&quot;: [ # Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
                      &quot;A String&quot;,
                    ],
                  },
                  &quot;tableTemplate&quot;: &quot;A String&quot;, # Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value i.e. &quot;${resource.labels.project_id}.&quot;
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;metricVisualization&quot;: &quot;A String&quot;, # Optional. Store rendering strategy
            },
            &quot;title&quot;: &quot;A String&quot;, # Optional. The title of the widget.
            &quot;xyChart&quot;: { # A chart that displays data on a 2D (X and Y axes) plane. # A chart of time series data.
              &quot;chartOptions&quot;: { # Options to control visual rendering of a chart. # Display options for the chart.
                &quot;displayHorizontal&quot;: True or False, # Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
                &quot;mode&quot;: &quot;A String&quot;, # The chart mode.
              },
              &quot;dataSets&quot;: [ # Required. The data displayed in this chart.
                { # Groups a time series query definition with charting options.
                  &quot;breakdowns&quot;: [ # Optional. The collection of breakdowns to be applied to the dataset.
                    { # Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The Aggregation function is applied across all data in each breakdown created.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the dataset containing the breakdown values.
                      &quot;limit&quot;: 42, # Required. A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # Required. The sort order is applied to the values of the breakdown column.
                    },
                  ],
                  &quot;dimensions&quot;: [ # Optional. A collection of dimension columns.
                    { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                      &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                      &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                      &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                      &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                      &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                      &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                    },
                  ],
                  &quot;legendTemplate&quot;: &quot;A String&quot;, # A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value.
                  &quot;measures&quot;: [ # Optional. A collection of measures.
                    { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                    },
                  ],
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;plotType&quot;: &quot;A String&quot;, # How this data should be plotted on the chart.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # Optional. The target axis to use for plotting the metric.
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;thresholds&quot;: [ # Threshold lines drawn horizontally across the chart.
                { # Defines a threshold for categorizing time series values.
                  &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                  &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                  &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                  &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                },
              ],
              &quot;timeshiftDuration&quot;: &quot;A String&quot;, # The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
              &quot;xAxis&quot;: { # A chart axis. # The properties applied to the x-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
              &quot;y2Axis&quot;: { # A chart axis. # The properties applied to the y2-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
              &quot;yAxis&quot;: { # A chart axis. # The properties applied to the y-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
            },
          },
        ],
      },
    ],
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="delete">delete(name, x__xgafv=None)</code>
  <pre>Deletes an existing custom dashboard.This method requires the monitoring.dashboards.delete permission on the specified dashboard. For more information, see Cloud Identity and Access Management (https://cloud.google.com/iam).

Args:
  name: string, Required. The resource name of the Dashboard. The format is: projects/[PROJECT_ID_OR_NUMBER]/dashboards/[DASHBOARD_ID]  (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
}</pre>
</div>

<div class="method">
    <code class="details" id="get">get(name, x__xgafv=None)</code>
  <pre>Fetches a specific dashboard.This method requires the monitoring.dashboards.get permission on the specified dashboard. For more information, see Cloud Identity and Access Management (https://cloud.google.com/iam).

Args:
  name: string, Required. The resource name of the Dashboard. The format is one of: dashboards/[DASHBOARD_ID] (for system dashboards) projects/[PROJECT_ID_OR_NUMBER]/dashboards/[DASHBOARD_ID] (for custom dashboards). (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A Google Stackdriver dashboard. Dashboards define the content and layout of pages in the Stackdriver web application.
  &quot;annotations&quot;: { # Dashboard-level configuration for annotations # Configuration for event annotations to display on this dashboard.
    &quot;defaultResourceNames&quot;: [ # Dashboard level defaults for names of logging resources to search for events. Currently only projects are supported. Each individual EventAnnotation may have its own overrides. If both this field and the per annotation field is empty, then the scoping project is used. Limit: 50 projects. For example: “projects/some-project-id”
      &quot;A String&quot;,
    ],
    &quot;eventAnnotations&quot;: [ # List of annotation configurations for this dashboard. Each entry specifies one event type.
      { # Annotation configuration for one event type on a dashboard
        &quot;displayName&quot;: &quot;A String&quot;, # Solely for UI display. Should not be used programmatically.
        &quot;enabled&quot;: True or False, # Whether or not to show the events on the dashboard by default
        &quot;eventType&quot;: &quot;A String&quot;, # The type of event to display.
        &quot;filter&quot;: &quot;A String&quot;, # string filtering the events - event dependant. Example values: &quot;resource.labels.pod_name = &#x27;pod-1&#x27;&quot; &quot;protoPayload.authenticationInfo.principalEmail=&#x27;user@example.com&#x27;&quot;
        &quot;resourceNames&quot;: [ # Per annotation level override for the names of logging resources to search for events. Currently only projects are supported. If both this field and the per annotation field is empty, it will default to the host project. Limit: 50 projects. For example: “projects/another-project-id”
          &quot;A String&quot;,
        ],
      },
    ],
  },
  &quot;columnLayout&quot;: { # A simplified layout that divides the available space into vertical columns and arranges a set of widgets vertically in each column. # The content is divided into equally spaced columns and the widgets are arranged vertically.
    &quot;columns&quot;: [ # The columns of content to display.
      { # Defines the layout properties and content for a column.
        &quot;weight&quot;: &quot;A String&quot;, # The relative weight of this column. The column weight is used to adjust the width of columns on the screen (relative to peers). Greater the weight, greater the width of the column on the screen. If omitted, a value of 1 is used while rendering.
        &quot;widgets&quot;: [ # The display widgets arranged vertically in this column.
          { # Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
            &quot;alertChart&quot;: { # A chart that displays alert policy data. # A chart of alert policy data.
              &quot;name&quot;: &quot;A String&quot;, # Required. The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
            },
            &quot;blank&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # A blank space.
            },
            &quot;collapsibleGroup&quot;: { # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
              &quot;collapsed&quot;: True or False, # The collapsed state of the widget on first page load.
            },
            &quot;errorReportingPanel&quot;: { # A widget that displays a list of error groups. # A widget that displays a list of error groups.
              &quot;projectNames&quot;: [ # The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
                &quot;A String&quot;,
              ],
              &quot;services&quot;: [ # An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
                &quot;A String&quot;,
              ],
              &quot;versions&quot;: [ # Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
                &quot;A String&quot;,
              ],
            },
            &quot;id&quot;: &quot;A String&quot;, # Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
            &quot;incidentList&quot;: { # A widget that displays a list of incidents # A widget that shows list of incidents.
              &quot;monitoredResources&quot;: [ # Optional. The monitored resource for which incidents are listed. The resource doesn&#x27;t need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
                { # An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource&#x27;s schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for &quot;gce_instance&quot; has labels &quot;project_id&quot;, &quot;instance_id&quot; and &quot;zone&quot;: { &quot;type&quot;: &quot;gce_instance&quot;, &quot;labels&quot;: { &quot;project_id&quot;: &quot;my-project&quot;, &quot;instance_id&quot;: &quot;12345678901234&quot;, &quot;zone&quot;: &quot;us-central1-a&quot; }}
                  &quot;labels&quot;: { # Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels &quot;project_id&quot;, &quot;instance_id&quot;, and &quot;zone&quot;.
                    &quot;a_key&quot;: &quot;A String&quot;,
                  },
                  &quot;type&quot;: &quot;A String&quot;, # Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
                },
              ],
              &quot;policyNames&quot;: [ # Optional. A list of alert policy names to filter the incident list by. Don&#x27;t include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
                &quot;A String&quot;,
              ],
            },
            &quot;logsPanel&quot;: { # A widget that displays a stream of log. # A widget that shows a stream of logs.
              &quot;filter&quot;: &quot;A String&quot;, # A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
              &quot;resourceNames&quot;: [ # The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
                &quot;A String&quot;,
              ],
            },
            &quot;pieChart&quot;: { # A widget that displays timeseries data as a pie or a donut. # A widget that displays timeseries data as a pie chart.
              &quot;chartType&quot;: &quot;A String&quot;, # Required. Indicates the visualization type for the PieChart.
              &quot;dataSets&quot;: [ # Required. The queries for the chart&#x27;s data.
                { # Groups a time series query definition.
                  &quot;dimensions&quot;: [ # A dimension is a structured label, class, or category for a set of measurements in your data.
                    { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                      &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                      &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                      &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                      &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                      &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                      &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                    },
                  ],
                  &quot;measures&quot;: [ # A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                    { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                    },
                  ],
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;sliceNameTemplate&quot;: &quot;A String&quot;, # Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone&#x27;s value will be used for the name instead of the default name.
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;showLabels&quot;: True or False, # Optional. Indicates whether or not the pie chart should show slices&#x27; labels
            },
            &quot;scorecard&quot;: { # A widget showing the latest value of a metric, and how this value relates to one or more thresholds. # A scorecard summarizing time series data.
              &quot;blankView&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
              },
              &quot;dimensions&quot;: [ # Optional. A dimension is a structured label, class, or category for a set of measurements in your data.
                { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                  &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                  &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                  &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                  &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                  &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                  &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                  &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                },
              ],
              &quot;gaugeView&quot;: { # A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard&#x27;s query (inclusive). # Will cause the scorecard to show a gauge chart.
                &quot;lowerBound&quot;: 3.14, # The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
                &quot;upperBound&quot;: 3.14, # The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
              },
              &quot;measures&quot;: [ # Optional. A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                  &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                    &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                      { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                        &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                        &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                      },
                    ],
                    &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                  },
                  &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                },
              ],
              &quot;sparkChartView&quot;: { # A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard&#x27;s timeseries. # Will cause the scorecard to show a spark chart.
                &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
                &quot;sparkChartType&quot;: &quot;A String&quot;, # Required. The type of sparkchart to show in this chartView.
              },
              &quot;thresholds&quot;: [ # The thresholds used to determine the state of the scorecard given the time series&#x27; current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: &#x27;DANGER&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 70, category: &#x27;WARNING&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 10, category: &#x27;DANGER&#x27;, trigger: &#x27;BELOW&#x27;, }, { value: 20, category: &#x27;WARNING&#x27;, trigger: &#x27;BELOW&#x27;, } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
                { # Defines a threshold for categorizing time series values.
                  &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                  &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                  &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                  &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                },
              ],
              &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                  &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                },
                &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                  &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
              },
            },
            &quot;sectionHeader&quot;: { # A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content. # A widget that defines a section header for easier navigation of the dashboard.
              &quot;dividerBelow&quot;: True or False, # Whether to insert a divider below the section in the table of contents
              &quot;subtitle&quot;: &quot;A String&quot;, # The subtitle of the section
            },
            &quot;singleViewGroup&quot;: { # A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets by using a dropdown menu.
            },
            &quot;text&quot;: { # A widget that displays textual content. # A raw string or markdown displaying textual content.
              &quot;content&quot;: &quot;A String&quot;, # The text content to be displayed.
              &quot;format&quot;: &quot;A String&quot;, # How the text content is formatted.
              &quot;style&quot;: { # Properties that determine how the title and content are styled # How the text is styled
                &quot;backgroundColor&quot;: &quot;A String&quot;, # The background color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                &quot;fontSize&quot;: &quot;A String&quot;, # Font sizes for both the title and content. The title will still be larger relative to the content.
                &quot;horizontalAlignment&quot;: &quot;A String&quot;, # The horizontal alignment of both the title and content
                &quot;padding&quot;: &quot;A String&quot;, # The amount of padding around the widget
                &quot;pointerLocation&quot;: &quot;A String&quot;, # The pointer location for this widget (also sometimes called a &quot;tail&quot;)
                &quot;textColor&quot;: &quot;A String&quot;, # The text color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                &quot;verticalAlignment&quot;: &quot;A String&quot;, # The vertical alignment of both the title and content
              },
            },
            &quot;timeSeriesTable&quot;: { # A table that displays time series data. # A widget that displays time series data in a tabular format.
              &quot;columnSettings&quot;: [ # Optional. The list of the persistent column settings for the table.
                { # The persistent settings for a table&#x27;s columns.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The id of the column.
                  &quot;visible&quot;: True or False, # Required. Whether the column should be visible on page load.
                },
              ],
              &quot;dataSets&quot;: [ # Required. The data displayed in this table.
                { # Groups a time series query definition with table options.
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;tableDisplayOptions&quot;: { # Table display options that can be reused. # Optional. Table display options for configuring how the table is rendered.
                    &quot;shownColumns&quot;: [ # Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
                      &quot;A String&quot;,
                    ],
                  },
                  &quot;tableTemplate&quot;: &quot;A String&quot;, # Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value i.e. &quot;${resource.labels.project_id}.&quot;
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;metricVisualization&quot;: &quot;A String&quot;, # Optional. Store rendering strategy
            },
            &quot;title&quot;: &quot;A String&quot;, # Optional. The title of the widget.
            &quot;xyChart&quot;: { # A chart that displays data on a 2D (X and Y axes) plane. # A chart of time series data.
              &quot;chartOptions&quot;: { # Options to control visual rendering of a chart. # Display options for the chart.
                &quot;displayHorizontal&quot;: True or False, # Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
                &quot;mode&quot;: &quot;A String&quot;, # The chart mode.
              },
              &quot;dataSets&quot;: [ # Required. The data displayed in this chart.
                { # Groups a time series query definition with charting options.
                  &quot;breakdowns&quot;: [ # Optional. The collection of breakdowns to be applied to the dataset.
                    { # Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The Aggregation function is applied across all data in each breakdown created.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the dataset containing the breakdown values.
                      &quot;limit&quot;: 42, # Required. A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # Required. The sort order is applied to the values of the breakdown column.
                    },
                  ],
                  &quot;dimensions&quot;: [ # Optional. A collection of dimension columns.
                    { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                      &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                      &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                      &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                      &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                      &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                      &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                    },
                  ],
                  &quot;legendTemplate&quot;: &quot;A String&quot;, # A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value.
                  &quot;measures&quot;: [ # Optional. A collection of measures.
                    { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                    },
                  ],
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;plotType&quot;: &quot;A String&quot;, # How this data should be plotted on the chart.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # Optional. The target axis to use for plotting the metric.
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;thresholds&quot;: [ # Threshold lines drawn horizontally across the chart.
                { # Defines a threshold for categorizing time series values.
                  &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                  &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                  &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                  &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                },
              ],
              &quot;timeshiftDuration&quot;: &quot;A String&quot;, # The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
              &quot;xAxis&quot;: { # A chart axis. # The properties applied to the x-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
              &quot;y2Axis&quot;: { # A chart axis. # The properties applied to the y2-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
              &quot;yAxis&quot;: { # A chart axis. # The properties applied to the y-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
            },
          },
        ],
      },
    ],
  },
  &quot;dashboardFilters&quot;: [ # Filters to reduce the amount of data charted based on the filter criteria.
    { # A filter to reduce the amount of data charted in relevant widgets.
      &quot;filterType&quot;: &quot;A String&quot;, # The specified filter type
      &quot;labelKey&quot;: &quot;A String&quot;, # Required. The key for the label
      &quot;stringValue&quot;: &quot;A String&quot;, # A variable-length string value.
      &quot;templateVariable&quot;: &quot;A String&quot;, # The placeholder text that can be referenced in a filter string or MQL query. If omitted, the dashboard filter will be applied to all relevant widgets in the dashboard.
    },
  ],
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The mutable, human-readable name.
  &quot;etag&quot;: &quot;A String&quot;, # etag is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. An etag is returned in the response to GetDashboard, and users are expected to put that etag in the request to UpdateDashboard to ensure that their change will be applied to the same version of the Dashboard configuration. The field should not be passed during dashboard creation.
  &quot;gridLayout&quot;: { # A basic layout divides the available space into vertical columns of equal width and arranges a list of widgets using a row-first strategy. # Content is arranged with a basic layout that re-flows a simple list of informational elements like widgets or tiles.
    &quot;columns&quot;: &quot;A String&quot;, # The number of columns into which the view&#x27;s width is divided. If omitted or set to zero, a system default will be used while rendering.
    &quot;widgets&quot;: [ # The informational elements that are arranged into the columns row-first.
      { # Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
        &quot;alertChart&quot;: { # A chart that displays alert policy data. # A chart of alert policy data.
          &quot;name&quot;: &quot;A String&quot;, # Required. The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
        },
        &quot;blank&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # A blank space.
        },
        &quot;collapsibleGroup&quot;: { # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
          &quot;collapsed&quot;: True or False, # The collapsed state of the widget on first page load.
        },
        &quot;errorReportingPanel&quot;: { # A widget that displays a list of error groups. # A widget that displays a list of error groups.
          &quot;projectNames&quot;: [ # The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
            &quot;A String&quot;,
          ],
          &quot;services&quot;: [ # An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
            &quot;A String&quot;,
          ],
          &quot;versions&quot;: [ # Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
            &quot;A String&quot;,
          ],
        },
        &quot;id&quot;: &quot;A String&quot;, # Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
        &quot;incidentList&quot;: { # A widget that displays a list of incidents # A widget that shows list of incidents.
          &quot;monitoredResources&quot;: [ # Optional. The monitored resource for which incidents are listed. The resource doesn&#x27;t need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
            { # An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource&#x27;s schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for &quot;gce_instance&quot; has labels &quot;project_id&quot;, &quot;instance_id&quot; and &quot;zone&quot;: { &quot;type&quot;: &quot;gce_instance&quot;, &quot;labels&quot;: { &quot;project_id&quot;: &quot;my-project&quot;, &quot;instance_id&quot;: &quot;12345678901234&quot;, &quot;zone&quot;: &quot;us-central1-a&quot; }}
              &quot;labels&quot;: { # Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels &quot;project_id&quot;, &quot;instance_id&quot;, and &quot;zone&quot;.
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;type&quot;: &quot;A String&quot;, # Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
            },
          ],
          &quot;policyNames&quot;: [ # Optional. A list of alert policy names to filter the incident list by. Don&#x27;t include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
            &quot;A String&quot;,
          ],
        },
        &quot;logsPanel&quot;: { # A widget that displays a stream of log. # A widget that shows a stream of logs.
          &quot;filter&quot;: &quot;A String&quot;, # A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
          &quot;resourceNames&quot;: [ # The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
            &quot;A String&quot;,
          ],
        },
        &quot;pieChart&quot;: { # A widget that displays timeseries data as a pie or a donut. # A widget that displays timeseries data as a pie chart.
          &quot;chartType&quot;: &quot;A String&quot;, # Required. Indicates the visualization type for the PieChart.
          &quot;dataSets&quot;: [ # Required. The queries for the chart&#x27;s data.
            { # Groups a time series query definition.
              &quot;dimensions&quot;: [ # A dimension is a structured label, class, or category for a set of measurements in your data.
                { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                  &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                  &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                  &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                  &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                  &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                  &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                  &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                },
              ],
              &quot;measures&quot;: [ # A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                  &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                    &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                      { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                        &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                        &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                      },
                    ],
                    &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                  },
                  &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                },
              ],
              &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
              &quot;sliceNameTemplate&quot;: &quot;A String&quot;, # Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone&#x27;s value will be used for the name instead of the default name.
              &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
                &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                  &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                },
                &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                  &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
              },
            },
          ],
          &quot;showLabels&quot;: True or False, # Optional. Indicates whether or not the pie chart should show slices&#x27; labels
        },
        &quot;scorecard&quot;: { # A widget showing the latest value of a metric, and how this value relates to one or more thresholds. # A scorecard summarizing time series data.
          &quot;blankView&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
          },
          &quot;dimensions&quot;: [ # Optional. A dimension is a structured label, class, or category for a set of measurements in your data.
            { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
              &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
              &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
              &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
              &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
              &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
              &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
              &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
              &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
            },
          ],
          &quot;gaugeView&quot;: { # A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard&#x27;s query (inclusive). # Will cause the scorecard to show a gauge chart.
            &quot;lowerBound&quot;: 3.14, # The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
            &quot;upperBound&quot;: 3.14, # The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
          },
          &quot;measures&quot;: [ # Optional. A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
            { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
              &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                  { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                    &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                    &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                  },
                ],
                &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
              },
              &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
            },
          ],
          &quot;sparkChartView&quot;: { # A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard&#x27;s timeseries. # Will cause the scorecard to show a spark chart.
            &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
            &quot;sparkChartType&quot;: &quot;A String&quot;, # Required. The type of sparkchart to show in this chartView.
          },
          &quot;thresholds&quot;: [ # The thresholds used to determine the state of the scorecard given the time series&#x27; current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: &#x27;DANGER&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 70, category: &#x27;WARNING&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 10, category: &#x27;DANGER&#x27;, trigger: &#x27;BELOW&#x27;, }, { value: 20, category: &#x27;WARNING&#x27;, trigger: &#x27;BELOW&#x27;, } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
            { # Defines a threshold for categorizing time series values.
              &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
              &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
              &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
              &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
              &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
            },
          ],
          &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
            &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
              &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
            },
            &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
            &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
            &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
              &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                  &quot;A String&quot;,
                ],
                &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
              },
              &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
              &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                  &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                  &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                },
                &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
              },
              &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                  &quot;A String&quot;,
                ],
                &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
              },
              &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                &quot;numTimeSeries&quot;: 42, # How many time series to output.
                &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
              },
            },
            &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
              &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                  &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                  &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                  &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                    &quot;A String&quot;,
                  ],
                  &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                },
                &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
              },
              &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                  &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                  &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                  &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                    &quot;A String&quot;,
                  ],
                  &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                },
                &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
              },
              &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                  &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                  &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                },
                &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
              },
              &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                  &quot;A String&quot;,
                ],
                &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
              },
              &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                &quot;numTimeSeries&quot;: 42, # How many time series to output.
                &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
              },
            },
            &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
            &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
          },
        },
        &quot;sectionHeader&quot;: { # A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content. # A widget that defines a section header for easier navigation of the dashboard.
          &quot;dividerBelow&quot;: True or False, # Whether to insert a divider below the section in the table of contents
          &quot;subtitle&quot;: &quot;A String&quot;, # The subtitle of the section
        },
        &quot;singleViewGroup&quot;: { # A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets by using a dropdown menu.
        },
        &quot;text&quot;: { # A widget that displays textual content. # A raw string or markdown displaying textual content.
          &quot;content&quot;: &quot;A String&quot;, # The text content to be displayed.
          &quot;format&quot;: &quot;A String&quot;, # How the text content is formatted.
          &quot;style&quot;: { # Properties that determine how the title and content are styled # How the text is styled
            &quot;backgroundColor&quot;: &quot;A String&quot;, # The background color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
            &quot;fontSize&quot;: &quot;A String&quot;, # Font sizes for both the title and content. The title will still be larger relative to the content.
            &quot;horizontalAlignment&quot;: &quot;A String&quot;, # The horizontal alignment of both the title and content
            &quot;padding&quot;: &quot;A String&quot;, # The amount of padding around the widget
            &quot;pointerLocation&quot;: &quot;A String&quot;, # The pointer location for this widget (also sometimes called a &quot;tail&quot;)
            &quot;textColor&quot;: &quot;A String&quot;, # The text color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
            &quot;verticalAlignment&quot;: &quot;A String&quot;, # The vertical alignment of both the title and content
          },
        },
        &quot;timeSeriesTable&quot;: { # A table that displays time series data. # A widget that displays time series data in a tabular format.
          &quot;columnSettings&quot;: [ # Optional. The list of the persistent column settings for the table.
            { # The persistent settings for a table&#x27;s columns.
              &quot;column&quot;: &quot;A String&quot;, # Required. The id of the column.
              &quot;visible&quot;: True or False, # Required. Whether the column should be visible on page load.
            },
          ],
          &quot;dataSets&quot;: [ # Required. The data displayed in this table.
            { # Groups a time series query definition with table options.
              &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
              &quot;tableDisplayOptions&quot;: { # Table display options that can be reused. # Optional. Table display options for configuring how the table is rendered.
                &quot;shownColumns&quot;: [ # Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
                  &quot;A String&quot;,
                ],
              },
              &quot;tableTemplate&quot;: &quot;A String&quot;, # Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value i.e. &quot;${resource.labels.project_id}.&quot;
              &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                  &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                },
                &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                  &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
              },
            },
          ],
          &quot;metricVisualization&quot;: &quot;A String&quot;, # Optional. Store rendering strategy
        },
        &quot;title&quot;: &quot;A String&quot;, # Optional. The title of the widget.
        &quot;xyChart&quot;: { # A chart that displays data on a 2D (X and Y axes) plane. # A chart of time series data.
          &quot;chartOptions&quot;: { # Options to control visual rendering of a chart. # Display options for the chart.
            &quot;displayHorizontal&quot;: True or False, # Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
            &quot;mode&quot;: &quot;A String&quot;, # The chart mode.
          },
          &quot;dataSets&quot;: [ # Required. The data displayed in this chart.
            { # Groups a time series query definition with charting options.
              &quot;breakdowns&quot;: [ # Optional. The collection of breakdowns to be applied to the dataset.
                { # Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
                  &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The Aggregation function is applied across all data in each breakdown created.
                    &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                      { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                        &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                        &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                      },
                    ],
                    &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                  },
                  &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the dataset containing the breakdown values.
                  &quot;limit&quot;: 42, # Required. A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
                  &quot;sortOrder&quot;: &quot;A String&quot;, # Required. The sort order is applied to the values of the breakdown column.
                },
              ],
              &quot;dimensions&quot;: [ # Optional. A collection of dimension columns.
                { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                  &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                  &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                  &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                  &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                  &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                  &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                  &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                },
              ],
              &quot;legendTemplate&quot;: &quot;A String&quot;, # A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value.
              &quot;measures&quot;: [ # Optional. A collection of measures.
                { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                  &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                    &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                      { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                        &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                        &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                      },
                    ],
                    &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                  },
                  &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                },
              ],
              &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
              &quot;plotType&quot;: &quot;A String&quot;, # How this data should be plotted on the chart.
              &quot;targetAxis&quot;: &quot;A String&quot;, # Optional. The target axis to use for plotting the metric.
              &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                  &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                },
                &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                  &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
              },
            },
          ],
          &quot;thresholds&quot;: [ # Threshold lines drawn horizontally across the chart.
            { # Defines a threshold for categorizing time series values.
              &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
              &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
              &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
              &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
              &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
            },
          ],
          &quot;timeshiftDuration&quot;: &quot;A String&quot;, # The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
          &quot;xAxis&quot;: { # A chart axis. # The properties applied to the x-axis.
            &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
            &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
          },
          &quot;y2Axis&quot;: { # A chart axis. # The properties applied to the y2-axis.
            &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
            &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
          },
          &quot;yAxis&quot;: { # A chart axis. # The properties applied to the y-axis.
            &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
            &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
          },
        },
      },
    ],
  },
  &quot;labels&quot;: { # Labels applied to the dashboard
    &quot;a_key&quot;: &quot;A String&quot;,
  },
  &quot;mosaicLayout&quot;: { # A mosaic layout divides the available space into a grid of blocks, and overlays the grid with tiles. Unlike GridLayout, tiles may span multiple grid blocks and can be placed at arbitrary locations in the grid. # The content is arranged as a grid of tiles, with each content widget occupying one or more grid blocks.
    &quot;columns&quot;: 42, # The number of columns in the mosaic grid. The number of columns must be between 1 and 12, inclusive.
    &quot;tiles&quot;: [ # The tiles to display.
      { # A single tile in the mosaic. The placement and size of the tile are configurable.
        &quot;height&quot;: 42, # The height of the tile, measured in grid blocks. Tiles must have a minimum height of 1.
        &quot;widget&quot;: { # Widget contains a single dashboard component and configuration of how to present the component in the dashboard. # The informational widget contained in the tile. For example an XyChart.
          &quot;alertChart&quot;: { # A chart that displays alert policy data. # A chart of alert policy data.
            &quot;name&quot;: &quot;A String&quot;, # Required. The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
          },
          &quot;blank&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # A blank space.
          },
          &quot;collapsibleGroup&quot;: { # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
            &quot;collapsed&quot;: True or False, # The collapsed state of the widget on first page load.
          },
          &quot;errorReportingPanel&quot;: { # A widget that displays a list of error groups. # A widget that displays a list of error groups.
            &quot;projectNames&quot;: [ # The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
              &quot;A String&quot;,
            ],
            &quot;services&quot;: [ # An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
              &quot;A String&quot;,
            ],
            &quot;versions&quot;: [ # Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
              &quot;A String&quot;,
            ],
          },
          &quot;id&quot;: &quot;A String&quot;, # Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
          &quot;incidentList&quot;: { # A widget that displays a list of incidents # A widget that shows list of incidents.
            &quot;monitoredResources&quot;: [ # Optional. The monitored resource for which incidents are listed. The resource doesn&#x27;t need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
              { # An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource&#x27;s schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for &quot;gce_instance&quot; has labels &quot;project_id&quot;, &quot;instance_id&quot; and &quot;zone&quot;: { &quot;type&quot;: &quot;gce_instance&quot;, &quot;labels&quot;: { &quot;project_id&quot;: &quot;my-project&quot;, &quot;instance_id&quot;: &quot;12345678901234&quot;, &quot;zone&quot;: &quot;us-central1-a&quot; }}
                &quot;labels&quot;: { # Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels &quot;project_id&quot;, &quot;instance_id&quot;, and &quot;zone&quot;.
                  &quot;a_key&quot;: &quot;A String&quot;,
                },
                &quot;type&quot;: &quot;A String&quot;, # Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
              },
            ],
            &quot;policyNames&quot;: [ # Optional. A list of alert policy names to filter the incident list by. Don&#x27;t include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
              &quot;A String&quot;,
            ],
          },
          &quot;logsPanel&quot;: { # A widget that displays a stream of log. # A widget that shows a stream of logs.
            &quot;filter&quot;: &quot;A String&quot;, # A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
            &quot;resourceNames&quot;: [ # The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
              &quot;A String&quot;,
            ],
          },
          &quot;pieChart&quot;: { # A widget that displays timeseries data as a pie or a donut. # A widget that displays timeseries data as a pie chart.
            &quot;chartType&quot;: &quot;A String&quot;, # Required. Indicates the visualization type for the PieChart.
            &quot;dataSets&quot;: [ # Required. The queries for the chart&#x27;s data.
              { # Groups a time series query definition.
                &quot;dimensions&quot;: [ # A dimension is a structured label, class, or category for a set of measurements in your data.
                  { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                    &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                    &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                    &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                    &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                    &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                    &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                    &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                    &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                  },
                ],
                &quot;measures&quot;: [ # A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                  { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                    &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                      &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                        { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                          &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                          &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                        },
                      ],
                      &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                    },
                    &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                  },
                ],
                &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                &quot;sliceNameTemplate&quot;: &quot;A String&quot;, # Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone&#x27;s value will be used for the name instead of the default name.
                &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
                  &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                    &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                  },
                  &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                  &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                  &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                    &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                  &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                },
              },
            ],
            &quot;showLabels&quot;: True or False, # Optional. Indicates whether or not the pie chart should show slices&#x27; labels
          },
          &quot;scorecard&quot;: { # A widget showing the latest value of a metric, and how this value relates to one or more thresholds. # A scorecard summarizing time series data.
            &quot;blankView&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
            },
            &quot;dimensions&quot;: [ # Optional. A dimension is a structured label, class, or category for a set of measurements in your data.
              { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
              },
            ],
            &quot;gaugeView&quot;: { # A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard&#x27;s query (inclusive). # Will cause the scorecard to show a gauge chart.
              &quot;lowerBound&quot;: 3.14, # The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
              &quot;upperBound&quot;: 3.14, # The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
            },
            &quot;measures&quot;: [ # Optional. A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
              { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                  &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                    { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                      &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                      &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                    },
                  ],
                  &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                },
                &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
              },
            ],
            &quot;sparkChartView&quot;: { # A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard&#x27;s timeseries. # Will cause the scorecard to show a spark chart.
              &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
              &quot;sparkChartType&quot;: &quot;A String&quot;, # Required. The type of sparkchart to show in this chartView.
            },
            &quot;thresholds&quot;: [ # The thresholds used to determine the state of the scorecard given the time series&#x27; current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: &#x27;DANGER&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 70, category: &#x27;WARNING&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 10, category: &#x27;DANGER&#x27;, trigger: &#x27;BELOW&#x27;, }, { value: 20, category: &#x27;WARNING&#x27;, trigger: &#x27;BELOW&#x27;, } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
              { # Defines a threshold for categorizing time series values.
                &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
              },
            ],
            &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
              &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
              },
              &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
              &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
              &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                  &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                  &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                  &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                    &quot;A String&quot;,
                  ],
                  &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                },
                &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                  &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                  &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                    &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                    &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                  },
                  &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                  &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                },
                &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                  &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                  &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                  &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                    &quot;A String&quot;,
                  ],
                  &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                },
                &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                  &quot;numTimeSeries&quot;: 42, # How many time series to output.
                  &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                },
              },
              &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                },
                &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                },
                &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                  &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                  &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                    &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                    &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                  },
                  &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                  &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                },
                &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                  &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                  &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                  &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                    &quot;A String&quot;,
                  ],
                  &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                },
                &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                  &quot;numTimeSeries&quot;: 42, # How many time series to output.
                  &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                },
              },
              &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
              &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
            },
          },
          &quot;sectionHeader&quot;: { # A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content. # A widget that defines a section header for easier navigation of the dashboard.
            &quot;dividerBelow&quot;: True or False, # Whether to insert a divider below the section in the table of contents
            &quot;subtitle&quot;: &quot;A String&quot;, # The subtitle of the section
          },
          &quot;singleViewGroup&quot;: { # A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets by using a dropdown menu.
          },
          &quot;text&quot;: { # A widget that displays textual content. # A raw string or markdown displaying textual content.
            &quot;content&quot;: &quot;A String&quot;, # The text content to be displayed.
            &quot;format&quot;: &quot;A String&quot;, # How the text content is formatted.
            &quot;style&quot;: { # Properties that determine how the title and content are styled # How the text is styled
              &quot;backgroundColor&quot;: &quot;A String&quot;, # The background color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
              &quot;fontSize&quot;: &quot;A String&quot;, # Font sizes for both the title and content. The title will still be larger relative to the content.
              &quot;horizontalAlignment&quot;: &quot;A String&quot;, # The horizontal alignment of both the title and content
              &quot;padding&quot;: &quot;A String&quot;, # The amount of padding around the widget
              &quot;pointerLocation&quot;: &quot;A String&quot;, # The pointer location for this widget (also sometimes called a &quot;tail&quot;)
              &quot;textColor&quot;: &quot;A String&quot;, # The text color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
              &quot;verticalAlignment&quot;: &quot;A String&quot;, # The vertical alignment of both the title and content
            },
          },
          &quot;timeSeriesTable&quot;: { # A table that displays time series data. # A widget that displays time series data in a tabular format.
            &quot;columnSettings&quot;: [ # Optional. The list of the persistent column settings for the table.
              { # The persistent settings for a table&#x27;s columns.
                &quot;column&quot;: &quot;A String&quot;, # Required. The id of the column.
                &quot;visible&quot;: True or False, # Required. Whether the column should be visible on page load.
              },
            ],
            &quot;dataSets&quot;: [ # Required. The data displayed in this table.
              { # Groups a time series query definition with table options.
                &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                &quot;tableDisplayOptions&quot;: { # Table display options that can be reused. # Optional. Table display options for configuring how the table is rendered.
                  &quot;shownColumns&quot;: [ # Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
                    &quot;A String&quot;,
                  ],
                },
                &quot;tableTemplate&quot;: &quot;A String&quot;, # Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value i.e. &quot;${resource.labels.project_id}.&quot;
                &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                  &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                    &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                  },
                  &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                  &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                  &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                    &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                  &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                },
              },
            ],
            &quot;metricVisualization&quot;: &quot;A String&quot;, # Optional. Store rendering strategy
          },
          &quot;title&quot;: &quot;A String&quot;, # Optional. The title of the widget.
          &quot;xyChart&quot;: { # A chart that displays data on a 2D (X and Y axes) plane. # A chart of time series data.
            &quot;chartOptions&quot;: { # Options to control visual rendering of a chart. # Display options for the chart.
              &quot;displayHorizontal&quot;: True or False, # Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
              &quot;mode&quot;: &quot;A String&quot;, # The chart mode.
            },
            &quot;dataSets&quot;: [ # Required. The data displayed in this chart.
              { # Groups a time series query definition with charting options.
                &quot;breakdowns&quot;: [ # Optional. The collection of breakdowns to be applied to the dataset.
                  { # Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
                    &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The Aggregation function is applied across all data in each breakdown created.
                      &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                        { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                          &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                          &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                        },
                      ],
                      &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                    },
                    &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the dataset containing the breakdown values.
                    &quot;limit&quot;: 42, # Required. A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
                    &quot;sortOrder&quot;: &quot;A String&quot;, # Required. The sort order is applied to the values of the breakdown column.
                  },
                ],
                &quot;dimensions&quot;: [ # Optional. A collection of dimension columns.
                  { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                    &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                    &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                    &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                    &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                    &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                    &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                    &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                    &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                  },
                ],
                &quot;legendTemplate&quot;: &quot;A String&quot;, # A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value.
                &quot;measures&quot;: [ # Optional. A collection of measures.
                  { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                    &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                      &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                        { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                          &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                          &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                        },
                      ],
                      &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                    },
                    &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                  },
                ],
                &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                &quot;plotType&quot;: &quot;A String&quot;, # How this data should be plotted on the chart.
                &quot;targetAxis&quot;: &quot;A String&quot;, # Optional. The target axis to use for plotting the metric.
                &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                  &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                    &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                  },
                  &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                  &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                  &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                    &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                  &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                },
              },
            ],
            &quot;thresholds&quot;: [ # Threshold lines drawn horizontally across the chart.
              { # Defines a threshold for categorizing time series values.
                &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
              },
            ],
            &quot;timeshiftDuration&quot;: &quot;A String&quot;, # The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
            &quot;xAxis&quot;: { # A chart axis. # The properties applied to the x-axis.
              &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
              &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
            },
            &quot;y2Axis&quot;: { # A chart axis. # The properties applied to the y2-axis.
              &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
              &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
            },
            &quot;yAxis&quot;: { # A chart axis. # The properties applied to the y-axis.
              &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
              &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
            },
          },
        },
        &quot;width&quot;: 42, # The width of the tile, measured in grid blocks. Tiles must have a minimum width of 1.
        &quot;xPos&quot;: 42, # The zero-indexed position of the tile in grid blocks relative to the left edge of the grid. Tiles must be contained within the specified number of columns. x_pos cannot be negative.
        &quot;yPos&quot;: 42, # The zero-indexed position of the tile in grid blocks relative to the top edge of the grid. y_pos cannot be negative.
      },
    ],
  },
  &quot;name&quot;: &quot;A String&quot;, # Identifier. The resource name of the dashboard.
  &quot;rowLayout&quot;: { # A simplified layout that divides the available space into rows and arranges a set of widgets horizontally in each row. # The content is divided into equally spaced rows and the widgets are arranged horizontally.
    &quot;rows&quot;: [ # The rows of content to display.
      { # Defines the layout properties and content for a row.
        &quot;weight&quot;: &quot;A String&quot;, # The relative weight of this row. The row weight is used to adjust the height of rows on the screen (relative to peers). Greater the weight, greater the height of the row on the screen. If omitted, a value of 1 is used while rendering.
        &quot;widgets&quot;: [ # The display widgets arranged horizontally in this row.
          { # Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
            &quot;alertChart&quot;: { # A chart that displays alert policy data. # A chart of alert policy data.
              &quot;name&quot;: &quot;A String&quot;, # Required. The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
            },
            &quot;blank&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # A blank space.
            },
            &quot;collapsibleGroup&quot;: { # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
              &quot;collapsed&quot;: True or False, # The collapsed state of the widget on first page load.
            },
            &quot;errorReportingPanel&quot;: { # A widget that displays a list of error groups. # A widget that displays a list of error groups.
              &quot;projectNames&quot;: [ # The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
                &quot;A String&quot;,
              ],
              &quot;services&quot;: [ # An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
                &quot;A String&quot;,
              ],
              &quot;versions&quot;: [ # Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
                &quot;A String&quot;,
              ],
            },
            &quot;id&quot;: &quot;A String&quot;, # Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
            &quot;incidentList&quot;: { # A widget that displays a list of incidents # A widget that shows list of incidents.
              &quot;monitoredResources&quot;: [ # Optional. The monitored resource for which incidents are listed. The resource doesn&#x27;t need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
                { # An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource&#x27;s schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for &quot;gce_instance&quot; has labels &quot;project_id&quot;, &quot;instance_id&quot; and &quot;zone&quot;: { &quot;type&quot;: &quot;gce_instance&quot;, &quot;labels&quot;: { &quot;project_id&quot;: &quot;my-project&quot;, &quot;instance_id&quot;: &quot;12345678901234&quot;, &quot;zone&quot;: &quot;us-central1-a&quot; }}
                  &quot;labels&quot;: { # Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels &quot;project_id&quot;, &quot;instance_id&quot;, and &quot;zone&quot;.
                    &quot;a_key&quot;: &quot;A String&quot;,
                  },
                  &quot;type&quot;: &quot;A String&quot;, # Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
                },
              ],
              &quot;policyNames&quot;: [ # Optional. A list of alert policy names to filter the incident list by. Don&#x27;t include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
                &quot;A String&quot;,
              ],
            },
            &quot;logsPanel&quot;: { # A widget that displays a stream of log. # A widget that shows a stream of logs.
              &quot;filter&quot;: &quot;A String&quot;, # A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
              &quot;resourceNames&quot;: [ # The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
                &quot;A String&quot;,
              ],
            },
            &quot;pieChart&quot;: { # A widget that displays timeseries data as a pie or a donut. # A widget that displays timeseries data as a pie chart.
              &quot;chartType&quot;: &quot;A String&quot;, # Required. Indicates the visualization type for the PieChart.
              &quot;dataSets&quot;: [ # Required. The queries for the chart&#x27;s data.
                { # Groups a time series query definition.
                  &quot;dimensions&quot;: [ # A dimension is a structured label, class, or category for a set of measurements in your data.
                    { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                      &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                      &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                      &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                      &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                      &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                      &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                    },
                  ],
                  &quot;measures&quot;: [ # A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                    { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                    },
                  ],
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;sliceNameTemplate&quot;: &quot;A String&quot;, # Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone&#x27;s value will be used for the name instead of the default name.
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;showLabels&quot;: True or False, # Optional. Indicates whether or not the pie chart should show slices&#x27; labels
            },
            &quot;scorecard&quot;: { # A widget showing the latest value of a metric, and how this value relates to one or more thresholds. # A scorecard summarizing time series data.
              &quot;blankView&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
              },
              &quot;dimensions&quot;: [ # Optional. A dimension is a structured label, class, or category for a set of measurements in your data.
                { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                  &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                  &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                  &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                  &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                  &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                  &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                  &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                },
              ],
              &quot;gaugeView&quot;: { # A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard&#x27;s query (inclusive). # Will cause the scorecard to show a gauge chart.
                &quot;lowerBound&quot;: 3.14, # The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
                &quot;upperBound&quot;: 3.14, # The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
              },
              &quot;measures&quot;: [ # Optional. A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                  &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                    &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                      { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                        &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                        &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                      },
                    ],
                    &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                  },
                  &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                },
              ],
              &quot;sparkChartView&quot;: { # A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard&#x27;s timeseries. # Will cause the scorecard to show a spark chart.
                &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
                &quot;sparkChartType&quot;: &quot;A String&quot;, # Required. The type of sparkchart to show in this chartView.
              },
              &quot;thresholds&quot;: [ # The thresholds used to determine the state of the scorecard given the time series&#x27; current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: &#x27;DANGER&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 70, category: &#x27;WARNING&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 10, category: &#x27;DANGER&#x27;, trigger: &#x27;BELOW&#x27;, }, { value: 20, category: &#x27;WARNING&#x27;, trigger: &#x27;BELOW&#x27;, } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
                { # Defines a threshold for categorizing time series values.
                  &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                  &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                  &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                  &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                },
              ],
              &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                  &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                },
                &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                  &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
              },
            },
            &quot;sectionHeader&quot;: { # A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content. # A widget that defines a section header for easier navigation of the dashboard.
              &quot;dividerBelow&quot;: True or False, # Whether to insert a divider below the section in the table of contents
              &quot;subtitle&quot;: &quot;A String&quot;, # The subtitle of the section
            },
            &quot;singleViewGroup&quot;: { # A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets by using a dropdown menu.
            },
            &quot;text&quot;: { # A widget that displays textual content. # A raw string or markdown displaying textual content.
              &quot;content&quot;: &quot;A String&quot;, # The text content to be displayed.
              &quot;format&quot;: &quot;A String&quot;, # How the text content is formatted.
              &quot;style&quot;: { # Properties that determine how the title and content are styled # How the text is styled
                &quot;backgroundColor&quot;: &quot;A String&quot;, # The background color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                &quot;fontSize&quot;: &quot;A String&quot;, # Font sizes for both the title and content. The title will still be larger relative to the content.
                &quot;horizontalAlignment&quot;: &quot;A String&quot;, # The horizontal alignment of both the title and content
                &quot;padding&quot;: &quot;A String&quot;, # The amount of padding around the widget
                &quot;pointerLocation&quot;: &quot;A String&quot;, # The pointer location for this widget (also sometimes called a &quot;tail&quot;)
                &quot;textColor&quot;: &quot;A String&quot;, # The text color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                &quot;verticalAlignment&quot;: &quot;A String&quot;, # The vertical alignment of both the title and content
              },
            },
            &quot;timeSeriesTable&quot;: { # A table that displays time series data. # A widget that displays time series data in a tabular format.
              &quot;columnSettings&quot;: [ # Optional. The list of the persistent column settings for the table.
                { # The persistent settings for a table&#x27;s columns.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The id of the column.
                  &quot;visible&quot;: True or False, # Required. Whether the column should be visible on page load.
                },
              ],
              &quot;dataSets&quot;: [ # Required. The data displayed in this table.
                { # Groups a time series query definition with table options.
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;tableDisplayOptions&quot;: { # Table display options that can be reused. # Optional. Table display options for configuring how the table is rendered.
                    &quot;shownColumns&quot;: [ # Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
                      &quot;A String&quot;,
                    ],
                  },
                  &quot;tableTemplate&quot;: &quot;A String&quot;, # Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value i.e. &quot;${resource.labels.project_id}.&quot;
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;metricVisualization&quot;: &quot;A String&quot;, # Optional. Store rendering strategy
            },
            &quot;title&quot;: &quot;A String&quot;, # Optional. The title of the widget.
            &quot;xyChart&quot;: { # A chart that displays data on a 2D (X and Y axes) plane. # A chart of time series data.
              &quot;chartOptions&quot;: { # Options to control visual rendering of a chart. # Display options for the chart.
                &quot;displayHorizontal&quot;: True or False, # Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
                &quot;mode&quot;: &quot;A String&quot;, # The chart mode.
              },
              &quot;dataSets&quot;: [ # Required. The data displayed in this chart.
                { # Groups a time series query definition with charting options.
                  &quot;breakdowns&quot;: [ # Optional. The collection of breakdowns to be applied to the dataset.
                    { # Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The Aggregation function is applied across all data in each breakdown created.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the dataset containing the breakdown values.
                      &quot;limit&quot;: 42, # Required. A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # Required. The sort order is applied to the values of the breakdown column.
                    },
                  ],
                  &quot;dimensions&quot;: [ # Optional. A collection of dimension columns.
                    { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                      &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                      &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                      &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                      &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                      &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                      &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                    },
                  ],
                  &quot;legendTemplate&quot;: &quot;A String&quot;, # A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value.
                  &quot;measures&quot;: [ # Optional. A collection of measures.
                    { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                    },
                  ],
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;plotType&quot;: &quot;A String&quot;, # How this data should be plotted on the chart.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # Optional. The target axis to use for plotting the metric.
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;thresholds&quot;: [ # Threshold lines drawn horizontally across the chart.
                { # Defines a threshold for categorizing time series values.
                  &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                  &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                  &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                  &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                },
              ],
              &quot;timeshiftDuration&quot;: &quot;A String&quot;, # The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
              &quot;xAxis&quot;: { # A chart axis. # The properties applied to the x-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
              &quot;y2Axis&quot;: { # A chart axis. # The properties applied to the y2-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
              &quot;yAxis&quot;: { # A chart axis. # The properties applied to the y-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
            },
          },
        ],
      },
    ],
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="list">list(parent, pageSize=None, pageToken=None, x__xgafv=None)</code>
  <pre>Lists the existing dashboards.This method requires the monitoring.dashboards.list permission on the specified project. For more information, see Cloud Identity and Access Management (https://cloud.google.com/iam).

Args:
  parent: string, Required. The scope of the dashboards to list. The format is: projects/[PROJECT_ID_OR_NUMBER]  (required)
  pageSize: integer, A positive number that is the maximum number of results to return. If unspecified, a default of 1000 is used.
  pageToken: string, Optional. If this field is not empty then it must contain the nextPageToken value returned by a previous call to this method. Using this field causes the method to return additional results from the previous method call.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The ListDashboards request.
  &quot;dashboards&quot;: [ # The list of requested dashboards.
    { # A Google Stackdriver dashboard. Dashboards define the content and layout of pages in the Stackdriver web application.
      &quot;annotations&quot;: { # Dashboard-level configuration for annotations # Configuration for event annotations to display on this dashboard.
        &quot;defaultResourceNames&quot;: [ # Dashboard level defaults for names of logging resources to search for events. Currently only projects are supported. Each individual EventAnnotation may have its own overrides. If both this field and the per annotation field is empty, then the scoping project is used. Limit: 50 projects. For example: “projects/some-project-id”
          &quot;A String&quot;,
        ],
        &quot;eventAnnotations&quot;: [ # List of annotation configurations for this dashboard. Each entry specifies one event type.
          { # Annotation configuration for one event type on a dashboard
            &quot;displayName&quot;: &quot;A String&quot;, # Solely for UI display. Should not be used programmatically.
            &quot;enabled&quot;: True or False, # Whether or not to show the events on the dashboard by default
            &quot;eventType&quot;: &quot;A String&quot;, # The type of event to display.
            &quot;filter&quot;: &quot;A String&quot;, # string filtering the events - event dependant. Example values: &quot;resource.labels.pod_name = &#x27;pod-1&#x27;&quot; &quot;protoPayload.authenticationInfo.principalEmail=&#x27;user@example.com&#x27;&quot;
            &quot;resourceNames&quot;: [ # Per annotation level override for the names of logging resources to search for events. Currently only projects are supported. If both this field and the per annotation field is empty, it will default to the host project. Limit: 50 projects. For example: “projects/another-project-id”
              &quot;A String&quot;,
            ],
          },
        ],
      },
      &quot;columnLayout&quot;: { # A simplified layout that divides the available space into vertical columns and arranges a set of widgets vertically in each column. # The content is divided into equally spaced columns and the widgets are arranged vertically.
        &quot;columns&quot;: [ # The columns of content to display.
          { # Defines the layout properties and content for a column.
            &quot;weight&quot;: &quot;A String&quot;, # The relative weight of this column. The column weight is used to adjust the width of columns on the screen (relative to peers). Greater the weight, greater the width of the column on the screen. If omitted, a value of 1 is used while rendering.
            &quot;widgets&quot;: [ # The display widgets arranged vertically in this column.
              { # Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
                &quot;alertChart&quot;: { # A chart that displays alert policy data. # A chart of alert policy data.
                  &quot;name&quot;: &quot;A String&quot;, # Required. The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
                },
                &quot;blank&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # A blank space.
                },
                &quot;collapsibleGroup&quot;: { # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
                  &quot;collapsed&quot;: True or False, # The collapsed state of the widget on first page load.
                },
                &quot;errorReportingPanel&quot;: { # A widget that displays a list of error groups. # A widget that displays a list of error groups.
                  &quot;projectNames&quot;: [ # The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
                    &quot;A String&quot;,
                  ],
                  &quot;services&quot;: [ # An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
                    &quot;A String&quot;,
                  ],
                  &quot;versions&quot;: [ # Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
                    &quot;A String&quot;,
                  ],
                },
                &quot;id&quot;: &quot;A String&quot;, # Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
                &quot;incidentList&quot;: { # A widget that displays a list of incidents # A widget that shows list of incidents.
                  &quot;monitoredResources&quot;: [ # Optional. The monitored resource for which incidents are listed. The resource doesn&#x27;t need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
                    { # An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource&#x27;s schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for &quot;gce_instance&quot; has labels &quot;project_id&quot;, &quot;instance_id&quot; and &quot;zone&quot;: { &quot;type&quot;: &quot;gce_instance&quot;, &quot;labels&quot;: { &quot;project_id&quot;: &quot;my-project&quot;, &quot;instance_id&quot;: &quot;12345678901234&quot;, &quot;zone&quot;: &quot;us-central1-a&quot; }}
                      &quot;labels&quot;: { # Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels &quot;project_id&quot;, &quot;instance_id&quot;, and &quot;zone&quot;.
                        &quot;a_key&quot;: &quot;A String&quot;,
                      },
                      &quot;type&quot;: &quot;A String&quot;, # Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
                    },
                  ],
                  &quot;policyNames&quot;: [ # Optional. A list of alert policy names to filter the incident list by. Don&#x27;t include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
                    &quot;A String&quot;,
                  ],
                },
                &quot;logsPanel&quot;: { # A widget that displays a stream of log. # A widget that shows a stream of logs.
                  &quot;filter&quot;: &quot;A String&quot;, # A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
                  &quot;resourceNames&quot;: [ # The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
                    &quot;A String&quot;,
                  ],
                },
                &quot;pieChart&quot;: { # A widget that displays timeseries data as a pie or a donut. # A widget that displays timeseries data as a pie chart.
                  &quot;chartType&quot;: &quot;A String&quot;, # Required. Indicates the visualization type for the PieChart.
                  &quot;dataSets&quot;: [ # Required. The queries for the chart&#x27;s data.
                    { # Groups a time series query definition.
                      &quot;dimensions&quot;: [ # A dimension is a structured label, class, or category for a set of measurements in your data.
                        { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                          &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                          &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                          &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                          &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                          &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                          &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                          &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                          &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                        },
                      ],
                      &quot;measures&quot;: [ # A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                        { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                          &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                            &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                              { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                                &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                                &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                              },
                            ],
                            &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                          },
                          &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                        },
                      ],
                      &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                      &quot;sliceNameTemplate&quot;: &quot;A String&quot;, # Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone&#x27;s value will be used for the name instead of the default name.
                      &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
                        &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                          &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                        },
                        &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                        &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                        &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                          &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                            &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                            &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                            &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                              &quot;A String&quot;,
                            ],
                            &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                          },
                          &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                          &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                            &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                            &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                            },
                            &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                            &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                          },
                          &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                            &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                            &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                            &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                              &quot;A String&quot;,
                            ],
                            &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                          },
                          &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                            &quot;numTimeSeries&quot;: 42, # How many time series to output.
                            &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                          },
                        },
                        &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                          &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                            &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                              &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                              &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                              &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                                &quot;A String&quot;,
                              ],
                              &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                            },
                            &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                          },
                          &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                            &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                              &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                              &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                              &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                                &quot;A String&quot;,
                              ],
                              &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                            },
                            &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                          },
                          &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                            &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                            &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                            },
                            &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                            &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                          },
                          &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                            &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                            &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                            &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                              &quot;A String&quot;,
                            ],
                            &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                          },
                          &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                            &quot;numTimeSeries&quot;: 42, # How many time series to output.
                            &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                          },
                        },
                        &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                        &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                      },
                    },
                  ],
                  &quot;showLabels&quot;: True or False, # Optional. Indicates whether or not the pie chart should show slices&#x27; labels
                },
                &quot;scorecard&quot;: { # A widget showing the latest value of a metric, and how this value relates to one or more thresholds. # A scorecard summarizing time series data.
                  &quot;blankView&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
                  },
                  &quot;dimensions&quot;: [ # Optional. A dimension is a structured label, class, or category for a set of measurements in your data.
                    { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                      &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                      &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                      &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                      &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                      &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                      &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                    },
                  ],
                  &quot;gaugeView&quot;: { # A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard&#x27;s query (inclusive). # Will cause the scorecard to show a gauge chart.
                    &quot;lowerBound&quot;: 3.14, # The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
                    &quot;upperBound&quot;: 3.14, # The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
                  },
                  &quot;measures&quot;: [ # Optional. A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                    { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                    },
                  ],
                  &quot;sparkChartView&quot;: { # A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard&#x27;s timeseries. # Will cause the scorecard to show a spark chart.
                    &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
                    &quot;sparkChartType&quot;: &quot;A String&quot;, # Required. The type of sparkchart to show in this chartView.
                  },
                  &quot;thresholds&quot;: [ # The thresholds used to determine the state of the scorecard given the time series&#x27; current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: &#x27;DANGER&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 70, category: &#x27;WARNING&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 10, category: &#x27;DANGER&#x27;, trigger: &#x27;BELOW&#x27;, }, { value: 20, category: &#x27;WARNING&#x27;, trigger: &#x27;BELOW&#x27;, } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
                    { # Defines a threshold for categorizing time series values.
                      &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                      &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                      &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                      &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                      &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                    },
                  ],
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
                &quot;sectionHeader&quot;: { # A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content. # A widget that defines a section header for easier navigation of the dashboard.
                  &quot;dividerBelow&quot;: True or False, # Whether to insert a divider below the section in the table of contents
                  &quot;subtitle&quot;: &quot;A String&quot;, # The subtitle of the section
                },
                &quot;singleViewGroup&quot;: { # A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets by using a dropdown menu.
                },
                &quot;text&quot;: { # A widget that displays textual content. # A raw string or markdown displaying textual content.
                  &quot;content&quot;: &quot;A String&quot;, # The text content to be displayed.
                  &quot;format&quot;: &quot;A String&quot;, # How the text content is formatted.
                  &quot;style&quot;: { # Properties that determine how the title and content are styled # How the text is styled
                    &quot;backgroundColor&quot;: &quot;A String&quot;, # The background color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                    &quot;fontSize&quot;: &quot;A String&quot;, # Font sizes for both the title and content. The title will still be larger relative to the content.
                    &quot;horizontalAlignment&quot;: &quot;A String&quot;, # The horizontal alignment of both the title and content
                    &quot;padding&quot;: &quot;A String&quot;, # The amount of padding around the widget
                    &quot;pointerLocation&quot;: &quot;A String&quot;, # The pointer location for this widget (also sometimes called a &quot;tail&quot;)
                    &quot;textColor&quot;: &quot;A String&quot;, # The text color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                    &quot;verticalAlignment&quot;: &quot;A String&quot;, # The vertical alignment of both the title and content
                  },
                },
                &quot;timeSeriesTable&quot;: { # A table that displays time series data. # A widget that displays time series data in a tabular format.
                  &quot;columnSettings&quot;: [ # Optional. The list of the persistent column settings for the table.
                    { # The persistent settings for a table&#x27;s columns.
                      &quot;column&quot;: &quot;A String&quot;, # Required. The id of the column.
                      &quot;visible&quot;: True or False, # Required. Whether the column should be visible on page load.
                    },
                  ],
                  &quot;dataSets&quot;: [ # Required. The data displayed in this table.
                    { # Groups a time series query definition with table options.
                      &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                      &quot;tableDisplayOptions&quot;: { # Table display options that can be reused. # Optional. Table display options for configuring how the table is rendered.
                        &quot;shownColumns&quot;: [ # Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
                          &quot;A String&quot;,
                        ],
                      },
                      &quot;tableTemplate&quot;: &quot;A String&quot;, # Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value i.e. &quot;${resource.labels.project_id}.&quot;
                      &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                        &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                          &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                        },
                        &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                        &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                        &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                          &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                            &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                            &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                            &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                              &quot;A String&quot;,
                            ],
                            &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                          },
                          &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                          &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                            &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                            &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                            },
                            &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                            &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                          },
                          &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                            &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                            &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                            &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                              &quot;A String&quot;,
                            ],
                            &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                          },
                          &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                            &quot;numTimeSeries&quot;: 42, # How many time series to output.
                            &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                          },
                        },
                        &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                          &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                            &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                              &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                              &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                              &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                                &quot;A String&quot;,
                              ],
                              &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                            },
                            &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                          },
                          &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                            &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                              &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                              &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                              &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                                &quot;A String&quot;,
                              ],
                              &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                            },
                            &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                          },
                          &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                            &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                            &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                            },
                            &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                            &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                          },
                          &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                            &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                            &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                            &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                              &quot;A String&quot;,
                            ],
                            &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                          },
                          &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                            &quot;numTimeSeries&quot;: 42, # How many time series to output.
                            &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                          },
                        },
                        &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                        &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                      },
                    },
                  ],
                  &quot;metricVisualization&quot;: &quot;A String&quot;, # Optional. Store rendering strategy
                },
                &quot;title&quot;: &quot;A String&quot;, # Optional. The title of the widget.
                &quot;xyChart&quot;: { # A chart that displays data on a 2D (X and Y axes) plane. # A chart of time series data.
                  &quot;chartOptions&quot;: { # Options to control visual rendering of a chart. # Display options for the chart.
                    &quot;displayHorizontal&quot;: True or False, # Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
                    &quot;mode&quot;: &quot;A String&quot;, # The chart mode.
                  },
                  &quot;dataSets&quot;: [ # Required. The data displayed in this chart.
                    { # Groups a time series query definition with charting options.
                      &quot;breakdowns&quot;: [ # Optional. The collection of breakdowns to be applied to the dataset.
                        { # Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
                          &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The Aggregation function is applied across all data in each breakdown created.
                            &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                              { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                                &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                                &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                              },
                            ],
                            &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                          },
                          &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the dataset containing the breakdown values.
                          &quot;limit&quot;: 42, # Required. A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
                          &quot;sortOrder&quot;: &quot;A String&quot;, # Required. The sort order is applied to the values of the breakdown column.
                        },
                      ],
                      &quot;dimensions&quot;: [ # Optional. A collection of dimension columns.
                        { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                          &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                          &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                          &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                          &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                          &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                          &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                          &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                          &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                        },
                      ],
                      &quot;legendTemplate&quot;: &quot;A String&quot;, # A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value.
                      &quot;measures&quot;: [ # Optional. A collection of measures.
                        { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                          &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                            &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                              { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                                &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                                &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                              },
                            ],
                            &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                          },
                          &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                        },
                      ],
                      &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                      &quot;plotType&quot;: &quot;A String&quot;, # How this data should be plotted on the chart.
                      &quot;targetAxis&quot;: &quot;A String&quot;, # Optional. The target axis to use for plotting the metric.
                      &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                        &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                          &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                        },
                        &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                        &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                        &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                          &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                            &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                            &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                            &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                              &quot;A String&quot;,
                            ],
                            &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                          },
                          &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                          &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                            &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                            &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                            },
                            &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                            &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                          },
                          &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                            &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                            &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                            &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                              &quot;A String&quot;,
                            ],
                            &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                          },
                          &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                            &quot;numTimeSeries&quot;: 42, # How many time series to output.
                            &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                          },
                        },
                        &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                          &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                            &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                              &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                              &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                              &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                                &quot;A String&quot;,
                              ],
                              &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                            },
                            &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                          },
                          &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                            &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                              &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                              &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                              &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                                &quot;A String&quot;,
                              ],
                              &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                            },
                            &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                          },
                          &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                            &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                            &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                            },
                            &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                            &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                          },
                          &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                            &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                            &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                            &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                              &quot;A String&quot;,
                            ],
                            &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                          },
                          &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                            &quot;numTimeSeries&quot;: 42, # How many time series to output.
                            &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                          },
                        },
                        &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                        &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                      },
                    },
                  ],
                  &quot;thresholds&quot;: [ # Threshold lines drawn horizontally across the chart.
                    { # Defines a threshold for categorizing time series values.
                      &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                      &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                      &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                      &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                      &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                    },
                  ],
                  &quot;timeshiftDuration&quot;: &quot;A String&quot;, # The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
                  &quot;xAxis&quot;: { # A chart axis. # The properties applied to the x-axis.
                    &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                    &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
                  },
                  &quot;y2Axis&quot;: { # A chart axis. # The properties applied to the y2-axis.
                    &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                    &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
                  },
                  &quot;yAxis&quot;: { # A chart axis. # The properties applied to the y-axis.
                    &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                    &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
                  },
                },
              },
            ],
          },
        ],
      },
      &quot;dashboardFilters&quot;: [ # Filters to reduce the amount of data charted based on the filter criteria.
        { # A filter to reduce the amount of data charted in relevant widgets.
          &quot;filterType&quot;: &quot;A String&quot;, # The specified filter type
          &quot;labelKey&quot;: &quot;A String&quot;, # Required. The key for the label
          &quot;stringValue&quot;: &quot;A String&quot;, # A variable-length string value.
          &quot;templateVariable&quot;: &quot;A String&quot;, # The placeholder text that can be referenced in a filter string or MQL query. If omitted, the dashboard filter will be applied to all relevant widgets in the dashboard.
        },
      ],
      &quot;displayName&quot;: &quot;A String&quot;, # Required. The mutable, human-readable name.
      &quot;etag&quot;: &quot;A String&quot;, # etag is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. An etag is returned in the response to GetDashboard, and users are expected to put that etag in the request to UpdateDashboard to ensure that their change will be applied to the same version of the Dashboard configuration. The field should not be passed during dashboard creation.
      &quot;gridLayout&quot;: { # A basic layout divides the available space into vertical columns of equal width and arranges a list of widgets using a row-first strategy. # Content is arranged with a basic layout that re-flows a simple list of informational elements like widgets or tiles.
        &quot;columns&quot;: &quot;A String&quot;, # The number of columns into which the view&#x27;s width is divided. If omitted or set to zero, a system default will be used while rendering.
        &quot;widgets&quot;: [ # The informational elements that are arranged into the columns row-first.
          { # Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
            &quot;alertChart&quot;: { # A chart that displays alert policy data. # A chart of alert policy data.
              &quot;name&quot;: &quot;A String&quot;, # Required. The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
            },
            &quot;blank&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # A blank space.
            },
            &quot;collapsibleGroup&quot;: { # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
              &quot;collapsed&quot;: True or False, # The collapsed state of the widget on first page load.
            },
            &quot;errorReportingPanel&quot;: { # A widget that displays a list of error groups. # A widget that displays a list of error groups.
              &quot;projectNames&quot;: [ # The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
                &quot;A String&quot;,
              ],
              &quot;services&quot;: [ # An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
                &quot;A String&quot;,
              ],
              &quot;versions&quot;: [ # Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
                &quot;A String&quot;,
              ],
            },
            &quot;id&quot;: &quot;A String&quot;, # Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
            &quot;incidentList&quot;: { # A widget that displays a list of incidents # A widget that shows list of incidents.
              &quot;monitoredResources&quot;: [ # Optional. The monitored resource for which incidents are listed. The resource doesn&#x27;t need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
                { # An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource&#x27;s schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for &quot;gce_instance&quot; has labels &quot;project_id&quot;, &quot;instance_id&quot; and &quot;zone&quot;: { &quot;type&quot;: &quot;gce_instance&quot;, &quot;labels&quot;: { &quot;project_id&quot;: &quot;my-project&quot;, &quot;instance_id&quot;: &quot;12345678901234&quot;, &quot;zone&quot;: &quot;us-central1-a&quot; }}
                  &quot;labels&quot;: { # Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels &quot;project_id&quot;, &quot;instance_id&quot;, and &quot;zone&quot;.
                    &quot;a_key&quot;: &quot;A String&quot;,
                  },
                  &quot;type&quot;: &quot;A String&quot;, # Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
                },
              ],
              &quot;policyNames&quot;: [ # Optional. A list of alert policy names to filter the incident list by. Don&#x27;t include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
                &quot;A String&quot;,
              ],
            },
            &quot;logsPanel&quot;: { # A widget that displays a stream of log. # A widget that shows a stream of logs.
              &quot;filter&quot;: &quot;A String&quot;, # A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
              &quot;resourceNames&quot;: [ # The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
                &quot;A String&quot;,
              ],
            },
            &quot;pieChart&quot;: { # A widget that displays timeseries data as a pie or a donut. # A widget that displays timeseries data as a pie chart.
              &quot;chartType&quot;: &quot;A String&quot;, # Required. Indicates the visualization type for the PieChart.
              &quot;dataSets&quot;: [ # Required. The queries for the chart&#x27;s data.
                { # Groups a time series query definition.
                  &quot;dimensions&quot;: [ # A dimension is a structured label, class, or category for a set of measurements in your data.
                    { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                      &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                      &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                      &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                      &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                      &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                      &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                    },
                  ],
                  &quot;measures&quot;: [ # A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                    { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                    },
                  ],
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;sliceNameTemplate&quot;: &quot;A String&quot;, # Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone&#x27;s value will be used for the name instead of the default name.
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;showLabels&quot;: True or False, # Optional. Indicates whether or not the pie chart should show slices&#x27; labels
            },
            &quot;scorecard&quot;: { # A widget showing the latest value of a metric, and how this value relates to one or more thresholds. # A scorecard summarizing time series data.
              &quot;blankView&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
              },
              &quot;dimensions&quot;: [ # Optional. A dimension is a structured label, class, or category for a set of measurements in your data.
                { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                  &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                  &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                  &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                  &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                  &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                  &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                  &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                },
              ],
              &quot;gaugeView&quot;: { # A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard&#x27;s query (inclusive). # Will cause the scorecard to show a gauge chart.
                &quot;lowerBound&quot;: 3.14, # The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
                &quot;upperBound&quot;: 3.14, # The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
              },
              &quot;measures&quot;: [ # Optional. A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                  &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                    &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                      { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                        &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                        &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                      },
                    ],
                    &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                  },
                  &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                },
              ],
              &quot;sparkChartView&quot;: { # A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard&#x27;s timeseries. # Will cause the scorecard to show a spark chart.
                &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
                &quot;sparkChartType&quot;: &quot;A String&quot;, # Required. The type of sparkchart to show in this chartView.
              },
              &quot;thresholds&quot;: [ # The thresholds used to determine the state of the scorecard given the time series&#x27; current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: &#x27;DANGER&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 70, category: &#x27;WARNING&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 10, category: &#x27;DANGER&#x27;, trigger: &#x27;BELOW&#x27;, }, { value: 20, category: &#x27;WARNING&#x27;, trigger: &#x27;BELOW&#x27;, } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
                { # Defines a threshold for categorizing time series values.
                  &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                  &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                  &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                  &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                },
              ],
              &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                  &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                },
                &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                  &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
              },
            },
            &quot;sectionHeader&quot;: { # A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content. # A widget that defines a section header for easier navigation of the dashboard.
              &quot;dividerBelow&quot;: True or False, # Whether to insert a divider below the section in the table of contents
              &quot;subtitle&quot;: &quot;A String&quot;, # The subtitle of the section
            },
            &quot;singleViewGroup&quot;: { # A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets by using a dropdown menu.
            },
            &quot;text&quot;: { # A widget that displays textual content. # A raw string or markdown displaying textual content.
              &quot;content&quot;: &quot;A String&quot;, # The text content to be displayed.
              &quot;format&quot;: &quot;A String&quot;, # How the text content is formatted.
              &quot;style&quot;: { # Properties that determine how the title and content are styled # How the text is styled
                &quot;backgroundColor&quot;: &quot;A String&quot;, # The background color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                &quot;fontSize&quot;: &quot;A String&quot;, # Font sizes for both the title and content. The title will still be larger relative to the content.
                &quot;horizontalAlignment&quot;: &quot;A String&quot;, # The horizontal alignment of both the title and content
                &quot;padding&quot;: &quot;A String&quot;, # The amount of padding around the widget
                &quot;pointerLocation&quot;: &quot;A String&quot;, # The pointer location for this widget (also sometimes called a &quot;tail&quot;)
                &quot;textColor&quot;: &quot;A String&quot;, # The text color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                &quot;verticalAlignment&quot;: &quot;A String&quot;, # The vertical alignment of both the title and content
              },
            },
            &quot;timeSeriesTable&quot;: { # A table that displays time series data. # A widget that displays time series data in a tabular format.
              &quot;columnSettings&quot;: [ # Optional. The list of the persistent column settings for the table.
                { # The persistent settings for a table&#x27;s columns.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The id of the column.
                  &quot;visible&quot;: True or False, # Required. Whether the column should be visible on page load.
                },
              ],
              &quot;dataSets&quot;: [ # Required. The data displayed in this table.
                { # Groups a time series query definition with table options.
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;tableDisplayOptions&quot;: { # Table display options that can be reused. # Optional. Table display options for configuring how the table is rendered.
                    &quot;shownColumns&quot;: [ # Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
                      &quot;A String&quot;,
                    ],
                  },
                  &quot;tableTemplate&quot;: &quot;A String&quot;, # Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value i.e. &quot;${resource.labels.project_id}.&quot;
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;metricVisualization&quot;: &quot;A String&quot;, # Optional. Store rendering strategy
            },
            &quot;title&quot;: &quot;A String&quot;, # Optional. The title of the widget.
            &quot;xyChart&quot;: { # A chart that displays data on a 2D (X and Y axes) plane. # A chart of time series data.
              &quot;chartOptions&quot;: { # Options to control visual rendering of a chart. # Display options for the chart.
                &quot;displayHorizontal&quot;: True or False, # Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
                &quot;mode&quot;: &quot;A String&quot;, # The chart mode.
              },
              &quot;dataSets&quot;: [ # Required. The data displayed in this chart.
                { # Groups a time series query definition with charting options.
                  &quot;breakdowns&quot;: [ # Optional. The collection of breakdowns to be applied to the dataset.
                    { # Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The Aggregation function is applied across all data in each breakdown created.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the dataset containing the breakdown values.
                      &quot;limit&quot;: 42, # Required. A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # Required. The sort order is applied to the values of the breakdown column.
                    },
                  ],
                  &quot;dimensions&quot;: [ # Optional. A collection of dimension columns.
                    { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                      &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                      &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                      &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                      &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                      &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                      &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                    },
                  ],
                  &quot;legendTemplate&quot;: &quot;A String&quot;, # A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value.
                  &quot;measures&quot;: [ # Optional. A collection of measures.
                    { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                    },
                  ],
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;plotType&quot;: &quot;A String&quot;, # How this data should be plotted on the chart.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # Optional. The target axis to use for plotting the metric.
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;thresholds&quot;: [ # Threshold lines drawn horizontally across the chart.
                { # Defines a threshold for categorizing time series values.
                  &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                  &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                  &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                  &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                },
              ],
              &quot;timeshiftDuration&quot;: &quot;A String&quot;, # The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
              &quot;xAxis&quot;: { # A chart axis. # The properties applied to the x-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
              &quot;y2Axis&quot;: { # A chart axis. # The properties applied to the y2-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
              &quot;yAxis&quot;: { # A chart axis. # The properties applied to the y-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
            },
          },
        ],
      },
      &quot;labels&quot;: { # Labels applied to the dashboard
        &quot;a_key&quot;: &quot;A String&quot;,
      },
      &quot;mosaicLayout&quot;: { # A mosaic layout divides the available space into a grid of blocks, and overlays the grid with tiles. Unlike GridLayout, tiles may span multiple grid blocks and can be placed at arbitrary locations in the grid. # The content is arranged as a grid of tiles, with each content widget occupying one or more grid blocks.
        &quot;columns&quot;: 42, # The number of columns in the mosaic grid. The number of columns must be between 1 and 12, inclusive.
        &quot;tiles&quot;: [ # The tiles to display.
          { # A single tile in the mosaic. The placement and size of the tile are configurable.
            &quot;height&quot;: 42, # The height of the tile, measured in grid blocks. Tiles must have a minimum height of 1.
            &quot;widget&quot;: { # Widget contains a single dashboard component and configuration of how to present the component in the dashboard. # The informational widget contained in the tile. For example an XyChart.
              &quot;alertChart&quot;: { # A chart that displays alert policy data. # A chart of alert policy data.
                &quot;name&quot;: &quot;A String&quot;, # Required. The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
              },
              &quot;blank&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # A blank space.
              },
              &quot;collapsibleGroup&quot;: { # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
                &quot;collapsed&quot;: True or False, # The collapsed state of the widget on first page load.
              },
              &quot;errorReportingPanel&quot;: { # A widget that displays a list of error groups. # A widget that displays a list of error groups.
                &quot;projectNames&quot;: [ # The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
                  &quot;A String&quot;,
                ],
                &quot;services&quot;: [ # An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
                  &quot;A String&quot;,
                ],
                &quot;versions&quot;: [ # Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
                  &quot;A String&quot;,
                ],
              },
              &quot;id&quot;: &quot;A String&quot;, # Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
              &quot;incidentList&quot;: { # A widget that displays a list of incidents # A widget that shows list of incidents.
                &quot;monitoredResources&quot;: [ # Optional. The monitored resource for which incidents are listed. The resource doesn&#x27;t need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
                  { # An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource&#x27;s schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for &quot;gce_instance&quot; has labels &quot;project_id&quot;, &quot;instance_id&quot; and &quot;zone&quot;: { &quot;type&quot;: &quot;gce_instance&quot;, &quot;labels&quot;: { &quot;project_id&quot;: &quot;my-project&quot;, &quot;instance_id&quot;: &quot;12345678901234&quot;, &quot;zone&quot;: &quot;us-central1-a&quot; }}
                    &quot;labels&quot;: { # Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels &quot;project_id&quot;, &quot;instance_id&quot;, and &quot;zone&quot;.
                      &quot;a_key&quot;: &quot;A String&quot;,
                    },
                    &quot;type&quot;: &quot;A String&quot;, # Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
                  },
                ],
                &quot;policyNames&quot;: [ # Optional. A list of alert policy names to filter the incident list by. Don&#x27;t include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
                  &quot;A String&quot;,
                ],
              },
              &quot;logsPanel&quot;: { # A widget that displays a stream of log. # A widget that shows a stream of logs.
                &quot;filter&quot;: &quot;A String&quot;, # A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
                &quot;resourceNames&quot;: [ # The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
                  &quot;A String&quot;,
                ],
              },
              &quot;pieChart&quot;: { # A widget that displays timeseries data as a pie or a donut. # A widget that displays timeseries data as a pie chart.
                &quot;chartType&quot;: &quot;A String&quot;, # Required. Indicates the visualization type for the PieChart.
                &quot;dataSets&quot;: [ # Required. The queries for the chart&#x27;s data.
                  { # Groups a time series query definition.
                    &quot;dimensions&quot;: [ # A dimension is a structured label, class, or category for a set of measurements in your data.
                      { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                        &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                        &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                        &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                        &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                        &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                        &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                        &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                        &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                      },
                    ],
                    &quot;measures&quot;: [ # A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                      { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                        &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                          &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                            { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                              &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                              &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                            },
                          ],
                          &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                        },
                        &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                      },
                    ],
                    &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                    &quot;sliceNameTemplate&quot;: &quot;A String&quot;, # Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone&#x27;s value will be used for the name instead of the default name.
                    &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
                      &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                        &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                      },
                      &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                      &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                      &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                        &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                          &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                          &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                            &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                            &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                          },
                          &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                          &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                        },
                        &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                          &quot;numTimeSeries&quot;: 42, # How many time series to output.
                          &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                        },
                      },
                      &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                        &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                          &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                            &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                            &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                            &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                              &quot;A String&quot;,
                            ],
                            &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                          },
                          &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                        },
                        &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                          &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                            &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                            &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                            &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                              &quot;A String&quot;,
                            ],
                            &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                          },
                          &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                        },
                        &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                          &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                          &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                            &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                            &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                          },
                          &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                          &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                        },
                        &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                          &quot;numTimeSeries&quot;: 42, # How many time series to output.
                          &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                        },
                      },
                      &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                      &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                    },
                  },
                ],
                &quot;showLabels&quot;: True or False, # Optional. Indicates whether or not the pie chart should show slices&#x27; labels
              },
              &quot;scorecard&quot;: { # A widget showing the latest value of a metric, and how this value relates to one or more thresholds. # A scorecard summarizing time series data.
                &quot;blankView&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
                },
                &quot;dimensions&quot;: [ # Optional. A dimension is a structured label, class, or category for a set of measurements in your data.
                  { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                    &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                    &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                    &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                    &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                    &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                    &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                    &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                    &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                  },
                ],
                &quot;gaugeView&quot;: { # A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard&#x27;s query (inclusive). # Will cause the scorecard to show a gauge chart.
                  &quot;lowerBound&quot;: 3.14, # The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
                  &quot;upperBound&quot;: 3.14, # The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
                },
                &quot;measures&quot;: [ # Optional. A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                  { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                    &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                      &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                        { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                          &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                          &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                        },
                      ],
                      &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                    },
                    &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                  },
                ],
                &quot;sparkChartView&quot;: { # A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard&#x27;s timeseries. # Will cause the scorecard to show a spark chart.
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
                  &quot;sparkChartType&quot;: &quot;A String&quot;, # Required. The type of sparkchart to show in this chartView.
                },
                &quot;thresholds&quot;: [ # The thresholds used to determine the state of the scorecard given the time series&#x27; current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: &#x27;DANGER&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 70, category: &#x27;WARNING&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 10, category: &#x27;DANGER&#x27;, trigger: &#x27;BELOW&#x27;, }, { value: 20, category: &#x27;WARNING&#x27;, trigger: &#x27;BELOW&#x27;, } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
                  { # Defines a threshold for categorizing time series values.
                    &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                    &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                    &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                    &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                    &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                  },
                ],
                &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                  &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                    &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                  },
                  &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                  &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                  &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                    &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                  &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                },
              },
              &quot;sectionHeader&quot;: { # A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content. # A widget that defines a section header for easier navigation of the dashboard.
                &quot;dividerBelow&quot;: True or False, # Whether to insert a divider below the section in the table of contents
                &quot;subtitle&quot;: &quot;A String&quot;, # The subtitle of the section
              },
              &quot;singleViewGroup&quot;: { # A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets by using a dropdown menu.
              },
              &quot;text&quot;: { # A widget that displays textual content. # A raw string or markdown displaying textual content.
                &quot;content&quot;: &quot;A String&quot;, # The text content to be displayed.
                &quot;format&quot;: &quot;A String&quot;, # How the text content is formatted.
                &quot;style&quot;: { # Properties that determine how the title and content are styled # How the text is styled
                  &quot;backgroundColor&quot;: &quot;A String&quot;, # The background color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                  &quot;fontSize&quot;: &quot;A String&quot;, # Font sizes for both the title and content. The title will still be larger relative to the content.
                  &quot;horizontalAlignment&quot;: &quot;A String&quot;, # The horizontal alignment of both the title and content
                  &quot;padding&quot;: &quot;A String&quot;, # The amount of padding around the widget
                  &quot;pointerLocation&quot;: &quot;A String&quot;, # The pointer location for this widget (also sometimes called a &quot;tail&quot;)
                  &quot;textColor&quot;: &quot;A String&quot;, # The text color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                  &quot;verticalAlignment&quot;: &quot;A String&quot;, # The vertical alignment of both the title and content
                },
              },
              &quot;timeSeriesTable&quot;: { # A table that displays time series data. # A widget that displays time series data in a tabular format.
                &quot;columnSettings&quot;: [ # Optional. The list of the persistent column settings for the table.
                  { # The persistent settings for a table&#x27;s columns.
                    &quot;column&quot;: &quot;A String&quot;, # Required. The id of the column.
                    &quot;visible&quot;: True or False, # Required. Whether the column should be visible on page load.
                  },
                ],
                &quot;dataSets&quot;: [ # Required. The data displayed in this table.
                  { # Groups a time series query definition with table options.
                    &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                    &quot;tableDisplayOptions&quot;: { # Table display options that can be reused. # Optional. Table display options for configuring how the table is rendered.
                      &quot;shownColumns&quot;: [ # Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
                        &quot;A String&quot;,
                      ],
                    },
                    &quot;tableTemplate&quot;: &quot;A String&quot;, # Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value i.e. &quot;${resource.labels.project_id}.&quot;
                    &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                      &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                        &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                      },
                      &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                      &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                      &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                        &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                          &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                          &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                            &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                            &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                          },
                          &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                          &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                        },
                        &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                          &quot;numTimeSeries&quot;: 42, # How many time series to output.
                          &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                        },
                      },
                      &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                        &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                          &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                            &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                            &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                            &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                              &quot;A String&quot;,
                            ],
                            &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                          },
                          &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                        },
                        &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                          &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                            &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                            &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                            &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                              &quot;A String&quot;,
                            ],
                            &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                          },
                          &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                        },
                        &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                          &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                          &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                            &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                            &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                          },
                          &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                          &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                        },
                        &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                          &quot;numTimeSeries&quot;: 42, # How many time series to output.
                          &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                        },
                      },
                      &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                      &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                    },
                  },
                ],
                &quot;metricVisualization&quot;: &quot;A String&quot;, # Optional. Store rendering strategy
              },
              &quot;title&quot;: &quot;A String&quot;, # Optional. The title of the widget.
              &quot;xyChart&quot;: { # A chart that displays data on a 2D (X and Y axes) plane. # A chart of time series data.
                &quot;chartOptions&quot;: { # Options to control visual rendering of a chart. # Display options for the chart.
                  &quot;displayHorizontal&quot;: True or False, # Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
                  &quot;mode&quot;: &quot;A String&quot;, # The chart mode.
                },
                &quot;dataSets&quot;: [ # Required. The data displayed in this chart.
                  { # Groups a time series query definition with charting options.
                    &quot;breakdowns&quot;: [ # Optional. The collection of breakdowns to be applied to the dataset.
                      { # Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
                        &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The Aggregation function is applied across all data in each breakdown created.
                          &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                            { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                              &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                              &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                            },
                          ],
                          &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                        },
                        &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the dataset containing the breakdown values.
                        &quot;limit&quot;: 42, # Required. A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
                        &quot;sortOrder&quot;: &quot;A String&quot;, # Required. The sort order is applied to the values of the breakdown column.
                      },
                    ],
                    &quot;dimensions&quot;: [ # Optional. A collection of dimension columns.
                      { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                        &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                        &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                        &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                        &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                        &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                        &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                        &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                        &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                      },
                    ],
                    &quot;legendTemplate&quot;: &quot;A String&quot;, # A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value.
                    &quot;measures&quot;: [ # Optional. A collection of measures.
                      { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                        &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                          &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                            { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                              &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                              &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                            },
                          ],
                          &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                        },
                        &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                      },
                    ],
                    &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                    &quot;plotType&quot;: &quot;A String&quot;, # How this data should be plotted on the chart.
                    &quot;targetAxis&quot;: &quot;A String&quot;, # Optional. The target axis to use for plotting the metric.
                    &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                      &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                        &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                      },
                      &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                      &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                      &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                        &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                          &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                          &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                            &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                            &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                          },
                          &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                          &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                        },
                        &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                          &quot;numTimeSeries&quot;: 42, # How many time series to output.
                          &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                        },
                      },
                      &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                        &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                          &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                            &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                            &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                            &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                              &quot;A String&quot;,
                            ],
                            &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                          },
                          &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                        },
                        &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                          &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                            &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                            &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                            &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                              &quot;A String&quot;,
                            ],
                            &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                          },
                          &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                        },
                        &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                          &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                          &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                            &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                            &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                          },
                          &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                          &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                        },
                        &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                          &quot;numTimeSeries&quot;: 42, # How many time series to output.
                          &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                        },
                      },
                      &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                      &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                    },
                  },
                ],
                &quot;thresholds&quot;: [ # Threshold lines drawn horizontally across the chart.
                  { # Defines a threshold for categorizing time series values.
                    &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                    &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                    &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                    &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                    &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                  },
                ],
                &quot;timeshiftDuration&quot;: &quot;A String&quot;, # The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
                &quot;xAxis&quot;: { # A chart axis. # The properties applied to the x-axis.
                  &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                  &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
                },
                &quot;y2Axis&quot;: { # A chart axis. # The properties applied to the y2-axis.
                  &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                  &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
                },
                &quot;yAxis&quot;: { # A chart axis. # The properties applied to the y-axis.
                  &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                  &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
                },
              },
            },
            &quot;width&quot;: 42, # The width of the tile, measured in grid blocks. Tiles must have a minimum width of 1.
            &quot;xPos&quot;: 42, # The zero-indexed position of the tile in grid blocks relative to the left edge of the grid. Tiles must be contained within the specified number of columns. x_pos cannot be negative.
            &quot;yPos&quot;: 42, # The zero-indexed position of the tile in grid blocks relative to the top edge of the grid. y_pos cannot be negative.
          },
        ],
      },
      &quot;name&quot;: &quot;A String&quot;, # Identifier. The resource name of the dashboard.
      &quot;rowLayout&quot;: { # A simplified layout that divides the available space into rows and arranges a set of widgets horizontally in each row. # The content is divided into equally spaced rows and the widgets are arranged horizontally.
        &quot;rows&quot;: [ # The rows of content to display.
          { # Defines the layout properties and content for a row.
            &quot;weight&quot;: &quot;A String&quot;, # The relative weight of this row. The row weight is used to adjust the height of rows on the screen (relative to peers). Greater the weight, greater the height of the row on the screen. If omitted, a value of 1 is used while rendering.
            &quot;widgets&quot;: [ # The display widgets arranged horizontally in this row.
              { # Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
                &quot;alertChart&quot;: { # A chart that displays alert policy data. # A chart of alert policy data.
                  &quot;name&quot;: &quot;A String&quot;, # Required. The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
                },
                &quot;blank&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # A blank space.
                },
                &quot;collapsibleGroup&quot;: { # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
                  &quot;collapsed&quot;: True or False, # The collapsed state of the widget on first page load.
                },
                &quot;errorReportingPanel&quot;: { # A widget that displays a list of error groups. # A widget that displays a list of error groups.
                  &quot;projectNames&quot;: [ # The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
                    &quot;A String&quot;,
                  ],
                  &quot;services&quot;: [ # An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
                    &quot;A String&quot;,
                  ],
                  &quot;versions&quot;: [ # Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
                    &quot;A String&quot;,
                  ],
                },
                &quot;id&quot;: &quot;A String&quot;, # Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
                &quot;incidentList&quot;: { # A widget that displays a list of incidents # A widget that shows list of incidents.
                  &quot;monitoredResources&quot;: [ # Optional. The monitored resource for which incidents are listed. The resource doesn&#x27;t need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
                    { # An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource&#x27;s schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for &quot;gce_instance&quot; has labels &quot;project_id&quot;, &quot;instance_id&quot; and &quot;zone&quot;: { &quot;type&quot;: &quot;gce_instance&quot;, &quot;labels&quot;: { &quot;project_id&quot;: &quot;my-project&quot;, &quot;instance_id&quot;: &quot;12345678901234&quot;, &quot;zone&quot;: &quot;us-central1-a&quot; }}
                      &quot;labels&quot;: { # Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels &quot;project_id&quot;, &quot;instance_id&quot;, and &quot;zone&quot;.
                        &quot;a_key&quot;: &quot;A String&quot;,
                      },
                      &quot;type&quot;: &quot;A String&quot;, # Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
                    },
                  ],
                  &quot;policyNames&quot;: [ # Optional. A list of alert policy names to filter the incident list by. Don&#x27;t include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
                    &quot;A String&quot;,
                  ],
                },
                &quot;logsPanel&quot;: { # A widget that displays a stream of log. # A widget that shows a stream of logs.
                  &quot;filter&quot;: &quot;A String&quot;, # A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
                  &quot;resourceNames&quot;: [ # The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
                    &quot;A String&quot;,
                  ],
                },
                &quot;pieChart&quot;: { # A widget that displays timeseries data as a pie or a donut. # A widget that displays timeseries data as a pie chart.
                  &quot;chartType&quot;: &quot;A String&quot;, # Required. Indicates the visualization type for the PieChart.
                  &quot;dataSets&quot;: [ # Required. The queries for the chart&#x27;s data.
                    { # Groups a time series query definition.
                      &quot;dimensions&quot;: [ # A dimension is a structured label, class, or category for a set of measurements in your data.
                        { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                          &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                          &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                          &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                          &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                          &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                          &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                          &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                          &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                        },
                      ],
                      &quot;measures&quot;: [ # A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                        { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                          &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                            &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                              { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                                &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                                &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                              },
                            ],
                            &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                          },
                          &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                        },
                      ],
                      &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                      &quot;sliceNameTemplate&quot;: &quot;A String&quot;, # Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone&#x27;s value will be used for the name instead of the default name.
                      &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
                        &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                          &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                        },
                        &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                        &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                        &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                          &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                            &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                            &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                            &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                              &quot;A String&quot;,
                            ],
                            &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                          },
                          &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                          &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                            &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                            &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                            },
                            &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                            &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                          },
                          &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                            &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                            &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                            &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                              &quot;A String&quot;,
                            ],
                            &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                          },
                          &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                            &quot;numTimeSeries&quot;: 42, # How many time series to output.
                            &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                          },
                        },
                        &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                          &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                            &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                              &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                              &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                              &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                                &quot;A String&quot;,
                              ],
                              &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                            },
                            &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                          },
                          &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                            &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                              &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                              &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                              &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                                &quot;A String&quot;,
                              ],
                              &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                            },
                            &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                          },
                          &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                            &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                            &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                            },
                            &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                            &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                          },
                          &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                            &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                            &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                            &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                              &quot;A String&quot;,
                            ],
                            &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                          },
                          &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                            &quot;numTimeSeries&quot;: 42, # How many time series to output.
                            &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                          },
                        },
                        &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                        &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                      },
                    },
                  ],
                  &quot;showLabels&quot;: True or False, # Optional. Indicates whether or not the pie chart should show slices&#x27; labels
                },
                &quot;scorecard&quot;: { # A widget showing the latest value of a metric, and how this value relates to one or more thresholds. # A scorecard summarizing time series data.
                  &quot;blankView&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
                  },
                  &quot;dimensions&quot;: [ # Optional. A dimension is a structured label, class, or category for a set of measurements in your data.
                    { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                      &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                      &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                      &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                      &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                      &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                      &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                    },
                  ],
                  &quot;gaugeView&quot;: { # A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard&#x27;s query (inclusive). # Will cause the scorecard to show a gauge chart.
                    &quot;lowerBound&quot;: 3.14, # The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
                    &quot;upperBound&quot;: 3.14, # The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
                  },
                  &quot;measures&quot;: [ # Optional. A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                    { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                    },
                  ],
                  &quot;sparkChartView&quot;: { # A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard&#x27;s timeseries. # Will cause the scorecard to show a spark chart.
                    &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
                    &quot;sparkChartType&quot;: &quot;A String&quot;, # Required. The type of sparkchart to show in this chartView.
                  },
                  &quot;thresholds&quot;: [ # The thresholds used to determine the state of the scorecard given the time series&#x27; current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: &#x27;DANGER&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 70, category: &#x27;WARNING&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 10, category: &#x27;DANGER&#x27;, trigger: &#x27;BELOW&#x27;, }, { value: 20, category: &#x27;WARNING&#x27;, trigger: &#x27;BELOW&#x27;, } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
                    { # Defines a threshold for categorizing time series values.
                      &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                      &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                      &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                      &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                      &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                    },
                  ],
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
                &quot;sectionHeader&quot;: { # A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content. # A widget that defines a section header for easier navigation of the dashboard.
                  &quot;dividerBelow&quot;: True or False, # Whether to insert a divider below the section in the table of contents
                  &quot;subtitle&quot;: &quot;A String&quot;, # The subtitle of the section
                },
                &quot;singleViewGroup&quot;: { # A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets by using a dropdown menu.
                },
                &quot;text&quot;: { # A widget that displays textual content. # A raw string or markdown displaying textual content.
                  &quot;content&quot;: &quot;A String&quot;, # The text content to be displayed.
                  &quot;format&quot;: &quot;A String&quot;, # How the text content is formatted.
                  &quot;style&quot;: { # Properties that determine how the title and content are styled # How the text is styled
                    &quot;backgroundColor&quot;: &quot;A String&quot;, # The background color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                    &quot;fontSize&quot;: &quot;A String&quot;, # Font sizes for both the title and content. The title will still be larger relative to the content.
                    &quot;horizontalAlignment&quot;: &quot;A String&quot;, # The horizontal alignment of both the title and content
                    &quot;padding&quot;: &quot;A String&quot;, # The amount of padding around the widget
                    &quot;pointerLocation&quot;: &quot;A String&quot;, # The pointer location for this widget (also sometimes called a &quot;tail&quot;)
                    &quot;textColor&quot;: &quot;A String&quot;, # The text color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                    &quot;verticalAlignment&quot;: &quot;A String&quot;, # The vertical alignment of both the title and content
                  },
                },
                &quot;timeSeriesTable&quot;: { # A table that displays time series data. # A widget that displays time series data in a tabular format.
                  &quot;columnSettings&quot;: [ # Optional. The list of the persistent column settings for the table.
                    { # The persistent settings for a table&#x27;s columns.
                      &quot;column&quot;: &quot;A String&quot;, # Required. The id of the column.
                      &quot;visible&quot;: True or False, # Required. Whether the column should be visible on page load.
                    },
                  ],
                  &quot;dataSets&quot;: [ # Required. The data displayed in this table.
                    { # Groups a time series query definition with table options.
                      &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                      &quot;tableDisplayOptions&quot;: { # Table display options that can be reused. # Optional. Table display options for configuring how the table is rendered.
                        &quot;shownColumns&quot;: [ # Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
                          &quot;A String&quot;,
                        ],
                      },
                      &quot;tableTemplate&quot;: &quot;A String&quot;, # Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value i.e. &quot;${resource.labels.project_id}.&quot;
                      &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                        &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                          &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                        },
                        &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                        &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                        &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                          &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                            &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                            &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                            &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                              &quot;A String&quot;,
                            ],
                            &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                          },
                          &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                          &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                            &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                            &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                            },
                            &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                            &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                          },
                          &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                            &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                            &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                            &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                              &quot;A String&quot;,
                            ],
                            &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                          },
                          &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                            &quot;numTimeSeries&quot;: 42, # How many time series to output.
                            &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                          },
                        },
                        &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                          &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                            &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                              &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                              &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                              &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                                &quot;A String&quot;,
                              ],
                              &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                            },
                            &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                          },
                          &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                            &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                              &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                              &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                              &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                                &quot;A String&quot;,
                              ],
                              &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                            },
                            &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                          },
                          &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                            &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                            &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                            },
                            &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                            &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                          },
                          &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                            &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                            &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                            &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                              &quot;A String&quot;,
                            ],
                            &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                          },
                          &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                            &quot;numTimeSeries&quot;: 42, # How many time series to output.
                            &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                          },
                        },
                        &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                        &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                      },
                    },
                  ],
                  &quot;metricVisualization&quot;: &quot;A String&quot;, # Optional. Store rendering strategy
                },
                &quot;title&quot;: &quot;A String&quot;, # Optional. The title of the widget.
                &quot;xyChart&quot;: { # A chart that displays data on a 2D (X and Y axes) plane. # A chart of time series data.
                  &quot;chartOptions&quot;: { # Options to control visual rendering of a chart. # Display options for the chart.
                    &quot;displayHorizontal&quot;: True or False, # Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
                    &quot;mode&quot;: &quot;A String&quot;, # The chart mode.
                  },
                  &quot;dataSets&quot;: [ # Required. The data displayed in this chart.
                    { # Groups a time series query definition with charting options.
                      &quot;breakdowns&quot;: [ # Optional. The collection of breakdowns to be applied to the dataset.
                        { # Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
                          &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The Aggregation function is applied across all data in each breakdown created.
                            &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                              { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                                &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                                &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                              },
                            ],
                            &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                          },
                          &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the dataset containing the breakdown values.
                          &quot;limit&quot;: 42, # Required. A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
                          &quot;sortOrder&quot;: &quot;A String&quot;, # Required. The sort order is applied to the values of the breakdown column.
                        },
                      ],
                      &quot;dimensions&quot;: [ # Optional. A collection of dimension columns.
                        { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                          &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                          &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                          &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                          &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                          &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                          &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                          &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                          &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                        },
                      ],
                      &quot;legendTemplate&quot;: &quot;A String&quot;, # A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value.
                      &quot;measures&quot;: [ # Optional. A collection of measures.
                        { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                          &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                            &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                              { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                                &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                                &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                              },
                            ],
                            &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                          },
                          &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                        },
                      ],
                      &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                      &quot;plotType&quot;: &quot;A String&quot;, # How this data should be plotted on the chart.
                      &quot;targetAxis&quot;: &quot;A String&quot;, # Optional. The target axis to use for plotting the metric.
                      &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                        &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                          &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                        },
                        &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                        &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                        &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                          &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                            &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                            &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                            &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                              &quot;A String&quot;,
                            ],
                            &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                          },
                          &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                          &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                            &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                            &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                            },
                            &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                            &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                          },
                          &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                            &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                            &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                            &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                              &quot;A String&quot;,
                            ],
                            &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                          },
                          &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                            &quot;numTimeSeries&quot;: 42, # How many time series to output.
                            &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                          },
                        },
                        &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                          &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                            &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                              &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                              &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                              &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                                &quot;A String&quot;,
                              ],
                              &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                            },
                            &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                          },
                          &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                            &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                              &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                              &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                              &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                                &quot;A String&quot;,
                              ],
                              &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                            },
                            &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                          },
                          &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                            &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                            &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                            },
                            &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                            &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                          },
                          &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                            &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                            &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                            &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                              &quot;A String&quot;,
                            ],
                            &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                          },
                          &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                            &quot;numTimeSeries&quot;: 42, # How many time series to output.
                            &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                          },
                        },
                        &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                        &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                      },
                    },
                  ],
                  &quot;thresholds&quot;: [ # Threshold lines drawn horizontally across the chart.
                    { # Defines a threshold for categorizing time series values.
                      &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                      &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                      &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                      &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                      &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                    },
                  ],
                  &quot;timeshiftDuration&quot;: &quot;A String&quot;, # The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
                  &quot;xAxis&quot;: { # A chart axis. # The properties applied to the x-axis.
                    &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                    &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
                  },
                  &quot;y2Axis&quot;: { # A chart axis. # The properties applied to the y2-axis.
                    &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                    &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
                  },
                  &quot;yAxis&quot;: { # A chart axis. # The properties applied to the y-axis.
                    &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                    &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
                  },
                },
              },
            ],
          },
        ],
      },
    },
  ],
  &quot;nextPageToken&quot;: &quot;A String&quot;, # If there are more results than have been returned, then this field is set to a non-empty value. To see the additional results, use that value as page_token in the next call to this method.
}</pre>
</div>

<div class="method">
    <code class="details" id="list_next">list_next()</code>
  <pre>Retrieves the next page of results.

        Args:
          previous_request: The request for the previous page. (required)
          previous_response: The response from the request for the previous page. (required)

        Returns:
          A request object that you can call &#x27;execute()&#x27; on to request the next
          page. Returns None if there are no more items in the collection.
        </pre>
</div>

<div class="method">
    <code class="details" id="patch">patch(name, body=None, validateOnly=None, x__xgafv=None)</code>
  <pre>Replaces an existing custom dashboard with a new definition.This method requires the monitoring.dashboards.update permission on the specified dashboard. For more information, see Cloud Identity and Access Management (https://cloud.google.com/iam).

Args:
  name: string, Identifier. The resource name of the dashboard. (required)
  body: object, The request body.
    The object takes the form of:

{ # A Google Stackdriver dashboard. Dashboards define the content and layout of pages in the Stackdriver web application.
  &quot;annotations&quot;: { # Dashboard-level configuration for annotations # Configuration for event annotations to display on this dashboard.
    &quot;defaultResourceNames&quot;: [ # Dashboard level defaults for names of logging resources to search for events. Currently only projects are supported. Each individual EventAnnotation may have its own overrides. If both this field and the per annotation field is empty, then the scoping project is used. Limit: 50 projects. For example: “projects/some-project-id”
      &quot;A String&quot;,
    ],
    &quot;eventAnnotations&quot;: [ # List of annotation configurations for this dashboard. Each entry specifies one event type.
      { # Annotation configuration for one event type on a dashboard
        &quot;displayName&quot;: &quot;A String&quot;, # Solely for UI display. Should not be used programmatically.
        &quot;enabled&quot;: True or False, # Whether or not to show the events on the dashboard by default
        &quot;eventType&quot;: &quot;A String&quot;, # The type of event to display.
        &quot;filter&quot;: &quot;A String&quot;, # string filtering the events - event dependant. Example values: &quot;resource.labels.pod_name = &#x27;pod-1&#x27;&quot; &quot;protoPayload.authenticationInfo.principalEmail=&#x27;user@example.com&#x27;&quot;
        &quot;resourceNames&quot;: [ # Per annotation level override for the names of logging resources to search for events. Currently only projects are supported. If both this field and the per annotation field is empty, it will default to the host project. Limit: 50 projects. For example: “projects/another-project-id”
          &quot;A String&quot;,
        ],
      },
    ],
  },
  &quot;columnLayout&quot;: { # A simplified layout that divides the available space into vertical columns and arranges a set of widgets vertically in each column. # The content is divided into equally spaced columns and the widgets are arranged vertically.
    &quot;columns&quot;: [ # The columns of content to display.
      { # Defines the layout properties and content for a column.
        &quot;weight&quot;: &quot;A String&quot;, # The relative weight of this column. The column weight is used to adjust the width of columns on the screen (relative to peers). Greater the weight, greater the width of the column on the screen. If omitted, a value of 1 is used while rendering.
        &quot;widgets&quot;: [ # The display widgets arranged vertically in this column.
          { # Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
            &quot;alertChart&quot;: { # A chart that displays alert policy data. # A chart of alert policy data.
              &quot;name&quot;: &quot;A String&quot;, # Required. The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
            },
            &quot;blank&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # A blank space.
            },
            &quot;collapsibleGroup&quot;: { # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
              &quot;collapsed&quot;: True or False, # The collapsed state of the widget on first page load.
            },
            &quot;errorReportingPanel&quot;: { # A widget that displays a list of error groups. # A widget that displays a list of error groups.
              &quot;projectNames&quot;: [ # The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
                &quot;A String&quot;,
              ],
              &quot;services&quot;: [ # An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
                &quot;A String&quot;,
              ],
              &quot;versions&quot;: [ # Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
                &quot;A String&quot;,
              ],
            },
            &quot;id&quot;: &quot;A String&quot;, # Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
            &quot;incidentList&quot;: { # A widget that displays a list of incidents # A widget that shows list of incidents.
              &quot;monitoredResources&quot;: [ # Optional. The monitored resource for which incidents are listed. The resource doesn&#x27;t need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
                { # An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource&#x27;s schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for &quot;gce_instance&quot; has labels &quot;project_id&quot;, &quot;instance_id&quot; and &quot;zone&quot;: { &quot;type&quot;: &quot;gce_instance&quot;, &quot;labels&quot;: { &quot;project_id&quot;: &quot;my-project&quot;, &quot;instance_id&quot;: &quot;12345678901234&quot;, &quot;zone&quot;: &quot;us-central1-a&quot; }}
                  &quot;labels&quot;: { # Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels &quot;project_id&quot;, &quot;instance_id&quot;, and &quot;zone&quot;.
                    &quot;a_key&quot;: &quot;A String&quot;,
                  },
                  &quot;type&quot;: &quot;A String&quot;, # Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
                },
              ],
              &quot;policyNames&quot;: [ # Optional. A list of alert policy names to filter the incident list by. Don&#x27;t include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
                &quot;A String&quot;,
              ],
            },
            &quot;logsPanel&quot;: { # A widget that displays a stream of log. # A widget that shows a stream of logs.
              &quot;filter&quot;: &quot;A String&quot;, # A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
              &quot;resourceNames&quot;: [ # The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
                &quot;A String&quot;,
              ],
            },
            &quot;pieChart&quot;: { # A widget that displays timeseries data as a pie or a donut. # A widget that displays timeseries data as a pie chart.
              &quot;chartType&quot;: &quot;A String&quot;, # Required. Indicates the visualization type for the PieChart.
              &quot;dataSets&quot;: [ # Required. The queries for the chart&#x27;s data.
                { # Groups a time series query definition.
                  &quot;dimensions&quot;: [ # A dimension is a structured label, class, or category for a set of measurements in your data.
                    { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                      &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                      &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                      &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                      &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                      &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                      &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                    },
                  ],
                  &quot;measures&quot;: [ # A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                    { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                    },
                  ],
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;sliceNameTemplate&quot;: &quot;A String&quot;, # Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone&#x27;s value will be used for the name instead of the default name.
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;showLabels&quot;: True or False, # Optional. Indicates whether or not the pie chart should show slices&#x27; labels
            },
            &quot;scorecard&quot;: { # A widget showing the latest value of a metric, and how this value relates to one or more thresholds. # A scorecard summarizing time series data.
              &quot;blankView&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
              },
              &quot;dimensions&quot;: [ # Optional. A dimension is a structured label, class, or category for a set of measurements in your data.
                { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                  &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                  &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                  &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                  &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                  &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                  &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                  &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                },
              ],
              &quot;gaugeView&quot;: { # A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard&#x27;s query (inclusive). # Will cause the scorecard to show a gauge chart.
                &quot;lowerBound&quot;: 3.14, # The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
                &quot;upperBound&quot;: 3.14, # The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
              },
              &quot;measures&quot;: [ # Optional. A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                  &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                    &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                      { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                        &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                        &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                      },
                    ],
                    &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                  },
                  &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                },
              ],
              &quot;sparkChartView&quot;: { # A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard&#x27;s timeseries. # Will cause the scorecard to show a spark chart.
                &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
                &quot;sparkChartType&quot;: &quot;A String&quot;, # Required. The type of sparkchart to show in this chartView.
              },
              &quot;thresholds&quot;: [ # The thresholds used to determine the state of the scorecard given the time series&#x27; current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: &#x27;DANGER&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 70, category: &#x27;WARNING&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 10, category: &#x27;DANGER&#x27;, trigger: &#x27;BELOW&#x27;, }, { value: 20, category: &#x27;WARNING&#x27;, trigger: &#x27;BELOW&#x27;, } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
                { # Defines a threshold for categorizing time series values.
                  &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                  &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                  &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                  &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                },
              ],
              &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                  &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                },
                &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                  &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
              },
            },
            &quot;sectionHeader&quot;: { # A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content. # A widget that defines a section header for easier navigation of the dashboard.
              &quot;dividerBelow&quot;: True or False, # Whether to insert a divider below the section in the table of contents
              &quot;subtitle&quot;: &quot;A String&quot;, # The subtitle of the section
            },
            &quot;singleViewGroup&quot;: { # A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets by using a dropdown menu.
            },
            &quot;text&quot;: { # A widget that displays textual content. # A raw string or markdown displaying textual content.
              &quot;content&quot;: &quot;A String&quot;, # The text content to be displayed.
              &quot;format&quot;: &quot;A String&quot;, # How the text content is formatted.
              &quot;style&quot;: { # Properties that determine how the title and content are styled # How the text is styled
                &quot;backgroundColor&quot;: &quot;A String&quot;, # The background color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                &quot;fontSize&quot;: &quot;A String&quot;, # Font sizes for both the title and content. The title will still be larger relative to the content.
                &quot;horizontalAlignment&quot;: &quot;A String&quot;, # The horizontal alignment of both the title and content
                &quot;padding&quot;: &quot;A String&quot;, # The amount of padding around the widget
                &quot;pointerLocation&quot;: &quot;A String&quot;, # The pointer location for this widget (also sometimes called a &quot;tail&quot;)
                &quot;textColor&quot;: &quot;A String&quot;, # The text color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                &quot;verticalAlignment&quot;: &quot;A String&quot;, # The vertical alignment of both the title and content
              },
            },
            &quot;timeSeriesTable&quot;: { # A table that displays time series data. # A widget that displays time series data in a tabular format.
              &quot;columnSettings&quot;: [ # Optional. The list of the persistent column settings for the table.
                { # The persistent settings for a table&#x27;s columns.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The id of the column.
                  &quot;visible&quot;: True or False, # Required. Whether the column should be visible on page load.
                },
              ],
              &quot;dataSets&quot;: [ # Required. The data displayed in this table.
                { # Groups a time series query definition with table options.
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;tableDisplayOptions&quot;: { # Table display options that can be reused. # Optional. Table display options for configuring how the table is rendered.
                    &quot;shownColumns&quot;: [ # Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
                      &quot;A String&quot;,
                    ],
                  },
                  &quot;tableTemplate&quot;: &quot;A String&quot;, # Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value i.e. &quot;${resource.labels.project_id}.&quot;
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;metricVisualization&quot;: &quot;A String&quot;, # Optional. Store rendering strategy
            },
            &quot;title&quot;: &quot;A String&quot;, # Optional. The title of the widget.
            &quot;xyChart&quot;: { # A chart that displays data on a 2D (X and Y axes) plane. # A chart of time series data.
              &quot;chartOptions&quot;: { # Options to control visual rendering of a chart. # Display options for the chart.
                &quot;displayHorizontal&quot;: True or False, # Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
                &quot;mode&quot;: &quot;A String&quot;, # The chart mode.
              },
              &quot;dataSets&quot;: [ # Required. The data displayed in this chart.
                { # Groups a time series query definition with charting options.
                  &quot;breakdowns&quot;: [ # Optional. The collection of breakdowns to be applied to the dataset.
                    { # Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The Aggregation function is applied across all data in each breakdown created.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the dataset containing the breakdown values.
                      &quot;limit&quot;: 42, # Required. A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # Required. The sort order is applied to the values of the breakdown column.
                    },
                  ],
                  &quot;dimensions&quot;: [ # Optional. A collection of dimension columns.
                    { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                      &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                      &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                      &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                      &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                      &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                      &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                    },
                  ],
                  &quot;legendTemplate&quot;: &quot;A String&quot;, # A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value.
                  &quot;measures&quot;: [ # Optional. A collection of measures.
                    { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                    },
                  ],
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;plotType&quot;: &quot;A String&quot;, # How this data should be plotted on the chart.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # Optional. The target axis to use for plotting the metric.
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;thresholds&quot;: [ # Threshold lines drawn horizontally across the chart.
                { # Defines a threshold for categorizing time series values.
                  &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                  &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                  &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                  &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                },
              ],
              &quot;timeshiftDuration&quot;: &quot;A String&quot;, # The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
              &quot;xAxis&quot;: { # A chart axis. # The properties applied to the x-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
              &quot;y2Axis&quot;: { # A chart axis. # The properties applied to the y2-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
              &quot;yAxis&quot;: { # A chart axis. # The properties applied to the y-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
            },
          },
        ],
      },
    ],
  },
  &quot;dashboardFilters&quot;: [ # Filters to reduce the amount of data charted based on the filter criteria.
    { # A filter to reduce the amount of data charted in relevant widgets.
      &quot;filterType&quot;: &quot;A String&quot;, # The specified filter type
      &quot;labelKey&quot;: &quot;A String&quot;, # Required. The key for the label
      &quot;stringValue&quot;: &quot;A String&quot;, # A variable-length string value.
      &quot;templateVariable&quot;: &quot;A String&quot;, # The placeholder text that can be referenced in a filter string or MQL query. If omitted, the dashboard filter will be applied to all relevant widgets in the dashboard.
    },
  ],
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The mutable, human-readable name.
  &quot;etag&quot;: &quot;A String&quot;, # etag is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. An etag is returned in the response to GetDashboard, and users are expected to put that etag in the request to UpdateDashboard to ensure that their change will be applied to the same version of the Dashboard configuration. The field should not be passed during dashboard creation.
  &quot;gridLayout&quot;: { # A basic layout divides the available space into vertical columns of equal width and arranges a list of widgets using a row-first strategy. # Content is arranged with a basic layout that re-flows a simple list of informational elements like widgets or tiles.
    &quot;columns&quot;: &quot;A String&quot;, # The number of columns into which the view&#x27;s width is divided. If omitted or set to zero, a system default will be used while rendering.
    &quot;widgets&quot;: [ # The informational elements that are arranged into the columns row-first.
      { # Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
        &quot;alertChart&quot;: { # A chart that displays alert policy data. # A chart of alert policy data.
          &quot;name&quot;: &quot;A String&quot;, # Required. The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
        },
        &quot;blank&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # A blank space.
        },
        &quot;collapsibleGroup&quot;: { # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
          &quot;collapsed&quot;: True or False, # The collapsed state of the widget on first page load.
        },
        &quot;errorReportingPanel&quot;: { # A widget that displays a list of error groups. # A widget that displays a list of error groups.
          &quot;projectNames&quot;: [ # The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
            &quot;A String&quot;,
          ],
          &quot;services&quot;: [ # An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
            &quot;A String&quot;,
          ],
          &quot;versions&quot;: [ # Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
            &quot;A String&quot;,
          ],
        },
        &quot;id&quot;: &quot;A String&quot;, # Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
        &quot;incidentList&quot;: { # A widget that displays a list of incidents # A widget that shows list of incidents.
          &quot;monitoredResources&quot;: [ # Optional. The monitored resource for which incidents are listed. The resource doesn&#x27;t need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
            { # An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource&#x27;s schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for &quot;gce_instance&quot; has labels &quot;project_id&quot;, &quot;instance_id&quot; and &quot;zone&quot;: { &quot;type&quot;: &quot;gce_instance&quot;, &quot;labels&quot;: { &quot;project_id&quot;: &quot;my-project&quot;, &quot;instance_id&quot;: &quot;12345678901234&quot;, &quot;zone&quot;: &quot;us-central1-a&quot; }}
              &quot;labels&quot;: { # Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels &quot;project_id&quot;, &quot;instance_id&quot;, and &quot;zone&quot;.
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;type&quot;: &quot;A String&quot;, # Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
            },
          ],
          &quot;policyNames&quot;: [ # Optional. A list of alert policy names to filter the incident list by. Don&#x27;t include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
            &quot;A String&quot;,
          ],
        },
        &quot;logsPanel&quot;: { # A widget that displays a stream of log. # A widget that shows a stream of logs.
          &quot;filter&quot;: &quot;A String&quot;, # A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
          &quot;resourceNames&quot;: [ # The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
            &quot;A String&quot;,
          ],
        },
        &quot;pieChart&quot;: { # A widget that displays timeseries data as a pie or a donut. # A widget that displays timeseries data as a pie chart.
          &quot;chartType&quot;: &quot;A String&quot;, # Required. Indicates the visualization type for the PieChart.
          &quot;dataSets&quot;: [ # Required. The queries for the chart&#x27;s data.
            { # Groups a time series query definition.
              &quot;dimensions&quot;: [ # A dimension is a structured label, class, or category for a set of measurements in your data.
                { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                  &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                  &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                  &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                  &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                  &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                  &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                  &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                },
              ],
              &quot;measures&quot;: [ # A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                  &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                    &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                      { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                        &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                        &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                      },
                    ],
                    &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                  },
                  &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                },
              ],
              &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
              &quot;sliceNameTemplate&quot;: &quot;A String&quot;, # Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone&#x27;s value will be used for the name instead of the default name.
              &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
                &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                  &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                },
                &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                  &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
              },
            },
          ],
          &quot;showLabels&quot;: True or False, # Optional. Indicates whether or not the pie chart should show slices&#x27; labels
        },
        &quot;scorecard&quot;: { # A widget showing the latest value of a metric, and how this value relates to one or more thresholds. # A scorecard summarizing time series data.
          &quot;blankView&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
          },
          &quot;dimensions&quot;: [ # Optional. A dimension is a structured label, class, or category for a set of measurements in your data.
            { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
              &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
              &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
              &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
              &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
              &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
              &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
              &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
              &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
            },
          ],
          &quot;gaugeView&quot;: { # A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard&#x27;s query (inclusive). # Will cause the scorecard to show a gauge chart.
            &quot;lowerBound&quot;: 3.14, # The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
            &quot;upperBound&quot;: 3.14, # The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
          },
          &quot;measures&quot;: [ # Optional. A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
            { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
              &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                  { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                    &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                    &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                  },
                ],
                &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
              },
              &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
            },
          ],
          &quot;sparkChartView&quot;: { # A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard&#x27;s timeseries. # Will cause the scorecard to show a spark chart.
            &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
            &quot;sparkChartType&quot;: &quot;A String&quot;, # Required. The type of sparkchart to show in this chartView.
          },
          &quot;thresholds&quot;: [ # The thresholds used to determine the state of the scorecard given the time series&#x27; current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: &#x27;DANGER&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 70, category: &#x27;WARNING&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 10, category: &#x27;DANGER&#x27;, trigger: &#x27;BELOW&#x27;, }, { value: 20, category: &#x27;WARNING&#x27;, trigger: &#x27;BELOW&#x27;, } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
            { # Defines a threshold for categorizing time series values.
              &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
              &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
              &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
              &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
              &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
            },
          ],
          &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
            &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
              &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
            },
            &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
            &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
            &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
              &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                  &quot;A String&quot;,
                ],
                &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
              },
              &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
              &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                  &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                  &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                },
                &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
              },
              &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                  &quot;A String&quot;,
                ],
                &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
              },
              &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                &quot;numTimeSeries&quot;: 42, # How many time series to output.
                &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
              },
            },
            &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
              &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                  &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                  &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                  &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                    &quot;A String&quot;,
                  ],
                  &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                },
                &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
              },
              &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                  &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                  &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                  &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                    &quot;A String&quot;,
                  ],
                  &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                },
                &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
              },
              &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                  &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                  &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                },
                &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
              },
              &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                  &quot;A String&quot;,
                ],
                &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
              },
              &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                &quot;numTimeSeries&quot;: 42, # How many time series to output.
                &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
              },
            },
            &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
            &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
          },
        },
        &quot;sectionHeader&quot;: { # A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content. # A widget that defines a section header for easier navigation of the dashboard.
          &quot;dividerBelow&quot;: True or False, # Whether to insert a divider below the section in the table of contents
          &quot;subtitle&quot;: &quot;A String&quot;, # The subtitle of the section
        },
        &quot;singleViewGroup&quot;: { # A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets by using a dropdown menu.
        },
        &quot;text&quot;: { # A widget that displays textual content. # A raw string or markdown displaying textual content.
          &quot;content&quot;: &quot;A String&quot;, # The text content to be displayed.
          &quot;format&quot;: &quot;A String&quot;, # How the text content is formatted.
          &quot;style&quot;: { # Properties that determine how the title and content are styled # How the text is styled
            &quot;backgroundColor&quot;: &quot;A String&quot;, # The background color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
            &quot;fontSize&quot;: &quot;A String&quot;, # Font sizes for both the title and content. The title will still be larger relative to the content.
            &quot;horizontalAlignment&quot;: &quot;A String&quot;, # The horizontal alignment of both the title and content
            &quot;padding&quot;: &quot;A String&quot;, # The amount of padding around the widget
            &quot;pointerLocation&quot;: &quot;A String&quot;, # The pointer location for this widget (also sometimes called a &quot;tail&quot;)
            &quot;textColor&quot;: &quot;A String&quot;, # The text color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
            &quot;verticalAlignment&quot;: &quot;A String&quot;, # The vertical alignment of both the title and content
          },
        },
        &quot;timeSeriesTable&quot;: { # A table that displays time series data. # A widget that displays time series data in a tabular format.
          &quot;columnSettings&quot;: [ # Optional. The list of the persistent column settings for the table.
            { # The persistent settings for a table&#x27;s columns.
              &quot;column&quot;: &quot;A String&quot;, # Required. The id of the column.
              &quot;visible&quot;: True or False, # Required. Whether the column should be visible on page load.
            },
          ],
          &quot;dataSets&quot;: [ # Required. The data displayed in this table.
            { # Groups a time series query definition with table options.
              &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
              &quot;tableDisplayOptions&quot;: { # Table display options that can be reused. # Optional. Table display options for configuring how the table is rendered.
                &quot;shownColumns&quot;: [ # Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
                  &quot;A String&quot;,
                ],
              },
              &quot;tableTemplate&quot;: &quot;A String&quot;, # Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value i.e. &quot;${resource.labels.project_id}.&quot;
              &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                  &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                },
                &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                  &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
              },
            },
          ],
          &quot;metricVisualization&quot;: &quot;A String&quot;, # Optional. Store rendering strategy
        },
        &quot;title&quot;: &quot;A String&quot;, # Optional. The title of the widget.
        &quot;xyChart&quot;: { # A chart that displays data on a 2D (X and Y axes) plane. # A chart of time series data.
          &quot;chartOptions&quot;: { # Options to control visual rendering of a chart. # Display options for the chart.
            &quot;displayHorizontal&quot;: True or False, # Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
            &quot;mode&quot;: &quot;A String&quot;, # The chart mode.
          },
          &quot;dataSets&quot;: [ # Required. The data displayed in this chart.
            { # Groups a time series query definition with charting options.
              &quot;breakdowns&quot;: [ # Optional. The collection of breakdowns to be applied to the dataset.
                { # Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
                  &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The Aggregation function is applied across all data in each breakdown created.
                    &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                      { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                        &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                        &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                      },
                    ],
                    &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                  },
                  &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the dataset containing the breakdown values.
                  &quot;limit&quot;: 42, # Required. A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
                  &quot;sortOrder&quot;: &quot;A String&quot;, # Required. The sort order is applied to the values of the breakdown column.
                },
              ],
              &quot;dimensions&quot;: [ # Optional. A collection of dimension columns.
                { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                  &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                  &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                  &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                  &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                  &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                  &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                  &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                },
              ],
              &quot;legendTemplate&quot;: &quot;A String&quot;, # A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value.
              &quot;measures&quot;: [ # Optional. A collection of measures.
                { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                  &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                    &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                      { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                        &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                        &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                      },
                    ],
                    &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                  },
                  &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                },
              ],
              &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
              &quot;plotType&quot;: &quot;A String&quot;, # How this data should be plotted on the chart.
              &quot;targetAxis&quot;: &quot;A String&quot;, # Optional. The target axis to use for plotting the metric.
              &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                  &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                },
                &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                  &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
              },
            },
          ],
          &quot;thresholds&quot;: [ # Threshold lines drawn horizontally across the chart.
            { # Defines a threshold for categorizing time series values.
              &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
              &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
              &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
              &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
              &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
            },
          ],
          &quot;timeshiftDuration&quot;: &quot;A String&quot;, # The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
          &quot;xAxis&quot;: { # A chart axis. # The properties applied to the x-axis.
            &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
            &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
          },
          &quot;y2Axis&quot;: { # A chart axis. # The properties applied to the y2-axis.
            &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
            &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
          },
          &quot;yAxis&quot;: { # A chart axis. # The properties applied to the y-axis.
            &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
            &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
          },
        },
      },
    ],
  },
  &quot;labels&quot;: { # Labels applied to the dashboard
    &quot;a_key&quot;: &quot;A String&quot;,
  },
  &quot;mosaicLayout&quot;: { # A mosaic layout divides the available space into a grid of blocks, and overlays the grid with tiles. Unlike GridLayout, tiles may span multiple grid blocks and can be placed at arbitrary locations in the grid. # The content is arranged as a grid of tiles, with each content widget occupying one or more grid blocks.
    &quot;columns&quot;: 42, # The number of columns in the mosaic grid. The number of columns must be between 1 and 12, inclusive.
    &quot;tiles&quot;: [ # The tiles to display.
      { # A single tile in the mosaic. The placement and size of the tile are configurable.
        &quot;height&quot;: 42, # The height of the tile, measured in grid blocks. Tiles must have a minimum height of 1.
        &quot;widget&quot;: { # Widget contains a single dashboard component and configuration of how to present the component in the dashboard. # The informational widget contained in the tile. For example an XyChart.
          &quot;alertChart&quot;: { # A chart that displays alert policy data. # A chart of alert policy data.
            &quot;name&quot;: &quot;A String&quot;, # Required. The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
          },
          &quot;blank&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # A blank space.
          },
          &quot;collapsibleGroup&quot;: { # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
            &quot;collapsed&quot;: True or False, # The collapsed state of the widget on first page load.
          },
          &quot;errorReportingPanel&quot;: { # A widget that displays a list of error groups. # A widget that displays a list of error groups.
            &quot;projectNames&quot;: [ # The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
              &quot;A String&quot;,
            ],
            &quot;services&quot;: [ # An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
              &quot;A String&quot;,
            ],
            &quot;versions&quot;: [ # Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
              &quot;A String&quot;,
            ],
          },
          &quot;id&quot;: &quot;A String&quot;, # Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
          &quot;incidentList&quot;: { # A widget that displays a list of incidents # A widget that shows list of incidents.
            &quot;monitoredResources&quot;: [ # Optional. The monitored resource for which incidents are listed. The resource doesn&#x27;t need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
              { # An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource&#x27;s schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for &quot;gce_instance&quot; has labels &quot;project_id&quot;, &quot;instance_id&quot; and &quot;zone&quot;: { &quot;type&quot;: &quot;gce_instance&quot;, &quot;labels&quot;: { &quot;project_id&quot;: &quot;my-project&quot;, &quot;instance_id&quot;: &quot;12345678901234&quot;, &quot;zone&quot;: &quot;us-central1-a&quot; }}
                &quot;labels&quot;: { # Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels &quot;project_id&quot;, &quot;instance_id&quot;, and &quot;zone&quot;.
                  &quot;a_key&quot;: &quot;A String&quot;,
                },
                &quot;type&quot;: &quot;A String&quot;, # Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
              },
            ],
            &quot;policyNames&quot;: [ # Optional. A list of alert policy names to filter the incident list by. Don&#x27;t include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
              &quot;A String&quot;,
            ],
          },
          &quot;logsPanel&quot;: { # A widget that displays a stream of log. # A widget that shows a stream of logs.
            &quot;filter&quot;: &quot;A String&quot;, # A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
            &quot;resourceNames&quot;: [ # The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
              &quot;A String&quot;,
            ],
          },
          &quot;pieChart&quot;: { # A widget that displays timeseries data as a pie or a donut. # A widget that displays timeseries data as a pie chart.
            &quot;chartType&quot;: &quot;A String&quot;, # Required. Indicates the visualization type for the PieChart.
            &quot;dataSets&quot;: [ # Required. The queries for the chart&#x27;s data.
              { # Groups a time series query definition.
                &quot;dimensions&quot;: [ # A dimension is a structured label, class, or category for a set of measurements in your data.
                  { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                    &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                    &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                    &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                    &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                    &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                    &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                    &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                    &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                  },
                ],
                &quot;measures&quot;: [ # A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                  { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                    &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                      &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                        { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                          &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                          &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                        },
                      ],
                      &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                    },
                    &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                  },
                ],
                &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                &quot;sliceNameTemplate&quot;: &quot;A String&quot;, # Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone&#x27;s value will be used for the name instead of the default name.
                &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
                  &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                    &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                  },
                  &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                  &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                  &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                    &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                  &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                },
              },
            ],
            &quot;showLabels&quot;: True or False, # Optional. Indicates whether or not the pie chart should show slices&#x27; labels
          },
          &quot;scorecard&quot;: { # A widget showing the latest value of a metric, and how this value relates to one or more thresholds. # A scorecard summarizing time series data.
            &quot;blankView&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
            },
            &quot;dimensions&quot;: [ # Optional. A dimension is a structured label, class, or category for a set of measurements in your data.
              { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
              },
            ],
            &quot;gaugeView&quot;: { # A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard&#x27;s query (inclusive). # Will cause the scorecard to show a gauge chart.
              &quot;lowerBound&quot;: 3.14, # The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
              &quot;upperBound&quot;: 3.14, # The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
            },
            &quot;measures&quot;: [ # Optional. A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
              { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                  &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                    { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                      &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                      &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                    },
                  ],
                  &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                },
                &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
              },
            ],
            &quot;sparkChartView&quot;: { # A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard&#x27;s timeseries. # Will cause the scorecard to show a spark chart.
              &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
              &quot;sparkChartType&quot;: &quot;A String&quot;, # Required. The type of sparkchart to show in this chartView.
            },
            &quot;thresholds&quot;: [ # The thresholds used to determine the state of the scorecard given the time series&#x27; current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: &#x27;DANGER&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 70, category: &#x27;WARNING&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 10, category: &#x27;DANGER&#x27;, trigger: &#x27;BELOW&#x27;, }, { value: 20, category: &#x27;WARNING&#x27;, trigger: &#x27;BELOW&#x27;, } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
              { # Defines a threshold for categorizing time series values.
                &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
              },
            ],
            &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
              &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
              },
              &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
              &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
              &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                  &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                  &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                  &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                    &quot;A String&quot;,
                  ],
                  &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                },
                &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                  &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                  &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                    &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                    &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                  },
                  &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                  &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                },
                &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                  &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                  &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                  &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                    &quot;A String&quot;,
                  ],
                  &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                },
                &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                  &quot;numTimeSeries&quot;: 42, # How many time series to output.
                  &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                },
              },
              &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                },
                &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                },
                &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                  &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                  &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                    &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                    &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                  },
                  &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                  &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                },
                &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                  &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                  &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                  &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                    &quot;A String&quot;,
                  ],
                  &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                },
                &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                  &quot;numTimeSeries&quot;: 42, # How many time series to output.
                  &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                },
              },
              &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
              &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
            },
          },
          &quot;sectionHeader&quot;: { # A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content. # A widget that defines a section header for easier navigation of the dashboard.
            &quot;dividerBelow&quot;: True or False, # Whether to insert a divider below the section in the table of contents
            &quot;subtitle&quot;: &quot;A String&quot;, # The subtitle of the section
          },
          &quot;singleViewGroup&quot;: { # A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets by using a dropdown menu.
          },
          &quot;text&quot;: { # A widget that displays textual content. # A raw string or markdown displaying textual content.
            &quot;content&quot;: &quot;A String&quot;, # The text content to be displayed.
            &quot;format&quot;: &quot;A String&quot;, # How the text content is formatted.
            &quot;style&quot;: { # Properties that determine how the title and content are styled # How the text is styled
              &quot;backgroundColor&quot;: &quot;A String&quot;, # The background color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
              &quot;fontSize&quot;: &quot;A String&quot;, # Font sizes for both the title and content. The title will still be larger relative to the content.
              &quot;horizontalAlignment&quot;: &quot;A String&quot;, # The horizontal alignment of both the title and content
              &quot;padding&quot;: &quot;A String&quot;, # The amount of padding around the widget
              &quot;pointerLocation&quot;: &quot;A String&quot;, # The pointer location for this widget (also sometimes called a &quot;tail&quot;)
              &quot;textColor&quot;: &quot;A String&quot;, # The text color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
              &quot;verticalAlignment&quot;: &quot;A String&quot;, # The vertical alignment of both the title and content
            },
          },
          &quot;timeSeriesTable&quot;: { # A table that displays time series data. # A widget that displays time series data in a tabular format.
            &quot;columnSettings&quot;: [ # Optional. The list of the persistent column settings for the table.
              { # The persistent settings for a table&#x27;s columns.
                &quot;column&quot;: &quot;A String&quot;, # Required. The id of the column.
                &quot;visible&quot;: True or False, # Required. Whether the column should be visible on page load.
              },
            ],
            &quot;dataSets&quot;: [ # Required. The data displayed in this table.
              { # Groups a time series query definition with table options.
                &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                &quot;tableDisplayOptions&quot;: { # Table display options that can be reused. # Optional. Table display options for configuring how the table is rendered.
                  &quot;shownColumns&quot;: [ # Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
                    &quot;A String&quot;,
                  ],
                },
                &quot;tableTemplate&quot;: &quot;A String&quot;, # Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value i.e. &quot;${resource.labels.project_id}.&quot;
                &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                  &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                    &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                  },
                  &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                  &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                  &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                    &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                  &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                },
              },
            ],
            &quot;metricVisualization&quot;: &quot;A String&quot;, # Optional. Store rendering strategy
          },
          &quot;title&quot;: &quot;A String&quot;, # Optional. The title of the widget.
          &quot;xyChart&quot;: { # A chart that displays data on a 2D (X and Y axes) plane. # A chart of time series data.
            &quot;chartOptions&quot;: { # Options to control visual rendering of a chart. # Display options for the chart.
              &quot;displayHorizontal&quot;: True or False, # Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
              &quot;mode&quot;: &quot;A String&quot;, # The chart mode.
            },
            &quot;dataSets&quot;: [ # Required. The data displayed in this chart.
              { # Groups a time series query definition with charting options.
                &quot;breakdowns&quot;: [ # Optional. The collection of breakdowns to be applied to the dataset.
                  { # Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
                    &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The Aggregation function is applied across all data in each breakdown created.
                      &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                        { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                          &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                          &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                        },
                      ],
                      &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                    },
                    &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the dataset containing the breakdown values.
                    &quot;limit&quot;: 42, # Required. A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
                    &quot;sortOrder&quot;: &quot;A String&quot;, # Required. The sort order is applied to the values of the breakdown column.
                  },
                ],
                &quot;dimensions&quot;: [ # Optional. A collection of dimension columns.
                  { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                    &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                    &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                    &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                    &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                    &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                    &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                    &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                    &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                  },
                ],
                &quot;legendTemplate&quot;: &quot;A String&quot;, # A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value.
                &quot;measures&quot;: [ # Optional. A collection of measures.
                  { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                    &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                      &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                        { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                          &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                          &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                        },
                      ],
                      &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                    },
                    &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                  },
                ],
                &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                &quot;plotType&quot;: &quot;A String&quot;, # How this data should be plotted on the chart.
                &quot;targetAxis&quot;: &quot;A String&quot;, # Optional. The target axis to use for plotting the metric.
                &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                  &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                    &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                  },
                  &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                  &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                  &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                    &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                  &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                },
              },
            ],
            &quot;thresholds&quot;: [ # Threshold lines drawn horizontally across the chart.
              { # Defines a threshold for categorizing time series values.
                &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
              },
            ],
            &quot;timeshiftDuration&quot;: &quot;A String&quot;, # The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
            &quot;xAxis&quot;: { # A chart axis. # The properties applied to the x-axis.
              &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
              &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
            },
            &quot;y2Axis&quot;: { # A chart axis. # The properties applied to the y2-axis.
              &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
              &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
            },
            &quot;yAxis&quot;: { # A chart axis. # The properties applied to the y-axis.
              &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
              &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
            },
          },
        },
        &quot;width&quot;: 42, # The width of the tile, measured in grid blocks. Tiles must have a minimum width of 1.
        &quot;xPos&quot;: 42, # The zero-indexed position of the tile in grid blocks relative to the left edge of the grid. Tiles must be contained within the specified number of columns. x_pos cannot be negative.
        &quot;yPos&quot;: 42, # The zero-indexed position of the tile in grid blocks relative to the top edge of the grid. y_pos cannot be negative.
      },
    ],
  },
  &quot;name&quot;: &quot;A String&quot;, # Identifier. The resource name of the dashboard.
  &quot;rowLayout&quot;: { # A simplified layout that divides the available space into rows and arranges a set of widgets horizontally in each row. # The content is divided into equally spaced rows and the widgets are arranged horizontally.
    &quot;rows&quot;: [ # The rows of content to display.
      { # Defines the layout properties and content for a row.
        &quot;weight&quot;: &quot;A String&quot;, # The relative weight of this row. The row weight is used to adjust the height of rows on the screen (relative to peers). Greater the weight, greater the height of the row on the screen. If omitted, a value of 1 is used while rendering.
        &quot;widgets&quot;: [ # The display widgets arranged horizontally in this row.
          { # Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
            &quot;alertChart&quot;: { # A chart that displays alert policy data. # A chart of alert policy data.
              &quot;name&quot;: &quot;A String&quot;, # Required. The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
            },
            &quot;blank&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # A blank space.
            },
            &quot;collapsibleGroup&quot;: { # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
              &quot;collapsed&quot;: True or False, # The collapsed state of the widget on first page load.
            },
            &quot;errorReportingPanel&quot;: { # A widget that displays a list of error groups. # A widget that displays a list of error groups.
              &quot;projectNames&quot;: [ # The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
                &quot;A String&quot;,
              ],
              &quot;services&quot;: [ # An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
                &quot;A String&quot;,
              ],
              &quot;versions&quot;: [ # Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
                &quot;A String&quot;,
              ],
            },
            &quot;id&quot;: &quot;A String&quot;, # Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
            &quot;incidentList&quot;: { # A widget that displays a list of incidents # A widget that shows list of incidents.
              &quot;monitoredResources&quot;: [ # Optional. The monitored resource for which incidents are listed. The resource doesn&#x27;t need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
                { # An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource&#x27;s schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for &quot;gce_instance&quot; has labels &quot;project_id&quot;, &quot;instance_id&quot; and &quot;zone&quot;: { &quot;type&quot;: &quot;gce_instance&quot;, &quot;labels&quot;: { &quot;project_id&quot;: &quot;my-project&quot;, &quot;instance_id&quot;: &quot;12345678901234&quot;, &quot;zone&quot;: &quot;us-central1-a&quot; }}
                  &quot;labels&quot;: { # Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels &quot;project_id&quot;, &quot;instance_id&quot;, and &quot;zone&quot;.
                    &quot;a_key&quot;: &quot;A String&quot;,
                  },
                  &quot;type&quot;: &quot;A String&quot;, # Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
                },
              ],
              &quot;policyNames&quot;: [ # Optional. A list of alert policy names to filter the incident list by. Don&#x27;t include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
                &quot;A String&quot;,
              ],
            },
            &quot;logsPanel&quot;: { # A widget that displays a stream of log. # A widget that shows a stream of logs.
              &quot;filter&quot;: &quot;A String&quot;, # A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
              &quot;resourceNames&quot;: [ # The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
                &quot;A String&quot;,
              ],
            },
            &quot;pieChart&quot;: { # A widget that displays timeseries data as a pie or a donut. # A widget that displays timeseries data as a pie chart.
              &quot;chartType&quot;: &quot;A String&quot;, # Required. Indicates the visualization type for the PieChart.
              &quot;dataSets&quot;: [ # Required. The queries for the chart&#x27;s data.
                { # Groups a time series query definition.
                  &quot;dimensions&quot;: [ # A dimension is a structured label, class, or category for a set of measurements in your data.
                    { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                      &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                      &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                      &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                      &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                      &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                      &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                    },
                  ],
                  &quot;measures&quot;: [ # A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                    { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                    },
                  ],
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;sliceNameTemplate&quot;: &quot;A String&quot;, # Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone&#x27;s value will be used for the name instead of the default name.
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;showLabels&quot;: True or False, # Optional. Indicates whether or not the pie chart should show slices&#x27; labels
            },
            &quot;scorecard&quot;: { # A widget showing the latest value of a metric, and how this value relates to one or more thresholds. # A scorecard summarizing time series data.
              &quot;blankView&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
              },
              &quot;dimensions&quot;: [ # Optional. A dimension is a structured label, class, or category for a set of measurements in your data.
                { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                  &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                  &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                  &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                  &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                  &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                  &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                  &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                },
              ],
              &quot;gaugeView&quot;: { # A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard&#x27;s query (inclusive). # Will cause the scorecard to show a gauge chart.
                &quot;lowerBound&quot;: 3.14, # The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
                &quot;upperBound&quot;: 3.14, # The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
              },
              &quot;measures&quot;: [ # Optional. A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                  &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                    &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                      { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                        &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                        &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                      },
                    ],
                    &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                  },
                  &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                },
              ],
              &quot;sparkChartView&quot;: { # A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard&#x27;s timeseries. # Will cause the scorecard to show a spark chart.
                &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
                &quot;sparkChartType&quot;: &quot;A String&quot;, # Required. The type of sparkchart to show in this chartView.
              },
              &quot;thresholds&quot;: [ # The thresholds used to determine the state of the scorecard given the time series&#x27; current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: &#x27;DANGER&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 70, category: &#x27;WARNING&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 10, category: &#x27;DANGER&#x27;, trigger: &#x27;BELOW&#x27;, }, { value: 20, category: &#x27;WARNING&#x27;, trigger: &#x27;BELOW&#x27;, } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
                { # Defines a threshold for categorizing time series values.
                  &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                  &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                  &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                  &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                },
              ],
              &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                  &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                },
                &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                  &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
              },
            },
            &quot;sectionHeader&quot;: { # A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content. # A widget that defines a section header for easier navigation of the dashboard.
              &quot;dividerBelow&quot;: True or False, # Whether to insert a divider below the section in the table of contents
              &quot;subtitle&quot;: &quot;A String&quot;, # The subtitle of the section
            },
            &quot;singleViewGroup&quot;: { # A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets by using a dropdown menu.
            },
            &quot;text&quot;: { # A widget that displays textual content. # A raw string or markdown displaying textual content.
              &quot;content&quot;: &quot;A String&quot;, # The text content to be displayed.
              &quot;format&quot;: &quot;A String&quot;, # How the text content is formatted.
              &quot;style&quot;: { # Properties that determine how the title and content are styled # How the text is styled
                &quot;backgroundColor&quot;: &quot;A String&quot;, # The background color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                &quot;fontSize&quot;: &quot;A String&quot;, # Font sizes for both the title and content. The title will still be larger relative to the content.
                &quot;horizontalAlignment&quot;: &quot;A String&quot;, # The horizontal alignment of both the title and content
                &quot;padding&quot;: &quot;A String&quot;, # The amount of padding around the widget
                &quot;pointerLocation&quot;: &quot;A String&quot;, # The pointer location for this widget (also sometimes called a &quot;tail&quot;)
                &quot;textColor&quot;: &quot;A String&quot;, # The text color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                &quot;verticalAlignment&quot;: &quot;A String&quot;, # The vertical alignment of both the title and content
              },
            },
            &quot;timeSeriesTable&quot;: { # A table that displays time series data. # A widget that displays time series data in a tabular format.
              &quot;columnSettings&quot;: [ # Optional. The list of the persistent column settings for the table.
                { # The persistent settings for a table&#x27;s columns.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The id of the column.
                  &quot;visible&quot;: True or False, # Required. Whether the column should be visible on page load.
                },
              ],
              &quot;dataSets&quot;: [ # Required. The data displayed in this table.
                { # Groups a time series query definition with table options.
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;tableDisplayOptions&quot;: { # Table display options that can be reused. # Optional. Table display options for configuring how the table is rendered.
                    &quot;shownColumns&quot;: [ # Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
                      &quot;A String&quot;,
                    ],
                  },
                  &quot;tableTemplate&quot;: &quot;A String&quot;, # Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value i.e. &quot;${resource.labels.project_id}.&quot;
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;metricVisualization&quot;: &quot;A String&quot;, # Optional. Store rendering strategy
            },
            &quot;title&quot;: &quot;A String&quot;, # Optional. The title of the widget.
            &quot;xyChart&quot;: { # A chart that displays data on a 2D (X and Y axes) plane. # A chart of time series data.
              &quot;chartOptions&quot;: { # Options to control visual rendering of a chart. # Display options for the chart.
                &quot;displayHorizontal&quot;: True or False, # Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
                &quot;mode&quot;: &quot;A String&quot;, # The chart mode.
              },
              &quot;dataSets&quot;: [ # Required. The data displayed in this chart.
                { # Groups a time series query definition with charting options.
                  &quot;breakdowns&quot;: [ # Optional. The collection of breakdowns to be applied to the dataset.
                    { # Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The Aggregation function is applied across all data in each breakdown created.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the dataset containing the breakdown values.
                      &quot;limit&quot;: 42, # Required. A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # Required. The sort order is applied to the values of the breakdown column.
                    },
                  ],
                  &quot;dimensions&quot;: [ # Optional. A collection of dimension columns.
                    { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                      &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                      &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                      &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                      &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                      &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                      &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                    },
                  ],
                  &quot;legendTemplate&quot;: &quot;A String&quot;, # A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value.
                  &quot;measures&quot;: [ # Optional. A collection of measures.
                    { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                    },
                  ],
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;plotType&quot;: &quot;A String&quot;, # How this data should be plotted on the chart.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # Optional. The target axis to use for plotting the metric.
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;thresholds&quot;: [ # Threshold lines drawn horizontally across the chart.
                { # Defines a threshold for categorizing time series values.
                  &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                  &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                  &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                  &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                },
              ],
              &quot;timeshiftDuration&quot;: &quot;A String&quot;, # The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
              &quot;xAxis&quot;: { # A chart axis. # The properties applied to the x-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
              &quot;y2Axis&quot;: { # A chart axis. # The properties applied to the y2-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
              &quot;yAxis&quot;: { # A chart axis. # The properties applied to the y-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
            },
          },
        ],
      },
    ],
  },
}

  validateOnly: boolean, If set, validate the request and preview the review, but do not actually save it.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A Google Stackdriver dashboard. Dashboards define the content and layout of pages in the Stackdriver web application.
  &quot;annotations&quot;: { # Dashboard-level configuration for annotations # Configuration for event annotations to display on this dashboard.
    &quot;defaultResourceNames&quot;: [ # Dashboard level defaults for names of logging resources to search for events. Currently only projects are supported. Each individual EventAnnotation may have its own overrides. If both this field and the per annotation field is empty, then the scoping project is used. Limit: 50 projects. For example: “projects/some-project-id”
      &quot;A String&quot;,
    ],
    &quot;eventAnnotations&quot;: [ # List of annotation configurations for this dashboard. Each entry specifies one event type.
      { # Annotation configuration for one event type on a dashboard
        &quot;displayName&quot;: &quot;A String&quot;, # Solely for UI display. Should not be used programmatically.
        &quot;enabled&quot;: True or False, # Whether or not to show the events on the dashboard by default
        &quot;eventType&quot;: &quot;A String&quot;, # The type of event to display.
        &quot;filter&quot;: &quot;A String&quot;, # string filtering the events - event dependant. Example values: &quot;resource.labels.pod_name = &#x27;pod-1&#x27;&quot; &quot;protoPayload.authenticationInfo.principalEmail=&#x27;user@example.com&#x27;&quot;
        &quot;resourceNames&quot;: [ # Per annotation level override for the names of logging resources to search for events. Currently only projects are supported. If both this field and the per annotation field is empty, it will default to the host project. Limit: 50 projects. For example: “projects/another-project-id”
          &quot;A String&quot;,
        ],
      },
    ],
  },
  &quot;columnLayout&quot;: { # A simplified layout that divides the available space into vertical columns and arranges a set of widgets vertically in each column. # The content is divided into equally spaced columns and the widgets are arranged vertically.
    &quot;columns&quot;: [ # The columns of content to display.
      { # Defines the layout properties and content for a column.
        &quot;weight&quot;: &quot;A String&quot;, # The relative weight of this column. The column weight is used to adjust the width of columns on the screen (relative to peers). Greater the weight, greater the width of the column on the screen. If omitted, a value of 1 is used while rendering.
        &quot;widgets&quot;: [ # The display widgets arranged vertically in this column.
          { # Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
            &quot;alertChart&quot;: { # A chart that displays alert policy data. # A chart of alert policy data.
              &quot;name&quot;: &quot;A String&quot;, # Required. The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
            },
            &quot;blank&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # A blank space.
            },
            &quot;collapsibleGroup&quot;: { # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
              &quot;collapsed&quot;: True or False, # The collapsed state of the widget on first page load.
            },
            &quot;errorReportingPanel&quot;: { # A widget that displays a list of error groups. # A widget that displays a list of error groups.
              &quot;projectNames&quot;: [ # The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
                &quot;A String&quot;,
              ],
              &quot;services&quot;: [ # An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
                &quot;A String&quot;,
              ],
              &quot;versions&quot;: [ # Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
                &quot;A String&quot;,
              ],
            },
            &quot;id&quot;: &quot;A String&quot;, # Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
            &quot;incidentList&quot;: { # A widget that displays a list of incidents # A widget that shows list of incidents.
              &quot;monitoredResources&quot;: [ # Optional. The monitored resource for which incidents are listed. The resource doesn&#x27;t need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
                { # An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource&#x27;s schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for &quot;gce_instance&quot; has labels &quot;project_id&quot;, &quot;instance_id&quot; and &quot;zone&quot;: { &quot;type&quot;: &quot;gce_instance&quot;, &quot;labels&quot;: { &quot;project_id&quot;: &quot;my-project&quot;, &quot;instance_id&quot;: &quot;12345678901234&quot;, &quot;zone&quot;: &quot;us-central1-a&quot; }}
                  &quot;labels&quot;: { # Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels &quot;project_id&quot;, &quot;instance_id&quot;, and &quot;zone&quot;.
                    &quot;a_key&quot;: &quot;A String&quot;,
                  },
                  &quot;type&quot;: &quot;A String&quot;, # Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
                },
              ],
              &quot;policyNames&quot;: [ # Optional. A list of alert policy names to filter the incident list by. Don&#x27;t include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
                &quot;A String&quot;,
              ],
            },
            &quot;logsPanel&quot;: { # A widget that displays a stream of log. # A widget that shows a stream of logs.
              &quot;filter&quot;: &quot;A String&quot;, # A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
              &quot;resourceNames&quot;: [ # The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
                &quot;A String&quot;,
              ],
            },
            &quot;pieChart&quot;: { # A widget that displays timeseries data as a pie or a donut. # A widget that displays timeseries data as a pie chart.
              &quot;chartType&quot;: &quot;A String&quot;, # Required. Indicates the visualization type for the PieChart.
              &quot;dataSets&quot;: [ # Required. The queries for the chart&#x27;s data.
                { # Groups a time series query definition.
                  &quot;dimensions&quot;: [ # A dimension is a structured label, class, or category for a set of measurements in your data.
                    { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                      &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                      &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                      &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                      &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                      &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                      &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                    },
                  ],
                  &quot;measures&quot;: [ # A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                    { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                    },
                  ],
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;sliceNameTemplate&quot;: &quot;A String&quot;, # Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone&#x27;s value will be used for the name instead of the default name.
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;showLabels&quot;: True or False, # Optional. Indicates whether or not the pie chart should show slices&#x27; labels
            },
            &quot;scorecard&quot;: { # A widget showing the latest value of a metric, and how this value relates to one or more thresholds. # A scorecard summarizing time series data.
              &quot;blankView&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
              },
              &quot;dimensions&quot;: [ # Optional. A dimension is a structured label, class, or category for a set of measurements in your data.
                { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                  &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                  &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                  &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                  &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                  &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                  &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                  &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                },
              ],
              &quot;gaugeView&quot;: { # A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard&#x27;s query (inclusive). # Will cause the scorecard to show a gauge chart.
                &quot;lowerBound&quot;: 3.14, # The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
                &quot;upperBound&quot;: 3.14, # The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
              },
              &quot;measures&quot;: [ # Optional. A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                  &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                    &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                      { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                        &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                        &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                      },
                    ],
                    &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                  },
                  &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                },
              ],
              &quot;sparkChartView&quot;: { # A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard&#x27;s timeseries. # Will cause the scorecard to show a spark chart.
                &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
                &quot;sparkChartType&quot;: &quot;A String&quot;, # Required. The type of sparkchart to show in this chartView.
              },
              &quot;thresholds&quot;: [ # The thresholds used to determine the state of the scorecard given the time series&#x27; current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: &#x27;DANGER&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 70, category: &#x27;WARNING&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 10, category: &#x27;DANGER&#x27;, trigger: &#x27;BELOW&#x27;, }, { value: 20, category: &#x27;WARNING&#x27;, trigger: &#x27;BELOW&#x27;, } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
                { # Defines a threshold for categorizing time series values.
                  &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                  &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                  &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                  &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                },
              ],
              &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                  &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                },
                &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                  &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
              },
            },
            &quot;sectionHeader&quot;: { # A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content. # A widget that defines a section header for easier navigation of the dashboard.
              &quot;dividerBelow&quot;: True or False, # Whether to insert a divider below the section in the table of contents
              &quot;subtitle&quot;: &quot;A String&quot;, # The subtitle of the section
            },
            &quot;singleViewGroup&quot;: { # A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets by using a dropdown menu.
            },
            &quot;text&quot;: { # A widget that displays textual content. # A raw string or markdown displaying textual content.
              &quot;content&quot;: &quot;A String&quot;, # The text content to be displayed.
              &quot;format&quot;: &quot;A String&quot;, # How the text content is formatted.
              &quot;style&quot;: { # Properties that determine how the title and content are styled # How the text is styled
                &quot;backgroundColor&quot;: &quot;A String&quot;, # The background color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                &quot;fontSize&quot;: &quot;A String&quot;, # Font sizes for both the title and content. The title will still be larger relative to the content.
                &quot;horizontalAlignment&quot;: &quot;A String&quot;, # The horizontal alignment of both the title and content
                &quot;padding&quot;: &quot;A String&quot;, # The amount of padding around the widget
                &quot;pointerLocation&quot;: &quot;A String&quot;, # The pointer location for this widget (also sometimes called a &quot;tail&quot;)
                &quot;textColor&quot;: &quot;A String&quot;, # The text color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                &quot;verticalAlignment&quot;: &quot;A String&quot;, # The vertical alignment of both the title and content
              },
            },
            &quot;timeSeriesTable&quot;: { # A table that displays time series data. # A widget that displays time series data in a tabular format.
              &quot;columnSettings&quot;: [ # Optional. The list of the persistent column settings for the table.
                { # The persistent settings for a table&#x27;s columns.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The id of the column.
                  &quot;visible&quot;: True or False, # Required. Whether the column should be visible on page load.
                },
              ],
              &quot;dataSets&quot;: [ # Required. The data displayed in this table.
                { # Groups a time series query definition with table options.
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;tableDisplayOptions&quot;: { # Table display options that can be reused. # Optional. Table display options for configuring how the table is rendered.
                    &quot;shownColumns&quot;: [ # Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
                      &quot;A String&quot;,
                    ],
                  },
                  &quot;tableTemplate&quot;: &quot;A String&quot;, # Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value i.e. &quot;${resource.labels.project_id}.&quot;
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;metricVisualization&quot;: &quot;A String&quot;, # Optional. Store rendering strategy
            },
            &quot;title&quot;: &quot;A String&quot;, # Optional. The title of the widget.
            &quot;xyChart&quot;: { # A chart that displays data on a 2D (X and Y axes) plane. # A chart of time series data.
              &quot;chartOptions&quot;: { # Options to control visual rendering of a chart. # Display options for the chart.
                &quot;displayHorizontal&quot;: True or False, # Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
                &quot;mode&quot;: &quot;A String&quot;, # The chart mode.
              },
              &quot;dataSets&quot;: [ # Required. The data displayed in this chart.
                { # Groups a time series query definition with charting options.
                  &quot;breakdowns&quot;: [ # Optional. The collection of breakdowns to be applied to the dataset.
                    { # Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The Aggregation function is applied across all data in each breakdown created.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the dataset containing the breakdown values.
                      &quot;limit&quot;: 42, # Required. A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # Required. The sort order is applied to the values of the breakdown column.
                    },
                  ],
                  &quot;dimensions&quot;: [ # Optional. A collection of dimension columns.
                    { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                      &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                      &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                      &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                      &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                      &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                      &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                    },
                  ],
                  &quot;legendTemplate&quot;: &quot;A String&quot;, # A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value.
                  &quot;measures&quot;: [ # Optional. A collection of measures.
                    { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                    },
                  ],
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;plotType&quot;: &quot;A String&quot;, # How this data should be plotted on the chart.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # Optional. The target axis to use for plotting the metric.
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;thresholds&quot;: [ # Threshold lines drawn horizontally across the chart.
                { # Defines a threshold for categorizing time series values.
                  &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                  &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                  &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                  &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                },
              ],
              &quot;timeshiftDuration&quot;: &quot;A String&quot;, # The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
              &quot;xAxis&quot;: { # A chart axis. # The properties applied to the x-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
              &quot;y2Axis&quot;: { # A chart axis. # The properties applied to the y2-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
              &quot;yAxis&quot;: { # A chart axis. # The properties applied to the y-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
            },
          },
        ],
      },
    ],
  },
  &quot;dashboardFilters&quot;: [ # Filters to reduce the amount of data charted based on the filter criteria.
    { # A filter to reduce the amount of data charted in relevant widgets.
      &quot;filterType&quot;: &quot;A String&quot;, # The specified filter type
      &quot;labelKey&quot;: &quot;A String&quot;, # Required. The key for the label
      &quot;stringValue&quot;: &quot;A String&quot;, # A variable-length string value.
      &quot;templateVariable&quot;: &quot;A String&quot;, # The placeholder text that can be referenced in a filter string or MQL query. If omitted, the dashboard filter will be applied to all relevant widgets in the dashboard.
    },
  ],
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The mutable, human-readable name.
  &quot;etag&quot;: &quot;A String&quot;, # etag is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. An etag is returned in the response to GetDashboard, and users are expected to put that etag in the request to UpdateDashboard to ensure that their change will be applied to the same version of the Dashboard configuration. The field should not be passed during dashboard creation.
  &quot;gridLayout&quot;: { # A basic layout divides the available space into vertical columns of equal width and arranges a list of widgets using a row-first strategy. # Content is arranged with a basic layout that re-flows a simple list of informational elements like widgets or tiles.
    &quot;columns&quot;: &quot;A String&quot;, # The number of columns into which the view&#x27;s width is divided. If omitted or set to zero, a system default will be used while rendering.
    &quot;widgets&quot;: [ # The informational elements that are arranged into the columns row-first.
      { # Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
        &quot;alertChart&quot;: { # A chart that displays alert policy data. # A chart of alert policy data.
          &quot;name&quot;: &quot;A String&quot;, # Required. The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
        },
        &quot;blank&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # A blank space.
        },
        &quot;collapsibleGroup&quot;: { # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
          &quot;collapsed&quot;: True or False, # The collapsed state of the widget on first page load.
        },
        &quot;errorReportingPanel&quot;: { # A widget that displays a list of error groups. # A widget that displays a list of error groups.
          &quot;projectNames&quot;: [ # The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
            &quot;A String&quot;,
          ],
          &quot;services&quot;: [ # An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
            &quot;A String&quot;,
          ],
          &quot;versions&quot;: [ # Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
            &quot;A String&quot;,
          ],
        },
        &quot;id&quot;: &quot;A String&quot;, # Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
        &quot;incidentList&quot;: { # A widget that displays a list of incidents # A widget that shows list of incidents.
          &quot;monitoredResources&quot;: [ # Optional. The monitored resource for which incidents are listed. The resource doesn&#x27;t need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
            { # An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource&#x27;s schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for &quot;gce_instance&quot; has labels &quot;project_id&quot;, &quot;instance_id&quot; and &quot;zone&quot;: { &quot;type&quot;: &quot;gce_instance&quot;, &quot;labels&quot;: { &quot;project_id&quot;: &quot;my-project&quot;, &quot;instance_id&quot;: &quot;12345678901234&quot;, &quot;zone&quot;: &quot;us-central1-a&quot; }}
              &quot;labels&quot;: { # Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels &quot;project_id&quot;, &quot;instance_id&quot;, and &quot;zone&quot;.
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;type&quot;: &quot;A String&quot;, # Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
            },
          ],
          &quot;policyNames&quot;: [ # Optional. A list of alert policy names to filter the incident list by. Don&#x27;t include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
            &quot;A String&quot;,
          ],
        },
        &quot;logsPanel&quot;: { # A widget that displays a stream of log. # A widget that shows a stream of logs.
          &quot;filter&quot;: &quot;A String&quot;, # A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
          &quot;resourceNames&quot;: [ # The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
            &quot;A String&quot;,
          ],
        },
        &quot;pieChart&quot;: { # A widget that displays timeseries data as a pie or a donut. # A widget that displays timeseries data as a pie chart.
          &quot;chartType&quot;: &quot;A String&quot;, # Required. Indicates the visualization type for the PieChart.
          &quot;dataSets&quot;: [ # Required. The queries for the chart&#x27;s data.
            { # Groups a time series query definition.
              &quot;dimensions&quot;: [ # A dimension is a structured label, class, or category for a set of measurements in your data.
                { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                  &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                  &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                  &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                  &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                  &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                  &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                  &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                },
              ],
              &quot;measures&quot;: [ # A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                  &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                    &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                      { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                        &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                        &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                      },
                    ],
                    &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                  },
                  &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                },
              ],
              &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
              &quot;sliceNameTemplate&quot;: &quot;A String&quot;, # Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone&#x27;s value will be used for the name instead of the default name.
              &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
                &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                  &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                },
                &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                  &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
              },
            },
          ],
          &quot;showLabels&quot;: True or False, # Optional. Indicates whether or not the pie chart should show slices&#x27; labels
        },
        &quot;scorecard&quot;: { # A widget showing the latest value of a metric, and how this value relates to one or more thresholds. # A scorecard summarizing time series data.
          &quot;blankView&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
          },
          &quot;dimensions&quot;: [ # Optional. A dimension is a structured label, class, or category for a set of measurements in your data.
            { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
              &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
              &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
              &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
              &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
              &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
              &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
              &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
              &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
            },
          ],
          &quot;gaugeView&quot;: { # A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard&#x27;s query (inclusive). # Will cause the scorecard to show a gauge chart.
            &quot;lowerBound&quot;: 3.14, # The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
            &quot;upperBound&quot;: 3.14, # The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
          },
          &quot;measures&quot;: [ # Optional. A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
            { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
              &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                  { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                    &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                    &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                  },
                ],
                &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
              },
              &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
            },
          ],
          &quot;sparkChartView&quot;: { # A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard&#x27;s timeseries. # Will cause the scorecard to show a spark chart.
            &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
            &quot;sparkChartType&quot;: &quot;A String&quot;, # Required. The type of sparkchart to show in this chartView.
          },
          &quot;thresholds&quot;: [ # The thresholds used to determine the state of the scorecard given the time series&#x27; current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: &#x27;DANGER&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 70, category: &#x27;WARNING&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 10, category: &#x27;DANGER&#x27;, trigger: &#x27;BELOW&#x27;, }, { value: 20, category: &#x27;WARNING&#x27;, trigger: &#x27;BELOW&#x27;, } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
            { # Defines a threshold for categorizing time series values.
              &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
              &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
              &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
              &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
              &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
            },
          ],
          &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
            &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
              &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
            },
            &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
            &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
            &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
              &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                  &quot;A String&quot;,
                ],
                &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
              },
              &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
              &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                  &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                  &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                },
                &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
              },
              &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                  &quot;A String&quot;,
                ],
                &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
              },
              &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                &quot;numTimeSeries&quot;: 42, # How many time series to output.
                &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
              },
            },
            &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
              &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                  &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                  &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                  &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                    &quot;A String&quot;,
                  ],
                  &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                },
                &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
              },
              &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                  &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                  &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                  &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                    &quot;A String&quot;,
                  ],
                  &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                },
                &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
              },
              &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                  &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                  &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                },
                &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
              },
              &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                  &quot;A String&quot;,
                ],
                &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
              },
              &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                &quot;numTimeSeries&quot;: 42, # How many time series to output.
                &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
              },
            },
            &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
            &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
          },
        },
        &quot;sectionHeader&quot;: { # A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content. # A widget that defines a section header for easier navigation of the dashboard.
          &quot;dividerBelow&quot;: True or False, # Whether to insert a divider below the section in the table of contents
          &quot;subtitle&quot;: &quot;A String&quot;, # The subtitle of the section
        },
        &quot;singleViewGroup&quot;: { # A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets by using a dropdown menu.
        },
        &quot;text&quot;: { # A widget that displays textual content. # A raw string or markdown displaying textual content.
          &quot;content&quot;: &quot;A String&quot;, # The text content to be displayed.
          &quot;format&quot;: &quot;A String&quot;, # How the text content is formatted.
          &quot;style&quot;: { # Properties that determine how the title and content are styled # How the text is styled
            &quot;backgroundColor&quot;: &quot;A String&quot;, # The background color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
            &quot;fontSize&quot;: &quot;A String&quot;, # Font sizes for both the title and content. The title will still be larger relative to the content.
            &quot;horizontalAlignment&quot;: &quot;A String&quot;, # The horizontal alignment of both the title and content
            &quot;padding&quot;: &quot;A String&quot;, # The amount of padding around the widget
            &quot;pointerLocation&quot;: &quot;A String&quot;, # The pointer location for this widget (also sometimes called a &quot;tail&quot;)
            &quot;textColor&quot;: &quot;A String&quot;, # The text color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
            &quot;verticalAlignment&quot;: &quot;A String&quot;, # The vertical alignment of both the title and content
          },
        },
        &quot;timeSeriesTable&quot;: { # A table that displays time series data. # A widget that displays time series data in a tabular format.
          &quot;columnSettings&quot;: [ # Optional. The list of the persistent column settings for the table.
            { # The persistent settings for a table&#x27;s columns.
              &quot;column&quot;: &quot;A String&quot;, # Required. The id of the column.
              &quot;visible&quot;: True or False, # Required. Whether the column should be visible on page load.
            },
          ],
          &quot;dataSets&quot;: [ # Required. The data displayed in this table.
            { # Groups a time series query definition with table options.
              &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
              &quot;tableDisplayOptions&quot;: { # Table display options that can be reused. # Optional. Table display options for configuring how the table is rendered.
                &quot;shownColumns&quot;: [ # Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
                  &quot;A String&quot;,
                ],
              },
              &quot;tableTemplate&quot;: &quot;A String&quot;, # Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value i.e. &quot;${resource.labels.project_id}.&quot;
              &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                  &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                },
                &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                  &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
              },
            },
          ],
          &quot;metricVisualization&quot;: &quot;A String&quot;, # Optional. Store rendering strategy
        },
        &quot;title&quot;: &quot;A String&quot;, # Optional. The title of the widget.
        &quot;xyChart&quot;: { # A chart that displays data on a 2D (X and Y axes) plane. # A chart of time series data.
          &quot;chartOptions&quot;: { # Options to control visual rendering of a chart. # Display options for the chart.
            &quot;displayHorizontal&quot;: True or False, # Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
            &quot;mode&quot;: &quot;A String&quot;, # The chart mode.
          },
          &quot;dataSets&quot;: [ # Required. The data displayed in this chart.
            { # Groups a time series query definition with charting options.
              &quot;breakdowns&quot;: [ # Optional. The collection of breakdowns to be applied to the dataset.
                { # Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
                  &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The Aggregation function is applied across all data in each breakdown created.
                    &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                      { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                        &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                        &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                      },
                    ],
                    &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                  },
                  &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the dataset containing the breakdown values.
                  &quot;limit&quot;: 42, # Required. A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
                  &quot;sortOrder&quot;: &quot;A String&quot;, # Required. The sort order is applied to the values of the breakdown column.
                },
              ],
              &quot;dimensions&quot;: [ # Optional. A collection of dimension columns.
                { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                  &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                  &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                  &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                  &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                  &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                  &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                  &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                },
              ],
              &quot;legendTemplate&quot;: &quot;A String&quot;, # A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value.
              &quot;measures&quot;: [ # Optional. A collection of measures.
                { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                  &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                    &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                      { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                        &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                        &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                      },
                    ],
                    &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                  },
                  &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                },
              ],
              &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
              &quot;plotType&quot;: &quot;A String&quot;, # How this data should be plotted on the chart.
              &quot;targetAxis&quot;: &quot;A String&quot;, # Optional. The target axis to use for plotting the metric.
              &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                  &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                },
                &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                  &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
              },
            },
          ],
          &quot;thresholds&quot;: [ # Threshold lines drawn horizontally across the chart.
            { # Defines a threshold for categorizing time series values.
              &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
              &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
              &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
              &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
              &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
            },
          ],
          &quot;timeshiftDuration&quot;: &quot;A String&quot;, # The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
          &quot;xAxis&quot;: { # A chart axis. # The properties applied to the x-axis.
            &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
            &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
          },
          &quot;y2Axis&quot;: { # A chart axis. # The properties applied to the y2-axis.
            &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
            &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
          },
          &quot;yAxis&quot;: { # A chart axis. # The properties applied to the y-axis.
            &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
            &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
          },
        },
      },
    ],
  },
  &quot;labels&quot;: { # Labels applied to the dashboard
    &quot;a_key&quot;: &quot;A String&quot;,
  },
  &quot;mosaicLayout&quot;: { # A mosaic layout divides the available space into a grid of blocks, and overlays the grid with tiles. Unlike GridLayout, tiles may span multiple grid blocks and can be placed at arbitrary locations in the grid. # The content is arranged as a grid of tiles, with each content widget occupying one or more grid blocks.
    &quot;columns&quot;: 42, # The number of columns in the mosaic grid. The number of columns must be between 1 and 12, inclusive.
    &quot;tiles&quot;: [ # The tiles to display.
      { # A single tile in the mosaic. The placement and size of the tile are configurable.
        &quot;height&quot;: 42, # The height of the tile, measured in grid blocks. Tiles must have a minimum height of 1.
        &quot;widget&quot;: { # Widget contains a single dashboard component and configuration of how to present the component in the dashboard. # The informational widget contained in the tile. For example an XyChart.
          &quot;alertChart&quot;: { # A chart that displays alert policy data. # A chart of alert policy data.
            &quot;name&quot;: &quot;A String&quot;, # Required. The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
          },
          &quot;blank&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # A blank space.
          },
          &quot;collapsibleGroup&quot;: { # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
            &quot;collapsed&quot;: True or False, # The collapsed state of the widget on first page load.
          },
          &quot;errorReportingPanel&quot;: { # A widget that displays a list of error groups. # A widget that displays a list of error groups.
            &quot;projectNames&quot;: [ # The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
              &quot;A String&quot;,
            ],
            &quot;services&quot;: [ # An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
              &quot;A String&quot;,
            ],
            &quot;versions&quot;: [ # Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
              &quot;A String&quot;,
            ],
          },
          &quot;id&quot;: &quot;A String&quot;, # Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
          &quot;incidentList&quot;: { # A widget that displays a list of incidents # A widget that shows list of incidents.
            &quot;monitoredResources&quot;: [ # Optional. The monitored resource for which incidents are listed. The resource doesn&#x27;t need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
              { # An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource&#x27;s schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for &quot;gce_instance&quot; has labels &quot;project_id&quot;, &quot;instance_id&quot; and &quot;zone&quot;: { &quot;type&quot;: &quot;gce_instance&quot;, &quot;labels&quot;: { &quot;project_id&quot;: &quot;my-project&quot;, &quot;instance_id&quot;: &quot;12345678901234&quot;, &quot;zone&quot;: &quot;us-central1-a&quot; }}
                &quot;labels&quot;: { # Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels &quot;project_id&quot;, &quot;instance_id&quot;, and &quot;zone&quot;.
                  &quot;a_key&quot;: &quot;A String&quot;,
                },
                &quot;type&quot;: &quot;A String&quot;, # Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
              },
            ],
            &quot;policyNames&quot;: [ # Optional. A list of alert policy names to filter the incident list by. Don&#x27;t include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
              &quot;A String&quot;,
            ],
          },
          &quot;logsPanel&quot;: { # A widget that displays a stream of log. # A widget that shows a stream of logs.
            &quot;filter&quot;: &quot;A String&quot;, # A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
            &quot;resourceNames&quot;: [ # The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
              &quot;A String&quot;,
            ],
          },
          &quot;pieChart&quot;: { # A widget that displays timeseries data as a pie or a donut. # A widget that displays timeseries data as a pie chart.
            &quot;chartType&quot;: &quot;A String&quot;, # Required. Indicates the visualization type for the PieChart.
            &quot;dataSets&quot;: [ # Required. The queries for the chart&#x27;s data.
              { # Groups a time series query definition.
                &quot;dimensions&quot;: [ # A dimension is a structured label, class, or category for a set of measurements in your data.
                  { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                    &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                    &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                    &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                    &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                    &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                    &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                    &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                    &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                  },
                ],
                &quot;measures&quot;: [ # A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                  { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                    &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                      &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                        { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                          &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                          &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                        },
                      ],
                      &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                    },
                    &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                  },
                ],
                &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                &quot;sliceNameTemplate&quot;: &quot;A String&quot;, # Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone&#x27;s value will be used for the name instead of the default name.
                &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
                  &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                    &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                  },
                  &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                  &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                  &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                    &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                  &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                },
              },
            ],
            &quot;showLabels&quot;: True or False, # Optional. Indicates whether or not the pie chart should show slices&#x27; labels
          },
          &quot;scorecard&quot;: { # A widget showing the latest value of a metric, and how this value relates to one or more thresholds. # A scorecard summarizing time series data.
            &quot;blankView&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
            },
            &quot;dimensions&quot;: [ # Optional. A dimension is a structured label, class, or category for a set of measurements in your data.
              { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
              },
            ],
            &quot;gaugeView&quot;: { # A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard&#x27;s query (inclusive). # Will cause the scorecard to show a gauge chart.
              &quot;lowerBound&quot;: 3.14, # The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
              &quot;upperBound&quot;: 3.14, # The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
            },
            &quot;measures&quot;: [ # Optional. A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
              { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                  &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                    { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                      &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                      &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                    },
                  ],
                  &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                },
                &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
              },
            ],
            &quot;sparkChartView&quot;: { # A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard&#x27;s timeseries. # Will cause the scorecard to show a spark chart.
              &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
              &quot;sparkChartType&quot;: &quot;A String&quot;, # Required. The type of sparkchart to show in this chartView.
            },
            &quot;thresholds&quot;: [ # The thresholds used to determine the state of the scorecard given the time series&#x27; current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: &#x27;DANGER&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 70, category: &#x27;WARNING&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 10, category: &#x27;DANGER&#x27;, trigger: &#x27;BELOW&#x27;, }, { value: 20, category: &#x27;WARNING&#x27;, trigger: &#x27;BELOW&#x27;, } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
              { # Defines a threshold for categorizing time series values.
                &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
              },
            ],
            &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
              &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
              },
              &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
              &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
              &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                  &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                  &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                  &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                    &quot;A String&quot;,
                  ],
                  &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                },
                &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                  &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                  &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                    &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                    &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                  },
                  &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                  &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                },
                &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                  &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                  &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                  &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                    &quot;A String&quot;,
                  ],
                  &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                },
                &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                  &quot;numTimeSeries&quot;: 42, # How many time series to output.
                  &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                },
              },
              &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                },
                &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                },
                &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                  &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                  &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                    &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                    &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                  },
                  &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                  &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                },
                &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                  &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                  &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                  &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                    &quot;A String&quot;,
                  ],
                  &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                },
                &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                  &quot;numTimeSeries&quot;: 42, # How many time series to output.
                  &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                },
              },
              &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
              &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
            },
          },
          &quot;sectionHeader&quot;: { # A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content. # A widget that defines a section header for easier navigation of the dashboard.
            &quot;dividerBelow&quot;: True or False, # Whether to insert a divider below the section in the table of contents
            &quot;subtitle&quot;: &quot;A String&quot;, # The subtitle of the section
          },
          &quot;singleViewGroup&quot;: { # A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets by using a dropdown menu.
          },
          &quot;text&quot;: { # A widget that displays textual content. # A raw string or markdown displaying textual content.
            &quot;content&quot;: &quot;A String&quot;, # The text content to be displayed.
            &quot;format&quot;: &quot;A String&quot;, # How the text content is formatted.
            &quot;style&quot;: { # Properties that determine how the title and content are styled # How the text is styled
              &quot;backgroundColor&quot;: &quot;A String&quot;, # The background color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
              &quot;fontSize&quot;: &quot;A String&quot;, # Font sizes for both the title and content. The title will still be larger relative to the content.
              &quot;horizontalAlignment&quot;: &quot;A String&quot;, # The horizontal alignment of both the title and content
              &quot;padding&quot;: &quot;A String&quot;, # The amount of padding around the widget
              &quot;pointerLocation&quot;: &quot;A String&quot;, # The pointer location for this widget (also sometimes called a &quot;tail&quot;)
              &quot;textColor&quot;: &quot;A String&quot;, # The text color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
              &quot;verticalAlignment&quot;: &quot;A String&quot;, # The vertical alignment of both the title and content
            },
          },
          &quot;timeSeriesTable&quot;: { # A table that displays time series data. # A widget that displays time series data in a tabular format.
            &quot;columnSettings&quot;: [ # Optional. The list of the persistent column settings for the table.
              { # The persistent settings for a table&#x27;s columns.
                &quot;column&quot;: &quot;A String&quot;, # Required. The id of the column.
                &quot;visible&quot;: True or False, # Required. Whether the column should be visible on page load.
              },
            ],
            &quot;dataSets&quot;: [ # Required. The data displayed in this table.
              { # Groups a time series query definition with table options.
                &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                &quot;tableDisplayOptions&quot;: { # Table display options that can be reused. # Optional. Table display options for configuring how the table is rendered.
                  &quot;shownColumns&quot;: [ # Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
                    &quot;A String&quot;,
                  ],
                },
                &quot;tableTemplate&quot;: &quot;A String&quot;, # Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value i.e. &quot;${resource.labels.project_id}.&quot;
                &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                  &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                    &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                  },
                  &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                  &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                  &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                    &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                  &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                },
              },
            ],
            &quot;metricVisualization&quot;: &quot;A String&quot;, # Optional. Store rendering strategy
          },
          &quot;title&quot;: &quot;A String&quot;, # Optional. The title of the widget.
          &quot;xyChart&quot;: { # A chart that displays data on a 2D (X and Y axes) plane. # A chart of time series data.
            &quot;chartOptions&quot;: { # Options to control visual rendering of a chart. # Display options for the chart.
              &quot;displayHorizontal&quot;: True or False, # Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
              &quot;mode&quot;: &quot;A String&quot;, # The chart mode.
            },
            &quot;dataSets&quot;: [ # Required. The data displayed in this chart.
              { # Groups a time series query definition with charting options.
                &quot;breakdowns&quot;: [ # Optional. The collection of breakdowns to be applied to the dataset.
                  { # Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
                    &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The Aggregation function is applied across all data in each breakdown created.
                      &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                        { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                          &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                          &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                        },
                      ],
                      &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                    },
                    &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the dataset containing the breakdown values.
                    &quot;limit&quot;: 42, # Required. A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
                    &quot;sortOrder&quot;: &quot;A String&quot;, # Required. The sort order is applied to the values of the breakdown column.
                  },
                ],
                &quot;dimensions&quot;: [ # Optional. A collection of dimension columns.
                  { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                    &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                    &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                    &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                    &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                    &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                    &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                    &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                    &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                  },
                ],
                &quot;legendTemplate&quot;: &quot;A String&quot;, # A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value.
                &quot;measures&quot;: [ # Optional. A collection of measures.
                  { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                    &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                      &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                        { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                          &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                          &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                        },
                      ],
                      &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                    },
                    &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                  },
                ],
                &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                &quot;plotType&quot;: &quot;A String&quot;, # How this data should be plotted on the chart.
                &quot;targetAxis&quot;: &quot;A String&quot;, # Optional. The target axis to use for plotting the metric.
                &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                  &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                    &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                  },
                  &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                  &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                  &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                    &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                    },
                    &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                      &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                      &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                        &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                        &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                      },
                      &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                    },
                    &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                      &quot;numTimeSeries&quot;: 42, # How many time series to output.
                      &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                    },
                  },
                  &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                  &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                },
              },
            ],
            &quot;thresholds&quot;: [ # Threshold lines drawn horizontally across the chart.
              { # Defines a threshold for categorizing time series values.
                &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
              },
            ],
            &quot;timeshiftDuration&quot;: &quot;A String&quot;, # The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
            &quot;xAxis&quot;: { # A chart axis. # The properties applied to the x-axis.
              &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
              &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
            },
            &quot;y2Axis&quot;: { # A chart axis. # The properties applied to the y2-axis.
              &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
              &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
            },
            &quot;yAxis&quot;: { # A chart axis. # The properties applied to the y-axis.
              &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
              &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
            },
          },
        },
        &quot;width&quot;: 42, # The width of the tile, measured in grid blocks. Tiles must have a minimum width of 1.
        &quot;xPos&quot;: 42, # The zero-indexed position of the tile in grid blocks relative to the left edge of the grid. Tiles must be contained within the specified number of columns. x_pos cannot be negative.
        &quot;yPos&quot;: 42, # The zero-indexed position of the tile in grid blocks relative to the top edge of the grid. y_pos cannot be negative.
      },
    ],
  },
  &quot;name&quot;: &quot;A String&quot;, # Identifier. The resource name of the dashboard.
  &quot;rowLayout&quot;: { # A simplified layout that divides the available space into rows and arranges a set of widgets horizontally in each row. # The content is divided into equally spaced rows and the widgets are arranged horizontally.
    &quot;rows&quot;: [ # The rows of content to display.
      { # Defines the layout properties and content for a row.
        &quot;weight&quot;: &quot;A String&quot;, # The relative weight of this row. The row weight is used to adjust the height of rows on the screen (relative to peers). Greater the weight, greater the height of the row on the screen. If omitted, a value of 1 is used while rendering.
        &quot;widgets&quot;: [ # The display widgets arranged horizontally in this row.
          { # Widget contains a single dashboard component and configuration of how to present the component in the dashboard.
            &quot;alertChart&quot;: { # A chart that displays alert policy data. # A chart of alert policy data.
              &quot;name&quot;: &quot;A String&quot;, # Required. The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
            },
            &quot;blank&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # A blank space.
            },
            &quot;collapsibleGroup&quot;: { # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.
              &quot;collapsed&quot;: True or False, # The collapsed state of the widget on first page load.
            },
            &quot;errorReportingPanel&quot;: { # A widget that displays a list of error groups. # A widget that displays a list of error groups.
              &quot;projectNames&quot;: [ # The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234.
                &quot;A String&quot;,
              ],
              &quot;services&quot;: [ # An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used.
                &quot;A String&quot;,
              ],
              &quot;versions&quot;: [ # Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.
                &quot;A String&quot;,
              ],
            },
            &quot;id&quot;: &quot;A String&quot;, # Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.
            &quot;incidentList&quot;: { # A widget that displays a list of incidents # A widget that shows list of incidents.
              &quot;monitoredResources&quot;: [ # Optional. The monitored resource for which incidents are listed. The resource doesn&#x27;t need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering.
                { # An object representing a resource that can be used for monitoring, logging, billing, or other purposes. Examples include virtual machine instances, databases, and storage devices such as disks. The type field identifies a MonitoredResourceDescriptor object that describes the resource&#x27;s schema. Information in the labels field identifies the actual resource and its attributes according to the schema. For example, a particular Compute Engine VM instance could be represented by the following object, because the MonitoredResourceDescriptor for &quot;gce_instance&quot; has labels &quot;project_id&quot;, &quot;instance_id&quot; and &quot;zone&quot;: { &quot;type&quot;: &quot;gce_instance&quot;, &quot;labels&quot;: { &quot;project_id&quot;: &quot;my-project&quot;, &quot;instance_id&quot;: &quot;12345678901234&quot;, &quot;zone&quot;: &quot;us-central1-a&quot; }}
                  &quot;labels&quot;: { # Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels &quot;project_id&quot;, &quot;instance_id&quot;, and &quot;zone&quot;.
                    &quot;a_key&quot;: &quot;A String&quot;,
                  },
                  &quot;type&quot;: &quot;A String&quot;, # Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
                },
              ],
              &quot;policyNames&quot;: [ # Optional. A list of alert policy names to filter the incident list by. Don&#x27;t include the project ID prefix in the policy name. For example, use alertPolicies/utilization.
                &quot;A String&quot;,
              ],
            },
            &quot;logsPanel&quot;: { # A widget that displays a stream of log. # A widget that shows a stream of logs.
              &quot;filter&quot;: &quot;A String&quot;, # A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.
              &quot;resourceNames&quot;: [ # The names of logging resources to collect logs for. Currently only projects are supported. If empty, the widget will default to the host project.
                &quot;A String&quot;,
              ],
            },
            &quot;pieChart&quot;: { # A widget that displays timeseries data as a pie or a donut. # A widget that displays timeseries data as a pie chart.
              &quot;chartType&quot;: &quot;A String&quot;, # Required. Indicates the visualization type for the PieChart.
              &quot;dataSets&quot;: [ # Required. The queries for the chart&#x27;s data.
                { # Groups a time series query definition.
                  &quot;dimensions&quot;: [ # A dimension is a structured label, class, or category for a set of measurements in your data.
                    { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                      &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                      &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                      &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                      &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                      &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                      &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                    },
                  ],
                  &quot;measures&quot;: [ # A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                    { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                    },
                  ],
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;sliceNameTemplate&quot;: &quot;A String&quot;, # Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone&#x27;s value will be used for the name instead of the default name.
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;showLabels&quot;: True or False, # Optional. Indicates whether or not the pie chart should show slices&#x27; labels
            },
            &quot;scorecard&quot;: { # A widget showing the latest value of a metric, and how this value relates to one or more thresholds. # A scorecard summarizing time series data.
              &quot;blankView&quot;: { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } # Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds.
              },
              &quot;dimensions&quot;: [ # Optional. A dimension is a structured label, class, or category for a set of measurements in your data.
                { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                  &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                  &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                  &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                  &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                  &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                  &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                  &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                },
              ],
              &quot;gaugeView&quot;: { # A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard&#x27;s query (inclusive). # Will cause the scorecard to show a gauge chart.
                &quot;lowerBound&quot;: 3.14, # The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.
                &quot;upperBound&quot;: 3.14, # The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.
              },
              &quot;measures&quot;: [ # Optional. A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc.
                { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                  &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                    &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                      { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                        &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                        &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                      },
                    ],
                    &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                  },
                  &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                },
              ],
              &quot;sparkChartView&quot;: { # A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard&#x27;s timeseries. # Will cause the scorecard to show a spark chart.
                &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.
                &quot;sparkChartType&quot;: &quot;A String&quot;, # Required. The type of sparkchart to show in this chartView.
              },
              &quot;thresholds&quot;: [ # The thresholds used to determine the state of the scorecard given the time series&#x27; current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: &#x27;DANGER&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 70, category: &#x27;WARNING&#x27;, trigger: &#x27;ABOVE&#x27;, }, { value: 10, category: &#x27;DANGER&#x27;, trigger: &#x27;BELOW&#x27;, }, { value: 20, category: &#x27;WARNING&#x27;, trigger: &#x27;BELOW&#x27;, } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.
                { # Defines a threshold for categorizing time series values.
                  &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                  &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                  &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                  &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                },
              ],
              &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                  &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                },
                &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                  &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                  &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                    &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                      &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                      &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                      &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                        &quot;A String&quot;,
                      ],
                      &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                    },
                    &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                  },
                  &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                    &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                    &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                    },
                    &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                  },
                  &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                    &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                    &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                    &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                      &quot;A String&quot;,
                    ],
                    &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                  },
                  &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                    &quot;numTimeSeries&quot;: 42, # How many time series to output.
                    &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                  },
                },
                &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
              },
            },
            &quot;sectionHeader&quot;: { # A widget that defines a new section header. Sections populate a table of contents and allow easier navigation of long-form content. # A widget that defines a section header for easier navigation of the dashboard.
              &quot;dividerBelow&quot;: True or False, # Whether to insert a divider below the section in the table of contents
              &quot;subtitle&quot;: &quot;A String&quot;, # The subtitle of the section
            },
            &quot;singleViewGroup&quot;: { # A widget that groups the other widgets by using a dropdown menu. All widgets that are within the area spanned by the grouping widget are considered member widgets. # A widget that groups the other widgets by using a dropdown menu.
            },
            &quot;text&quot;: { # A widget that displays textual content. # A raw string or markdown displaying textual content.
              &quot;content&quot;: &quot;A String&quot;, # The text content to be displayed.
              &quot;format&quot;: &quot;A String&quot;, # How the text content is formatted.
              &quot;style&quot;: { # Properties that determine how the title and content are styled # How the text is styled
                &quot;backgroundColor&quot;: &quot;A String&quot;, # The background color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                &quot;fontSize&quot;: &quot;A String&quot;, # Font sizes for both the title and content. The title will still be larger relative to the content.
                &quot;horizontalAlignment&quot;: &quot;A String&quot;, # The horizontal alignment of both the title and content
                &quot;padding&quot;: &quot;A String&quot;, # The amount of padding around the widget
                &quot;pointerLocation&quot;: &quot;A String&quot;, # The pointer location for this widget (also sometimes called a &quot;tail&quot;)
                &quot;textColor&quot;: &quot;A String&quot;, # The text color as a hex string. &quot;#RRGGBB&quot; or &quot;#RGB&quot;
                &quot;verticalAlignment&quot;: &quot;A String&quot;, # The vertical alignment of both the title and content
              },
            },
            &quot;timeSeriesTable&quot;: { # A table that displays time series data. # A widget that displays time series data in a tabular format.
              &quot;columnSettings&quot;: [ # Optional. The list of the persistent column settings for the table.
                { # The persistent settings for a table&#x27;s columns.
                  &quot;column&quot;: &quot;A String&quot;, # Required. The id of the column.
                  &quot;visible&quot;: True or False, # Required. Whether the column should be visible on page load.
                },
              ],
              &quot;dataSets&quot;: [ # Required. The data displayed in this table.
                { # Groups a time series query definition with table options.
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;tableDisplayOptions&quot;: { # Table display options that can be reused. # Optional. Table display options for configuring how the table is rendered.
                    &quot;shownColumns&quot;: [ # Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings
                      &quot;A String&quot;,
                    ],
                  },
                  &quot;tableTemplate&quot;: &quot;A String&quot;, # Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value i.e. &quot;${resource.labels.project_id}.&quot;
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;metricVisualization&quot;: &quot;A String&quot;, # Optional. Store rendering strategy
            },
            &quot;title&quot;: &quot;A String&quot;, # Optional. The title of the widget.
            &quot;xyChart&quot;: { # A chart that displays data on a 2D (X and Y axes) plane. # A chart of time series data.
              &quot;chartOptions&quot;: { # Options to control visual rendering of a chart. # Display options for the chart.
                &quot;displayHorizontal&quot;: True or False, # Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release.
                &quot;mode&quot;: &quot;A String&quot;, # The chart mode.
              },
              &quot;dataSets&quot;: [ # Required. The data displayed in this chart.
                { # Groups a time series query definition with charting options.
                  &quot;breakdowns&quot;: [ # Optional. The collection of breakdowns to be applied to the dataset.
                    { # Preview: A breakdown is an aggregation applied to the measures over a specified column. A breakdown can result in multiple series across a category for the provided measure. This is a preview feature and may be subject to change before final release.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The Aggregation function is applied across all data in each breakdown created.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the dataset containing the breakdown values.
                      &quot;limit&quot;: 42, # Required. A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # Required. The sort order is applied to the values of the breakdown column.
                    },
                  ],
                  &quot;dimensions&quot;: [ # Optional. A collection of dimension columns.
                    { # A chart dimension. Dimensions are a structured label, class, or category for a set of measurements in your data.
                      &quot;column&quot;: &quot;A String&quot;, # Required. The name of the column in the source SQL query that is used to chart the dimension.
                      &quot;columnType&quot;: &quot;A String&quot;, # Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64.
                      &quot;floatBinSize&quot;: 3.14, # Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column.
                      &quot;maxBinCount&quot;: 42, # A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced.
                      &quot;numericBinSize&quot;: 42, # numeric_bin_size is used when the column type used for a dimension is numeric or string.
                      &quot;sortColumn&quot;: &quot;A String&quot;, # The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used.
                      &quot;sortOrder&quot;: &quot;A String&quot;, # The sort order applied to the sort column.
                      &quot;timeBinSize&quot;: &quot;A String&quot;, # time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours.
                    },
                  ],
                  &quot;legendTemplate&quot;: &quot;A String&quot;, # A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label&#x27;s value.
                  &quot;measures&quot;: [ # Optional. A collection of measures.
                    { # A chart measure. Measures represent a measured property in your chart data such as rainfall in inches, number of units sold, revenue gained, etc.
                      &quot;aggregationFunction&quot;: { # Preview: An identifier for an aggregation function. Aggregation functions are SQL functions that group or transform data from multiple points to a single point. This is a preview feature and may be subject to change before final release. # Required. The aggregation function applied to the input column. This must not be set to &quot;none&quot; unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins.
                        &quot;parameters&quot;: [ # Optional. Parameters applied to the aggregation function. Only used for functions that require them.
                          { # Preview: Parameter value applied to the aggregation function. This is a preview feature and may be subject to change before final release.
                            &quot;doubleValue&quot;: 3.14, # A floating-point parameter value.
                            &quot;intValue&quot;: &quot;A String&quot;, # An integer parameter value.
                          },
                        ],
                        &quot;type&quot;: &quot;A String&quot;, # Required. The type of aggregation function, must be one of the following: &quot;none&quot; - no function. &quot;percentile&quot; - APPROX_QUANTILES() - 1 parameter numeric value &quot;average&quot; - AVG() &quot;count&quot; - COUNT() &quot;count-distinct&quot; - COUNT(DISTINCT) &quot;count-distinct-approx&quot; - APPROX_COUNT_DISTINCT() &quot;max&quot; - MAX() &quot;min&quot; - MIN() &quot;sum&quot; - SUM()
                      },
                      &quot;column&quot;: &quot;A String&quot;, # Required. The column name within in the dataset used for the measure.
                    },
                  ],
                  &quot;minAlignmentPeriod&quot;: &quot;A String&quot;, # Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.
                  &quot;plotType&quot;: &quot;A String&quot;, # How this data should be plotted on the chart.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # Optional. The target axis to use for plotting the metric.
                  &quot;timeSeriesQuery&quot;: { # TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API. # Required. Fields for querying time series data from the Stackdriver metrics API.
                    &quot;opsAnalyticsQuery&quot;: { # Preview: A query that produces an aggregated response and supporting data. This is a preview feature and may be subject to change before final release. # Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release.
                      &quot;sql&quot;: &quot;A String&quot;, # A SQL query to fetch time series, category series, or numeric series data.
                    },
                    &quot;outputFullDuration&quot;: True or False, # Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard&#x27;s spark chart
                    &quot;prometheusQuery&quot;: &quot;A String&quot;, # A query used to fetch time series with PromQL.
                    &quot;timeSeriesFilter&quot;: { # A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list) method. # Filter parameters to fetch time series.
                      &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after aggregation is applied.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesFilterRatio&quot;: { # A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series. # Parameters to fetch a ratio between two time series filters.
                      &quot;denominator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The denominator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;numerator&quot;: { # Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio. # The numerator of the ratio.
                        &quot;aggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.
                          &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                          &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                          &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                            &quot;A String&quot;,
                          ],
                          &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                        },
                        &quot;filter&quot;: &quot;A String&quot;, # Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.
                      },
                      &quot;pickTimeSeriesFilter&quot;: { # Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter will allow up to num_time_series time series to pass through it, selecting them based on the relative ranking.For example, if ranking_method is METHOD_MEAN,direction is BOTTOM, and num_time_series is 3, then the 3 times series with the lowest mean values will pass through the filter. # Ranking based time series filter.
                        &quot;direction&quot;: &quot;A String&quot;, # How to use the ranking to select time series that pass through the filter.
                        &quot;interval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive).The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Select the top N streams/time series within this time interval
                          &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end.
                          &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start.
                        },
                        &quot;numTimeSeries&quot;: 42, # How many time series to allow to pass through the filter.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series.
                      },
                      &quot;secondaryAggregation&quot;: { # Describes how to combine multiple time series to provide a different view of the data. Aggregation of time series is done in two steps. First, each time series in the set is aligned to the same time interval boundaries, then the set of time series is optionally reduced in number.Alignment consists of applying the per_series_aligner operation to each time series after its data has been divided into regular alignment_period time intervals. This process takes all of the data points in an alignment period, applies a mathematical transformation such as averaging, minimum, maximum, delta, etc., and converts them into a single data point per period.Reduction is when the aligned and transformed time series can optionally be combined, reducing the number of time series through similar mathematical transformations. Reduction involves applying a cross_series_reducer to all the time series, optionally sorting the time series into subsets with group_by_fields, and applying the reducer to each subset.The raw time series data can contain a huge amount of information from multiple sources. Alignment and reduction transforms this mass of data into a more manageable and representative collection of data, for example &quot;the 95% latency across the average of all tasks in a cluster&quot;. This representative data can be more easily graphed and comprehended, and the individual time series data is still available for later drilldown. For more details, see Filtering and aggregation (https://cloud.google.com/monitoring/api/v3/aggregation). # Apply a second aggregation after the ratio is computed.
                        &quot;alignmentPeriod&quot;: &quot;A String&quot;, # The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks.
                        &quot;crossSeriesReducer&quot;: &quot;A String&quot;, # The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned.
                        &quot;groupByFields&quot;: [ # The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored.
                          &quot;A String&quot;,
                        ],
                        &quot;perSeriesAligner&quot;: &quot;A String&quot;, # An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned.
                      },
                      &quot;statisticalTimeSeriesFilter&quot;: { # A filter that ranks streams based on their statistical relation to other streams in a request. Note: This field is deprecated and completely ignored by the API. # Statistics based time series filter. Note: This field is deprecated and completely ignored by the API.
                        &quot;numTimeSeries&quot;: 42, # How many time series to output.
                        &quot;rankingMethod&quot;: &quot;A String&quot;, # rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.
                      },
                    },
                    &quot;timeSeriesQueryLanguage&quot;: &quot;A String&quot;, # A query used to fetch time series with MQL.
                    &quot;unitOverride&quot;: &quot;A String&quot;, # The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor.
                  },
                },
              ],
              &quot;thresholds&quot;: [ # Threshold lines drawn horizontally across the chart.
                { # Defines a threshold for categorizing time series values.
                  &quot;color&quot;: &quot;A String&quot;, # The state color for this threshold. Color is not allowed in a XyChart.
                  &quot;direction&quot;: &quot;A String&quot;, # The direction for the current threshold. Direction is not allowed in a XyChart.
                  &quot;label&quot;: &quot;A String&quot;, # A label for the threshold.
                  &quot;targetAxis&quot;: &quot;A String&quot;, # The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.
                  &quot;value&quot;: 3.14, # The value of the threshold. The value should be defined in the native scale of the metric.
                },
              ],
              &quot;timeshiftDuration&quot;: &quot;A String&quot;, # The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.
              &quot;xAxis&quot;: { # A chart axis. # The properties applied to the x-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
              &quot;y2Axis&quot;: { # A chart axis. # The properties applied to the y2-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
              &quot;yAxis&quot;: { # A chart axis. # The properties applied to the y-axis.
                &quot;label&quot;: &quot;A String&quot;, # The label of the axis.
                &quot;scale&quot;: &quot;A String&quot;, # The axis scale. By default, a linear scale is used.
              },
            },
          },
        ],
      },
    ],
  },
}</pre>
</div>

</body></html>