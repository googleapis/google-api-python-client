<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="vision_v1.html">Google Cloud Vision API</a> . <a href="vision_v1.images.html">images</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#annotate">annotate(body, x__xgafv=None)</a></code></p>
<p class="firstline">Run image detection and annotation for a batch of images.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="annotate">annotate(body, x__xgafv=None)</code>
  <pre>Run image detection and annotation for a batch of images.

Args:
  body: object, The request body. (required)
    The object takes the form of:

{ # Multiple image annotation requests are batched into a single service call.
    "requests": [ # Individual image annotation requests for this batch.
      { # Request for performing Google Cloud Vision API tasks over a user-provided
          # image, with user-requested features.
        "imageContext": { # Image context and/or feature-specific parameters. # Additional context that may accompany the image.
          "latLongRect": { # Rectangle determined by min and max `LatLng` pairs. # lat/long rectangle that specifies the location of the image.
            "minLatLng": { # An object representing a latitude/longitude pair. This is expressed as a pair # Min lat/long pair.
                # of doubles representing degrees latitude and degrees longitude. Unless
                # specified otherwise, this must conform to the
                # <a href="http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf">WGS84
                # standard</a>. Values must be within normalized ranges.
                #
                # Example of normalization code in Python:
                #
                #     def NormalizeLongitude(longitude):
                #       """Wraps decimal degrees longitude to [-180.0, 180.0]."""
                #       q, r = divmod(longitude, 360.0)
                #       if r > 180.0 or (r == 180.0 and q <= -1.0):
                #         return r - 360.0
                #       return r
                #
                #     def NormalizeLatLng(latitude, longitude):
                #       """Wraps decimal degrees latitude and longitude to
                #       [-90.0, 90.0] and [-180.0, 180.0], respectively."""
                #       r = latitude % 360.0
                #       if r <= 90.0:
                #         return r, NormalizeLongitude(longitude)
                #       elif r >= 270.0:
                #         return r - 360, NormalizeLongitude(longitude)
                #       else:
                #         return 180 - r, NormalizeLongitude(longitude + 180.0)
                #
                #     assert 180.0 == NormalizeLongitude(180.0)
                #     assert -180.0 == NormalizeLongitude(-180.0)
                #     assert -179.0 == NormalizeLongitude(181.0)
                #     assert (0.0, 0.0) == NormalizeLatLng(360.0, 0.0)
                #     assert (0.0, 0.0) == NormalizeLatLng(-360.0, 0.0)
                #     assert (85.0, 180.0) == NormalizeLatLng(95.0, 0.0)
                #     assert (-85.0, -170.0) == NormalizeLatLng(-95.0, 10.0)
                #     assert (90.0, 10.0) == NormalizeLatLng(90.0, 10.0)
                #     assert (-90.0, -10.0) == NormalizeLatLng(-90.0, -10.0)
                #     assert (0.0, -170.0) == NormalizeLatLng(-180.0, 10.0)
                #     assert (0.0, -170.0) == NormalizeLatLng(180.0, 10.0)
                #     assert (-90.0, 10.0) == NormalizeLatLng(270.0, 10.0)
                #     assert (90.0, 10.0) == NormalizeLatLng(-270.0, 10.0)
              "latitude": 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
              "longitude": 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
            },
            "maxLatLng": { # An object representing a latitude/longitude pair. This is expressed as a pair # Max lat/long pair.
                # of doubles representing degrees latitude and degrees longitude. Unless
                # specified otherwise, this must conform to the
                # <a href="http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf">WGS84
                # standard</a>. Values must be within normalized ranges.
                #
                # Example of normalization code in Python:
                #
                #     def NormalizeLongitude(longitude):
                #       """Wraps decimal degrees longitude to [-180.0, 180.0]."""
                #       q, r = divmod(longitude, 360.0)
                #       if r > 180.0 or (r == 180.0 and q <= -1.0):
                #         return r - 360.0
                #       return r
                #
                #     def NormalizeLatLng(latitude, longitude):
                #       """Wraps decimal degrees latitude and longitude to
                #       [-90.0, 90.0] and [-180.0, 180.0], respectively."""
                #       r = latitude % 360.0
                #       if r <= 90.0:
                #         return r, NormalizeLongitude(longitude)
                #       elif r >= 270.0:
                #         return r - 360, NormalizeLongitude(longitude)
                #       else:
                #         return 180 - r, NormalizeLongitude(longitude + 180.0)
                #
                #     assert 180.0 == NormalizeLongitude(180.0)
                #     assert -180.0 == NormalizeLongitude(-180.0)
                #     assert -179.0 == NormalizeLongitude(181.0)
                #     assert (0.0, 0.0) == NormalizeLatLng(360.0, 0.0)
                #     assert (0.0, 0.0) == NormalizeLatLng(-360.0, 0.0)
                #     assert (85.0, 180.0) == NormalizeLatLng(95.0, 0.0)
                #     assert (-85.0, -170.0) == NormalizeLatLng(-95.0, 10.0)
                #     assert (90.0, 10.0) == NormalizeLatLng(90.0, 10.0)
                #     assert (-90.0, -10.0) == NormalizeLatLng(-90.0, -10.0)
                #     assert (0.0, -170.0) == NormalizeLatLng(-180.0, 10.0)
                #     assert (0.0, -170.0) == NormalizeLatLng(180.0, 10.0)
                #     assert (-90.0, 10.0) == NormalizeLatLng(270.0, 10.0)
                #     assert (90.0, 10.0) == NormalizeLatLng(-270.0, 10.0)
              "latitude": 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
              "longitude": 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
            },
          },
          "languageHints": [ # List of languages to use for TEXT_DETECTION. In most cases, an empty value
              # yields the best results since it enables automatic language detection. For
              # languages based on the Latin alphabet, setting `language_hints` is not
              # needed. In rare cases, when the language of the text in the image is known,
              # setting a hint will help get better results (although it will be a
              # significant hindrance if the hint is wrong). Text detection returns an
              # error if one or more of the specified languages is not one of the
              # [supported languages](/vision/docs/languages).
            "A String",
          ],
          "cropHintsParams": { # Parameters for crop hints annotation request. # Parameters for crop hints annotation request.
            "aspectRatios": [ # Aspect ratios in floats, representing the ratio of the width to the height
                # of the image. For example, if the desired aspect ratio is 4/3, the
                # corresponding float value should be 1.33333.  If not specified, the
                # best possible crop is returned. The number of provided aspect ratios is
                # limited to a maximum of 16; any aspect ratios provided after the 16th are
                # ignored.
              3.14,
            ],
          },
        },
        "image": { # Client image to perform Google Cloud Vision API tasks over. # The image to be processed.
          "content": "A String", # Image content, represented as a stream of bytes.
              # Note: as with all `bytes` fields, protobuffers use a pure binary
              # representation, whereas JSON representations use base64.
          "source": { # External image source (Google Cloud Storage image location). # Google Cloud Storage image location. If both `content` and `source`
              # are provided for an image, `content` takes precedence and is
              # used to perform the image annotation request.
            "gcsImageUri": "A String", # NOTE: For new code `image_uri` below is preferred.
                # Google Cloud Storage image URI, which must be in the following form:
                # `gs://bucket_name/object_name` (for details, see
                # [Google Cloud Storage Request
                # URIs](https://cloud.google.com/storage/docs/reference-uris)).
                # NOTE: Cloud Storage object versioning is not supported.
            "imageUri": "A String", # Image URI which supports:
                # 1) Google Cloud Storage image URI, which must be in the following form:
                # `gs://bucket_name/object_name` (for details, see
                # [Google Cloud Storage Request
                # URIs](https://cloud.google.com/storage/docs/reference-uris)).
                # NOTE: Cloud Storage object versioning is not supported.
                # 2) Publicly accessible image HTTP/HTTPS URL.
                # This is preferred over the legacy `gcs_image_uri` above. When both
                # `gcs_image_uri` and `image_uri` are specified, `image_uri` takes
                # precedence.
          },
        },
        "features": [ # Requested features.
          { # Users describe the type of Google Cloud Vision API tasks to perform over
              # images by using *Feature*s. Each Feature indicates a type of image
              # detection task to perform. Features encode the Cloud Vision API
              # vertical to operate on and the number of top-scoring results to return.
            "type": "A String", # The feature type.
            "maxResults": 42, # Maximum number of results of this type.
          },
        ],
      },
    ],
  }

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response to a batch image annotation request.
    "responses": [ # Individual responses to image annotation requests within the batch.
      { # Response to an image annotation request.
        "safeSearchAnnotation": { # Set of features pertaining to the image, computed by computer vision # If present, safe-search annotation has completed successfully.
            # methods over safe-search verticals (for example, adult, spoof, medical,
            # violence).
          "medical": "A String", # Likelihood that this is a medical image.
          "spoof": "A String", # Spoof likelihood. The likelihood that an modification
              # was made to the image's canonical version to make it appear
              # funny or offensive.
          "violence": "A String", # Violence likelihood.
          "adult": "A String", # Represents the adult content likelihood for the image.
        },
        "textAnnotations": [ # If present, text (OCR) detection has completed successfully.
          { # Set of detected entity features.
            "confidence": 3.14, # The accuracy of the entity detection in an image.
                # For example, for an image in which the "Eiffel Tower" entity is detected,
                # this field represents the confidence that there is a tower in the query
                # image. Range [0, 1].
            "description": "A String", # Entity textual description, expressed in its `locale` language.
            "locale": "A String", # The language code for the locale in which the entity textual
                # `description` is expressed.
            "topicality": 3.14, # The relevancy of the ICA (Image Content Annotation) label to the
                # image. For example, the relevancy of "tower" is likely higher to an image
                # containing the detected "Eiffel Tower" than to an image containing a
                # detected distant towering building, even though the confidence that
                # there is a tower in each image may be the same. Range [0, 1].
            "mid": "A String", # Opaque entity ID. Some IDs may be available in
                # [Google Knowledge Graph Search API](https://developers.google.com/knowledge-graph/).
            "locations": [ # The location information for the detected entity. Multiple
                # `LocationInfo` elements can be present because one location may
                # indicate the location of the scene in the image, and another location
                # may indicate the location of the place where the image was taken.
                # Location information is usually present for landmarks.
              { # Detected entity location information.
                "latLng": { # An object representing a latitude/longitude pair. This is expressed as a pair # lat/long location coordinates.
                    # of doubles representing degrees latitude and degrees longitude. Unless
                    # specified otherwise, this must conform to the
                    # <a href="http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf">WGS84
                    # standard</a>. Values must be within normalized ranges.
                    #
                    # Example of normalization code in Python:
                    #
                    #     def NormalizeLongitude(longitude):
                    #       """Wraps decimal degrees longitude to [-180.0, 180.0]."""
                    #       q, r = divmod(longitude, 360.0)
                    #       if r > 180.0 or (r == 180.0 and q <= -1.0):
                    #         return r - 360.0
                    #       return r
                    #
                    #     def NormalizeLatLng(latitude, longitude):
                    #       """Wraps decimal degrees latitude and longitude to
                    #       [-90.0, 90.0] and [-180.0, 180.0], respectively."""
                    #       r = latitude % 360.0
                    #       if r <= 90.0:
                    #         return r, NormalizeLongitude(longitude)
                    #       elif r >= 270.0:
                    #         return r - 360, NormalizeLongitude(longitude)
                    #       else:
                    #         return 180 - r, NormalizeLongitude(longitude + 180.0)
                    #
                    #     assert 180.0 == NormalizeLongitude(180.0)
                    #     assert -180.0 == NormalizeLongitude(-180.0)
                    #     assert -179.0 == NormalizeLongitude(181.0)
                    #     assert (0.0, 0.0) == NormalizeLatLng(360.0, 0.0)
                    #     assert (0.0, 0.0) == NormalizeLatLng(-360.0, 0.0)
                    #     assert (85.0, 180.0) == NormalizeLatLng(95.0, 0.0)
                    #     assert (-85.0, -170.0) == NormalizeLatLng(-95.0, 10.0)
                    #     assert (90.0, 10.0) == NormalizeLatLng(90.0, 10.0)
                    #     assert (-90.0, -10.0) == NormalizeLatLng(-90.0, -10.0)
                    #     assert (0.0, -170.0) == NormalizeLatLng(-180.0, 10.0)
                    #     assert (0.0, -170.0) == NormalizeLatLng(180.0, 10.0)
                    #     assert (-90.0, 10.0) == NormalizeLatLng(270.0, 10.0)
                    #     assert (90.0, 10.0) == NormalizeLatLng(-270.0, 10.0)
                  "latitude": 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
                  "longitude": 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
                },
              },
            ],
            "score": 3.14, # Overall score of the result. Range [0, 1].
            "boundingPoly": { # A bounding polygon for the detected image annotation. # Image region to which this entity belongs. Currently not produced
                # for `LABEL_DETECTION` features. For `TEXT_DETECTION` (OCR), `boundingPoly`s
                # are produced for the entire text detected in an image region, followed by
                # `boundingPoly`s for each word within the detected text.
              "vertices": [ # The bounding polygon vertices.
                { # A vertex represents a 2D point in the image.
                    # NOTE: the vertex coordinates are in the same scale as the original image.
                  "y": 42, # Y coordinate.
                  "x": 42, # X coordinate.
                },
              ],
            },
            "properties": [ # Some entities may have optional user-supplied `Property` (name/value)
                # fields, such a score or string that qualifies the entity.
              { # A `Property` consists of a user-supplied name/value pair.
                "uint64Value": "A String", # Value of numeric properties.
                "name": "A String", # Name of the property.
                "value": "A String", # Value of the property.
              },
            ],
          },
        ],
        "webDetection": { # Relevant information for the image from the Internet. # If present, web detection has completed successfully.
          "webEntities": [ # Deduced entities from similar images on the Internet.
            { # Entity deduced from similar images on the Internet.
              "entityId": "A String", # Opaque entity ID.
              "score": 3.14, # Overall relevancy score for the entity.
                  # Not normalized and not comparable across different image queries.
              "description": "A String", # Canonical description of the entity, in English.
            },
          ],
          "pagesWithMatchingImages": [ # Web pages containing the matching images from the Internet.
            { # Metadata for web pages.
              "url": "A String", # The result web page URL.
              "score": 3.14, # Overall relevancy score for the web page.
                  # Not normalized and not comparable across different image queries.
            },
          ],
          "visuallySimilarImages": [ # The visually similar image results.
            { # Metadata for online images.
              "url": "A String", # The result image URL.
              "score": 3.14, # Overall relevancy score for the image.
                  # Not normalized and not comparable across different image queries.
            },
          ],
          "partialMatchingImages": [ # Partial matching images from the Internet.
              # Those images are similar enough to share some key-point features. For
              # example an original image will likely have partial matching for its crops.
            { # Metadata for online images.
              "url": "A String", # The result image URL.
              "score": 3.14, # Overall relevancy score for the image.
                  # Not normalized and not comparable across different image queries.
            },
          ],
          "fullMatchingImages": [ # Fully matching images from the Internet.
              # Can include resized copies of the query image.
            { # Metadata for online images.
              "url": "A String", # The result image URL.
              "score": 3.14, # Overall relevancy score for the image.
                  # Not normalized and not comparable across different image queries.
            },
          ],
        },
        "fullTextAnnotation": { # TextAnnotation contains a structured representation of OCR extracted text. # If present, text (OCR) detection or document (OCR) text detection has
            # completed successfully.
            # This annotation provides the structural hierarchy for the OCR detected
            # text.
            # The hierarchy of an OCR extracted text structure is like this:
            #     TextAnnotation -> Page -> Block -> Paragraph -> Word -> Symbol
            # Each structural component, starting from Page, may further have their own
            # properties. Properties describe detected languages, breaks etc.. Please
            # refer to the google.cloud.vision.v1.TextAnnotation.TextProperty message
            # definition below for more detail.
          "text": "A String", # UTF-8 text detected on the pages.
          "pages": [ # List of pages detected by OCR.
            { # Detected page from OCR.
              "width": 42, # Page width in pixels.
              "property": { # Additional information detected on the structural component. # Additional information detected on the page.
                "detectedBreak": { # Detected start or end of a structural component. # Detected start or end of a text segment.
                  "isPrefix": True or False, # True if break prepends the element.
                  "type": "A String", # Detected break type.
                },
                "detectedLanguages": [ # A list of detected languages together with confidence.
                  { # Detected language for a structural component.
                    "languageCode": "A String", # The BCP-47 language code, such as "en-US" or "sr-Latn". For more
                        # information, see
                        # http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.
                    "confidence": 3.14, # Confidence of detected language. Range [0, 1].
                  },
                ],
              },
              "blocks": [ # List of blocks of text, images etc on this page.
                { # Logical element on the page.
                  "boundingBox": { # A bounding polygon for the detected image annotation. # The bounding box for the block.
                      # The vertices are in the order of top-left, top-right, bottom-right,
                      # bottom-left. When a rotation of the bounding box is detected the rotation
                      # is represented as around the top-left corner as defined when the text is
                      # read in the 'natural' orientation.
                      # For example:
                      #   * when the text is horizontal it might look like:
                      #      0----1
                      #      |    |
                      #      3----2
                      #   * when it's rotated 180 degrees around the top-left corner it becomes:
                      #      2----3
                      #      |    |
                      #      1----0
                      #   and the vertice order will still be (0, 1, 2, 3).
                    "vertices": [ # The bounding polygon vertices.
                      { # A vertex represents a 2D point in the image.
                          # NOTE: the vertex coordinates are in the same scale as the original image.
                        "y": 42, # Y coordinate.
                        "x": 42, # X coordinate.
                      },
                    ],
                  },
                  "blockType": "A String", # Detected block type (text, image etc) for this block.
                  "property": { # Additional information detected on the structural component. # Additional information detected for the block.
                    "detectedBreak": { # Detected start or end of a structural component. # Detected start or end of a text segment.
                      "isPrefix": True or False, # True if break prepends the element.
                      "type": "A String", # Detected break type.
                    },
                    "detectedLanguages": [ # A list of detected languages together with confidence.
                      { # Detected language for a structural component.
                        "languageCode": "A String", # The BCP-47 language code, such as "en-US" or "sr-Latn". For more
                            # information, see
                            # http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.
                        "confidence": 3.14, # Confidence of detected language. Range [0, 1].
                      },
                    ],
                  },
                  "paragraphs": [ # List of paragraphs in this block (if this blocks is of type text).
                    { # Structural unit of text representing a number of words in certain order.
                      "boundingBox": { # A bounding polygon for the detected image annotation. # The bounding box for the paragraph.
                          # The vertices are in the order of top-left, top-right, bottom-right,
                          # bottom-left. When a rotation of the bounding box is detected the rotation
                          # is represented as around the top-left corner as defined when the text is
                          # read in the 'natural' orientation.
                          # For example:
                          #   * when the text is horizontal it might look like:
                          #      0----1
                          #      |    |
                          #      3----2
                          #   * when it's rotated 180 degrees around the top-left corner it becomes:
                          #      2----3
                          #      |    |
                          #      1----0
                          #   and the vertice order will still be (0, 1, 2, 3).
                        "vertices": [ # The bounding polygon vertices.
                          { # A vertex represents a 2D point in the image.
                              # NOTE: the vertex coordinates are in the same scale as the original image.
                            "y": 42, # Y coordinate.
                            "x": 42, # X coordinate.
                          },
                        ],
                      },
                      "property": { # Additional information detected on the structural component. # Additional information detected for the paragraph.
                        "detectedBreak": { # Detected start or end of a structural component. # Detected start or end of a text segment.
                          "isPrefix": True or False, # True if break prepends the element.
                          "type": "A String", # Detected break type.
                        },
                        "detectedLanguages": [ # A list of detected languages together with confidence.
                          { # Detected language for a structural component.
                            "languageCode": "A String", # The BCP-47 language code, such as "en-US" or "sr-Latn". For more
                                # information, see
                                # http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.
                            "confidence": 3.14, # Confidence of detected language. Range [0, 1].
                          },
                        ],
                      },
                      "words": [ # List of words in this paragraph.
                        { # A word representation.
                          "boundingBox": { # A bounding polygon for the detected image annotation. # The bounding box for the word.
                              # The vertices are in the order of top-left, top-right, bottom-right,
                              # bottom-left. When a rotation of the bounding box is detected the rotation
                              # is represented as around the top-left corner as defined when the text is
                              # read in the 'natural' orientation.
                              # For example:
                              #   * when the text is horizontal it might look like:
                              #      0----1
                              #      |    |
                              #      3----2
                              #   * when it's rotated 180 degrees around the top-left corner it becomes:
                              #      2----3
                              #      |    |
                              #      1----0
                              #   and the vertice order will still be (0, 1, 2, 3).
                            "vertices": [ # The bounding polygon vertices.
                              { # A vertex represents a 2D point in the image.
                                  # NOTE: the vertex coordinates are in the same scale as the original image.
                                "y": 42, # Y coordinate.
                                "x": 42, # X coordinate.
                              },
                            ],
                          },
                          "symbols": [ # List of symbols in the word.
                              # The order of the symbols follows the natural reading order.
                            { # A single symbol representation.
                              "boundingBox": { # A bounding polygon for the detected image annotation. # The bounding box for the symbol.
                                  # The vertices are in the order of top-left, top-right, bottom-right,
                                  # bottom-left. When a rotation of the bounding box is detected the rotation
                                  # is represented as around the top-left corner as defined when the text is
                                  # read in the 'natural' orientation.
                                  # For example:
                                  #   * when the text is horizontal it might look like:
                                  #      0----1
                                  #      |    |
                                  #      3----2
                                  #   * when it's rotated 180 degrees around the top-left corner it becomes:
                                  #      2----3
                                  #      |    |
                                  #      1----0
                                  #   and the vertice order will still be (0, 1, 2, 3).
                                "vertices": [ # The bounding polygon vertices.
                                  { # A vertex represents a 2D point in the image.
                                      # NOTE: the vertex coordinates are in the same scale as the original image.
                                    "y": 42, # Y coordinate.
                                    "x": 42, # X coordinate.
                                  },
                                ],
                              },
                              "text": "A String", # The actual UTF-8 representation of the symbol.
                              "property": { # Additional information detected on the structural component. # Additional information detected for the symbol.
                                "detectedBreak": { # Detected start or end of a structural component. # Detected start or end of a text segment.
                                  "isPrefix": True or False, # True if break prepends the element.
                                  "type": "A String", # Detected break type.
                                },
                                "detectedLanguages": [ # A list of detected languages together with confidence.
                                  { # Detected language for a structural component.
                                    "languageCode": "A String", # The BCP-47 language code, such as "en-US" or "sr-Latn". For more
                                        # information, see
                                        # http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.
                                    "confidence": 3.14, # Confidence of detected language. Range [0, 1].
                                  },
                                ],
                              },
                            },
                          ],
                          "property": { # Additional information detected on the structural component. # Additional information detected for the word.
                            "detectedBreak": { # Detected start or end of a structural component. # Detected start or end of a text segment.
                              "isPrefix": True or False, # True if break prepends the element.
                              "type": "A String", # Detected break type.
                            },
                            "detectedLanguages": [ # A list of detected languages together with confidence.
                              { # Detected language for a structural component.
                                "languageCode": "A String", # The BCP-47 language code, such as "en-US" or "sr-Latn". For more
                                    # information, see
                                    # http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.
                                "confidence": 3.14, # Confidence of detected language. Range [0, 1].
                              },
                            ],
                          },
                        },
                      ],
                    },
                  ],
                },
              ],
              "height": 42, # Page height in pixels.
            },
          ],
        },
        "labelAnnotations": [ # If present, label detection has completed successfully.
          { # Set of detected entity features.
            "confidence": 3.14, # The accuracy of the entity detection in an image.
                # For example, for an image in which the "Eiffel Tower" entity is detected,
                # this field represents the confidence that there is a tower in the query
                # image. Range [0, 1].
            "description": "A String", # Entity textual description, expressed in its `locale` language.
            "locale": "A String", # The language code for the locale in which the entity textual
                # `description` is expressed.
            "topicality": 3.14, # The relevancy of the ICA (Image Content Annotation) label to the
                # image. For example, the relevancy of "tower" is likely higher to an image
                # containing the detected "Eiffel Tower" than to an image containing a
                # detected distant towering building, even though the confidence that
                # there is a tower in each image may be the same. Range [0, 1].
            "mid": "A String", # Opaque entity ID. Some IDs may be available in
                # [Google Knowledge Graph Search API](https://developers.google.com/knowledge-graph/).
            "locations": [ # The location information for the detected entity. Multiple
                # `LocationInfo` elements can be present because one location may
                # indicate the location of the scene in the image, and another location
                # may indicate the location of the place where the image was taken.
                # Location information is usually present for landmarks.
              { # Detected entity location information.
                "latLng": { # An object representing a latitude/longitude pair. This is expressed as a pair # lat/long location coordinates.
                    # of doubles representing degrees latitude and degrees longitude. Unless
                    # specified otherwise, this must conform to the
                    # <a href="http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf">WGS84
                    # standard</a>. Values must be within normalized ranges.
                    #
                    # Example of normalization code in Python:
                    #
                    #     def NormalizeLongitude(longitude):
                    #       """Wraps decimal degrees longitude to [-180.0, 180.0]."""
                    #       q, r = divmod(longitude, 360.0)
                    #       if r > 180.0 or (r == 180.0 and q <= -1.0):
                    #         return r - 360.0
                    #       return r
                    #
                    #     def NormalizeLatLng(latitude, longitude):
                    #       """Wraps decimal degrees latitude and longitude to
                    #       [-90.0, 90.0] and [-180.0, 180.0], respectively."""
                    #       r = latitude % 360.0
                    #       if r <= 90.0:
                    #         return r, NormalizeLongitude(longitude)
                    #       elif r >= 270.0:
                    #         return r - 360, NormalizeLongitude(longitude)
                    #       else:
                    #         return 180 - r, NormalizeLongitude(longitude + 180.0)
                    #
                    #     assert 180.0 == NormalizeLongitude(180.0)
                    #     assert -180.0 == NormalizeLongitude(-180.0)
                    #     assert -179.0 == NormalizeLongitude(181.0)
                    #     assert (0.0, 0.0) == NormalizeLatLng(360.0, 0.0)
                    #     assert (0.0, 0.0) == NormalizeLatLng(-360.0, 0.0)
                    #     assert (85.0, 180.0) == NormalizeLatLng(95.0, 0.0)
                    #     assert (-85.0, -170.0) == NormalizeLatLng(-95.0, 10.0)
                    #     assert (90.0, 10.0) == NormalizeLatLng(90.0, 10.0)
                    #     assert (-90.0, -10.0) == NormalizeLatLng(-90.0, -10.0)
                    #     assert (0.0, -170.0) == NormalizeLatLng(-180.0, 10.0)
                    #     assert (0.0, -170.0) == NormalizeLatLng(180.0, 10.0)
                    #     assert (-90.0, 10.0) == NormalizeLatLng(270.0, 10.0)
                    #     assert (90.0, 10.0) == NormalizeLatLng(-270.0, 10.0)
                  "latitude": 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
                  "longitude": 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
                },
              },
            ],
            "score": 3.14, # Overall score of the result. Range [0, 1].
            "boundingPoly": { # A bounding polygon for the detected image annotation. # Image region to which this entity belongs. Currently not produced
                # for `LABEL_DETECTION` features. For `TEXT_DETECTION` (OCR), `boundingPoly`s
                # are produced for the entire text detected in an image region, followed by
                # `boundingPoly`s for each word within the detected text.
              "vertices": [ # The bounding polygon vertices.
                { # A vertex represents a 2D point in the image.
                    # NOTE: the vertex coordinates are in the same scale as the original image.
                  "y": 42, # Y coordinate.
                  "x": 42, # X coordinate.
                },
              ],
            },
            "properties": [ # Some entities may have optional user-supplied `Property` (name/value)
                # fields, such a score or string that qualifies the entity.
              { # A `Property` consists of a user-supplied name/value pair.
                "uint64Value": "A String", # Value of numeric properties.
                "name": "A String", # Name of the property.
                "value": "A String", # Value of the property.
              },
            ],
          },
        ],
        "imagePropertiesAnnotation": { # Stores image properties, such as dominant colors. # If present, image properties were extracted successfully.
          "dominantColors": { # Set of dominant colors and their corresponding scores. # If present, dominant colors completed successfully.
            "colors": [ # RGB color values with their score and pixel fraction.
              { # Color information consists of RGB channels, score, and the fraction of
                  # the image that the color occupies in the image.
                "color": { # Represents a color in the RGBA color space. This representation is designed # RGB components of the color.
                    # for simplicity of conversion to/from color representations in various
                    # languages over compactness; for example, the fields of this representation
                    # can be trivially provided to the constructor of "java.awt.Color" in Java; it
                    # can also be trivially provided to UIColor's "+colorWithRed:green:blue:alpha"
                    # method in iOS; and, with just a little work, it can be easily formatted into
                    # a CSS "rgba()" string in JavaScript, as well. Here are some examples:
                    #
                    # Example (Java):
                    #
                    #      import com.google.type.Color;
                    #
                    #      // ...
                    #      public static java.awt.Color fromProto(Color protocolor) {
                    #        float alpha = protocolor.hasAlpha()
                    #            ? protocolor.getAlpha().getValue()
                    #            : 1.0;
                    #
                    #        return new java.awt.Color(
                    #            protocolor.getRed(),
                    #            protocolor.getGreen(),
                    #            protocolor.getBlue(),
                    #            alpha);
                    #      }
                    #
                    #      public static Color toProto(java.awt.Color color) {
                    #        float red = (float) color.getRed();
                    #        float green = (float) color.getGreen();
                    #        float blue = (float) color.getBlue();
                    #        float denominator = 255.0;
                    #        Color.Builder resultBuilder =
                    #            Color
                    #                .newBuilder()
                    #                .setRed(red / denominator)
                    #                .setGreen(green / denominator)
                    #                .setBlue(blue / denominator);
                    #        int alpha = color.getAlpha();
                    #        if (alpha != 255) {
                    #          result.setAlpha(
                    #              FloatValue
                    #                  .newBuilder()
                    #                  .setValue(((float) alpha) / denominator)
                    #                  .build());
                    #        }
                    #        return resultBuilder.build();
                    #      }
                    #      // ...
                    #
                    # Example (iOS / Obj-C):
                    #
                    #      // ...
                    #      static UIColor* fromProto(Color* protocolor) {
                    #         float red = [protocolor red];
                    #         float green = [protocolor green];
                    #         float blue = [protocolor blue];
                    #         FloatValue* alpha_wrapper = [protocolor alpha];
                    #         float alpha = 1.0;
                    #         if (alpha_wrapper != nil) {
                    #           alpha = [alpha_wrapper value];
                    #         }
                    #         return [UIColor colorWithRed:red green:green blue:blue alpha:alpha];
                    #      }
                    #
                    #      static Color* toProto(UIColor* color) {
                    #          CGFloat red, green, blue, alpha;
                    #          if (![color getRed:&red green:&green blue:&blue alpha:&alpha]) {
                    #            return nil;
                    #          }
                    #          Color* result = [Color alloc] init];
                    #          [result setRed:red];
                    #          [result setGreen:green];
                    #          [result setBlue:blue];
                    #          if (alpha <= 0.9999) {
                    #            [result setAlpha:floatWrapperWithValue(alpha)];
                    #          }
                    #          [result autorelease];
                    #          return result;
                    #     }
                    #     // ...
                    #
                    #  Example (JavaScript):
                    #
                    #     // ...
                    #
                    #     var protoToCssColor = function(rgb_color) {
                    #        var redFrac = rgb_color.red || 0.0;
                    #        var greenFrac = rgb_color.green || 0.0;
                    #        var blueFrac = rgb_color.blue || 0.0;
                    #        var red = Math.floor(redFrac * 255);
                    #        var green = Math.floor(greenFrac * 255);
                    #        var blue = Math.floor(blueFrac * 255);
                    #
                    #        if (!('alpha' in rgb_color)) {
                    #           return rgbToCssColor_(red, green, blue);
                    #        }
                    #
                    #        var alphaFrac = rgb_color.alpha.value || 0.0;
                    #        var rgbParams = [red, green, blue].join(',');
                    #        return ['rgba(', rgbParams, ',', alphaFrac, ')'].join('');
                    #     };
                    #
                    #     var rgbToCssColor_ = function(red, green, blue) {
                    #       var rgbNumber = new Number((red << 16) | (green << 8) | blue);
                    #       var hexString = rgbNumber.toString(16);
                    #       var missingZeros = 6 - hexString.length;
                    #       var resultBuilder = ['#'];
                    #       for (var i = 0; i < missingZeros; i++) {
                    #          resultBuilder.push('0');
                    #       }
                    #       resultBuilder.push(hexString);
                    #       return resultBuilder.join('');
                    #     };
                    #
                    #     // ...
                  "blue": 3.14, # The amount of blue in the color as a value in the interval [0, 1].
                  "alpha": 3.14, # The fraction of this color that should be applied to the pixel. That is,
                      # the final pixel color is defined by the equation:
                      #
                      #   pixel color = alpha * (this color) + (1.0 - alpha) * (background color)
                      #
                      # This means that a value of 1.0 corresponds to a solid color, whereas
                      # a value of 0.0 corresponds to a completely transparent color. This
                      # uses a wrapper message rather than a simple float scalar so that it is
                      # possible to distinguish between a default value and the value being unset.
                      # If omitted, this color object is to be rendered as a solid color
                      # (as if the alpha value had been explicitly given with a value of 1.0).
                  "green": 3.14, # The amount of green in the color as a value in the interval [0, 1].
                  "red": 3.14, # The amount of red in the color as a value in the interval [0, 1].
                },
                "pixelFraction": 3.14, # The fraction of pixels the color occupies in the image.
                    # Value in range [0, 1].
                "score": 3.14, # Image-specific score for this color. Value in range [0, 1].
              },
            ],
          },
        },
        "faceAnnotations": [ # If present, face detection has completed successfully.
          { # A face annotation object contains the results of face detection.
            "sorrowLikelihood": "A String", # Sorrow likelihood.
            "landmarkingConfidence": 3.14, # Face landmarking confidence. Range [0, 1].
            "underExposedLikelihood": "A String", # Under-exposed likelihood.
            "detectionConfidence": 3.14, # Detection confidence. Range [0, 1].
            "joyLikelihood": "A String", # Joy likelihood.
            "landmarks": [ # Detected face landmarks.
              { # A face-specific landmark (for example, a face feature).
                  # Landmark positions may fall outside the bounds of the image
                  # if the face is near one or more edges of the image.
                  # Therefore it is NOT guaranteed that `0 <= x < width` or
                  # `0 <= y < height`.
                "position": { # A 3D position in the image, used primarily for Face detection landmarks. # Face landmark position.
                    # A valid Position must have both x and y coordinates.
                    # The position coordinates are in the same scale as the original image.
                  "y": 3.14, # Y coordinate.
                  "x": 3.14, # X coordinate.
                  "z": 3.14, # Z coordinate (or depth).
                },
                "type": "A String", # Face landmark type.
              },
            ],
            "surpriseLikelihood": "A String", # Surprise likelihood.
            "blurredLikelihood": "A String", # Blurred likelihood.
            "tiltAngle": 3.14, # Pitch angle, which indicates the upwards/downwards angle that the face is
                # pointing relative to the image's horizontal plane. Range [-180,180].
            "angerLikelihood": "A String", # Anger likelihood.
            "boundingPoly": { # A bounding polygon for the detected image annotation. # The bounding polygon around the face. The coordinates of the bounding box
                # are in the original image's scale, as returned in `ImageParams`.
                # The bounding box is computed to "frame" the face in accordance with human
                # expectations. It is based on the landmarker results.
                # Note that one or more x and/or y coordinates may not be generated in the
                # `BoundingPoly` (the polygon will be unbounded) if only a partial face
                # appears in the image to be annotated.
              "vertices": [ # The bounding polygon vertices.
                { # A vertex represents a 2D point in the image.
                    # NOTE: the vertex coordinates are in the same scale as the original image.
                  "y": 42, # Y coordinate.
                  "x": 42, # X coordinate.
                },
              ],
            },
            "rollAngle": 3.14, # Roll angle, which indicates the amount of clockwise/anti-clockwise rotation
                # of the face relative to the image vertical about the axis perpendicular to
                # the face. Range [-180,180].
            "panAngle": 3.14, # Yaw angle, which indicates the leftward/rightward angle that the face is
                # pointing relative to the vertical plane perpendicular to the image. Range
                # [-180,180].
            "headwearLikelihood": "A String", # Headwear likelihood.
            "fdBoundingPoly": { # A bounding polygon for the detected image annotation. # The `fd_bounding_poly` bounding polygon is tighter than the
                # `boundingPoly`, and encloses only the skin part of the face. Typically, it
                # is used to eliminate the face from any image analysis that detects the
                # "amount of skin" visible in an image. It is not based on the
                # landmarker results, only on the initial face detection, hence
                # the <code>fd</code> (face detection) prefix.
              "vertices": [ # The bounding polygon vertices.
                { # A vertex represents a 2D point in the image.
                    # NOTE: the vertex coordinates are in the same scale as the original image.
                  "y": 42, # Y coordinate.
                  "x": 42, # X coordinate.
                },
              ],
            },
          },
        ],
        "logoAnnotations": [ # If present, logo detection has completed successfully.
          { # Set of detected entity features.
            "confidence": 3.14, # The accuracy of the entity detection in an image.
                # For example, for an image in which the "Eiffel Tower" entity is detected,
                # this field represents the confidence that there is a tower in the query
                # image. Range [0, 1].
            "description": "A String", # Entity textual description, expressed in its `locale` language.
            "locale": "A String", # The language code for the locale in which the entity textual
                # `description` is expressed.
            "topicality": 3.14, # The relevancy of the ICA (Image Content Annotation) label to the
                # image. For example, the relevancy of "tower" is likely higher to an image
                # containing the detected "Eiffel Tower" than to an image containing a
                # detected distant towering building, even though the confidence that
                # there is a tower in each image may be the same. Range [0, 1].
            "mid": "A String", # Opaque entity ID. Some IDs may be available in
                # [Google Knowledge Graph Search API](https://developers.google.com/knowledge-graph/).
            "locations": [ # The location information for the detected entity. Multiple
                # `LocationInfo` elements can be present because one location may
                # indicate the location of the scene in the image, and another location
                # may indicate the location of the place where the image was taken.
                # Location information is usually present for landmarks.
              { # Detected entity location information.
                "latLng": { # An object representing a latitude/longitude pair. This is expressed as a pair # lat/long location coordinates.
                    # of doubles representing degrees latitude and degrees longitude. Unless
                    # specified otherwise, this must conform to the
                    # <a href="http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf">WGS84
                    # standard</a>. Values must be within normalized ranges.
                    #
                    # Example of normalization code in Python:
                    #
                    #     def NormalizeLongitude(longitude):
                    #       """Wraps decimal degrees longitude to [-180.0, 180.0]."""
                    #       q, r = divmod(longitude, 360.0)
                    #       if r > 180.0 or (r == 180.0 and q <= -1.0):
                    #         return r - 360.0
                    #       return r
                    #
                    #     def NormalizeLatLng(latitude, longitude):
                    #       """Wraps decimal degrees latitude and longitude to
                    #       [-90.0, 90.0] and [-180.0, 180.0], respectively."""
                    #       r = latitude % 360.0
                    #       if r <= 90.0:
                    #         return r, NormalizeLongitude(longitude)
                    #       elif r >= 270.0:
                    #         return r - 360, NormalizeLongitude(longitude)
                    #       else:
                    #         return 180 - r, NormalizeLongitude(longitude + 180.0)
                    #
                    #     assert 180.0 == NormalizeLongitude(180.0)
                    #     assert -180.0 == NormalizeLongitude(-180.0)
                    #     assert -179.0 == NormalizeLongitude(181.0)
                    #     assert (0.0, 0.0) == NormalizeLatLng(360.0, 0.0)
                    #     assert (0.0, 0.0) == NormalizeLatLng(-360.0, 0.0)
                    #     assert (85.0, 180.0) == NormalizeLatLng(95.0, 0.0)
                    #     assert (-85.0, -170.0) == NormalizeLatLng(-95.0, 10.0)
                    #     assert (90.0, 10.0) == NormalizeLatLng(90.0, 10.0)
                    #     assert (-90.0, -10.0) == NormalizeLatLng(-90.0, -10.0)
                    #     assert (0.0, -170.0) == NormalizeLatLng(-180.0, 10.0)
                    #     assert (0.0, -170.0) == NormalizeLatLng(180.0, 10.0)
                    #     assert (-90.0, 10.0) == NormalizeLatLng(270.0, 10.0)
                    #     assert (90.0, 10.0) == NormalizeLatLng(-270.0, 10.0)
                  "latitude": 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
                  "longitude": 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
                },
              },
            ],
            "score": 3.14, # Overall score of the result. Range [0, 1].
            "boundingPoly": { # A bounding polygon for the detected image annotation. # Image region to which this entity belongs. Currently not produced
                # for `LABEL_DETECTION` features. For `TEXT_DETECTION` (OCR), `boundingPoly`s
                # are produced for the entire text detected in an image region, followed by
                # `boundingPoly`s for each word within the detected text.
              "vertices": [ # The bounding polygon vertices.
                { # A vertex represents a 2D point in the image.
                    # NOTE: the vertex coordinates are in the same scale as the original image.
                  "y": 42, # Y coordinate.
                  "x": 42, # X coordinate.
                },
              ],
            },
            "properties": [ # Some entities may have optional user-supplied `Property` (name/value)
                # fields, such a score or string that qualifies the entity.
              { # A `Property` consists of a user-supplied name/value pair.
                "uint64Value": "A String", # Value of numeric properties.
                "name": "A String", # Name of the property.
                "value": "A String", # Value of the property.
              },
            ],
          },
        ],
        "landmarkAnnotations": [ # If present, landmark detection has completed successfully.
          { # Set of detected entity features.
            "confidence": 3.14, # The accuracy of the entity detection in an image.
                # For example, for an image in which the "Eiffel Tower" entity is detected,
                # this field represents the confidence that there is a tower in the query
                # image. Range [0, 1].
            "description": "A String", # Entity textual description, expressed in its `locale` language.
            "locale": "A String", # The language code for the locale in which the entity textual
                # `description` is expressed.
            "topicality": 3.14, # The relevancy of the ICA (Image Content Annotation) label to the
                # image. For example, the relevancy of "tower" is likely higher to an image
                # containing the detected "Eiffel Tower" than to an image containing a
                # detected distant towering building, even though the confidence that
                # there is a tower in each image may be the same. Range [0, 1].
            "mid": "A String", # Opaque entity ID. Some IDs may be available in
                # [Google Knowledge Graph Search API](https://developers.google.com/knowledge-graph/).
            "locations": [ # The location information for the detected entity. Multiple
                # `LocationInfo` elements can be present because one location may
                # indicate the location of the scene in the image, and another location
                # may indicate the location of the place where the image was taken.
                # Location information is usually present for landmarks.
              { # Detected entity location information.
                "latLng": { # An object representing a latitude/longitude pair. This is expressed as a pair # lat/long location coordinates.
                    # of doubles representing degrees latitude and degrees longitude. Unless
                    # specified otherwise, this must conform to the
                    # <a href="http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf">WGS84
                    # standard</a>. Values must be within normalized ranges.
                    #
                    # Example of normalization code in Python:
                    #
                    #     def NormalizeLongitude(longitude):
                    #       """Wraps decimal degrees longitude to [-180.0, 180.0]."""
                    #       q, r = divmod(longitude, 360.0)
                    #       if r > 180.0 or (r == 180.0 and q <= -1.0):
                    #         return r - 360.0
                    #       return r
                    #
                    #     def NormalizeLatLng(latitude, longitude):
                    #       """Wraps decimal degrees latitude and longitude to
                    #       [-90.0, 90.0] and [-180.0, 180.0], respectively."""
                    #       r = latitude % 360.0
                    #       if r <= 90.0:
                    #         return r, NormalizeLongitude(longitude)
                    #       elif r >= 270.0:
                    #         return r - 360, NormalizeLongitude(longitude)
                    #       else:
                    #         return 180 - r, NormalizeLongitude(longitude + 180.0)
                    #
                    #     assert 180.0 == NormalizeLongitude(180.0)
                    #     assert -180.0 == NormalizeLongitude(-180.0)
                    #     assert -179.0 == NormalizeLongitude(181.0)
                    #     assert (0.0, 0.0) == NormalizeLatLng(360.0, 0.0)
                    #     assert (0.0, 0.0) == NormalizeLatLng(-360.0, 0.0)
                    #     assert (85.0, 180.0) == NormalizeLatLng(95.0, 0.0)
                    #     assert (-85.0, -170.0) == NormalizeLatLng(-95.0, 10.0)
                    #     assert (90.0, 10.0) == NormalizeLatLng(90.0, 10.0)
                    #     assert (-90.0, -10.0) == NormalizeLatLng(-90.0, -10.0)
                    #     assert (0.0, -170.0) == NormalizeLatLng(-180.0, 10.0)
                    #     assert (0.0, -170.0) == NormalizeLatLng(180.0, 10.0)
                    #     assert (-90.0, 10.0) == NormalizeLatLng(270.0, 10.0)
                    #     assert (90.0, 10.0) == NormalizeLatLng(-270.0, 10.0)
                  "latitude": 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
                  "longitude": 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
                },
              },
            ],
            "score": 3.14, # Overall score of the result. Range [0, 1].
            "boundingPoly": { # A bounding polygon for the detected image annotation. # Image region to which this entity belongs. Currently not produced
                # for `LABEL_DETECTION` features. For `TEXT_DETECTION` (OCR), `boundingPoly`s
                # are produced for the entire text detected in an image region, followed by
                # `boundingPoly`s for each word within the detected text.
              "vertices": [ # The bounding polygon vertices.
                { # A vertex represents a 2D point in the image.
                    # NOTE: the vertex coordinates are in the same scale as the original image.
                  "y": 42, # Y coordinate.
                  "x": 42, # X coordinate.
                },
              ],
            },
            "properties": [ # Some entities may have optional user-supplied `Property` (name/value)
                # fields, such a score or string that qualifies the entity.
              { # A `Property` consists of a user-supplied name/value pair.
                "uint64Value": "A String", # Value of numeric properties.
                "name": "A String", # Name of the property.
                "value": "A String", # Value of the property.
              },
            ],
          },
        ],
        "error": { # The `Status` type defines a logical error model that is suitable for different # If set, represents the error message for the operation.
            # Note that filled-in image annotations are guaranteed to be
            # correct, even when `error` is set.
            # programming environments, including REST APIs and RPC APIs. It is used by
            # [gRPC](https://github.com/grpc). The error model is designed to be:
            #
            # - Simple to use and understand for most users
            # - Flexible enough to meet unexpected needs
            #
            # # Overview
            #
            # The `Status` message contains three pieces of data: error code, error message,
            # and error details. The error code should be an enum value of
            # google.rpc.Code, but it may accept additional error codes if needed.  The
            # error message should be a developer-facing English message that helps
            # developers *understand* and *resolve* the error. If a localized user-facing
            # error message is needed, put the localized message in the error details or
            # localize it in the client. The optional error details may contain arbitrary
            # information about the error. There is a predefined set of error detail types
            # in the package `google.rpc` that can be used for common error conditions.
            #
            # # Language mapping
            #
            # The `Status` message is the logical representation of the error model, but it
            # is not necessarily the actual wire format. When the `Status` message is
            # exposed in different client libraries and different wire protocols, it can be
            # mapped differently. For example, it will likely be mapped to some exceptions
            # in Java, but more likely mapped to some error codes in C.
            #
            # # Other uses
            #
            # The error model and the `Status` message can be used in a variety of
            # environments, either with or without APIs, to provide a
            # consistent developer experience across different environments.
            #
            # Example uses of this error model include:
            #
            # - Partial errors. If a service needs to return partial errors to the client,
            #     it may embed the `Status` in the normal response to indicate the partial
            #     errors.
            #
            # - Workflow errors. A typical workflow has multiple steps. Each step may
            #     have a `Status` message for error reporting.
            #
            # - Batch operations. If a client uses batch request and batch response, the
            #     `Status` message should be used directly inside batch response, one for
            #     each error sub-response.
            #
            # - Asynchronous operations. If an API call embeds asynchronous operation
            #     results in its response, the status of those operations should be
            #     represented directly using the `Status` message.
            #
            # - Logging. If some API errors are stored in logs, the message `Status` could
            #     be used directly after any stripping needed for security/privacy reasons.
          "message": "A String", # A developer-facing error message, which should be in English. Any
              # user-facing error message should be localized and sent in the
              # google.rpc.Status.details field, or localized by the client.
          "code": 42, # The status code, which should be an enum value of google.rpc.Code.
          "details": [ # A list of messages that carry the error details.  There will be a
              # common set of message types for APIs to use.
            {
              "a_key": "", # Properties of the object. Contains field @type with type URL.
            },
          ],
        },
        "cropHintsAnnotation": { # Set of crop hints that are used to generate new crops when serving images. # If present, crop hints have completed successfully.
          "cropHints": [ # Crop hint results.
            { # Single crop hint that is used to generate a new crop when serving an image.
              "confidence": 3.14, # Confidence of this being a salient region.  Range [0, 1].
              "boundingPoly": { # A bounding polygon for the detected image annotation. # The bounding polygon for the crop region. The coordinates of the bounding
                  # box are in the original image's scale, as returned in `ImageParams`.
                "vertices": [ # The bounding polygon vertices.
                  { # A vertex represents a 2D point in the image.
                      # NOTE: the vertex coordinates are in the same scale as the original image.
                    "y": 42, # Y coordinate.
                    "x": 42, # X coordinate.
                  },
                ],
              },
              "importanceFraction": 3.14, # Fraction of importance of this salient region with respect to the original
                  # image.
            },
          ],
        },
      },
    ],
  }</pre>
</div>

</body></html>