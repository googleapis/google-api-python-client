<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="aiplatform_v1.html">Vertex AI API</a> . <a href="aiplatform_v1.projects.html">projects</a> . <a href="aiplatform_v1.projects.locations.html">locations</a> . <a href="aiplatform_v1.projects.locations.modelDeploymentMonitoringJobs.html">modelDeploymentMonitoringJobs</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="aiplatform_v1.projects.locations.modelDeploymentMonitoringJobs.operations.html">operations()</a></code>
</p>
<p class="firstline">Returns the operations Resource.</p>

<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#create">create(parent, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Creates a ModelDeploymentMonitoringJob. It will run periodically on a configured interval.</p>
<p class="toc_element">
  <code><a href="#delete">delete(name, x__xgafv=None)</a></code></p>
<p class="firstline">Deletes a ModelDeploymentMonitoringJob.</p>
<p class="toc_element">
  <code><a href="#get">get(name, x__xgafv=None)</a></code></p>
<p class="firstline">Gets a ModelDeploymentMonitoringJob.</p>
<p class="toc_element">
  <code><a href="#list">list(parent, filter=None, pageSize=None, pageToken=None, readMask=None, x__xgafv=None)</a></code></p>
<p class="firstline">Lists ModelDeploymentMonitoringJobs in a Location.</p>
<p class="toc_element">
  <code><a href="#list_next">list_next()</a></code></p>
<p class="firstline">Retrieves the next page of results.</p>
<p class="toc_element">
  <code><a href="#patch">patch(name, body=None, updateMask=None, x__xgafv=None)</a></code></p>
<p class="firstline">Updates a ModelDeploymentMonitoringJob.</p>
<p class="toc_element">
  <code><a href="#pause">pause(name, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Pauses a ModelDeploymentMonitoringJob. If the job is running, the server makes a best effort to cancel the job. Will mark ModelDeploymentMonitoringJob.state to 'PAUSED'.</p>
<p class="toc_element">
  <code><a href="#resume">resume(name, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Resumes a paused ModelDeploymentMonitoringJob. It will start to run from next scheduled time. A deleted ModelDeploymentMonitoringJob can't be resumed.</p>
<p class="toc_element">
  <code><a href="#searchModelDeploymentMonitoringStatsAnomalies">searchModelDeploymentMonitoringStatsAnomalies(modelDeploymentMonitoringJob, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Searches Model Monitoring Statistics generated within a given time window.</p>
<p class="toc_element">
  <code><a href="#searchModelDeploymentMonitoringStatsAnomalies_next">searchModelDeploymentMonitoringStatsAnomalies_next()</a></code></p>
<p class="firstline">Retrieves the next page of results.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="create">create(parent, body=None, x__xgafv=None)</code>
  <pre>Creates a ModelDeploymentMonitoringJob. It will run periodically on a configured interval.

Args:
  parent: string, Required. The parent of the ModelDeploymentMonitoringJob. Format: `projects/{project}/locations/{location}` (required)
  body: object, The request body.
    The object takes the form of:

{ # Represents a job that runs periodically to monitor the deployed models in an endpoint. It will analyze the logged training &amp; prediction data to detect any abnormal behaviors.
  &quot;analysisInstanceSchemaUri&quot;: &quot;A String&quot;, # YAML schema file uri describing the format of a single instance that you want Tensorflow Data Validation (TFDV) to analyze. If this field is empty, all the feature data types are inferred from predict_instance_schema_uri, meaning that TFDV will use the data in the exact format(data type) as prediction request/response. If there are any data type differences between predict instance and TFDV instance, this field can be used to override the schema. For models trained with Vertex AI, this field must be set as all the fields in predict instance formatted as string.
  &quot;bigqueryTables&quot;: [ # Output only. The created bigquery tables for the job under customer project. Customer could do their own query &amp; analysis. There could be 4 log tables in maximum: 1. Training data logging predict request/response 2. Serving data logging predict request/response
    { # ModelDeploymentMonitoringBigQueryTable specifies the BigQuery table name as well as some information of the logs stored in this table.
      &quot;bigqueryTablePath&quot;: &quot;A String&quot;, # The created BigQuery table to store logs. Customer could do their own query &amp; analysis. Format: `bq://.model_deployment_monitoring_._`
      &quot;logSource&quot;: &quot;A String&quot;, # The source of log.
      &quot;logType&quot;: &quot;A String&quot;, # The type of log.
      &quot;requestResponseLoggingSchemaVersion&quot;: &quot;A String&quot;, # Output only. The schema version of the request/response logging BigQuery table. Default to v1 if unset.
    },
  ],
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelDeploymentMonitoringJob was created.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The user-defined name of the ModelDeploymentMonitoringJob. The name can be up to 128 characters long and can consist of any UTF-8 characters. Display name of a ModelDeploymentMonitoringJob.
  &quot;enableMonitoringPipelineLogs&quot;: True or False, # If true, the scheduled monitoring pipeline logs are sent to Google Cloud Logging, including pipeline status and anomalies detected. Please note the logs incur cost, which are subject to [Cloud Logging pricing](https://cloud.google.com/logging#pricing).
  &quot;encryptionSpec&quot;: { # Represents a customer-managed encryption key spec that can be applied to a top-level resource. # Customer-managed encryption key spec for a ModelDeploymentMonitoringJob. If set, this ModelDeploymentMonitoringJob and all sub-resources of this ModelDeploymentMonitoringJob will be secured by this key.
    &quot;kmsKeyName&quot;: &quot;A String&quot;, # Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
  },
  &quot;endpoint&quot;: &quot;A String&quot;, # Required. Endpoint resource name. Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. Only populated when the job&#x27;s state is `JOB_STATE_FAILED` or `JOB_STATE_CANCELLED`.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;labels&quot;: { # The labels with user-defined metadata to organize your ModelDeploymentMonitoringJob. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels.
    &quot;a_key&quot;: &quot;A String&quot;,
  },
  &quot;latestMonitoringPipelineMetadata&quot;: { # All metadata of most recent monitoring pipelines. # Output only. Latest triggered monitoring pipeline metadata.
    &quot;runTime&quot;: &quot;A String&quot;, # The time that most recent monitoring pipelines that is related to this run.
    &quot;status&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The status of the most recent monitoring pipeline.
      &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
      &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
        {
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
        },
      ],
      &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
    },
  },
  &quot;logTtl&quot;: &quot;A String&quot;, # The TTL of BigQuery tables in user projects which stores logs. A day is the basic unit of the TTL and we take the ceil of TTL/86400(a day). e.g. { second: 3600} indicates ttl = 1 day.
  &quot;loggingSamplingStrategy&quot;: { # Sampling Strategy for logging, can be for both training and prediction dataset. # Required. Sample Strategy for logging.
    &quot;randomSampleConfig&quot;: { # Requests are randomly selected. # Random sample config. Will support more sampling strategies later.
      &quot;sampleRate&quot;: 3.14, # Sample rate (0, 1]
    },
  },
  &quot;modelDeploymentMonitoringObjectiveConfigs&quot;: [ # Required. The config for monitoring objectives. This is a per DeployedModel config. Each DeployedModel needs to be configured separately.
    { # ModelDeploymentMonitoringObjectiveConfig contains the pair of deployed_model_id to ModelMonitoringObjectiveConfig.
      &quot;deployedModelId&quot;: &quot;A String&quot;, # The DeployedModel ID of the objective config.
      &quot;objectiveConfig&quot;: { # The objective configuration for model monitoring, including the information needed to detect anomalies for one particular model. # The objective config of for the modelmonitoring job of this deployed model.
        &quot;explanationConfig&quot;: { # The config for integrating with Vertex Explainable AI. Only applicable if the Model has explanation_spec populated. # The config for integrating with Vertex Explainable AI.
          &quot;enableFeatureAttributes&quot;: True or False, # If want to analyze the Vertex Explainable AI feature attribute scores or not. If set to true, Vertex AI will log the feature attributions from explain response and do the skew/drift detection for them.
          &quot;explanationBaseline&quot;: { # Output from BatchPredictionJob for Model Monitoring baseline dataset, which can be used to generate baseline attribution scores. # Predictions generated by the BatchPredictionJob using baseline dataset.
            &quot;bigquery&quot;: { # The BigQuery location for the output content. # BigQuery location for BatchExplain output.
              &quot;outputUri&quot;: &quot;A String&quot;, # Required. BigQuery URI to a project or table, up to 2000 characters long. When only the project is specified, the Dataset and Table is created. When the full table reference is specified, the Dataset must exist and table must not exist. Accepted forms: * BigQuery path. For example: `bq://projectId` or `bq://projectId.bqDatasetId` or `bq://projectId.bqDatasetId.bqTableId`.
            },
            &quot;gcs&quot;: { # The Google Cloud Storage location where the output is to be written to. # Cloud Storage location for BatchExplain output.
              &quot;outputUriPrefix&quot;: &quot;A String&quot;, # Required. Google Cloud Storage URI to output directory. If the uri doesn&#x27;t end with &#x27;/&#x27;, a &#x27;/&#x27; will be automatically appended. The directory is created if it doesn&#x27;t exist.
            },
            &quot;predictionFormat&quot;: &quot;A String&quot;, # The storage format of the predictions generated BatchPrediction job.
          },
        },
        &quot;predictionDriftDetectionConfig&quot;: { # The config for Prediction data drift detection. # The config for drift of prediction data.
          &quot;attributionScoreDriftThresholds&quot;: { # Key is the feature name and value is the threshold. The threshold here is against attribution score distance between different time windows.
            &quot;a_key&quot;: { # The config for feature monitoring threshold.
              &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
            },
          },
          &quot;defaultDriftThreshold&quot;: { # The config for feature monitoring threshold. # Drift anomaly detection threshold used by all features. When the per-feature thresholds are not set, this field can be used to specify a threshold for all features.
            &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
          },
          &quot;driftThresholds&quot;: { # Key is the feature name and value is the threshold. If a feature needs to be monitored for drift, a value threshold must be configured for that feature. The threshold here is against feature distribution distance between different time windws.
            &quot;a_key&quot;: { # The config for feature monitoring threshold.
              &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
            },
          },
        },
        &quot;trainingDataset&quot;: { # Training Dataset information. # Training dataset for models. This field has to be set only if TrainingPredictionSkewDetectionConfig is specified.
          &quot;bigquerySource&quot;: { # The BigQuery location for the input content. # The BigQuery table of the unmanaged Dataset used to train this Model.
            &quot;inputUri&quot;: &quot;A String&quot;, # Required. BigQuery URI to a table, up to 2000 characters long. Accepted forms: * BigQuery path. For example: `bq://projectId.bqDatasetId.bqTableId`.
          },
          &quot;dataFormat&quot;: &quot;A String&quot;, # Data format of the dataset, only applicable if the input is from Google Cloud Storage. The possible formats are: &quot;tf-record&quot; The source file is a TFRecord file. &quot;csv&quot; The source file is a CSV file. &quot;jsonl&quot; The source file is a JSONL file.
          &quot;dataset&quot;: &quot;A String&quot;, # The resource name of the Dataset used to train this Model.
          &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Google Cloud Storage uri of the unmanaged Dataset used to train this Model.
            &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
              &quot;A String&quot;,
            ],
          },
          &quot;loggingSamplingStrategy&quot;: { # Sampling Strategy for logging, can be for both training and prediction dataset. # Strategy to sample data from Training Dataset. If not set, we process the whole dataset.
            &quot;randomSampleConfig&quot;: { # Requests are randomly selected. # Random sample config. Will support more sampling strategies later.
              &quot;sampleRate&quot;: 3.14, # Sample rate (0, 1]
            },
          },
          &quot;targetField&quot;: &quot;A String&quot;, # The target field name the model is to predict. This field will be excluded when doing Predict and (or) Explain for the training data.
        },
        &quot;trainingPredictionSkewDetectionConfig&quot;: { # The config for Training &amp; Prediction data skew detection. It specifies the training dataset sources and the skew detection parameters. # The config for skew between training data and prediction data.
          &quot;attributionScoreSkewThresholds&quot;: { # Key is the feature name and value is the threshold. The threshold here is against attribution score distance between the training and prediction feature.
            &quot;a_key&quot;: { # The config for feature monitoring threshold.
              &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
            },
          },
          &quot;defaultSkewThreshold&quot;: { # The config for feature monitoring threshold. # Skew anomaly detection threshold used by all features. When the per-feature thresholds are not set, this field can be used to specify a threshold for all features.
            &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
          },
          &quot;skewThresholds&quot;: { # Key is the feature name and value is the threshold. If a feature needs to be monitored for skew, a value threshold must be configured for that feature. The threshold here is against feature distribution distance between the training and prediction feature.
            &quot;a_key&quot;: { # The config for feature monitoring threshold.
              &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
            },
          },
        },
      },
    },
  ],
  &quot;modelDeploymentMonitoringScheduleConfig&quot;: { # The config for scheduling monitoring job. # Required. Schedule config for running the monitoring job.
    &quot;monitorInterval&quot;: &quot;A String&quot;, # Required. The model monitoring job scheduling interval. It will be rounded up to next full hour. This defines how often the monitoring jobs are triggered.
    &quot;monitorWindow&quot;: &quot;A String&quot;, # The time window of the prediction data being included in each prediction dataset. This window specifies how long the data should be collected from historical model results for each run. If not set, ModelDeploymentMonitoringScheduleConfig.monitor_interval will be used. e.g. If currently the cutoff time is 2022-01-08 14:30:00 and the monitor_window is set to be 3600, then data from 2022-01-08 13:30:00 to 2022-01-08 14:30:00 will be retrieved and aggregated to calculate the monitoring statistics.
  },
  &quot;modelMonitoringAlertConfig&quot;: { # The alert config for model monitoring. # Alert config for model monitoring.
    &quot;emailAlertConfig&quot;: { # The config for email alert. # Email alert config.
      &quot;userEmails&quot;: [ # The email addresses to send the alert.
        &quot;A String&quot;,
      ],
    },
    &quot;enableLogging&quot;: True or False, # Dump the anomalies to Cloud Logging. The anomalies will be put to json payload encoded from proto google.cloud.aiplatform.logging.ModelMonitoringAnomaliesLogEntry. This can be further sinked to Pub/Sub or any other services supported by Cloud Logging.
    &quot;notificationChannels&quot;: [ # Resource names of the NotificationChannels to send alert. Must be of the format `projects//notificationChannels/`
      &quot;A String&quot;,
    ],
  },
  &quot;name&quot;: &quot;A String&quot;, # Output only. Resource name of a ModelDeploymentMonitoringJob.
  &quot;nextScheduleTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this monitoring pipeline will be scheduled to run for the next round.
  &quot;predictInstanceSchemaUri&quot;: &quot;A String&quot;, # YAML schema file uri describing the format of a single instance, which are given to format this Endpoint&#x27;s prediction (and explanation). If not set, we will generate predict schema from collected predict requests.
  &quot;samplePredictInstance&quot;: &quot;&quot;, # Sample Predict instance, same format as PredictRequest.instances, this can be set as a replacement of ModelDeploymentMonitoringJob.predict_instance_schema_uri. If not set, we will generate predict schema from collected predict requests.
  &quot;satisfiesPzi&quot;: True or False, # Output only. Reserved for future use.
  &quot;satisfiesPzs&quot;: True or False, # Output only. Reserved for future use.
  &quot;scheduleState&quot;: &quot;A String&quot;, # Output only. Schedule state when the monitoring job is in Running state.
  &quot;state&quot;: &quot;A String&quot;, # Output only. The detailed state of the monitoring job. When the job is still creating, the state will be &#x27;PENDING&#x27;. Once the job is successfully created, the state will be &#x27;RUNNING&#x27;. Pause the job, the state will be &#x27;PAUSED&#x27;. Resume the job, the state will return to &#x27;RUNNING&#x27;.
  &quot;statsAnomaliesBaseDirectory&quot;: { # The Google Cloud Storage location where the output is to be written to. # Stats anomalies base folder path.
    &quot;outputUriPrefix&quot;: &quot;A String&quot;, # Required. Google Cloud Storage URI to output directory. If the uri doesn&#x27;t end with &#x27;/&#x27;, a &#x27;/&#x27; will be automatically appended. The directory is created if it doesn&#x27;t exist.
  },
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelDeploymentMonitoringJob was updated most recently.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Represents a job that runs periodically to monitor the deployed models in an endpoint. It will analyze the logged training &amp; prediction data to detect any abnormal behaviors.
  &quot;analysisInstanceSchemaUri&quot;: &quot;A String&quot;, # YAML schema file uri describing the format of a single instance that you want Tensorflow Data Validation (TFDV) to analyze. If this field is empty, all the feature data types are inferred from predict_instance_schema_uri, meaning that TFDV will use the data in the exact format(data type) as prediction request/response. If there are any data type differences between predict instance and TFDV instance, this field can be used to override the schema. For models trained with Vertex AI, this field must be set as all the fields in predict instance formatted as string.
  &quot;bigqueryTables&quot;: [ # Output only. The created bigquery tables for the job under customer project. Customer could do their own query &amp; analysis. There could be 4 log tables in maximum: 1. Training data logging predict request/response 2. Serving data logging predict request/response
    { # ModelDeploymentMonitoringBigQueryTable specifies the BigQuery table name as well as some information of the logs stored in this table.
      &quot;bigqueryTablePath&quot;: &quot;A String&quot;, # The created BigQuery table to store logs. Customer could do their own query &amp; analysis. Format: `bq://.model_deployment_monitoring_._`
      &quot;logSource&quot;: &quot;A String&quot;, # The source of log.
      &quot;logType&quot;: &quot;A String&quot;, # The type of log.
      &quot;requestResponseLoggingSchemaVersion&quot;: &quot;A String&quot;, # Output only. The schema version of the request/response logging BigQuery table. Default to v1 if unset.
    },
  ],
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelDeploymentMonitoringJob was created.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The user-defined name of the ModelDeploymentMonitoringJob. The name can be up to 128 characters long and can consist of any UTF-8 characters. Display name of a ModelDeploymentMonitoringJob.
  &quot;enableMonitoringPipelineLogs&quot;: True or False, # If true, the scheduled monitoring pipeline logs are sent to Google Cloud Logging, including pipeline status and anomalies detected. Please note the logs incur cost, which are subject to [Cloud Logging pricing](https://cloud.google.com/logging#pricing).
  &quot;encryptionSpec&quot;: { # Represents a customer-managed encryption key spec that can be applied to a top-level resource. # Customer-managed encryption key spec for a ModelDeploymentMonitoringJob. If set, this ModelDeploymentMonitoringJob and all sub-resources of this ModelDeploymentMonitoringJob will be secured by this key.
    &quot;kmsKeyName&quot;: &quot;A String&quot;, # Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
  },
  &quot;endpoint&quot;: &quot;A String&quot;, # Required. Endpoint resource name. Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. Only populated when the job&#x27;s state is `JOB_STATE_FAILED` or `JOB_STATE_CANCELLED`.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;labels&quot;: { # The labels with user-defined metadata to organize your ModelDeploymentMonitoringJob. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels.
    &quot;a_key&quot;: &quot;A String&quot;,
  },
  &quot;latestMonitoringPipelineMetadata&quot;: { # All metadata of most recent monitoring pipelines. # Output only. Latest triggered monitoring pipeline metadata.
    &quot;runTime&quot;: &quot;A String&quot;, # The time that most recent monitoring pipelines that is related to this run.
    &quot;status&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The status of the most recent monitoring pipeline.
      &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
      &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
        {
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
        },
      ],
      &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
    },
  },
  &quot;logTtl&quot;: &quot;A String&quot;, # The TTL of BigQuery tables in user projects which stores logs. A day is the basic unit of the TTL and we take the ceil of TTL/86400(a day). e.g. { second: 3600} indicates ttl = 1 day.
  &quot;loggingSamplingStrategy&quot;: { # Sampling Strategy for logging, can be for both training and prediction dataset. # Required. Sample Strategy for logging.
    &quot;randomSampleConfig&quot;: { # Requests are randomly selected. # Random sample config. Will support more sampling strategies later.
      &quot;sampleRate&quot;: 3.14, # Sample rate (0, 1]
    },
  },
  &quot;modelDeploymentMonitoringObjectiveConfigs&quot;: [ # Required. The config for monitoring objectives. This is a per DeployedModel config. Each DeployedModel needs to be configured separately.
    { # ModelDeploymentMonitoringObjectiveConfig contains the pair of deployed_model_id to ModelMonitoringObjectiveConfig.
      &quot;deployedModelId&quot;: &quot;A String&quot;, # The DeployedModel ID of the objective config.
      &quot;objectiveConfig&quot;: { # The objective configuration for model monitoring, including the information needed to detect anomalies for one particular model. # The objective config of for the modelmonitoring job of this deployed model.
        &quot;explanationConfig&quot;: { # The config for integrating with Vertex Explainable AI. Only applicable if the Model has explanation_spec populated. # The config for integrating with Vertex Explainable AI.
          &quot;enableFeatureAttributes&quot;: True or False, # If want to analyze the Vertex Explainable AI feature attribute scores or not. If set to true, Vertex AI will log the feature attributions from explain response and do the skew/drift detection for them.
          &quot;explanationBaseline&quot;: { # Output from BatchPredictionJob for Model Monitoring baseline dataset, which can be used to generate baseline attribution scores. # Predictions generated by the BatchPredictionJob using baseline dataset.
            &quot;bigquery&quot;: { # The BigQuery location for the output content. # BigQuery location for BatchExplain output.
              &quot;outputUri&quot;: &quot;A String&quot;, # Required. BigQuery URI to a project or table, up to 2000 characters long. When only the project is specified, the Dataset and Table is created. When the full table reference is specified, the Dataset must exist and table must not exist. Accepted forms: * BigQuery path. For example: `bq://projectId` or `bq://projectId.bqDatasetId` or `bq://projectId.bqDatasetId.bqTableId`.
            },
            &quot;gcs&quot;: { # The Google Cloud Storage location where the output is to be written to. # Cloud Storage location for BatchExplain output.
              &quot;outputUriPrefix&quot;: &quot;A String&quot;, # Required. Google Cloud Storage URI to output directory. If the uri doesn&#x27;t end with &#x27;/&#x27;, a &#x27;/&#x27; will be automatically appended. The directory is created if it doesn&#x27;t exist.
            },
            &quot;predictionFormat&quot;: &quot;A String&quot;, # The storage format of the predictions generated BatchPrediction job.
          },
        },
        &quot;predictionDriftDetectionConfig&quot;: { # The config for Prediction data drift detection. # The config for drift of prediction data.
          &quot;attributionScoreDriftThresholds&quot;: { # Key is the feature name and value is the threshold. The threshold here is against attribution score distance between different time windows.
            &quot;a_key&quot;: { # The config for feature monitoring threshold.
              &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
            },
          },
          &quot;defaultDriftThreshold&quot;: { # The config for feature monitoring threshold. # Drift anomaly detection threshold used by all features. When the per-feature thresholds are not set, this field can be used to specify a threshold for all features.
            &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
          },
          &quot;driftThresholds&quot;: { # Key is the feature name and value is the threshold. If a feature needs to be monitored for drift, a value threshold must be configured for that feature. The threshold here is against feature distribution distance between different time windws.
            &quot;a_key&quot;: { # The config for feature monitoring threshold.
              &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
            },
          },
        },
        &quot;trainingDataset&quot;: { # Training Dataset information. # Training dataset for models. This field has to be set only if TrainingPredictionSkewDetectionConfig is specified.
          &quot;bigquerySource&quot;: { # The BigQuery location for the input content. # The BigQuery table of the unmanaged Dataset used to train this Model.
            &quot;inputUri&quot;: &quot;A String&quot;, # Required. BigQuery URI to a table, up to 2000 characters long. Accepted forms: * BigQuery path. For example: `bq://projectId.bqDatasetId.bqTableId`.
          },
          &quot;dataFormat&quot;: &quot;A String&quot;, # Data format of the dataset, only applicable if the input is from Google Cloud Storage. The possible formats are: &quot;tf-record&quot; The source file is a TFRecord file. &quot;csv&quot; The source file is a CSV file. &quot;jsonl&quot; The source file is a JSONL file.
          &quot;dataset&quot;: &quot;A String&quot;, # The resource name of the Dataset used to train this Model.
          &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Google Cloud Storage uri of the unmanaged Dataset used to train this Model.
            &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
              &quot;A String&quot;,
            ],
          },
          &quot;loggingSamplingStrategy&quot;: { # Sampling Strategy for logging, can be for both training and prediction dataset. # Strategy to sample data from Training Dataset. If not set, we process the whole dataset.
            &quot;randomSampleConfig&quot;: { # Requests are randomly selected. # Random sample config. Will support more sampling strategies later.
              &quot;sampleRate&quot;: 3.14, # Sample rate (0, 1]
            },
          },
          &quot;targetField&quot;: &quot;A String&quot;, # The target field name the model is to predict. This field will be excluded when doing Predict and (or) Explain for the training data.
        },
        &quot;trainingPredictionSkewDetectionConfig&quot;: { # The config for Training &amp; Prediction data skew detection. It specifies the training dataset sources and the skew detection parameters. # The config for skew between training data and prediction data.
          &quot;attributionScoreSkewThresholds&quot;: { # Key is the feature name and value is the threshold. The threshold here is against attribution score distance between the training and prediction feature.
            &quot;a_key&quot;: { # The config for feature monitoring threshold.
              &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
            },
          },
          &quot;defaultSkewThreshold&quot;: { # The config for feature monitoring threshold. # Skew anomaly detection threshold used by all features. When the per-feature thresholds are not set, this field can be used to specify a threshold for all features.
            &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
          },
          &quot;skewThresholds&quot;: { # Key is the feature name and value is the threshold. If a feature needs to be monitored for skew, a value threshold must be configured for that feature. The threshold here is against feature distribution distance between the training and prediction feature.
            &quot;a_key&quot;: { # The config for feature monitoring threshold.
              &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
            },
          },
        },
      },
    },
  ],
  &quot;modelDeploymentMonitoringScheduleConfig&quot;: { # The config for scheduling monitoring job. # Required. Schedule config for running the monitoring job.
    &quot;monitorInterval&quot;: &quot;A String&quot;, # Required. The model monitoring job scheduling interval. It will be rounded up to next full hour. This defines how often the monitoring jobs are triggered.
    &quot;monitorWindow&quot;: &quot;A String&quot;, # The time window of the prediction data being included in each prediction dataset. This window specifies how long the data should be collected from historical model results for each run. If not set, ModelDeploymentMonitoringScheduleConfig.monitor_interval will be used. e.g. If currently the cutoff time is 2022-01-08 14:30:00 and the monitor_window is set to be 3600, then data from 2022-01-08 13:30:00 to 2022-01-08 14:30:00 will be retrieved and aggregated to calculate the monitoring statistics.
  },
  &quot;modelMonitoringAlertConfig&quot;: { # The alert config for model monitoring. # Alert config for model monitoring.
    &quot;emailAlertConfig&quot;: { # The config for email alert. # Email alert config.
      &quot;userEmails&quot;: [ # The email addresses to send the alert.
        &quot;A String&quot;,
      ],
    },
    &quot;enableLogging&quot;: True or False, # Dump the anomalies to Cloud Logging. The anomalies will be put to json payload encoded from proto google.cloud.aiplatform.logging.ModelMonitoringAnomaliesLogEntry. This can be further sinked to Pub/Sub or any other services supported by Cloud Logging.
    &quot;notificationChannels&quot;: [ # Resource names of the NotificationChannels to send alert. Must be of the format `projects//notificationChannels/`
      &quot;A String&quot;,
    ],
  },
  &quot;name&quot;: &quot;A String&quot;, # Output only. Resource name of a ModelDeploymentMonitoringJob.
  &quot;nextScheduleTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this monitoring pipeline will be scheduled to run for the next round.
  &quot;predictInstanceSchemaUri&quot;: &quot;A String&quot;, # YAML schema file uri describing the format of a single instance, which are given to format this Endpoint&#x27;s prediction (and explanation). If not set, we will generate predict schema from collected predict requests.
  &quot;samplePredictInstance&quot;: &quot;&quot;, # Sample Predict instance, same format as PredictRequest.instances, this can be set as a replacement of ModelDeploymentMonitoringJob.predict_instance_schema_uri. If not set, we will generate predict schema from collected predict requests.
  &quot;satisfiesPzi&quot;: True or False, # Output only. Reserved for future use.
  &quot;satisfiesPzs&quot;: True or False, # Output only. Reserved for future use.
  &quot;scheduleState&quot;: &quot;A String&quot;, # Output only. Schedule state when the monitoring job is in Running state.
  &quot;state&quot;: &quot;A String&quot;, # Output only. The detailed state of the monitoring job. When the job is still creating, the state will be &#x27;PENDING&#x27;. Once the job is successfully created, the state will be &#x27;RUNNING&#x27;. Pause the job, the state will be &#x27;PAUSED&#x27;. Resume the job, the state will return to &#x27;RUNNING&#x27;.
  &quot;statsAnomaliesBaseDirectory&quot;: { # The Google Cloud Storage location where the output is to be written to. # Stats anomalies base folder path.
    &quot;outputUriPrefix&quot;: &quot;A String&quot;, # Required. Google Cloud Storage URI to output directory. If the uri doesn&#x27;t end with &#x27;/&#x27;, a &#x27;/&#x27; will be automatically appended. The directory is created if it doesn&#x27;t exist.
  },
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelDeploymentMonitoringJob was updated most recently.
}</pre>
</div>

<div class="method">
    <code class="details" id="delete">delete(name, x__xgafv=None)</code>
  <pre>Deletes a ModelDeploymentMonitoringJob.

Args:
  name: string, Required. The resource name of the model monitoring job to delete. Format: `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}` (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # This resource represents a long-running operation that is the result of a network API call.
  &quot;done&quot;: True or False, # If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The error result of the operation in case of failure or cancellation.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;metadata&quot;: { # Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
  &quot;name&quot;: &quot;A String&quot;, # The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
  &quot;response&quot;: { # The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="get">get(name, x__xgafv=None)</code>
  <pre>Gets a ModelDeploymentMonitoringJob.

Args:
  name: string, Required. The resource name of the ModelDeploymentMonitoringJob. Format: `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}` (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Represents a job that runs periodically to monitor the deployed models in an endpoint. It will analyze the logged training &amp; prediction data to detect any abnormal behaviors.
  &quot;analysisInstanceSchemaUri&quot;: &quot;A String&quot;, # YAML schema file uri describing the format of a single instance that you want Tensorflow Data Validation (TFDV) to analyze. If this field is empty, all the feature data types are inferred from predict_instance_schema_uri, meaning that TFDV will use the data in the exact format(data type) as prediction request/response. If there are any data type differences between predict instance and TFDV instance, this field can be used to override the schema. For models trained with Vertex AI, this field must be set as all the fields in predict instance formatted as string.
  &quot;bigqueryTables&quot;: [ # Output only. The created bigquery tables for the job under customer project. Customer could do their own query &amp; analysis. There could be 4 log tables in maximum: 1. Training data logging predict request/response 2. Serving data logging predict request/response
    { # ModelDeploymentMonitoringBigQueryTable specifies the BigQuery table name as well as some information of the logs stored in this table.
      &quot;bigqueryTablePath&quot;: &quot;A String&quot;, # The created BigQuery table to store logs. Customer could do their own query &amp; analysis. Format: `bq://.model_deployment_monitoring_._`
      &quot;logSource&quot;: &quot;A String&quot;, # The source of log.
      &quot;logType&quot;: &quot;A String&quot;, # The type of log.
      &quot;requestResponseLoggingSchemaVersion&quot;: &quot;A String&quot;, # Output only. The schema version of the request/response logging BigQuery table. Default to v1 if unset.
    },
  ],
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelDeploymentMonitoringJob was created.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The user-defined name of the ModelDeploymentMonitoringJob. The name can be up to 128 characters long and can consist of any UTF-8 characters. Display name of a ModelDeploymentMonitoringJob.
  &quot;enableMonitoringPipelineLogs&quot;: True or False, # If true, the scheduled monitoring pipeline logs are sent to Google Cloud Logging, including pipeline status and anomalies detected. Please note the logs incur cost, which are subject to [Cloud Logging pricing](https://cloud.google.com/logging#pricing).
  &quot;encryptionSpec&quot;: { # Represents a customer-managed encryption key spec that can be applied to a top-level resource. # Customer-managed encryption key spec for a ModelDeploymentMonitoringJob. If set, this ModelDeploymentMonitoringJob and all sub-resources of this ModelDeploymentMonitoringJob will be secured by this key.
    &quot;kmsKeyName&quot;: &quot;A String&quot;, # Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
  },
  &quot;endpoint&quot;: &quot;A String&quot;, # Required. Endpoint resource name. Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. Only populated when the job&#x27;s state is `JOB_STATE_FAILED` or `JOB_STATE_CANCELLED`.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;labels&quot;: { # The labels with user-defined metadata to organize your ModelDeploymentMonitoringJob. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels.
    &quot;a_key&quot;: &quot;A String&quot;,
  },
  &quot;latestMonitoringPipelineMetadata&quot;: { # All metadata of most recent monitoring pipelines. # Output only. Latest triggered monitoring pipeline metadata.
    &quot;runTime&quot;: &quot;A String&quot;, # The time that most recent monitoring pipelines that is related to this run.
    &quot;status&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The status of the most recent monitoring pipeline.
      &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
      &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
        {
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
        },
      ],
      &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
    },
  },
  &quot;logTtl&quot;: &quot;A String&quot;, # The TTL of BigQuery tables in user projects which stores logs. A day is the basic unit of the TTL and we take the ceil of TTL/86400(a day). e.g. { second: 3600} indicates ttl = 1 day.
  &quot;loggingSamplingStrategy&quot;: { # Sampling Strategy for logging, can be for both training and prediction dataset. # Required. Sample Strategy for logging.
    &quot;randomSampleConfig&quot;: { # Requests are randomly selected. # Random sample config. Will support more sampling strategies later.
      &quot;sampleRate&quot;: 3.14, # Sample rate (0, 1]
    },
  },
  &quot;modelDeploymentMonitoringObjectiveConfigs&quot;: [ # Required. The config for monitoring objectives. This is a per DeployedModel config. Each DeployedModel needs to be configured separately.
    { # ModelDeploymentMonitoringObjectiveConfig contains the pair of deployed_model_id to ModelMonitoringObjectiveConfig.
      &quot;deployedModelId&quot;: &quot;A String&quot;, # The DeployedModel ID of the objective config.
      &quot;objectiveConfig&quot;: { # The objective configuration for model monitoring, including the information needed to detect anomalies for one particular model. # The objective config of for the modelmonitoring job of this deployed model.
        &quot;explanationConfig&quot;: { # The config for integrating with Vertex Explainable AI. Only applicable if the Model has explanation_spec populated. # The config for integrating with Vertex Explainable AI.
          &quot;enableFeatureAttributes&quot;: True or False, # If want to analyze the Vertex Explainable AI feature attribute scores or not. If set to true, Vertex AI will log the feature attributions from explain response and do the skew/drift detection for them.
          &quot;explanationBaseline&quot;: { # Output from BatchPredictionJob for Model Monitoring baseline dataset, which can be used to generate baseline attribution scores. # Predictions generated by the BatchPredictionJob using baseline dataset.
            &quot;bigquery&quot;: { # The BigQuery location for the output content. # BigQuery location for BatchExplain output.
              &quot;outputUri&quot;: &quot;A String&quot;, # Required. BigQuery URI to a project or table, up to 2000 characters long. When only the project is specified, the Dataset and Table is created. When the full table reference is specified, the Dataset must exist and table must not exist. Accepted forms: * BigQuery path. For example: `bq://projectId` or `bq://projectId.bqDatasetId` or `bq://projectId.bqDatasetId.bqTableId`.
            },
            &quot;gcs&quot;: { # The Google Cloud Storage location where the output is to be written to. # Cloud Storage location for BatchExplain output.
              &quot;outputUriPrefix&quot;: &quot;A String&quot;, # Required. Google Cloud Storage URI to output directory. If the uri doesn&#x27;t end with &#x27;/&#x27;, a &#x27;/&#x27; will be automatically appended. The directory is created if it doesn&#x27;t exist.
            },
            &quot;predictionFormat&quot;: &quot;A String&quot;, # The storage format of the predictions generated BatchPrediction job.
          },
        },
        &quot;predictionDriftDetectionConfig&quot;: { # The config for Prediction data drift detection. # The config for drift of prediction data.
          &quot;attributionScoreDriftThresholds&quot;: { # Key is the feature name and value is the threshold. The threshold here is against attribution score distance between different time windows.
            &quot;a_key&quot;: { # The config for feature monitoring threshold.
              &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
            },
          },
          &quot;defaultDriftThreshold&quot;: { # The config for feature monitoring threshold. # Drift anomaly detection threshold used by all features. When the per-feature thresholds are not set, this field can be used to specify a threshold for all features.
            &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
          },
          &quot;driftThresholds&quot;: { # Key is the feature name and value is the threshold. If a feature needs to be monitored for drift, a value threshold must be configured for that feature. The threshold here is against feature distribution distance between different time windws.
            &quot;a_key&quot;: { # The config for feature monitoring threshold.
              &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
            },
          },
        },
        &quot;trainingDataset&quot;: { # Training Dataset information. # Training dataset for models. This field has to be set only if TrainingPredictionSkewDetectionConfig is specified.
          &quot;bigquerySource&quot;: { # The BigQuery location for the input content. # The BigQuery table of the unmanaged Dataset used to train this Model.
            &quot;inputUri&quot;: &quot;A String&quot;, # Required. BigQuery URI to a table, up to 2000 characters long. Accepted forms: * BigQuery path. For example: `bq://projectId.bqDatasetId.bqTableId`.
          },
          &quot;dataFormat&quot;: &quot;A String&quot;, # Data format of the dataset, only applicable if the input is from Google Cloud Storage. The possible formats are: &quot;tf-record&quot; The source file is a TFRecord file. &quot;csv&quot; The source file is a CSV file. &quot;jsonl&quot; The source file is a JSONL file.
          &quot;dataset&quot;: &quot;A String&quot;, # The resource name of the Dataset used to train this Model.
          &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Google Cloud Storage uri of the unmanaged Dataset used to train this Model.
            &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
              &quot;A String&quot;,
            ],
          },
          &quot;loggingSamplingStrategy&quot;: { # Sampling Strategy for logging, can be for both training and prediction dataset. # Strategy to sample data from Training Dataset. If not set, we process the whole dataset.
            &quot;randomSampleConfig&quot;: { # Requests are randomly selected. # Random sample config. Will support more sampling strategies later.
              &quot;sampleRate&quot;: 3.14, # Sample rate (0, 1]
            },
          },
          &quot;targetField&quot;: &quot;A String&quot;, # The target field name the model is to predict. This field will be excluded when doing Predict and (or) Explain for the training data.
        },
        &quot;trainingPredictionSkewDetectionConfig&quot;: { # The config for Training &amp; Prediction data skew detection. It specifies the training dataset sources and the skew detection parameters. # The config for skew between training data and prediction data.
          &quot;attributionScoreSkewThresholds&quot;: { # Key is the feature name and value is the threshold. The threshold here is against attribution score distance between the training and prediction feature.
            &quot;a_key&quot;: { # The config for feature monitoring threshold.
              &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
            },
          },
          &quot;defaultSkewThreshold&quot;: { # The config for feature monitoring threshold. # Skew anomaly detection threshold used by all features. When the per-feature thresholds are not set, this field can be used to specify a threshold for all features.
            &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
          },
          &quot;skewThresholds&quot;: { # Key is the feature name and value is the threshold. If a feature needs to be monitored for skew, a value threshold must be configured for that feature. The threshold here is against feature distribution distance between the training and prediction feature.
            &quot;a_key&quot;: { # The config for feature monitoring threshold.
              &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
            },
          },
        },
      },
    },
  ],
  &quot;modelDeploymentMonitoringScheduleConfig&quot;: { # The config for scheduling monitoring job. # Required. Schedule config for running the monitoring job.
    &quot;monitorInterval&quot;: &quot;A String&quot;, # Required. The model monitoring job scheduling interval. It will be rounded up to next full hour. This defines how often the monitoring jobs are triggered.
    &quot;monitorWindow&quot;: &quot;A String&quot;, # The time window of the prediction data being included in each prediction dataset. This window specifies how long the data should be collected from historical model results for each run. If not set, ModelDeploymentMonitoringScheduleConfig.monitor_interval will be used. e.g. If currently the cutoff time is 2022-01-08 14:30:00 and the monitor_window is set to be 3600, then data from 2022-01-08 13:30:00 to 2022-01-08 14:30:00 will be retrieved and aggregated to calculate the monitoring statistics.
  },
  &quot;modelMonitoringAlertConfig&quot;: { # The alert config for model monitoring. # Alert config for model monitoring.
    &quot;emailAlertConfig&quot;: { # The config for email alert. # Email alert config.
      &quot;userEmails&quot;: [ # The email addresses to send the alert.
        &quot;A String&quot;,
      ],
    },
    &quot;enableLogging&quot;: True or False, # Dump the anomalies to Cloud Logging. The anomalies will be put to json payload encoded from proto google.cloud.aiplatform.logging.ModelMonitoringAnomaliesLogEntry. This can be further sinked to Pub/Sub or any other services supported by Cloud Logging.
    &quot;notificationChannels&quot;: [ # Resource names of the NotificationChannels to send alert. Must be of the format `projects//notificationChannels/`
      &quot;A String&quot;,
    ],
  },
  &quot;name&quot;: &quot;A String&quot;, # Output only. Resource name of a ModelDeploymentMonitoringJob.
  &quot;nextScheduleTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this monitoring pipeline will be scheduled to run for the next round.
  &quot;predictInstanceSchemaUri&quot;: &quot;A String&quot;, # YAML schema file uri describing the format of a single instance, which are given to format this Endpoint&#x27;s prediction (and explanation). If not set, we will generate predict schema from collected predict requests.
  &quot;samplePredictInstance&quot;: &quot;&quot;, # Sample Predict instance, same format as PredictRequest.instances, this can be set as a replacement of ModelDeploymentMonitoringJob.predict_instance_schema_uri. If not set, we will generate predict schema from collected predict requests.
  &quot;satisfiesPzi&quot;: True or False, # Output only. Reserved for future use.
  &quot;satisfiesPzs&quot;: True or False, # Output only. Reserved for future use.
  &quot;scheduleState&quot;: &quot;A String&quot;, # Output only. Schedule state when the monitoring job is in Running state.
  &quot;state&quot;: &quot;A String&quot;, # Output only. The detailed state of the monitoring job. When the job is still creating, the state will be &#x27;PENDING&#x27;. Once the job is successfully created, the state will be &#x27;RUNNING&#x27;. Pause the job, the state will be &#x27;PAUSED&#x27;. Resume the job, the state will return to &#x27;RUNNING&#x27;.
  &quot;statsAnomaliesBaseDirectory&quot;: { # The Google Cloud Storage location where the output is to be written to. # Stats anomalies base folder path.
    &quot;outputUriPrefix&quot;: &quot;A String&quot;, # Required. Google Cloud Storage URI to output directory. If the uri doesn&#x27;t end with &#x27;/&#x27;, a &#x27;/&#x27; will be automatically appended. The directory is created if it doesn&#x27;t exist.
  },
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelDeploymentMonitoringJob was updated most recently.
}</pre>
</div>

<div class="method">
    <code class="details" id="list">list(parent, filter=None, pageSize=None, pageToken=None, readMask=None, x__xgafv=None)</code>
  <pre>Lists ModelDeploymentMonitoringJobs in a Location.

Args:
  parent: string, Required. The parent of the ModelDeploymentMonitoringJob. Format: `projects/{project}/locations/{location}` (required)
  filter: string, The standard list filter. Supported fields: * `display_name` supports `=`, `!=` comparisons, and `:` wildcard. * `state` supports `=`, `!=` comparisons. * `create_time` supports `=`, `!=`,`&lt;`, `&lt;=`,`&gt;`, `&gt;=` comparisons. `create_time` must be in RFC 3339 format. * `labels` supports general map functions that is: `labels.key=value` - key:value equality `labels.key:* - key existence Some examples of using the filter are: * `state=&quot;JOB_STATE_SUCCEEDED&quot; AND display_name:&quot;my_job_*&quot;` * `state!=&quot;JOB_STATE_FAILED&quot; OR display_name=&quot;my_job&quot;` * `NOT display_name=&quot;my_job&quot;` * `create_time&gt;&quot;2021-05-18T00:00:00Z&quot;` * `labels.keyA=valueA` * `labels.keyB:*`
  pageSize: integer, The standard list page size.
  pageToken: string, The standard list page token.
  readMask: string, Mask specifying which fields to read
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response message for JobService.ListModelDeploymentMonitoringJobs.
  &quot;modelDeploymentMonitoringJobs&quot;: [ # A list of ModelDeploymentMonitoringJobs that matches the specified filter in the request.
    { # Represents a job that runs periodically to monitor the deployed models in an endpoint. It will analyze the logged training &amp; prediction data to detect any abnormal behaviors.
      &quot;analysisInstanceSchemaUri&quot;: &quot;A String&quot;, # YAML schema file uri describing the format of a single instance that you want Tensorflow Data Validation (TFDV) to analyze. If this field is empty, all the feature data types are inferred from predict_instance_schema_uri, meaning that TFDV will use the data in the exact format(data type) as prediction request/response. If there are any data type differences between predict instance and TFDV instance, this field can be used to override the schema. For models trained with Vertex AI, this field must be set as all the fields in predict instance formatted as string.
      &quot;bigqueryTables&quot;: [ # Output only. The created bigquery tables for the job under customer project. Customer could do their own query &amp; analysis. There could be 4 log tables in maximum: 1. Training data logging predict request/response 2. Serving data logging predict request/response
        { # ModelDeploymentMonitoringBigQueryTable specifies the BigQuery table name as well as some information of the logs stored in this table.
          &quot;bigqueryTablePath&quot;: &quot;A String&quot;, # The created BigQuery table to store logs. Customer could do their own query &amp; analysis. Format: `bq://.model_deployment_monitoring_._`
          &quot;logSource&quot;: &quot;A String&quot;, # The source of log.
          &quot;logType&quot;: &quot;A String&quot;, # The type of log.
          &quot;requestResponseLoggingSchemaVersion&quot;: &quot;A String&quot;, # Output only. The schema version of the request/response logging BigQuery table. Default to v1 if unset.
        },
      ],
      &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelDeploymentMonitoringJob was created.
      &quot;displayName&quot;: &quot;A String&quot;, # Required. The user-defined name of the ModelDeploymentMonitoringJob. The name can be up to 128 characters long and can consist of any UTF-8 characters. Display name of a ModelDeploymentMonitoringJob.
      &quot;enableMonitoringPipelineLogs&quot;: True or False, # If true, the scheduled monitoring pipeline logs are sent to Google Cloud Logging, including pipeline status and anomalies detected. Please note the logs incur cost, which are subject to [Cloud Logging pricing](https://cloud.google.com/logging#pricing).
      &quot;encryptionSpec&quot;: { # Represents a customer-managed encryption key spec that can be applied to a top-level resource. # Customer-managed encryption key spec for a ModelDeploymentMonitoringJob. If set, this ModelDeploymentMonitoringJob and all sub-resources of this ModelDeploymentMonitoringJob will be secured by this key.
        &quot;kmsKeyName&quot;: &quot;A String&quot;, # Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
      },
      &quot;endpoint&quot;: &quot;A String&quot;, # Required. Endpoint resource name. Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`
      &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. Only populated when the job&#x27;s state is `JOB_STATE_FAILED` or `JOB_STATE_CANCELLED`.
        &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
        &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
          {
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
          },
        ],
        &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
      },
      &quot;labels&quot;: { # The labels with user-defined metadata to organize your ModelDeploymentMonitoringJob. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
      &quot;latestMonitoringPipelineMetadata&quot;: { # All metadata of most recent monitoring pipelines. # Output only. Latest triggered monitoring pipeline metadata.
        &quot;runTime&quot;: &quot;A String&quot;, # The time that most recent monitoring pipelines that is related to this run.
        &quot;status&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The status of the most recent monitoring pipeline.
          &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
          &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
            {
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
            },
          ],
          &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
        },
      },
      &quot;logTtl&quot;: &quot;A String&quot;, # The TTL of BigQuery tables in user projects which stores logs. A day is the basic unit of the TTL and we take the ceil of TTL/86400(a day). e.g. { second: 3600} indicates ttl = 1 day.
      &quot;loggingSamplingStrategy&quot;: { # Sampling Strategy for logging, can be for both training and prediction dataset. # Required. Sample Strategy for logging.
        &quot;randomSampleConfig&quot;: { # Requests are randomly selected. # Random sample config. Will support more sampling strategies later.
          &quot;sampleRate&quot;: 3.14, # Sample rate (0, 1]
        },
      },
      &quot;modelDeploymentMonitoringObjectiveConfigs&quot;: [ # Required. The config for monitoring objectives. This is a per DeployedModel config. Each DeployedModel needs to be configured separately.
        { # ModelDeploymentMonitoringObjectiveConfig contains the pair of deployed_model_id to ModelMonitoringObjectiveConfig.
          &quot;deployedModelId&quot;: &quot;A String&quot;, # The DeployedModel ID of the objective config.
          &quot;objectiveConfig&quot;: { # The objective configuration for model monitoring, including the information needed to detect anomalies for one particular model. # The objective config of for the modelmonitoring job of this deployed model.
            &quot;explanationConfig&quot;: { # The config for integrating with Vertex Explainable AI. Only applicable if the Model has explanation_spec populated. # The config for integrating with Vertex Explainable AI.
              &quot;enableFeatureAttributes&quot;: True or False, # If want to analyze the Vertex Explainable AI feature attribute scores or not. If set to true, Vertex AI will log the feature attributions from explain response and do the skew/drift detection for them.
              &quot;explanationBaseline&quot;: { # Output from BatchPredictionJob for Model Monitoring baseline dataset, which can be used to generate baseline attribution scores. # Predictions generated by the BatchPredictionJob using baseline dataset.
                &quot;bigquery&quot;: { # The BigQuery location for the output content. # BigQuery location for BatchExplain output.
                  &quot;outputUri&quot;: &quot;A String&quot;, # Required. BigQuery URI to a project or table, up to 2000 characters long. When only the project is specified, the Dataset and Table is created. When the full table reference is specified, the Dataset must exist and table must not exist. Accepted forms: * BigQuery path. For example: `bq://projectId` or `bq://projectId.bqDatasetId` or `bq://projectId.bqDatasetId.bqTableId`.
                },
                &quot;gcs&quot;: { # The Google Cloud Storage location where the output is to be written to. # Cloud Storage location for BatchExplain output.
                  &quot;outputUriPrefix&quot;: &quot;A String&quot;, # Required. Google Cloud Storage URI to output directory. If the uri doesn&#x27;t end with &#x27;/&#x27;, a &#x27;/&#x27; will be automatically appended. The directory is created if it doesn&#x27;t exist.
                },
                &quot;predictionFormat&quot;: &quot;A String&quot;, # The storage format of the predictions generated BatchPrediction job.
              },
            },
            &quot;predictionDriftDetectionConfig&quot;: { # The config for Prediction data drift detection. # The config for drift of prediction data.
              &quot;attributionScoreDriftThresholds&quot;: { # Key is the feature name and value is the threshold. The threshold here is against attribution score distance between different time windows.
                &quot;a_key&quot;: { # The config for feature monitoring threshold.
                  &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
                },
              },
              &quot;defaultDriftThreshold&quot;: { # The config for feature monitoring threshold. # Drift anomaly detection threshold used by all features. When the per-feature thresholds are not set, this field can be used to specify a threshold for all features.
                &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
              },
              &quot;driftThresholds&quot;: { # Key is the feature name and value is the threshold. If a feature needs to be monitored for drift, a value threshold must be configured for that feature. The threshold here is against feature distribution distance between different time windws.
                &quot;a_key&quot;: { # The config for feature monitoring threshold.
                  &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
                },
              },
            },
            &quot;trainingDataset&quot;: { # Training Dataset information. # Training dataset for models. This field has to be set only if TrainingPredictionSkewDetectionConfig is specified.
              &quot;bigquerySource&quot;: { # The BigQuery location for the input content. # The BigQuery table of the unmanaged Dataset used to train this Model.
                &quot;inputUri&quot;: &quot;A String&quot;, # Required. BigQuery URI to a table, up to 2000 characters long. Accepted forms: * BigQuery path. For example: `bq://projectId.bqDatasetId.bqTableId`.
              },
              &quot;dataFormat&quot;: &quot;A String&quot;, # Data format of the dataset, only applicable if the input is from Google Cloud Storage. The possible formats are: &quot;tf-record&quot; The source file is a TFRecord file. &quot;csv&quot; The source file is a CSV file. &quot;jsonl&quot; The source file is a JSONL file.
              &quot;dataset&quot;: &quot;A String&quot;, # The resource name of the Dataset used to train this Model.
              &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Google Cloud Storage uri of the unmanaged Dataset used to train this Model.
                &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                  &quot;A String&quot;,
                ],
              },
              &quot;loggingSamplingStrategy&quot;: { # Sampling Strategy for logging, can be for both training and prediction dataset. # Strategy to sample data from Training Dataset. If not set, we process the whole dataset.
                &quot;randomSampleConfig&quot;: { # Requests are randomly selected. # Random sample config. Will support more sampling strategies later.
                  &quot;sampleRate&quot;: 3.14, # Sample rate (0, 1]
                },
              },
              &quot;targetField&quot;: &quot;A String&quot;, # The target field name the model is to predict. This field will be excluded when doing Predict and (or) Explain for the training data.
            },
            &quot;trainingPredictionSkewDetectionConfig&quot;: { # The config for Training &amp; Prediction data skew detection. It specifies the training dataset sources and the skew detection parameters. # The config for skew between training data and prediction data.
              &quot;attributionScoreSkewThresholds&quot;: { # Key is the feature name and value is the threshold. The threshold here is against attribution score distance between the training and prediction feature.
                &quot;a_key&quot;: { # The config for feature monitoring threshold.
                  &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
                },
              },
              &quot;defaultSkewThreshold&quot;: { # The config for feature monitoring threshold. # Skew anomaly detection threshold used by all features. When the per-feature thresholds are not set, this field can be used to specify a threshold for all features.
                &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
              },
              &quot;skewThresholds&quot;: { # Key is the feature name and value is the threshold. If a feature needs to be monitored for skew, a value threshold must be configured for that feature. The threshold here is against feature distribution distance between the training and prediction feature.
                &quot;a_key&quot;: { # The config for feature monitoring threshold.
                  &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
                },
              },
            },
          },
        },
      ],
      &quot;modelDeploymentMonitoringScheduleConfig&quot;: { # The config for scheduling monitoring job. # Required. Schedule config for running the monitoring job.
        &quot;monitorInterval&quot;: &quot;A String&quot;, # Required. The model monitoring job scheduling interval. It will be rounded up to next full hour. This defines how often the monitoring jobs are triggered.
        &quot;monitorWindow&quot;: &quot;A String&quot;, # The time window of the prediction data being included in each prediction dataset. This window specifies how long the data should be collected from historical model results for each run. If not set, ModelDeploymentMonitoringScheduleConfig.monitor_interval will be used. e.g. If currently the cutoff time is 2022-01-08 14:30:00 and the monitor_window is set to be 3600, then data from 2022-01-08 13:30:00 to 2022-01-08 14:30:00 will be retrieved and aggregated to calculate the monitoring statistics.
      },
      &quot;modelMonitoringAlertConfig&quot;: { # The alert config for model monitoring. # Alert config for model monitoring.
        &quot;emailAlertConfig&quot;: { # The config for email alert. # Email alert config.
          &quot;userEmails&quot;: [ # The email addresses to send the alert.
            &quot;A String&quot;,
          ],
        },
        &quot;enableLogging&quot;: True or False, # Dump the anomalies to Cloud Logging. The anomalies will be put to json payload encoded from proto google.cloud.aiplatform.logging.ModelMonitoringAnomaliesLogEntry. This can be further sinked to Pub/Sub or any other services supported by Cloud Logging.
        &quot;notificationChannels&quot;: [ # Resource names of the NotificationChannels to send alert. Must be of the format `projects//notificationChannels/`
          &quot;A String&quot;,
        ],
      },
      &quot;name&quot;: &quot;A String&quot;, # Output only. Resource name of a ModelDeploymentMonitoringJob.
      &quot;nextScheduleTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this monitoring pipeline will be scheduled to run for the next round.
      &quot;predictInstanceSchemaUri&quot;: &quot;A String&quot;, # YAML schema file uri describing the format of a single instance, which are given to format this Endpoint&#x27;s prediction (and explanation). If not set, we will generate predict schema from collected predict requests.
      &quot;samplePredictInstance&quot;: &quot;&quot;, # Sample Predict instance, same format as PredictRequest.instances, this can be set as a replacement of ModelDeploymentMonitoringJob.predict_instance_schema_uri. If not set, we will generate predict schema from collected predict requests.
      &quot;satisfiesPzi&quot;: True or False, # Output only. Reserved for future use.
      &quot;satisfiesPzs&quot;: True or False, # Output only. Reserved for future use.
      &quot;scheduleState&quot;: &quot;A String&quot;, # Output only. Schedule state when the monitoring job is in Running state.
      &quot;state&quot;: &quot;A String&quot;, # Output only. The detailed state of the monitoring job. When the job is still creating, the state will be &#x27;PENDING&#x27;. Once the job is successfully created, the state will be &#x27;RUNNING&#x27;. Pause the job, the state will be &#x27;PAUSED&#x27;. Resume the job, the state will return to &#x27;RUNNING&#x27;.
      &quot;statsAnomaliesBaseDirectory&quot;: { # The Google Cloud Storage location where the output is to be written to. # Stats anomalies base folder path.
        &quot;outputUriPrefix&quot;: &quot;A String&quot;, # Required. Google Cloud Storage URI to output directory. If the uri doesn&#x27;t end with &#x27;/&#x27;, a &#x27;/&#x27; will be automatically appended. The directory is created if it doesn&#x27;t exist.
      },
      &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelDeploymentMonitoringJob was updated most recently.
    },
  ],
  &quot;nextPageToken&quot;: &quot;A String&quot;, # The standard List next-page token.
}</pre>
</div>

<div class="method">
    <code class="details" id="list_next">list_next()</code>
  <pre>Retrieves the next page of results.

        Args:
          previous_request: The request for the previous page. (required)
          previous_response: The response from the request for the previous page. (required)

        Returns:
          A request object that you can call &#x27;execute()&#x27; on to request the next
          page. Returns None if there are no more items in the collection.
        </pre>
</div>

<div class="method">
    <code class="details" id="patch">patch(name, body=None, updateMask=None, x__xgafv=None)</code>
  <pre>Updates a ModelDeploymentMonitoringJob.

Args:
  name: string, Output only. Resource name of a ModelDeploymentMonitoringJob. (required)
  body: object, The request body.
    The object takes the form of:

{ # Represents a job that runs periodically to monitor the deployed models in an endpoint. It will analyze the logged training &amp; prediction data to detect any abnormal behaviors.
  &quot;analysisInstanceSchemaUri&quot;: &quot;A String&quot;, # YAML schema file uri describing the format of a single instance that you want Tensorflow Data Validation (TFDV) to analyze. If this field is empty, all the feature data types are inferred from predict_instance_schema_uri, meaning that TFDV will use the data in the exact format(data type) as prediction request/response. If there are any data type differences between predict instance and TFDV instance, this field can be used to override the schema. For models trained with Vertex AI, this field must be set as all the fields in predict instance formatted as string.
  &quot;bigqueryTables&quot;: [ # Output only. The created bigquery tables for the job under customer project. Customer could do their own query &amp; analysis. There could be 4 log tables in maximum: 1. Training data logging predict request/response 2. Serving data logging predict request/response
    { # ModelDeploymentMonitoringBigQueryTable specifies the BigQuery table name as well as some information of the logs stored in this table.
      &quot;bigqueryTablePath&quot;: &quot;A String&quot;, # The created BigQuery table to store logs. Customer could do their own query &amp; analysis. Format: `bq://.model_deployment_monitoring_._`
      &quot;logSource&quot;: &quot;A String&quot;, # The source of log.
      &quot;logType&quot;: &quot;A String&quot;, # The type of log.
      &quot;requestResponseLoggingSchemaVersion&quot;: &quot;A String&quot;, # Output only. The schema version of the request/response logging BigQuery table. Default to v1 if unset.
    },
  ],
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelDeploymentMonitoringJob was created.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The user-defined name of the ModelDeploymentMonitoringJob. The name can be up to 128 characters long and can consist of any UTF-8 characters. Display name of a ModelDeploymentMonitoringJob.
  &quot;enableMonitoringPipelineLogs&quot;: True or False, # If true, the scheduled monitoring pipeline logs are sent to Google Cloud Logging, including pipeline status and anomalies detected. Please note the logs incur cost, which are subject to [Cloud Logging pricing](https://cloud.google.com/logging#pricing).
  &quot;encryptionSpec&quot;: { # Represents a customer-managed encryption key spec that can be applied to a top-level resource. # Customer-managed encryption key spec for a ModelDeploymentMonitoringJob. If set, this ModelDeploymentMonitoringJob and all sub-resources of this ModelDeploymentMonitoringJob will be secured by this key.
    &quot;kmsKeyName&quot;: &quot;A String&quot;, # Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
  },
  &quot;endpoint&quot;: &quot;A String&quot;, # Required. Endpoint resource name. Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. Only populated when the job&#x27;s state is `JOB_STATE_FAILED` or `JOB_STATE_CANCELLED`.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;labels&quot;: { # The labels with user-defined metadata to organize your ModelDeploymentMonitoringJob. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels.
    &quot;a_key&quot;: &quot;A String&quot;,
  },
  &quot;latestMonitoringPipelineMetadata&quot;: { # All metadata of most recent monitoring pipelines. # Output only. Latest triggered monitoring pipeline metadata.
    &quot;runTime&quot;: &quot;A String&quot;, # The time that most recent monitoring pipelines that is related to this run.
    &quot;status&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The status of the most recent monitoring pipeline.
      &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
      &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
        {
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
        },
      ],
      &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
    },
  },
  &quot;logTtl&quot;: &quot;A String&quot;, # The TTL of BigQuery tables in user projects which stores logs. A day is the basic unit of the TTL and we take the ceil of TTL/86400(a day). e.g. { second: 3600} indicates ttl = 1 day.
  &quot;loggingSamplingStrategy&quot;: { # Sampling Strategy for logging, can be for both training and prediction dataset. # Required. Sample Strategy for logging.
    &quot;randomSampleConfig&quot;: { # Requests are randomly selected. # Random sample config. Will support more sampling strategies later.
      &quot;sampleRate&quot;: 3.14, # Sample rate (0, 1]
    },
  },
  &quot;modelDeploymentMonitoringObjectiveConfigs&quot;: [ # Required. The config for monitoring objectives. This is a per DeployedModel config. Each DeployedModel needs to be configured separately.
    { # ModelDeploymentMonitoringObjectiveConfig contains the pair of deployed_model_id to ModelMonitoringObjectiveConfig.
      &quot;deployedModelId&quot;: &quot;A String&quot;, # The DeployedModel ID of the objective config.
      &quot;objectiveConfig&quot;: { # The objective configuration for model monitoring, including the information needed to detect anomalies for one particular model. # The objective config of for the modelmonitoring job of this deployed model.
        &quot;explanationConfig&quot;: { # The config for integrating with Vertex Explainable AI. Only applicable if the Model has explanation_spec populated. # The config for integrating with Vertex Explainable AI.
          &quot;enableFeatureAttributes&quot;: True or False, # If want to analyze the Vertex Explainable AI feature attribute scores or not. If set to true, Vertex AI will log the feature attributions from explain response and do the skew/drift detection for them.
          &quot;explanationBaseline&quot;: { # Output from BatchPredictionJob for Model Monitoring baseline dataset, which can be used to generate baseline attribution scores. # Predictions generated by the BatchPredictionJob using baseline dataset.
            &quot;bigquery&quot;: { # The BigQuery location for the output content. # BigQuery location for BatchExplain output.
              &quot;outputUri&quot;: &quot;A String&quot;, # Required. BigQuery URI to a project or table, up to 2000 characters long. When only the project is specified, the Dataset and Table is created. When the full table reference is specified, the Dataset must exist and table must not exist. Accepted forms: * BigQuery path. For example: `bq://projectId` or `bq://projectId.bqDatasetId` or `bq://projectId.bqDatasetId.bqTableId`.
            },
            &quot;gcs&quot;: { # The Google Cloud Storage location where the output is to be written to. # Cloud Storage location for BatchExplain output.
              &quot;outputUriPrefix&quot;: &quot;A String&quot;, # Required. Google Cloud Storage URI to output directory. If the uri doesn&#x27;t end with &#x27;/&#x27;, a &#x27;/&#x27; will be automatically appended. The directory is created if it doesn&#x27;t exist.
            },
            &quot;predictionFormat&quot;: &quot;A String&quot;, # The storage format of the predictions generated BatchPrediction job.
          },
        },
        &quot;predictionDriftDetectionConfig&quot;: { # The config for Prediction data drift detection. # The config for drift of prediction data.
          &quot;attributionScoreDriftThresholds&quot;: { # Key is the feature name and value is the threshold. The threshold here is against attribution score distance between different time windows.
            &quot;a_key&quot;: { # The config for feature monitoring threshold.
              &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
            },
          },
          &quot;defaultDriftThreshold&quot;: { # The config for feature monitoring threshold. # Drift anomaly detection threshold used by all features. When the per-feature thresholds are not set, this field can be used to specify a threshold for all features.
            &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
          },
          &quot;driftThresholds&quot;: { # Key is the feature name and value is the threshold. If a feature needs to be monitored for drift, a value threshold must be configured for that feature. The threshold here is against feature distribution distance between different time windws.
            &quot;a_key&quot;: { # The config for feature monitoring threshold.
              &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
            },
          },
        },
        &quot;trainingDataset&quot;: { # Training Dataset information. # Training dataset for models. This field has to be set only if TrainingPredictionSkewDetectionConfig is specified.
          &quot;bigquerySource&quot;: { # The BigQuery location for the input content. # The BigQuery table of the unmanaged Dataset used to train this Model.
            &quot;inputUri&quot;: &quot;A String&quot;, # Required. BigQuery URI to a table, up to 2000 characters long. Accepted forms: * BigQuery path. For example: `bq://projectId.bqDatasetId.bqTableId`.
          },
          &quot;dataFormat&quot;: &quot;A String&quot;, # Data format of the dataset, only applicable if the input is from Google Cloud Storage. The possible formats are: &quot;tf-record&quot; The source file is a TFRecord file. &quot;csv&quot; The source file is a CSV file. &quot;jsonl&quot; The source file is a JSONL file.
          &quot;dataset&quot;: &quot;A String&quot;, # The resource name of the Dataset used to train this Model.
          &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Google Cloud Storage uri of the unmanaged Dataset used to train this Model.
            &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
              &quot;A String&quot;,
            ],
          },
          &quot;loggingSamplingStrategy&quot;: { # Sampling Strategy for logging, can be for both training and prediction dataset. # Strategy to sample data from Training Dataset. If not set, we process the whole dataset.
            &quot;randomSampleConfig&quot;: { # Requests are randomly selected. # Random sample config. Will support more sampling strategies later.
              &quot;sampleRate&quot;: 3.14, # Sample rate (0, 1]
            },
          },
          &quot;targetField&quot;: &quot;A String&quot;, # The target field name the model is to predict. This field will be excluded when doing Predict and (or) Explain for the training data.
        },
        &quot;trainingPredictionSkewDetectionConfig&quot;: { # The config for Training &amp; Prediction data skew detection. It specifies the training dataset sources and the skew detection parameters. # The config for skew between training data and prediction data.
          &quot;attributionScoreSkewThresholds&quot;: { # Key is the feature name and value is the threshold. The threshold here is against attribution score distance between the training and prediction feature.
            &quot;a_key&quot;: { # The config for feature monitoring threshold.
              &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
            },
          },
          &quot;defaultSkewThreshold&quot;: { # The config for feature monitoring threshold. # Skew anomaly detection threshold used by all features. When the per-feature thresholds are not set, this field can be used to specify a threshold for all features.
            &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
          },
          &quot;skewThresholds&quot;: { # Key is the feature name and value is the threshold. If a feature needs to be monitored for skew, a value threshold must be configured for that feature. The threshold here is against feature distribution distance between the training and prediction feature.
            &quot;a_key&quot;: { # The config for feature monitoring threshold.
              &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
            },
          },
        },
      },
    },
  ],
  &quot;modelDeploymentMonitoringScheduleConfig&quot;: { # The config for scheduling monitoring job. # Required. Schedule config for running the monitoring job.
    &quot;monitorInterval&quot;: &quot;A String&quot;, # Required. The model monitoring job scheduling interval. It will be rounded up to next full hour. This defines how often the monitoring jobs are triggered.
    &quot;monitorWindow&quot;: &quot;A String&quot;, # The time window of the prediction data being included in each prediction dataset. This window specifies how long the data should be collected from historical model results for each run. If not set, ModelDeploymentMonitoringScheduleConfig.monitor_interval will be used. e.g. If currently the cutoff time is 2022-01-08 14:30:00 and the monitor_window is set to be 3600, then data from 2022-01-08 13:30:00 to 2022-01-08 14:30:00 will be retrieved and aggregated to calculate the monitoring statistics.
  },
  &quot;modelMonitoringAlertConfig&quot;: { # The alert config for model monitoring. # Alert config for model monitoring.
    &quot;emailAlertConfig&quot;: { # The config for email alert. # Email alert config.
      &quot;userEmails&quot;: [ # The email addresses to send the alert.
        &quot;A String&quot;,
      ],
    },
    &quot;enableLogging&quot;: True or False, # Dump the anomalies to Cloud Logging. The anomalies will be put to json payload encoded from proto google.cloud.aiplatform.logging.ModelMonitoringAnomaliesLogEntry. This can be further sinked to Pub/Sub or any other services supported by Cloud Logging.
    &quot;notificationChannels&quot;: [ # Resource names of the NotificationChannels to send alert. Must be of the format `projects//notificationChannels/`
      &quot;A String&quot;,
    ],
  },
  &quot;name&quot;: &quot;A String&quot;, # Output only. Resource name of a ModelDeploymentMonitoringJob.
  &quot;nextScheduleTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this monitoring pipeline will be scheduled to run for the next round.
  &quot;predictInstanceSchemaUri&quot;: &quot;A String&quot;, # YAML schema file uri describing the format of a single instance, which are given to format this Endpoint&#x27;s prediction (and explanation). If not set, we will generate predict schema from collected predict requests.
  &quot;samplePredictInstance&quot;: &quot;&quot;, # Sample Predict instance, same format as PredictRequest.instances, this can be set as a replacement of ModelDeploymentMonitoringJob.predict_instance_schema_uri. If not set, we will generate predict schema from collected predict requests.
  &quot;satisfiesPzi&quot;: True or False, # Output only. Reserved for future use.
  &quot;satisfiesPzs&quot;: True or False, # Output only. Reserved for future use.
  &quot;scheduleState&quot;: &quot;A String&quot;, # Output only. Schedule state when the monitoring job is in Running state.
  &quot;state&quot;: &quot;A String&quot;, # Output only. The detailed state of the monitoring job. When the job is still creating, the state will be &#x27;PENDING&#x27;. Once the job is successfully created, the state will be &#x27;RUNNING&#x27;. Pause the job, the state will be &#x27;PAUSED&#x27;. Resume the job, the state will return to &#x27;RUNNING&#x27;.
  &quot;statsAnomaliesBaseDirectory&quot;: { # The Google Cloud Storage location where the output is to be written to. # Stats anomalies base folder path.
    &quot;outputUriPrefix&quot;: &quot;A String&quot;, # Required. Google Cloud Storage URI to output directory. If the uri doesn&#x27;t end with &#x27;/&#x27;, a &#x27;/&#x27; will be automatically appended. The directory is created if it doesn&#x27;t exist.
  },
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelDeploymentMonitoringJob was updated most recently.
}

  updateMask: string, Required. The update mask is used to specify the fields to be overwritten in the ModelDeploymentMonitoringJob resource by the update. The fields specified in the update_mask are relative to the resource, not the full request. A field will be overwritten if it is in the mask. If the user does not provide a mask then only the non-empty fields present in the request will be overwritten. Set the update_mask to `*` to override all fields. For the objective config, the user can either provide the update mask for model_deployment_monitoring_objective_configs or any combination of its nested fields, such as: model_deployment_monitoring_objective_configs.objective_config.training_dataset. Updatable fields: * `display_name` * `model_deployment_monitoring_schedule_config` * `model_monitoring_alert_config` * `logging_sampling_strategy` * `labels` * `log_ttl` * `enable_monitoring_pipeline_logs` . and * `model_deployment_monitoring_objective_configs` . or * `model_deployment_monitoring_objective_configs.objective_config.training_dataset` * `model_deployment_monitoring_objective_configs.objective_config.training_prediction_skew_detection_config` * `model_deployment_monitoring_objective_configs.objective_config.prediction_drift_detection_config`
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # This resource represents a long-running operation that is the result of a network API call.
  &quot;done&quot;: True or False, # If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The error result of the operation in case of failure or cancellation.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;metadata&quot;: { # Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
  &quot;name&quot;: &quot;A String&quot;, # The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
  &quot;response&quot;: { # The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="pause">pause(name, body=None, x__xgafv=None)</code>
  <pre>Pauses a ModelDeploymentMonitoringJob. If the job is running, the server makes a best effort to cancel the job. Will mark ModelDeploymentMonitoringJob.state to &#x27;PAUSED&#x27;.

Args:
  name: string, Required. The resource name of the ModelDeploymentMonitoringJob to pause. Format: `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}` (required)
  body: object, The request body.
    The object takes the form of:

{ # Request message for JobService.PauseModelDeploymentMonitoringJob.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
}</pre>
</div>

<div class="method">
    <code class="details" id="resume">resume(name, body=None, x__xgafv=None)</code>
  <pre>Resumes a paused ModelDeploymentMonitoringJob. It will start to run from next scheduled time. A deleted ModelDeploymentMonitoringJob can&#x27;t be resumed.

Args:
  name: string, Required. The resource name of the ModelDeploymentMonitoringJob to resume. Format: `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}` (required)
  body: object, The request body.
    The object takes the form of:

{ # Request message for JobService.ResumeModelDeploymentMonitoringJob.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
}</pre>
</div>

<div class="method">
    <code class="details" id="searchModelDeploymentMonitoringStatsAnomalies">searchModelDeploymentMonitoringStatsAnomalies(modelDeploymentMonitoringJob, body=None, x__xgafv=None)</code>
  <pre>Searches Model Monitoring Statistics generated within a given time window.

Args:
  modelDeploymentMonitoringJob: string, Required. ModelDeploymentMonitoring Job resource name. Format: `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}` (required)
  body: object, The request body.
    The object takes the form of:

{ # Request message for JobService.SearchModelDeploymentMonitoringStatsAnomalies.
  &quot;deployedModelId&quot;: &quot;A String&quot;, # Required. The DeployedModel ID of the [ModelDeploymentMonitoringObjectiveConfig.deployed_model_id].
  &quot;endTime&quot;: &quot;A String&quot;, # The latest timestamp of stats being generated. If not set, indicates feching stats till the latest possible one.
  &quot;featureDisplayName&quot;: &quot;A String&quot;, # The feature display name. If specified, only return the stats belonging to this feature. Format: ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies.feature_display_name, example: &quot;user_destination&quot;.
  &quot;objectives&quot;: [ # Required. Objectives of the stats to retrieve.
    { # Stats requested for specific objective.
      &quot;topFeatureCount&quot;: 42, # If set, all attribution scores between SearchModelDeploymentMonitoringStatsAnomaliesRequest.start_time and SearchModelDeploymentMonitoringStatsAnomaliesRequest.end_time are fetched, and page token doesn&#x27;t take effect in this case. Only used to retrieve attribution score for the top Features which has the highest attribution score in the latest monitoring run.
      &quot;type&quot;: &quot;A String&quot;,
    },
  ],
  &quot;pageSize&quot;: 42, # The standard list page size.
  &quot;pageToken&quot;: &quot;A String&quot;, # A page token received from a previous JobService.SearchModelDeploymentMonitoringStatsAnomalies call.
  &quot;startTime&quot;: &quot;A String&quot;, # The earliest timestamp of stats being generated. If not set, indicates fetching stats till the earliest possible one.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response message for JobService.SearchModelDeploymentMonitoringStatsAnomalies.
  &quot;monitoringStats&quot;: [ # Stats retrieved for requested objectives. There are at most 1000 ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies.prediction_stats in the response.
    { # Statistics and anomalies generated by Model Monitoring.
      &quot;anomalyCount&quot;: 42, # Number of anomalies within all stats.
      &quot;deployedModelId&quot;: &quot;A String&quot;, # Deployed Model ID.
      &quot;featureStats&quot;: [ # A list of historical Stats and Anomalies generated for all Features.
        { # Historical Stats (and Anomalies) for a specific Feature.
          &quot;featureDisplayName&quot;: &quot;A String&quot;, # Display Name of the Feature.
          &quot;predictionStats&quot;: [ # A list of historical stats generated by different time window&#x27;s Prediction Dataset.
            { # Stats and Anomaly generated at specific timestamp for specific Feature. The start_time and end_time are used to define the time range of the dataset that current stats belongs to, e.g. prediction traffic is bucketed into prediction datasets by time window. If the Dataset is not defined by time window, start_time = end_time. Timestamp of the stats and anomalies always refers to end_time. Raw stats and anomalies are stored in stats_uri or anomaly_uri in the tensorflow defined protos. Field data_stats contains almost identical information with the raw stats in Vertex AI defined proto, for UI to display.
              &quot;anomalyDetectionThreshold&quot;: 3.14, # This is the threshold used when detecting anomalies. The threshold can be changed by user, so this one might be different from ThresholdConfig.value.
              &quot;anomalyUri&quot;: &quot;A String&quot;, # Path of the anomaly file for current feature values in Cloud Storage bucket. Format: gs:////anomalies. Example: gs://monitoring_bucket/feature_name/anomalies. Stats are stored as binary format with Protobuf message Anoamlies are stored as binary format with Protobuf message [tensorflow.metadata.v0.AnomalyInfo] (https://github.com/tensorflow/metadata/blob/master/tensorflow_metadata/proto/v0/anomalies.proto).
              &quot;distributionDeviation&quot;: 3.14, # Deviation from the current stats to baseline stats. 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence.
              &quot;endTime&quot;: &quot;A String&quot;, # The end timestamp of window where stats were generated. For objectives where time window doesn&#x27;t make sense (e.g. Featurestore Snapshot Monitoring), end_time indicates the timestamp of the data used to generate stats (e.g. timestamp we take snapshots for feature values).
              &quot;score&quot;: 3.14, # Feature importance score, only populated when cross-feature monitoring is enabled. For now only used to represent feature attribution score within range [0, 1] for ModelDeploymentMonitoringObjectiveType.FEATURE_ATTRIBUTION_SKEW and ModelDeploymentMonitoringObjectiveType.FEATURE_ATTRIBUTION_DRIFT.
              &quot;startTime&quot;: &quot;A String&quot;, # The start timestamp of window where stats were generated. For objectives where time window doesn&#x27;t make sense (e.g. Featurestore Snapshot Monitoring), start_time is only used to indicate the monitoring intervals, so it always equals to (end_time - monitoring_interval).
              &quot;statsUri&quot;: &quot;A String&quot;, # Path of the stats file for current feature values in Cloud Storage bucket. Format: gs:////stats. Example: gs://monitoring_bucket/feature_name/stats. Stats are stored as binary format with Protobuf message [tensorflow.metadata.v0.FeatureNameStatistics](https://github.com/tensorflow/metadata/blob/master/tensorflow_metadata/proto/v0/statistics.proto).
            },
          ],
          &quot;threshold&quot;: { # The config for feature monitoring threshold. # Threshold for anomaly detection.
            &quot;value&quot;: 3.14, # Specify a threshold value that can trigger the alert. If this threshold config is for feature distribution distance: 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence. Each feature must have a non-zero threshold if they need to be monitored. Otherwise no alert will be triggered for that feature.
          },
          &quot;trainingStats&quot;: { # Stats and Anomaly generated at specific timestamp for specific Feature. The start_time and end_time are used to define the time range of the dataset that current stats belongs to, e.g. prediction traffic is bucketed into prediction datasets by time window. If the Dataset is not defined by time window, start_time = end_time. Timestamp of the stats and anomalies always refers to end_time. Raw stats and anomalies are stored in stats_uri or anomaly_uri in the tensorflow defined protos. Field data_stats contains almost identical information with the raw stats in Vertex AI defined proto, for UI to display. # Stats calculated for the Training Dataset.
            &quot;anomalyDetectionThreshold&quot;: 3.14, # This is the threshold used when detecting anomalies. The threshold can be changed by user, so this one might be different from ThresholdConfig.value.
            &quot;anomalyUri&quot;: &quot;A String&quot;, # Path of the anomaly file for current feature values in Cloud Storage bucket. Format: gs:////anomalies. Example: gs://monitoring_bucket/feature_name/anomalies. Stats are stored as binary format with Protobuf message Anoamlies are stored as binary format with Protobuf message [tensorflow.metadata.v0.AnomalyInfo] (https://github.com/tensorflow/metadata/blob/master/tensorflow_metadata/proto/v0/anomalies.proto).
            &quot;distributionDeviation&quot;: 3.14, # Deviation from the current stats to baseline stats. 1. For categorical feature, the distribution distance is calculated by L-inifinity norm. 2. For numerical feature, the distribution distance is calculated by Jensen–Shannon divergence.
            &quot;endTime&quot;: &quot;A String&quot;, # The end timestamp of window where stats were generated. For objectives where time window doesn&#x27;t make sense (e.g. Featurestore Snapshot Monitoring), end_time indicates the timestamp of the data used to generate stats (e.g. timestamp we take snapshots for feature values).
            &quot;score&quot;: 3.14, # Feature importance score, only populated when cross-feature monitoring is enabled. For now only used to represent feature attribution score within range [0, 1] for ModelDeploymentMonitoringObjectiveType.FEATURE_ATTRIBUTION_SKEW and ModelDeploymentMonitoringObjectiveType.FEATURE_ATTRIBUTION_DRIFT.
            &quot;startTime&quot;: &quot;A String&quot;, # The start timestamp of window where stats were generated. For objectives where time window doesn&#x27;t make sense (e.g. Featurestore Snapshot Monitoring), start_time is only used to indicate the monitoring intervals, so it always equals to (end_time - monitoring_interval).
            &quot;statsUri&quot;: &quot;A String&quot;, # Path of the stats file for current feature values in Cloud Storage bucket. Format: gs:////stats. Example: gs://monitoring_bucket/feature_name/stats. Stats are stored as binary format with Protobuf message [tensorflow.metadata.v0.FeatureNameStatistics](https://github.com/tensorflow/metadata/blob/master/tensorflow_metadata/proto/v0/statistics.proto).
          },
        },
      ],
      &quot;objective&quot;: &quot;A String&quot;, # Model Monitoring Objective those stats and anomalies belonging to.
    },
  ],
  &quot;nextPageToken&quot;: &quot;A String&quot;, # The page token that can be used by the next JobService.SearchModelDeploymentMonitoringStatsAnomalies call.
}</pre>
</div>

<div class="method">
    <code class="details" id="searchModelDeploymentMonitoringStatsAnomalies_next">searchModelDeploymentMonitoringStatsAnomalies_next()</code>
  <pre>Retrieves the next page of results.

        Args:
          previous_request: The request for the previous page. (required)
          previous_response: The response from the request for the previous page. (required)

        Returns:
          A request object that you can call &#x27;execute()&#x27; on to request the next
          page. Returns None if there are no more items in the collection.
        </pre>
</div>

</body></html>