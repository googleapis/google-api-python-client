<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="pubsub_v1beta1a.html">Google Cloud Pub/Sub API</a> . <a href="pubsub_v1beta1a.topics.html">topics</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#create">create(body, x__xgafv=None)</a></code></p>
<p class="firstline">Creates the given topic with the given name.</p>
<p class="toc_element">
  <code><a href="#delete">delete(topic, x__xgafv=None)</a></code></p>
<p class="firstline">Deletes the topic with the given name. Returns NOT_FOUND if the topic does</p>
<p class="toc_element">
  <code><a href="#get">get(topic, x__xgafv=None)</a></code></p>
<p class="firstline">Gets the configuration of a topic. Since the topic only has the name</p>
<p class="toc_element">
  <code><a href="#list">list(maxResults=None, pageToken=None, query=None, x__xgafv=None)</a></code></p>
<p class="firstline">Lists matching topics.</p>
<p class="toc_element">
  <code><a href="#list_next">list_next(previous_request, previous_response)</a></code></p>
<p class="firstline">Retrieves the next page of results.</p>
<p class="toc_element">
  <code><a href="#publish">publish(body, x__xgafv=None)</a></code></p>
<p class="firstline">Adds a message to the topic.  Returns NOT_FOUND if the topic does not</p>
<p class="toc_element">
  <code><a href="#publishBatch">publishBatch(body, x__xgafv=None)</a></code></p>
<p class="firstline">Adds one or more messages to the topic. Returns NOT_FOUND if the topic does</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="create">create(body, x__xgafv=None)</code>
  <pre>Creates the given topic with the given name.

Args:
  body: object, The request body. (required)
    The object takes the form of:

{ # A topic resource.
  "name": "A String", # Name of the topic.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A topic resource.
    "name": "A String", # Name of the topic.
  }</pre>
</div>

<div class="method">
    <code class="details" id="delete">delete(topic, x__xgafv=None)</code>
  <pre>Deletes the topic with the given name. Returns NOT_FOUND if the topic does
not exist. After a topic is deleted, a new topic may be created with the
same name.

Args:
  topic: string, Name of the topic to delete. (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # An empty message that you can re-use to avoid defining duplicated empty
      # messages in your project. A typical example is to use it as argument or the
      # return value of a service API. For instance:
      #
      #   service Foo {
      #     rpc Bar (proto2.Empty) returns (proto2.Empty) { };
      #   };
      #
      # BEGIN GOOGLE-INTERNAL
      # The difference between this one and net/rpc/empty-message.proto is that
      # 1) The generated message here is in proto2 C++ API.
      # 2) The proto2.Empty has minimum dependencies
      #    (no message_set or net/rpc dependencies)
      # END GOOGLE-INTERNAL
  }</pre>
</div>

<div class="method">
    <code class="details" id="get">get(topic, x__xgafv=None)</code>
  <pre>Gets the configuration of a topic. Since the topic only has the name
attribute, this method is only useful to check the existence of a topic.
If other attributes are added in the future, they will be returned here.

Args:
  topic: string, The name of the topic to get. (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A topic resource.
    "name": "A String", # Name of the topic.
  }</pre>
</div>

<div class="method">
    <code class="details" id="list">list(maxResults=None, pageToken=None, query=None, x__xgafv=None)</code>
  <pre>Lists matching topics.

Args:
  maxResults: integer, Maximum number of topics to return.
  pageToken: string, The value obtained in the last <code>ListTopicsResponse</code>
for continuation.
  query: string, A valid label query expression.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response for the ListTopics method.
    "nextPageToken": "A String", # If not empty, indicates that there are more topics that match the request,
        # and this value should be passed to the next <code>ListTopicsRequest</code>
        # to continue.
    "topic": [ # The resulting topics.
      { # A topic resource.
        "name": "A String", # Name of the topic.
      },
    ],
  }</pre>
</div>

<div class="method">
    <code class="details" id="list_next">list_next(previous_request, previous_response)</code>
  <pre>Retrieves the next page of results.

Args:
  previous_request: The request for the previous page. (required)
  previous_response: The response from the request for the previous page. (required)

Returns:
  A request object that you can call 'execute()' on to request the next
  page. Returns None if there are no more items in the collection.
    </pre>
</div>

<div class="method">
    <code class="details" id="publish">publish(body, x__xgafv=None)</code>
  <pre>Adds a message to the topic.  Returns NOT_FOUND if the topic does not
exist.

Args:
  body: object, The request body. (required)
    The object takes the form of:

{ # Request for the Publish method.
    "topic": "A String", # The message in the request will be published on this topic.
    "message": { # A message data and its labels. # The message to publish.
      "label": [ # Optional list of labels for this message. Keys in this collection must
          # be unique.
        { # A key-value pair applied to a given object.
          "numValue": "A String", # An integer value.
          "strValue": "A String", # A string value.
          "key": "A String", # The key of a label is a syntactically valid URL (as per RFC 1738) with
              # the "scheme" and initial slashes omitted and with the additional
              # restrictions noted below.  Each key should be globally unique.  The
              # "host" portion is called the "namespace" and is not necessarily
              # resolvable to a network endpoint.  Instead, the namespace indicates what
              # system or entity defines the semantics of the label.  Namespaces do not
              # restrict the set of objects to which a label may be associated.
              #
              # Keys are defined by the following grammar:
              #
              #   key          = hostname "/" kpath
              #   kpath        = ksegment *[ "/" ksegment ]
              #   ksegment     = alphadigit | *[ alphadigit | "-" | "_" | "." ]
              #
              # where "hostname" and "alphadigit" are defined as in RFC 1738.
              #
              # Example key:
              #   spanner.google.com/universe
        },
      ],
      "data": "A String", # The message payload.
      "publishTime": "A String", # The time at which the message was published.
          # The time is milliseconds since the UNIX epoch.
      "messageId": "A String", # ID of this message assigned by the server at publication time. Guaranteed
          # to be unique within the topic. This value may be read by a subscriber
          # that receives a PubsubMessage via a Pull call or a push delivery. It must
          # not be populated by a publisher in a Publish call.
    },
  }

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # An empty message that you can re-use to avoid defining duplicated empty
      # messages in your project. A typical example is to use it as argument or the
      # return value of a service API. For instance:
      #
      #   service Foo {
      #     rpc Bar (proto2.Empty) returns (proto2.Empty) { };
      #   };
      #
      # BEGIN GOOGLE-INTERNAL
      # The difference between this one and net/rpc/empty-message.proto is that
      # 1) The generated message here is in proto2 C++ API.
      # 2) The proto2.Empty has minimum dependencies
      #    (no message_set or net/rpc dependencies)
      # END GOOGLE-INTERNAL
  }</pre>
</div>

<div class="method">
    <code class="details" id="publishBatch">publishBatch(body, x__xgafv=None)</code>
  <pre>Adds one or more messages to the topic. Returns NOT_FOUND if the topic does
not exist.

Args:
  body: object, The request body. (required)
    The object takes the form of:

{ # Request for the PublishBatch method.
    "topic": "A String", # The messages in the request will be published on this topic.
    "messages": [ # The messages to publish.
      { # A message data and its labels.
        "label": [ # Optional list of labels for this message. Keys in this collection must
            # be unique.
          { # A key-value pair applied to a given object.
            "numValue": "A String", # An integer value.
            "strValue": "A String", # A string value.
            "key": "A String", # The key of a label is a syntactically valid URL (as per RFC 1738) with
                # the "scheme" and initial slashes omitted and with the additional
                # restrictions noted below.  Each key should be globally unique.  The
                # "host" portion is called the "namespace" and is not necessarily
                # resolvable to a network endpoint.  Instead, the namespace indicates what
                # system or entity defines the semantics of the label.  Namespaces do not
                # restrict the set of objects to which a label may be associated.
                #
                # Keys are defined by the following grammar:
                #
                #   key          = hostname "/" kpath
                #   kpath        = ksegment *[ "/" ksegment ]
                #   ksegment     = alphadigit | *[ alphadigit | "-" | "_" | "." ]
                #
                # where "hostname" and "alphadigit" are defined as in RFC 1738.
                #
                # Example key:
                #   spanner.google.com/universe
          },
        ],
        "data": "A String", # The message payload.
        "publishTime": "A String", # The time at which the message was published.
            # The time is milliseconds since the UNIX epoch.
        "messageId": "A String", # ID of this message assigned by the server at publication time. Guaranteed
            # to be unique within the topic. This value may be read by a subscriber
            # that receives a PubsubMessage via a Pull call or a push delivery. It must
            # not be populated by a publisher in a Publish call.
      },
    ],
  }

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response for the PublishBatch method.
    "messageIds": [ # The server-assigned ID of each published message, in the same order as
        # the messages in the request. IDs are guaranteed to be unique within
        # the topic.
      "A String",
    ],
  }</pre>
</div>

</body></html>