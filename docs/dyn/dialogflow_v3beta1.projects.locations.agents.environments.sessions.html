<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="dialogflow_v3beta1.html">Dialogflow API</a> . <a href="dialogflow_v3beta1.projects.html">projects</a> . <a href="dialogflow_v3beta1.projects.locations.html">locations</a> . <a href="dialogflow_v3beta1.projects.locations.agents.html">agents</a> . <a href="dialogflow_v3beta1.projects.locations.agents.environments.html">environments</a> . <a href="dialogflow_v3beta1.projects.locations.agents.environments.sessions.html">sessions</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="dialogflow_v3beta1.projects.locations.agents.environments.sessions.entityTypes.html">entityTypes()</a></code>
</p>
<p class="firstline">Returns the entityTypes Resource.</p>

<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#detectIntent">detectIntent(session, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Processes a natural language query and returns structured, actionable data as a result. This method is not idempotent, because it may cause session entity types to be updated, which in turn might affect results of future queries. Note: Always use agent versions for production traffic. See [Versions and environments](https://cloud.google.com/dialogflow/cx/docs/concept/version).</p>
<p class="toc_element">
  <code><a href="#fulfillIntent">fulfillIntent(session, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Fulfills a matched intent returned by MatchIntent. Must be called after MatchIntent, with input from MatchIntentResponse. Otherwise, the behavior is undefined.</p>
<p class="toc_element">
  <code><a href="#matchIntent">matchIntent(session, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Returns preliminary intent match results, doesn't change the session status.</p>
<p class="toc_element">
  <code><a href="#serverStreamingDetectIntent">serverStreamingDetectIntent(session, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Processes a natural language query and returns structured, actionable data as a result through server-side streaming. Server-side streaming allows Dialogflow to send [partial responses](https://cloud.google.com/dialogflow/cx/docs/concept/fulfillment#partial-response) earlier in a single request.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="detectIntent">detectIntent(session, body=None, x__xgafv=None)</code>
  <pre>Processes a natural language query and returns structured, actionable data as a result. This method is not idempotent, because it may cause session entity types to be updated, which in turn might affect results of future queries. Note: Always use agent versions for production traffic. See [Versions and environments](https://cloud.google.com/dialogflow/cx/docs/concept/version).

Args:
  session: string, Required. The name of the session this query is sent to. Format: `projects//locations//agents//sessions/` or `projects//locations//agents//environments//sessions/`. If `Environment ID` is not specified, we assume default &#x27;draft&#x27; environment. It&#x27;s up to the API caller to choose an appropriate `Session ID`. It can be a random number or some type of session identifiers (preferably hashed). The length of the `Session ID` must not exceed 36 characters. For more information, see the [sessions guide](https://cloud.google.com/dialogflow/cx/docs/concept/session). Note: Always use agent versions for production traffic. See [Versions and environments](https://cloud.google.com/dialogflow/cx/docs/concept/version). (required)
  body: object, The request body.
    The object takes the form of:

{ # The request to detect user&#x27;s intent.
  &quot;outputAudioConfig&quot;: { # Instructs the speech synthesizer how to generate the output audio content. # Instructs the speech synthesizer how to generate the output audio.
    &quot;audioEncoding&quot;: &quot;A String&quot;, # Required. Audio encoding of the synthesized audio content.
    &quot;sampleRateHertz&quot;: 42, # Optional. The synthesis sample rate (in hertz) for this audio. If not provided, then the synthesizer will use the default sample rate based on the audio encoding. If this is different from the voice&#x27;s natural sample rate, then the synthesizer will honor this request by converting to the desired sample rate (which might result in worse audio quality).
    &quot;synthesizeSpeechConfig&quot;: { # Configuration of how speech should be synthesized. # Optional. Configuration of how speech should be synthesized. If not specified, Agent.text_to_speech_settings is applied.
      &quot;effectsProfileId&quot;: [ # Optional. An identifier which selects &#x27;audio effects&#x27; profiles that are applied on (post synthesized) text to speech. Effects are applied on top of each other in the order they are given.
        &quot;A String&quot;,
      ],
      &quot;pitch&quot;: 3.14, # Optional. Speaking pitch, in the range [-20.0, 20.0]. 20 means increase 20 semitones from the original pitch. -20 means decrease 20 semitones from the original pitch.
      &quot;speakingRate&quot;: 3.14, # Optional. Speaking rate/speed, in the range [0.25, 4.0]. 1.0 is the normal native speed supported by the specific voice. 2.0 is twice as fast, and 0.5 is half as fast. If unset(0.0), defaults to the native 1.0 speed. Any other values &lt; 0.25 or &gt; 4.0 will return an error.
      &quot;voice&quot;: { # Description of which voice to use for speech synthesis. # Optional. The desired voice of the synthesized audio.
        &quot;name&quot;: &quot;A String&quot;, # Optional. The name of the voice. If not set, the service will choose a voice based on the other parameters such as language_code and ssml_gender. For the list of available voices, please refer to [Supported voices and languages](https://cloud.google.com/text-to-speech/docs/voices).
        &quot;ssmlGender&quot;: &quot;A String&quot;, # Optional. The preferred gender of the voice. If not set, the service will choose a voice based on the other parameters such as language_code and name. Note that this is only a preference, not requirement. If a voice of the appropriate gender is not available, the synthesizer should substitute a voice with a different gender rather than failing the request.
      },
      &quot;volumeGainDb&quot;: 3.14, # Optional. Volume gain (in dB) of the normal native volume supported by the specific voice, in the range [-96.0, 16.0]. If unset, or set to a value of 0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB) will play at approximately half the amplitude of the normal native signal amplitude. A value of +6.0 (dB) will play at approximately twice the amplitude of the normal native signal amplitude. We strongly recommend not to exceed +10 (dB) as there&#x27;s usually no effective increase in loudness for any value greater than that.
    },
  },
  &quot;queryInput&quot;: { # Represents the query input. It can contain one of: 1. A conversational query in the form of text. 2. An intent query that specifies which intent to trigger. 3. Natural language speech audio to be processed. 4. An event to be triggered. 5. DTMF digits to invoke an intent and fill in parameter value. 6. The results of a tool executed by the client. # Required. The input specification.
    &quot;audio&quot;: { # Represents the natural speech audio to be processed. # The natural language speech audio to be processed.
      &quot;audio&quot;: &quot;A String&quot;, # The natural language speech audio to be processed. A single request can contain up to 2 minutes of speech audio data. The transcribed text cannot contain more than 256 bytes. For non-streaming audio detect intent, both `config` and `audio` must be provided. For streaming audio detect intent, `config` must be provided in the first request and `audio` must be provided in all following requests.
      &quot;config&quot;: { # Instructs the speech recognizer on how to process the audio content. # Required. Instructs the speech recognizer how to process the speech audio.
        &quot;audioEncoding&quot;: &quot;A String&quot;, # Required. Audio encoding of the audio content to process.
        &quot;bargeInConfig&quot;: { # Configuration of the barge-in behavior. Barge-in instructs the API to return a detected utterance at a proper time while the client is playing back the response audio from a previous request. When the client sees the utterance, it should stop the playback and immediately get ready for receiving the responses for the current request. The barge-in handling requires the client to start streaming audio input as soon as it starts playing back the audio from the previous response. The playback is modeled into two phases: * No barge-in phase: which goes first and during which speech detection should not be carried out. * Barge-in phase: which follows the no barge-in phase and during which the API starts speech detection and may inform the client that an utterance has been detected. Note that no-speech event is not expected in this phase. The client provides this configuration in terms of the durations of those two phases. The durations are measured in terms of the audio length from the the start of the input audio. No-speech event is a response with END_OF_UTTERANCE without any transcript following up. # Configuration of barge-in behavior during the streaming of input audio.
          &quot;noBargeInDuration&quot;: &quot;A String&quot;, # Duration that is not eligible for barge-in at the beginning of the input audio.
          &quot;totalDuration&quot;: &quot;A String&quot;, # Total duration for the playback at the beginning of the input audio.
        },
        &quot;enableWordInfo&quot;: True or False, # Optional. If `true`, Dialogflow returns SpeechWordInfo in StreamingRecognitionResult with information about the recognized speech words, e.g. start and end time offsets. If false or unspecified, Speech doesn&#x27;t return any word-level information.
        &quot;model&quot;: &quot;A String&quot;, # Optional. Which Speech model to select for the given request. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
        &quot;modelVariant&quot;: &quot;A String&quot;, # Optional. Which variant of the Speech model to use.
        &quot;optOutConformerModelMigration&quot;: True or False, # If `true`, the request will opt out for STT conformer model migration. This field will be deprecated once force migration takes place in June 2024. Please refer to [Dialogflow CX Speech model migration](https://cloud.google.com/dialogflow/cx/docs/concept/speech-model-migration).
        &quot;phraseHints&quot;: [ # Optional. A list of strings containing words and phrases that the speech recognizer should recognize with higher likelihood. See [the Cloud Speech documentation](https://cloud.google.com/speech-to-text/docs/basics#phrase-hints) for more details.
          &quot;A String&quot;,
        ],
        &quot;sampleRateHertz&quot;: 42, # Sample rate (in Hertz) of the audio content sent in the query. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics) for more details.
        &quot;singleUtterance&quot;: True or False, # Optional. If `false` (default), recognition does not cease until the client closes the stream. If `true`, the recognizer will detect a single spoken utterance in input audio. Recognition ceases when it detects the audio&#x27;s voice has stopped or paused. In this case, once a detected intent is received, the client should close the stream and start a new request with a new stream as needed. Note: This setting is relevant only for streaming methods.
      },
    },
    &quot;dtmf&quot;: { # Represents the input for dtmf event. # The DTMF event to be handled.
      &quot;digits&quot;: &quot;A String&quot;, # The dtmf digits.
      &quot;finishDigit&quot;: &quot;A String&quot;, # The finish digit (if any).
    },
    &quot;event&quot;: { # Represents the event to trigger. # The event to be triggered.
      &quot;event&quot;: &quot;A String&quot;, # Name of the event.
    },
    &quot;intent&quot;: { # Represents the intent to trigger programmatically rather than as a result of natural language processing. # The intent to be triggered.
      &quot;intent&quot;: &quot;A String&quot;, # Required. The unique identifier of the intent. Format: `projects//locations//agents//intents/`.
    },
    &quot;languageCode&quot;: &quot;A String&quot;, # Required. The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes. Note that queries in the same session do not necessarily need to specify the same language.
    &quot;text&quot;: { # Represents the natural language text to be processed. # The natural language text to be processed.
      &quot;text&quot;: &quot;A String&quot;, # Required. The UTF-8 encoded natural language text to be processed.
    },
    &quot;toolCallResult&quot;: { # The result of calling a tool&#x27;s action that has been executed by the client. # The results of a tool executed by the client.
      &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
      &quot;error&quot;: { # An error produced by the tool call. # The tool call&#x27;s error.
        &quot;message&quot;: &quot;A String&quot;, # Optional. The error message of the function.
      },
      &quot;outputParameters&quot;: { # The tool call&#x27;s output parameters.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
    },
  },
  &quot;queryParams&quot;: { # Represents the parameters of a conversational query. # The parameters of this query.
    &quot;analyzeQueryTextSentiment&quot;: True or False, # Configures whether sentiment analysis should be performed. If not provided, sentiment analysis is not performed.
    &quot;channel&quot;: &quot;A String&quot;, # The channel which this query is for. If specified, only the ResponseMessage associated with the channel will be returned. If no ResponseMessage is associated with the channel, it falls back to the ResponseMessage with unspecified channel. If unspecified, the ResponseMessage with unspecified channel will be returned.
    &quot;currentPage&quot;: &quot;A String&quot;, # The unique identifier of the page to override the current page in the session. Format: `projects//locations//agents//flows//pages/`. If `current_page` is specified, the previous state of the session will be ignored by Dialogflow, including the previous page and the previous session parameters. In most cases, current_page and parameters should be configured together to direct a session to a specific state.
    &quot;currentPlaybook&quot;: &quot;A String&quot;, # Optional. Start the session with the specified playbook. You can only specify the playbook at the beginning of the session. Otherwise, an error will be thrown. Format: `projects//locations//agents//playbooks/`.
    &quot;disableWebhook&quot;: True or False, # Whether to disable webhook calls for this request.
    &quot;endUserMetadata&quot;: { # Optional. Information about the end-user to improve the relevance and accuracy of generative answers. This will be interpreted and used by a language model, so, for good results, the data should be self-descriptive, and in a simple structure. Example: ```json { &quot;subscription plan&quot;: &quot;Business Premium Plus&quot;, &quot;devices owned&quot;: [ {&quot;model&quot;: &quot;Google Pixel 7&quot;}, {&quot;model&quot;: &quot;Google Pixel Tablet&quot;} ] } ```
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;flowVersions&quot;: [ # A list of flow versions to override for the request. Format: `projects//locations//agents//flows//versions/`. If version 1 of flow X is included in this list, the traffic of flow X will go through version 1 regardless of the version configuration in the environment. Each flow can have at most one version specified in this list.
      &quot;A String&quot;,
    ],
    &quot;geoLocation&quot;: { # An object that represents a latitude/longitude pair. This is expressed as a pair of doubles to represent degrees latitude and degrees longitude. Unless specified otherwise, this object must conform to the WGS84 standard. Values must be within normalized ranges. # The geo location of this conversational query.
      &quot;latitude&quot;: 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
      &quot;longitude&quot;: 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
    },
    &quot;llmModelSettings&quot;: { # Settings for LLM models. # Optional. Use the specified LLM model settings for processing the request.
      &quot;model&quot;: &quot;A String&quot;, # The selected LLM model.
      &quot;promptText&quot;: &quot;A String&quot;, # The custom prompt to use.
    },
    &quot;parameters&quot;: { # Additional parameters to be put into session parameters. To remove a parameter from the session, clients should explicitly set the parameter value to null. You can reference the session parameters in the agent with the following format: $session.params.parameter-id. Depending on your protocol or client library language, this is a map, associative array, symbol table, dictionary, or JSON object composed of a collection of (MapKey, MapValue) pairs: * MapKey type: string * MapKey value: parameter name * MapValue type: If parameter&#x27;s entity type is a composite entity then use map, otherwise, depending on the parameter value type, it could be one of string, number, boolean, null, list or map. * MapValue value: If parameter&#x27;s entity type is a composite entity then use map from composite entity property names to property values, otherwise, use parameter value.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;payload&quot;: { # This field can be used to pass custom data into the webhook associated with the agent. Arbitrary JSON objects are supported. Some integrations that query a Dialogflow agent may provide additional information in the payload. In particular, for the Dialogflow Phone Gateway integration, this field has the form: ``` { &quot;telephony&quot;: { &quot;caller_id&quot;: &quot;+18558363987&quot; } } ```
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;populateDataStoreConnectionSignals&quot;: True or False, # Optional. If set to true and data stores are involved in serving the request then DetectIntentResponse.query_result.data_store_connection_signals will be filled with data that can help evaluations.
    &quot;searchConfig&quot;: { # Search configuration for UCS search queries. # Optional. Search configuration for UCS search queries.
      &quot;boostSpecs&quot;: [ # Optional. Boosting configuration for the datastores.
        { # Boost specifications for data stores.
          &quot;dataStores&quot;: [ # Optional. Data Stores where the boosting configuration is applied. The full names of the referenced data stores. Formats: `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}` `projects/{project}/locations/{location}/dataStores/{data_store}
            &quot;A String&quot;,
          ],
          &quot;spec&quot;: [ # Optional. A list of boosting specifications.
            { # Boost specification to boost certain documents. A copy of google.cloud.discoveryengine.v1main.BoostSpec, field documentation is available at https://cloud.google.com/generative-ai-app-builder/docs/reference/rest/v1alpha/BoostSpec
              &quot;conditionBoostSpecs&quot;: [ # Optional. Condition boost specifications. If a document matches multiple conditions in the specifictions, boost scores from these specifications are all applied and combined in a non-linear way. Maximum number of specifications is 20.
                { # Boost applies to documents which match a condition.
                  &quot;boost&quot;: 3.14, # Optional. Strength of the condition boost, which should be in [-1, 1]. Negative boost means demotion. Default is 0.0. Setting to 1.0 gives the document a big promotion. However, it does not necessarily mean that the boosted document will be the top result at all times, nor that other documents will be excluded. Results could still be shown even when none of them matches the condition. And results that are significantly more relevant to the search query can still trump your heavily favored but irrelevant documents. Setting to -1.0 gives the document a big demotion. However, results that are deeply relevant might still be shown. The document will have an upstream battle to get a fairly high ranking, but it is not blocked out completely. Setting to 0.0 means no boost applied. The boosting condition is ignored.
                  &quot;boostControlSpec&quot;: { # Specification for custom ranking based on customer specified attribute value. It provides more controls for customized ranking than the simple (condition, boost) combination above. # Optional. Complex specification for custom ranking based on customer defined attribute value.
                    &quot;attributeType&quot;: &quot;A String&quot;, # Optional. The attribute type to be used to determine the boost amount. The attribute value can be derived from the field value of the specified field_name. In the case of numerical it is straightforward i.e. attribute_value = numerical_field_value. In the case of freshness however, attribute_value = (time.now() - datetime_field_value).
                    &quot;controlPoints&quot;: [ # Optional. The control points used to define the curve. The monotonic function (defined through the interpolation_type above) passes through the control points listed here.
                      { # The control points used to define the curve. The curve defined through these control points can only be monotonically increasing or decreasing(constant values are acceptable).
                        &quot;attributeValue&quot;: &quot;A String&quot;, # Optional. Can be one of: 1. The numerical field value. 2. The duration spec for freshness: The value must be formatted as an XSD `dayTimeDuration` value (a restricted subset of an ISO 8601 duration value). The pattern for this is: `nDnM]`.
                        &quot;boostAmount&quot;: 3.14, # Optional. The value between -1 to 1 by which to boost the score if the attribute_value evaluates to the value specified above.
                      },
                    ],
                    &quot;fieldName&quot;: &quot;A String&quot;, # Optional. The name of the field whose value will be used to determine the boost amount.
                    &quot;interpolationType&quot;: &quot;A String&quot;, # Optional. The interpolation type to be applied to connect the control points listed below.
                  },
                  &quot;condition&quot;: &quot;A String&quot;, # Optional. An expression which specifies a boost condition. The syntax and supported fields are the same as a filter expression. Examples: * To boost documents with document ID &quot;doc_1&quot; or &quot;doc_2&quot;, and color &quot;Red&quot; or &quot;Blue&quot;: * (id: ANY(&quot;doc_1&quot;, &quot;doc_2&quot;)) AND (color: ANY(&quot;Red&quot;,&quot;Blue&quot;))
                },
              ],
            },
          ],
        },
      ],
      &quot;filterSpecs&quot;: [ # Optional. Filter configuration for the datastores.
        { # Filter specifications for data stores.
          &quot;dataStores&quot;: [ # Optional. Data Stores where the boosting configuration is applied. The full names of the referenced data stores. Formats: `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}` `projects/{project}/locations/{location}/dataStores/{data_store}
            &quot;A String&quot;,
          ],
          &quot;filter&quot;: &quot;A String&quot;, # Optional. The filter expression to be applied. Expression syntax is documented at https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata#filter-expression-syntax
        },
      ],
    },
    &quot;sessionEntityTypes&quot;: [ # Additional session entity types to replace or extend developer entity types with. The entity synonyms apply to all languages and persist for the session of this query.
      { # Session entity types are referred to as **User** entity types and are entities that are built for an individual user such as favorites, preferences, playlists, and so on. You can redefine a session entity type at the session level to extend or replace a custom entity type at the user session level (we refer to the entity types defined at the agent level as &quot;custom entity types&quot;). Note: session entity types apply to all queries, regardless of the language. For more information about entity types, see the [Dialogflow documentation](https://cloud.google.com/dialogflow/docs/entities-overview).
        &quot;entities&quot;: [ # Required. The collection of entities to override or supplement the custom entity type.
          { # An **entity entry** for an associated entity type.
            &quot;synonyms&quot;: [ # Required. A collection of value synonyms. For example, if the entity type is *vegetable*, and `value` is *scallions*, a synonym could be *green onions*. For `KIND_LIST` entity types: * This collection must contain exactly one synonym equal to `value`.
              &quot;A String&quot;,
            ],
            &quot;value&quot;: &quot;A String&quot;, # Required. The primary value associated with this entity entry. For example, if the entity type is *vegetable*, the value could be *scallions*. For `KIND_MAP` entity types: * A canonical value to be used in place of synonyms. For `KIND_LIST` entity types: * A string that can contain references to other entity types (with or without aliases).
          },
        ],
        &quot;entityOverrideMode&quot;: &quot;A String&quot;, # Required. Indicates whether the additional data should override or supplement the custom entity type definition.
        &quot;name&quot;: &quot;A String&quot;, # Required. The unique identifier of the session entity type. Format: `projects//locations//agents//sessions//entityTypes/` or `projects//locations//agents//environments//sessions//entityTypes/`. If `Environment ID` is not specified, we assume default &#x27;draft&#x27; environment.
      },
    ],
    &quot;sessionTtl&quot;: &quot;A String&quot;, # Optional. Configure lifetime of the Dialogflow session. By default, a Dialogflow session remains active and its data is stored for 30 minutes after the last request is sent for the session. This value should be no longer than 1 day.
    &quot;timeZone&quot;: &quot;A String&quot;, # The time zone of this conversational query from the [time zone database](https://www.iana.org/time-zones), e.g., America/New_York, Europe/Paris. If not provided, the time zone specified in the agent is used.
    &quot;webhookHeaders&quot;: { # This field can be used to pass HTTP headers for a webhook call. These headers will be sent to webhook along with the headers that have been configured through Dialogflow web console. The headers defined within this field will overwrite the headers configured through Dialogflow console if there is a conflict. Header names are case-insensitive. Google&#x27;s specified headers are not allowed. Including: &quot;Host&quot;, &quot;Content-Length&quot;, &quot;Connection&quot;, &quot;From&quot;, &quot;User-Agent&quot;, &quot;Accept-Encoding&quot;, &quot;If-Modified-Since&quot;, &quot;If-None-Match&quot;, &quot;X-Forwarded-For&quot;, etc.
      &quot;a_key&quot;: &quot;A String&quot;,
    },
  },
  &quot;session&quot;: &quot;A String&quot;, # Required. The name of the session this query is sent to. Format: `projects//locations//agents//sessions/` or `projects//locations//agents//environments//sessions/`. If `Environment ID` is not specified, we assume default &#x27;draft&#x27; environment. It&#x27;s up to the API caller to choose an appropriate `Session ID`. It can be a random number or some type of session identifiers (preferably hashed). The length of the `Session ID` must not exceed 36 characters. For more information, see the [sessions guide](https://cloud.google.com/dialogflow/cx/docs/concept/session). Note: Always use agent versions for production traffic. See [Versions and environments](https://cloud.google.com/dialogflow/cx/docs/concept/version).
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The message returned from the DetectIntent method.
  &quot;allowCancellation&quot;: True or False, # Indicates whether the partial response can be cancelled when a later response arrives. e.g. if the agent specified some music as partial response, it can be cancelled.
  &quot;outputAudio&quot;: &quot;A String&quot;, # The audio data bytes encoded as specified in the request. Note: The output audio is generated based on the values of default platform text responses found in the `query_result.response_messages` field. If multiple default text responses exist, they will be concatenated when generating audio. If no default platform text responses exist, the generated audio content will be empty. In some scenarios, multiple output audio fields may be present in the response structure. In these cases, only the top-most-level audio output has content.
  &quot;outputAudioConfig&quot;: { # Instructs the speech synthesizer how to generate the output audio content. # The config used by the speech synthesizer to generate the output audio.
    &quot;audioEncoding&quot;: &quot;A String&quot;, # Required. Audio encoding of the synthesized audio content.
    &quot;sampleRateHertz&quot;: 42, # Optional. The synthesis sample rate (in hertz) for this audio. If not provided, then the synthesizer will use the default sample rate based on the audio encoding. If this is different from the voice&#x27;s natural sample rate, then the synthesizer will honor this request by converting to the desired sample rate (which might result in worse audio quality).
    &quot;synthesizeSpeechConfig&quot;: { # Configuration of how speech should be synthesized. # Optional. Configuration of how speech should be synthesized. If not specified, Agent.text_to_speech_settings is applied.
      &quot;effectsProfileId&quot;: [ # Optional. An identifier which selects &#x27;audio effects&#x27; profiles that are applied on (post synthesized) text to speech. Effects are applied on top of each other in the order they are given.
        &quot;A String&quot;,
      ],
      &quot;pitch&quot;: 3.14, # Optional. Speaking pitch, in the range [-20.0, 20.0]. 20 means increase 20 semitones from the original pitch. -20 means decrease 20 semitones from the original pitch.
      &quot;speakingRate&quot;: 3.14, # Optional. Speaking rate/speed, in the range [0.25, 4.0]. 1.0 is the normal native speed supported by the specific voice. 2.0 is twice as fast, and 0.5 is half as fast. If unset(0.0), defaults to the native 1.0 speed. Any other values &lt; 0.25 or &gt; 4.0 will return an error.
      &quot;voice&quot;: { # Description of which voice to use for speech synthesis. # Optional. The desired voice of the synthesized audio.
        &quot;name&quot;: &quot;A String&quot;, # Optional. The name of the voice. If not set, the service will choose a voice based on the other parameters such as language_code and ssml_gender. For the list of available voices, please refer to [Supported voices and languages](https://cloud.google.com/text-to-speech/docs/voices).
        &quot;ssmlGender&quot;: &quot;A String&quot;, # Optional. The preferred gender of the voice. If not set, the service will choose a voice based on the other parameters such as language_code and name. Note that this is only a preference, not requirement. If a voice of the appropriate gender is not available, the synthesizer should substitute a voice with a different gender rather than failing the request.
      },
      &quot;volumeGainDb&quot;: 3.14, # Optional. Volume gain (in dB) of the normal native volume supported by the specific voice, in the range [-96.0, 16.0]. If unset, or set to a value of 0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB) will play at approximately half the amplitude of the normal native signal amplitude. A value of +6.0 (dB) will play at approximately twice the amplitude of the normal native signal amplitude. We strongly recommend not to exceed +10 (dB) as there&#x27;s usually no effective increase in loudness for any value greater than that.
    },
  },
  &quot;queryResult&quot;: { # Represents the result of a conversational query. # The result of the conversational query.
    &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Returns the current advanced settings including IVR settings. Even though the operations configured by these settings are performed by Dialogflow, the client may need to perform special logic at the moment. For example, if Dialogflow exports audio to Google Cloud Storage, then the client may need to wait for the resulting object to appear in the bucket before proceeding.
      &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
        &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
      },
      &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
        &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
        &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
        &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
        &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
      },
      &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
        &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
        &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
        &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
      },
      &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
        &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
        &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
          &quot;a_key&quot;: &quot;A String&quot;,
        },
        &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
        &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
      },
    },
    &quot;allowAnswerFeedback&quot;: True or False, # Indicates whether the Thumbs up/Thumbs down rating controls are need to be shown for the response in the Dialogflow Messenger widget.
    &quot;currentFlow&quot;: { # Flows represents the conversation flows when you build your chatbot agent. A flow consists of many pages connected by the transition routes. Conversations always start with the built-in Start Flow (with an all-0 ID). Transition routes can direct the conversation session from the current flow (parent flow) to another flow (sub flow). When the sub flow is finished, Dialogflow will bring the session back to the parent flow, where the sub flow is started. Usually, when a transition route is followed by a matched intent, the intent will be &quot;consumed&quot;. This means the intent won&#x27;t activate more transition routes. However, when the followed transition route moves the conversation session into a different flow, the matched intent can be carried over and to be consumed in the target flow. # The current Flow. Some, not all fields are filled in this message, including but not limited to `name` and `display_name`.
      &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this flow. The settings exposed at the lower level overrides the settings exposed at the higher level.
        &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
          &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
        },
        &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
          &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
          &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
          &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
          &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
          &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
        },
        &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
          &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
          &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
          &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
        },
        &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
          &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
          &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
          &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
        },
      },
      &quot;description&quot;: &quot;A String&quot;, # The description of the flow. The maximum length is 500 characters. If exceeded, the request is rejected.
      &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the flow.
      &quot;eventHandlers&quot;: [ # A flow&#x27;s event handlers serve two purposes: * They are responsible for handling events (e.g. no match, webhook errors) in the flow. * They are inherited by every page&#x27;s event handlers, which can be used to handle common events regardless of the current page. Event handlers defined in the page have higher priority than those defined in the flow. Unlike transition_routes, these handlers are evaluated on a first-match basis. The first one that matches the event get executed, with the rest being ignored.
        { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
          &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
          &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
          &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
          &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
          &quot;targetPlaybook&quot;: &quot;A String&quot;, # The target playbook to transition to. Format: `projects//locations//agents//playbooks/`.
          &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
            &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
              &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
                &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
              },
              &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
                &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
                &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
                &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
                &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
                &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
              },
              &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
                &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
                &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
                &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
              },
              &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
                &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
                &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                  &quot;a_key&quot;: &quot;A String&quot;,
                },
                &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
                &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
              },
            },
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                              &quot;A String&quot;,
                            ],
                          },
                          &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                            &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                            &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                            &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                    &quot;A String&quot;,
                  ],
                },
                &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                  &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                  &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                  &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                },
              },
            ],
            &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
        },
      ],
      &quot;knowledgeConnectorSettings&quot;: { # The Knowledge Connector settings for this page or flow. This includes information such as the attached Knowledge Bases, and the way to execute fulfillment. # Optional. Knowledge connector configuration.
        &quot;dataStoreConnections&quot;: [ # Optional. List of related data store connections.
          { # A data store connection. It represents a data store in Discovery Engine and the type of the contents it contains.
            &quot;dataStore&quot;: &quot;A String&quot;, # The full name of the referenced data store. Formats: `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}` `projects/{project}/locations/{location}/dataStores/{data_store}`
            &quot;dataStoreType&quot;: &quot;A String&quot;, # The type of the connected data store.
          },
        ],
        &quot;enabled&quot;: True or False, # Whether Knowledge Connector is enabled or not.
        &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
        &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
        &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to be triggered. When the answers from the Knowledge Connector are selected by Dialogflow, you can utitlize the request scoped parameter `$request.knowledge.answers` (contains up to the 5 highest confidence answers) and `$request.knowledge.questions` (contains the corresponding questions) to construct the fulfillment.
          &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
            &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
              &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
            },
            &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
              &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
              &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
              &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
              &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
              &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
            },
            &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
              &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
              &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
              &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
            },
            &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
              &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
              &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
              &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
            },
          },
          &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
            { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
              &quot;cases&quot;: [ # A list of cascading if-else conditions.
                { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                  &quot;caseContent&quot;: [ # A list of case content.
                    { # The list of messages or conditional cases to activate for this case.
                      &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                      &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                        },
                        &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                        },
                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                            { # Represents one segment of audio.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                            },
                          ],
                        },
                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                        },
                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                        },
                        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                        },
                        &quot;text&quot;: { # The text response message. # Returns a text response.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                            &quot;A String&quot;,
                          ],
                        },
                        &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                          &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                          &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                        },
                      },
                    },
                  ],
                  &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                },
              ],
            },
          ],
          &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
          &quot;messages&quot;: [ # The list of rich message responses to present to the user.
            { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
              },
              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
              },
              &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
              },
              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
              },
              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                &quot;segments&quot;: [ # Segments this audio response is composed of.
                  { # Represents one segment of audio.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                  },
                ],
              },
              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
              },
              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
              },
              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
              },
              &quot;text&quot;: { # The text response message. # Returns a text response.
                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                  &quot;A String&quot;,
                ],
              },
              &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
              },
            },
          ],
          &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
          &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
            { # Setting a parameter value.
              &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
              &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
            },
          ],
          &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
          &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
        },
      },
      &quot;locked&quot;: True or False, # Indicates whether the flow is locked for changes. If the flow is locked, modifications to the flow will be rejected.
      &quot;multiLanguageSettings&quot;: { # Settings for multi-lingual agents. # Optional. Multi-lingual agent settings for this flow.
        &quot;enableMultiLanguageDetection&quot;: True or False, # Optional. Enable multi-language detection for this flow. This can be set only if agent level multi language setting is enabled.
        &quot;supportedResponseLanguageCodes&quot;: [ # Optional. Agent will respond in the detected language if the detected language code is in the supported resolved languages for this flow. This will be used only if multi-language training is enabled in the agent and multi-language detection is enabled in the flow. The supported languages must be a subset of the languages supported by the agent.
          &quot;A String&quot;,
        ],
      },
      &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the flow. Format: `projects//locations//agents//flows/`.
      &quot;nluSettings&quot;: { # Settings related to NLU. # NLU related settings of the flow.
        &quot;classificationThreshold&quot;: 3.14, # To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold. If the returned score value is less than the threshold value, then a no-match event will be triggered. The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used. You can set a separate classification threshold for the flow in each language enabled for the agent.
        &quot;modelTrainingMode&quot;: &quot;A String&quot;, # Indicates NLU model training mode.
        &quot;modelType&quot;: &quot;A String&quot;, # Indicates the type of NLU model.
      },
      &quot;transitionRouteGroups&quot;: [ # A flow&#x27;s transition route group serve two purposes: * They are responsible for matching the user&#x27;s first utterances in the flow. * They are inherited by every page&#x27;s transition route groups. Transition route groups defined in the page have higher priority than those defined in the flow. Format:`projects//locations//agents//flows//transitionRouteGroups/` or `projects//locations//agents//transitionRouteGroups/` for agent-level groups.
        &quot;A String&quot;,
      ],
      &quot;transitionRoutes&quot;: [ # A flow&#x27;s transition routes serve two purposes: * They are responsible for matching the user&#x27;s first utterances in the flow. * They are inherited by every page&#x27;s transition routes and can support use cases such as the user saying &quot;help&quot; or &quot;can I talk to a human?&quot;, which can be handled in a common way regardless of the current page. Transition routes defined in the page have higher priority than those defined in the flow. TransitionRoutes are evalauted in the following order: * TransitionRoutes with intent specified. * TransitionRoutes with only condition specified. TransitionRoutes with intent specified are inherited by pages in the flow.
        { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
          &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
          &quot;description&quot;: &quot;A String&quot;, # Optional. The description of the transition route. The maximum length is 500 characters.
          &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
          &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
          &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
          &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
          &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
            &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
              &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
                &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
              },
              &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
                &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
                &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
                &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
                &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
                &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
              },
              &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
                &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
                &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
                &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
              },
              &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
                &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
                &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                  &quot;a_key&quot;: &quot;A String&quot;,
                },
                &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
                &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
              },
            },
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                              &quot;A String&quot;,
                            ],
                          },
                          &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                            &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                            &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                            &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                    &quot;A String&quot;,
                  ],
                },
                &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                  &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                  &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                  &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                },
              },
            ],
            &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
        },
      ],
    },
    &quot;currentPage&quot;: { # A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page). # The current Page. Some, not all fields are filled in this message, including but not limited to `name` and `display_name`.
      &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this page. The settings exposed at the lower level overrides the settings exposed at the higher level.
        &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
          &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
        },
        &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
          &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
          &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
          &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
          &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
          &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
        },
        &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
          &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
          &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
          &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
        },
        &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
          &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
          &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
          &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
        },
      },
      &quot;description&quot;: &quot;A String&quot;, # The description of the page. The maximum length is 500 characters.
      &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the page, unique within the flow.
      &quot;entryFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the session is entering the page.
        &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
          &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
            &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
          },
          &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
            &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
            &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
            &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
            &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
            &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
          },
          &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
            &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
            &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
            &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
          },
          &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
            &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
            &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
              &quot;a_key&quot;: &quot;A String&quot;,
            },
            &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
            &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
          },
        },
        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
            &quot;cases&quot;: [ # A list of cascading if-else conditions.
              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                &quot;caseContent&quot;: [ # A list of case content.
                  { # The list of messages or conditional cases to activate for this case.
                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                          &quot;A String&quot;,
                        ],
                      },
                      &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                        &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                        &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                        &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                      },
                    },
                  },
                ],
                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
              },
            ],
          },
        ],
        &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
            },
            &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
            },
            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
              &quot;segments&quot;: [ # Segments this audio response is composed of.
                { # Represents one segment of audio.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                },
              ],
            },
            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
            },
            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
            },
            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
            },
            &quot;text&quot;: { # The text response message. # Returns a text response.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                &quot;A String&quot;,
              ],
            },
            &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
              &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
              &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
            },
          },
        ],
        &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
          { # Setting a parameter value.
            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
          },
        ],
        &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
      },
      &quot;eventHandlers&quot;: [ # Handlers associated with the page to handle events such as webhook errors, no match or no input.
        { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
          &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
          &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
          &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
          &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
          &quot;targetPlaybook&quot;: &quot;A String&quot;, # The target playbook to transition to. Format: `projects//locations//agents//playbooks/`.
          &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
            &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
              &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
                &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
              },
              &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
                &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
                &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
                &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
                &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
                &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
              },
              &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
                &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
                &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
                &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
              },
              &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
                &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
                &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                  &quot;a_key&quot;: &quot;A String&quot;,
                },
                &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
                &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
              },
            },
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                              &quot;A String&quot;,
                            ],
                          },
                          &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                            &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                            &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                            &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                    &quot;A String&quot;,
                  ],
                },
                &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                  &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                  &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                  &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                },
              },
            ],
            &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
        },
      ],
      &quot;form&quot;: { # A form is a data model that groups related parameters that can be collected from the user. The process in which the agent prompts the user and collects parameter values from the user is called form filling. A form can be added to a page. When form filling is done, the filled parameters will be written to the session. # The form associated with the page, used for collecting parameters relevant to the page.
        &quot;parameters&quot;: [ # Parameters to collect from the user.
          { # Represents a form parameter.
            &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this parameter. The settings exposed at the lower level overrides the settings exposed at the higher level.
              &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
                &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
              },
              &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
                &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
                &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
                &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
                &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
                &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
              },
              &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
                &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
                &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
                &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
              },
              &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
                &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
                &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                  &quot;a_key&quot;: &quot;A String&quot;,
                },
                &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
                &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
              },
            },
            &quot;defaultValue&quot;: &quot;&quot;, # The default value of an optional parameter. If the parameter is required, the default value will be ignored.
            &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the parameter, unique within the form.
            &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
            &quot;fillBehavior&quot;: { # Configuration for how the filling of a parameter should be handled. # Required. Defines fill behavior for the parameter.
              &quot;initialPromptFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # Required. The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
                &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
                  &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
                    &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
                  },
                  &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
                    &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
                    &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
                    &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
                    &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
                    &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
                  },
                  &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
                    &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
                    &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
                    &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
                  },
                  &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
                    &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
                    &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                      &quot;a_key&quot;: &quot;A String&quot;,
                    },
                    &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
                    &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
                  },
                },
                &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                  { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                    &quot;cases&quot;: [ # A list of cascading if-else conditions.
                      { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                        &quot;caseContent&quot;: [ # A list of case content.
                          { # The list of messages or conditional cases to activate for this case.
                            &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                            &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                                  &quot;A String&quot;,
                                ],
                              },
                              &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                                &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                                &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                                &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                              },
                            },
                          },
                        ],
                        &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                      },
                    ],
                  },
                ],
                &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
                &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                  { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                    &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                    },
                    &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                    },
                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                        { # Represents one segment of audio.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                        },
                      ],
                    },
                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                    },
                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                    },
                    &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                      &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                    },
                    &quot;text&quot;: { # The text response message. # Returns a text response.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                        &quot;A String&quot;,
                      ],
                    },
                    &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                      &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                      &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                    },
                  },
                ],
                &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                  { # Setting a parameter value.
                    &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                    &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                  },
                ],
                &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
              },
              &quot;repromptEventHandlers&quot;: [ # The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are: * `sys.no-match-`, where N can be from 1 to 6 * `sys.no-match-default` * `sys.no-input-`, where N can be from 1 to 6 * `sys.no-input-default` * `sys.invalid-parameter` `initial_prompt_fulfillment` provides the first prompt for the parameter. If the user&#x27;s response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the `sys.no-match-1`/`sys.no-input-1` handler (if defined) will be called to provide a prompt. The `sys.no-match-2`/`sys.no-input-2` handler (if defined) will respond to the next no-match/no-input event, and so on. A `sys.no-match-default` or `sys.no-input-default` handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed. A `sys.invalid-parameter` handler can be defined to handle the case where the parameter values have been `invalidated` by webhook. For example, if the user&#x27;s response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the `sys.invalid-parameter` handler (if defined) will be called to provide a prompt. If the event handler for the corresponding event can&#x27;t be found on the parameter, `initial_prompt_fulfillment` will be re-prompted.
                { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                  &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                  &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                  &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                  &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                  &quot;targetPlaybook&quot;: &quot;A String&quot;, # The target playbook to transition to. Format: `projects//locations//agents//playbooks/`.
                  &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                    &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
                      &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
                        &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
                      },
                      &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
                        &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
                        &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
                        &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
                        &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
                        &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
                      },
                      &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
                        &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
                        &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
                        &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
                      },
                      &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
                        &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
                        &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                          &quot;a_key&quot;: &quot;A String&quot;,
                        },
                        &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
                        &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
                      },
                    },
                    &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                      { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                        &quot;cases&quot;: [ # A list of cascading if-else conditions.
                          { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                            &quot;caseContent&quot;: [ # A list of case content.
                              { # The list of messages or conditional cases to activate for this case.
                                &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                                &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                  &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                  &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                    &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                  },
                                  &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                  },
                                  &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                                  },
                                  &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                    &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                  },
                                  &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                    &quot;segments&quot;: [ # Segments this audio response is composed of.
                                      { # Represents one segment of audio.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                        &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                        &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                      },
                                    ],
                                  },
                                  &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                    &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                  },
                                  &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                  &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                  },
                                  &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                    &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                  },
                                  &quot;text&quot;: { # The text response message. # Returns a text response.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                                      &quot;A String&quot;,
                                    ],
                                  },
                                  &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                                    &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                                    &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                    &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                                  },
                                },
                              },
                            ],
                            &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                          },
                        ],
                      },
                    ],
                    &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
                    &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                      { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                        },
                        &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                        },
                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                            { # Represents one segment of audio.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                            },
                          ],
                        },
                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                        },
                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                        },
                        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                        },
                        &quot;text&quot;: { # The text response message. # Returns a text response.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                            &quot;A String&quot;,
                          ],
                        },
                        &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                          &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                          &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                        },
                      },
                    ],
                    &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                    &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                      { # Setting a parameter value.
                        &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                        &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                      },
                    ],
                    &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                    &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                  },
                },
              ],
            },
            &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
            &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
            &quot;required&quot;: True or False, # Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them. Required parameters must be filled before form filling concludes.
          },
        ],
      },
      &quot;knowledgeConnectorSettings&quot;: { # The Knowledge Connector settings for this page or flow. This includes information such as the attached Knowledge Bases, and the way to execute fulfillment. # Optional. Knowledge connector configuration.
        &quot;dataStoreConnections&quot;: [ # Optional. List of related data store connections.
          { # A data store connection. It represents a data store in Discovery Engine and the type of the contents it contains.
            &quot;dataStore&quot;: &quot;A String&quot;, # The full name of the referenced data store. Formats: `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}` `projects/{project}/locations/{location}/dataStores/{data_store}`
            &quot;dataStoreType&quot;: &quot;A String&quot;, # The type of the connected data store.
          },
        ],
        &quot;enabled&quot;: True or False, # Whether Knowledge Connector is enabled or not.
        &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
        &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
        &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to be triggered. When the answers from the Knowledge Connector are selected by Dialogflow, you can utitlize the request scoped parameter `$request.knowledge.answers` (contains up to the 5 highest confidence answers) and `$request.knowledge.questions` (contains the corresponding questions) to construct the fulfillment.
          &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
            &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
              &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
            },
            &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
              &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
              &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
              &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
              &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
              &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
            },
            &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
              &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
              &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
              &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
            },
            &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
              &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
              &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
              &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
            },
          },
          &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
            { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
              &quot;cases&quot;: [ # A list of cascading if-else conditions.
                { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                  &quot;caseContent&quot;: [ # A list of case content.
                    { # The list of messages or conditional cases to activate for this case.
                      &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                      &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                        },
                        &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                        },
                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                            { # Represents one segment of audio.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                            },
                          ],
                        },
                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                        },
                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                        },
                        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                        },
                        &quot;text&quot;: { # The text response message. # Returns a text response.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                            &quot;A String&quot;,
                          ],
                        },
                        &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                          &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                          &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                        },
                      },
                    },
                  ],
                  &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                },
              ],
            },
          ],
          &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
          &quot;messages&quot;: [ # The list of rich message responses to present to the user.
            { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
              },
              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
              },
              &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
              },
              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
              },
              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                &quot;segments&quot;: [ # Segments this audio response is composed of.
                  { # Represents one segment of audio.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                  },
                ],
              },
              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
              },
              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
              },
              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
              },
              &quot;text&quot;: { # The text response message. # Returns a text response.
                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                  &quot;A String&quot;,
                ],
              },
              &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
              },
            },
          ],
          &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
          &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
            { # Setting a parameter value.
              &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
              &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
            },
          ],
          &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
          &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
        },
      },
      &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the page. Required for the Pages.UpdatePage method. Pages.CreatePage populates the name automatically. Format: `projects//locations//agents//flows//pages/`.
      &quot;transitionRouteGroups&quot;: [ # Ordered list of `TransitionRouteGroups` added to the page. Transition route groups must be unique within a page. If the page links both flow-level transition route groups and agent-level transition route groups, the flow-level ones will have higher priority and will be put before the agent-level ones. * If multiple transition routes within a page scope refer to the same intent, then the precedence order is: page&#x27;s transition route -&gt; page&#x27;s transition route group -&gt; flow&#x27;s transition routes. * If multiple transition route groups within a page contain the same intent, then the first group in the ordered list takes precedence. Format:`projects//locations//agents//flows//transitionRouteGroups/` or `projects//locations//agents//transitionRouteGroups/` for agent-level groups.
        &quot;A String&quot;,
      ],
      &quot;transitionRoutes&quot;: [ # A list of transitions for the transition rules of this page. They route the conversation to another page in the same flow, or another flow. When we are in a certain page, the TransitionRoutes are evalauted in the following order: * TransitionRoutes defined in the page with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in flow with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in the page with only condition specified. * TransitionRoutes defined in the transition route groups with only condition specified.
        { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
          &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
          &quot;description&quot;: &quot;A String&quot;, # Optional. The description of the transition route. The maximum length is 500 characters.
          &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
          &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
          &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
          &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
          &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
            &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
              &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
                &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
              },
              &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
                &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
                &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
                &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
                &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
                &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
              },
              &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
                &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
                &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
                &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
              },
              &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
                &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
                &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                  &quot;a_key&quot;: &quot;A String&quot;,
                },
                &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
                &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
              },
            },
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                              &quot;A String&quot;,
                            ],
                          },
                          &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                            &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                            &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                            &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                    &quot;A String&quot;,
                  ],
                },
                &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                  &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                  &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                  &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                },
              },
            ],
            &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
        },
      ],
    },
    &quot;dataStoreConnectionSignals&quot;: { # Data store connection feature output signals. Might be only partially field if processing stop before the final answer. Reasons for this can be, but are not limited to: empty UCS search results, positive RAI check outcome, grounding failure, ... # Optional. Data store connection feature output signals. Filled only when data stores are involved in serving the query and DetectIntentRequest.populate_data_store_connection_signals is set to true in the request.
      &quot;answer&quot;: &quot;A String&quot;, # Optional. The final compiled answer.
      &quot;answerGenerationModelCallSignals&quot;: { # Diagnostic info related to the answer generation model call. # Optional. Diagnostic info related to the answer generation model call.
        &quot;model&quot;: &quot;A String&quot;, # Name of the generative model. For example, &quot;gemini-ultra&quot;, &quot;gemini-pro&quot;, &quot;gemini-1.5-flash&quot; etc. Defaults to &quot;Other&quot; if the model is unknown.
        &quot;modelOutput&quot;: &quot;A String&quot;, # Output of the generative model.
        &quot;renderedPrompt&quot;: &quot;A String&quot;, # Prompt as sent to the model.
      },
      &quot;answerParts&quot;: [ # Optional. Answer parts with relevant citations. Concatenation of texts should add up the `answer` (not counting whitespaces).
        { # Answer part with citation.
          &quot;supportingIndices&quot;: [ # Citations for this answer part. Indices of `search_snippets`.
            42,
          ],
          &quot;text&quot;: &quot;A String&quot;, # Substring of the answer.
        },
      ],
      &quot;citedSnippets&quot;: [ # Optional. Snippets cited by the answer generation model from the most to least relevant.
        { # Snippet cited by the answer generation model.
          &quot;searchSnippet&quot;: { # Search snippet details. # Details of the snippet.
            &quot;documentTitle&quot;: &quot;A String&quot;, # Title of the enclosing document.
            &quot;documentUri&quot;: &quot;A String&quot;, # Uri for the document. Present if specified for the document.
            &quot;text&quot;: &quot;A String&quot;, # Text included in the prompt.
          },
          &quot;snippetIndex&quot;: 42, # Index of the snippet in `search_snippets` field.
        },
      ],
      &quot;groundingSignals&quot;: { # Grounding signals. # Optional. Grounding signals.
        &quot;decision&quot;: &quot;A String&quot;, # Represents the decision of the grounding check.
        &quot;score&quot;: &quot;A String&quot;, # Grounding score bucket setting.
      },
      &quot;rewriterModelCallSignals&quot;: { # Diagnostic info related to the rewriter model call. # Optional. Diagnostic info related to the rewriter model call.
        &quot;model&quot;: &quot;A String&quot;, # Name of the generative model. For example, &quot;gemini-ultra&quot;, &quot;gemini-pro&quot;, &quot;gemini-1.5-flash&quot; etc. Defaults to &quot;Other&quot; if the model is unknown.
        &quot;modelOutput&quot;: &quot;A String&quot;, # Output of the generative model.
        &quot;renderedPrompt&quot;: &quot;A String&quot;, # Prompt as sent to the model.
      },
      &quot;rewrittenQuery&quot;: &quot;A String&quot;, # Optional. Rewritten string query used for search.
      &quot;safetySignals&quot;: { # Safety check results. # Optional. Safety check result.
        &quot;bannedPhraseMatch&quot;: &quot;A String&quot;, # Specifies banned phrase match subject.
        &quot;decision&quot;: &quot;A String&quot;, # Safety decision.
        &quot;matchedBannedPhrase&quot;: &quot;A String&quot;, # The matched banned phrase if there was a match.
      },
      &quot;searchSnippets&quot;: [ # Optional. Search snippets included in the answer generation prompt.
        { # Search snippet details.
          &quot;documentTitle&quot;: &quot;A String&quot;, # Title of the enclosing document.
          &quot;documentUri&quot;: &quot;A String&quot;, # Uri for the document. Present if specified for the document.
          &quot;text&quot;: &quot;A String&quot;, # Text included in the prompt.
        },
      ],
    },
    &quot;diagnosticInfo&quot;: { # The free-form diagnostic info. For example, this field could contain webhook call latency. The fields of this data can change without notice, so you should not write code that depends on its structure. One of the fields is called &quot;Alternative Matched Intents&quot;, which may aid with debugging. The following describes these intent results: - The list is empty if no intent was matched to end-user input. - Only intents that are referenced in the currently active flow are included. - The matched intent is included. - Other intents that could have matched end-user input, but did not match because they are referenced by intent routes that are out of [scope](https://cloud.google.com/dialogflow/cx/docs/concept/handler#scope), are included. - Other intents referenced by intent routes in scope that matched end-user input, but had a lower confidence score.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;dtmf&quot;: { # Represents the input for dtmf event. # If a DTMF was provided as input, this field will contain a copy of the DtmfInput.
      &quot;digits&quot;: &quot;A String&quot;, # The dtmf digits.
      &quot;finishDigit&quot;: &quot;A String&quot;, # The finish digit (if any).
    },
    &quot;generativeInfo&quot;: { # Represents the information of a query if handled by generative agent resources. # The information of a query if handled by generative agent resources.
      &quot;actionTracingInfo&quot;: { # Example represents a sample execution of the playbook in the conversation. An example consists of a list of ordered actions performed by end user or Dialogflow agent according the playbook instructions to fulfill the task. # The actions performed by the generative playbook for the current agent response.
        &quot;actions&quot;: [ # Required. The ordered list of actions performed by the end user and the Dialogflow agent.
          { # Action performed by end user or Dialogflow agent in the conversation.
            &quot;agentUtterance&quot;: { # AgentUtterance represents one message sent by the agent. # Optional. Action performed by the agent as a message.
              &quot;text&quot;: &quot;A String&quot;, # Required. Message content in text.
            },
            &quot;flowInvocation&quot;: { # Stores metadata of the invocation of a CX flow. Next Id: 7 # Optional. Action performed on behalf of the agent by invoking a CX flow.
              &quot;flow&quot;: &quot;A String&quot;, # Required. The unique identifier of the flow. Format: `projects//locations//agents//flows/`.
              &quot;flowState&quot;: &quot;A String&quot;, # Required. Flow invocation&#x27;s output state.
              &quot;inputActionParameters&quot;: { # Optional. A list of input parameters for the flow.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;outputActionParameters&quot;: { # Optional. A list of output parameters generated by the flow invocation.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;playbookInvocation&quot;: { # Stores metadata of the invocation of a child playbook. Next Id: 5 # Optional. Action performed on behalf of the agent by invoking a child playbook.
              &quot;playbook&quot;: &quot;A String&quot;, # Required. The unique identifier of the playbook. Format: `projects//locations//agents//playbooks/`.
              &quot;playbookInput&quot;: { # Input of the playbook. # Optional. Input of the child playbook invocation.
                &quot;actionParameters&quot;: { # Optional. A list of input parameters for the action.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;precedingConversationSummary&quot;: &quot;A String&quot;, # Optional. Summary string of the preceding conversation for the child playbook invocation.
              },
              &quot;playbookOutput&quot;: { # Output of the playbook. # Optional. Output of the child playbook invocation.
                &quot;actionParameters&quot;: { # Optional. A Struct object of output parameters for the action.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;executionSummary&quot;: &quot;A String&quot;, # Optional. Summary string of the execution result of the child playbook.
              },
              &quot;playbookState&quot;: &quot;A String&quot;, # Required. Playbook invocation&#x27;s output state.
            },
            &quot;toolUse&quot;: { # Stores metadata of the invocation of an action supported by a tool. # Optional. Action performed on behalf of the agent by calling a plugin tool.
              &quot;action&quot;: &quot;A String&quot;, # Optional. Name of the action to be called during the tool use.
              &quot;inputActionParameters&quot;: { # Optional. A list of input parameters for the action.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;outputActionParameters&quot;: { # Optional. A list of output parameters generated by the action.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;tool&quot;: &quot;A String&quot;, # Required. The tool that should be used. Format: `projects//locations//agents//tools/`.
            },
            &quot;userUtterance&quot;: { # UserUtterance represents one message sent by the customer. # Optional. Agent obtained a message from the customer.
              &quot;text&quot;: &quot;A String&quot;, # Required. Message content in text.
            },
          },
        ],
        &quot;conversationState&quot;: &quot;A String&quot;, # Required. Example&#x27;s output state.
        &quot;createTime&quot;: &quot;A String&quot;, # Output only. The timestamp of initial example creation.
        &quot;description&quot;: &quot;A String&quot;, # Optional. The high level concise description of the example. The max number of characters is 200.
        &quot;displayName&quot;: &quot;A String&quot;, # Required. The display name of the example.
        &quot;languageCode&quot;: &quot;A String&quot;, # Optional. The language code of the example. If not specified, the agent&#x27;s default language is used. Note: languages must be enabled in the agent before they can be used. Note: example&#x27;s language code is not currently used in dialogflow agents.
        &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the playbook example. Format: `projects//locations//agents//playbooks//examples/`.
        &quot;playbookInput&quot;: { # Input of the playbook. # Optional. The input to the playbook in the example.
          &quot;actionParameters&quot;: { # Optional. A list of input parameters for the action.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;precedingConversationSummary&quot;: &quot;A String&quot;, # Optional. Summary string of the preceding conversation for the child playbook invocation.
        },
        &quot;playbookOutput&quot;: { # Output of the playbook. # Optional. The output of the playbook in the example.
          &quot;actionParameters&quot;: { # Optional. A Struct object of output parameters for the action.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;executionSummary&quot;: &quot;A String&quot;, # Optional. Summary string of the execution result of the child playbook.
        },
        &quot;tokenCount&quot;: &quot;A String&quot;, # Output only. Estimated number of tokes current example takes when sent to the LLM.
        &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Last time the example was updated.
      },
      &quot;currentPlaybooks&quot;: [ # The stack of playbooks that the conversation has currently entered, with the most recent one on the top.
        &quot;A String&quot;,
      ],
    },
    &quot;intent&quot;: { # An intent represents a user&#x27;s intent to interact with a conversational agent. You can provide information for the Dialogflow API to use to match user input to an intent by adding training phrases (i.e., examples of user input) to your intent. # The Intent that matched the conversational query. Some, not all fields are filled in this message, including but not limited to: `name` and `display_name`. This field is deprecated, please use QueryResult.match instead.
      &quot;description&quot;: &quot;A String&quot;, # Human readable description for better understanding an intent like its scope, content, result etc. Maximum character limit: 140 characters.
      &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the intent, unique within the agent.
      &quot;isFallback&quot;: True or False, # Indicates whether this is a fallback intent. Currently only default fallback intent is allowed in the agent, which is added upon agent creation. Adding training phrases to fallback intent is useful in the case of requests that are mistakenly matched, since training phrases assigned to fallback intents act as negative examples that triggers no-match event.
      &quot;labels&quot;: { # The key/value metadata to label an intent. Labels can contain lowercase letters, digits and the symbols &#x27;-&#x27; and &#x27;_&#x27;. International characters are allowed, including letters from unicase alphabets. Keys must start with a letter. Keys and values can be no longer than 63 characters and no more than 128 bytes. Prefix &quot;sys-&quot; is reserved for Dialogflow defined labels. Currently allowed Dialogflow defined labels include: * sys-head * sys-contextual The above labels do not require value. &quot;sys-head&quot; means the intent is a head intent. &quot;sys-contextual&quot; means the intent is a contextual intent.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
      &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the intent. Required for the Intents.UpdateIntent method. Intents.CreateIntent populates the name automatically. Format: `projects//locations//agents//intents/`.
      &quot;parameters&quot;: [ # The collection of parameters associated with the intent.
        { # Represents an intent parameter.
          &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
          &quot;id&quot;: &quot;A String&quot;, # Required. The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
          &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
          &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
        },
      ],
      &quot;priority&quot;: 42, # The priority of this intent. Higher numbers represent higher priorities. - If the supplied value is unspecified or 0, the service translates the value to 500,000, which corresponds to the `Normal` priority in the console. - If the supplied value is negative, the intent is ignored in runtime detect intent requests.
      &quot;trainingPhrases&quot;: [ # The collection of training phrases the agent is trained on to identify the intent.
        { # Represents an example that the agent is trained on to identify the intent.
          &quot;id&quot;: &quot;A String&quot;, # Output only. The unique identifier of the training phrase.
          &quot;parts&quot;: [ # Required. The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase. Note: The API does not automatically annotate training phrases like the Dialogflow Console does. Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated. If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set. If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways: - `Part.text` is set to a part of the phrase that has no parameters. - `Part.text` is set to a part of the phrase that you want to annotate, and the `parameter_id` field is set.
            { # Represents a part of a training phrase.
              &quot;parameterId&quot;: &quot;A String&quot;, # The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
              &quot;text&quot;: &quot;A String&quot;, # Required. The text for this part.
            },
          ],
          &quot;repeatCount&quot;: 42, # Indicates how many times this example was added to the intent.
        },
      ],
    },
    &quot;intentDetectionConfidence&quot;: 3.14, # The intent detection confidence. Values range from 0.0 (completely uncertain) to 1.0 (completely certain). This value is for informational purpose only and is only used to help match the best intent within the classification threshold. This value may change for the same end-user expression at any time due to a model retraining or change in implementation. This field is deprecated, please use QueryResult.match instead.
    &quot;languageCode&quot;: &quot;A String&quot;, # The language that was triggered during intent detection. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes.
    &quot;match&quot;: { # Represents one match result of MatchIntent. # Intent match result, could be an intent or an event.
      &quot;confidence&quot;: 3.14, # The confidence of this match. Values range from 0.0 (completely uncertain) to 1.0 (completely certain). This value is for informational purpose only and is only used to help match the best intent within the classification threshold. This value may change for the same end-user expression at any time due to a model retraining or change in implementation.
      &quot;event&quot;: &quot;A String&quot;, # The event that matched the query. Filled for `EVENT`, `NO_MATCH` and `NO_INPUT` match types.
      &quot;intent&quot;: { # An intent represents a user&#x27;s intent to interact with a conversational agent. You can provide information for the Dialogflow API to use to match user input to an intent by adding training phrases (i.e., examples of user input) to your intent. # The Intent that matched the query. Some, not all fields are filled in this message, including but not limited to: `name` and `display_name`. Only filled for `INTENT` match type.
        &quot;description&quot;: &quot;A String&quot;, # Human readable description for better understanding an intent like its scope, content, result etc. Maximum character limit: 140 characters.
        &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the intent, unique within the agent.
        &quot;isFallback&quot;: True or False, # Indicates whether this is a fallback intent. Currently only default fallback intent is allowed in the agent, which is added upon agent creation. Adding training phrases to fallback intent is useful in the case of requests that are mistakenly matched, since training phrases assigned to fallback intents act as negative examples that triggers no-match event.
        &quot;labels&quot;: { # The key/value metadata to label an intent. Labels can contain lowercase letters, digits and the symbols &#x27;-&#x27; and &#x27;_&#x27;. International characters are allowed, including letters from unicase alphabets. Keys must start with a letter. Keys and values can be no longer than 63 characters and no more than 128 bytes. Prefix &quot;sys-&quot; is reserved for Dialogflow defined labels. Currently allowed Dialogflow defined labels include: * sys-head * sys-contextual The above labels do not require value. &quot;sys-head&quot; means the intent is a head intent. &quot;sys-contextual&quot; means the intent is a contextual intent.
          &quot;a_key&quot;: &quot;A String&quot;,
        },
        &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the intent. Required for the Intents.UpdateIntent method. Intents.CreateIntent populates the name automatically. Format: `projects//locations//agents//intents/`.
        &quot;parameters&quot;: [ # The collection of parameters associated with the intent.
          { # Represents an intent parameter.
            &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
            &quot;id&quot;: &quot;A String&quot;, # Required. The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
            &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
            &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
          },
        ],
        &quot;priority&quot;: 42, # The priority of this intent. Higher numbers represent higher priorities. - If the supplied value is unspecified or 0, the service translates the value to 500,000, which corresponds to the `Normal` priority in the console. - If the supplied value is negative, the intent is ignored in runtime detect intent requests.
        &quot;trainingPhrases&quot;: [ # The collection of training phrases the agent is trained on to identify the intent.
          { # Represents an example that the agent is trained on to identify the intent.
            &quot;id&quot;: &quot;A String&quot;, # Output only. The unique identifier of the training phrase.
            &quot;parts&quot;: [ # Required. The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase. Note: The API does not automatically annotate training phrases like the Dialogflow Console does. Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated. If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set. If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways: - `Part.text` is set to a part of the phrase that has no parameters. - `Part.text` is set to a part of the phrase that you want to annotate, and the `parameter_id` field is set.
              { # Represents a part of a training phrase.
                &quot;parameterId&quot;: &quot;A String&quot;, # The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
                &quot;text&quot;: &quot;A String&quot;, # Required. The text for this part.
              },
            ],
            &quot;repeatCount&quot;: 42, # Indicates how many times this example was added to the intent.
          },
        ],
      },
      &quot;matchType&quot;: &quot;A String&quot;, # Type of this Match.
      &quot;parameters&quot;: { # The collection of parameters extracted from the query. Depending on your protocol or client library language, this is a map, associative array, symbol table, dictionary, or JSON object composed of a collection of (MapKey, MapValue) pairs: * MapKey type: string * MapKey value: parameter name * MapValue type: If parameter&#x27;s entity type is a composite entity then use map, otherwise, depending on the parameter value type, it could be one of string, number, boolean, null, list or map. * MapValue value: If parameter&#x27;s entity type is a composite entity then use map from composite entity property names to property values, otherwise, use parameter value.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;resolvedInput&quot;: &quot;A String&quot;, # Final text input which was matched during MatchIntent. This value can be different from original input sent in request because of spelling correction or other processing.
    },
    &quot;parameters&quot;: { # The collected session parameters. Depending on your protocol or client library language, this is a map, associative array, symbol table, dictionary, or JSON object composed of a collection of (MapKey, MapValue) pairs: * MapKey type: string * MapKey value: parameter name * MapValue type: If parameter&#x27;s entity type is a composite entity then use map, otherwise, depending on the parameter value type, it could be one of string, number, boolean, null, list or map. * MapValue value: If parameter&#x27;s entity type is a composite entity then use map from composite entity property names to property values, otherwise, use parameter value.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;responseMessages&quot;: [ # The list of rich messages returned to the client. Responses vary from simple text messages to more sophisticated, structured payloads used to drive complex logic.
      { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
        },
        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
        },
        &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
        },
        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
        },
        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
          &quot;segments&quot;: [ # Segments this audio response is composed of.
            { # Represents one segment of audio.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
            },
          ],
        },
        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
        },
        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        },
        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
        },
        &quot;text&quot;: { # The text response message. # Returns a text response.
          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
          &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
            &quot;A String&quot;,
          ],
        },
        &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
          &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
          &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
        },
      },
    ],
    &quot;sentimentAnalysisResult&quot;: { # The result of sentiment analysis. Sentiment analysis inspects user input and identifies the prevailing subjective opinion, especially to determine a user&#x27;s attitude as positive, negative, or neutral. # The sentiment analyss result, which depends on `analyze_query_text_sentiment`, specified in the request.
      &quot;magnitude&quot;: 3.14, # A non-negative number in the [0, +inf) range, which represents the absolute magnitude of sentiment, regardless of score (positive or negative).
      &quot;score&quot;: 3.14, # Sentiment score between -1.0 (negative sentiment) and 1.0 (positive sentiment).
    },
    &quot;text&quot;: &quot;A String&quot;, # If natural language text was provided as input, this field will contain a copy of the text.
    &quot;transcript&quot;: &quot;A String&quot;, # If natural language speech audio was provided as input, this field will contain the transcript for the audio.
    &quot;triggerEvent&quot;: &quot;A String&quot;, # If an event was provided as input, this field will contain the name of the event.
    &quot;triggerIntent&quot;: &quot;A String&quot;, # If an intent was provided as input, this field will contain a copy of the intent identifier. Format: `projects//locations//agents//intents/`.
    &quot;webhookDisplayNames&quot;: [ # The list of webhook display names in the order of call sequence.
      &quot;A String&quot;,
    ],
    &quot;webhookIds&quot;: [ # The list of webhook ids in the order of call sequence.
      &quot;A String&quot;,
    ],
    &quot;webhookLatencies&quot;: [ # The list of webhook latencies in the order of call sequence.
      &quot;A String&quot;,
    ],
    &quot;webhookPayloads&quot;: [ # The list of webhook payload in WebhookResponse.payload, in the order of call sequence. If some webhook call fails or doesn&#x27;t return any payload, an empty `Struct` would be used instead.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
    ],
    &quot;webhookStatuses&quot;: [ # The list of webhook call status in the order of call sequence.
      { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
        &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
        &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
          {
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
          },
        ],
        &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
      },
    ],
    &quot;webhookTags&quot;: [ # The list of webhook tags in the order of call sequence.
      &quot;A String&quot;,
    ],
  },
  &quot;responseId&quot;: &quot;A String&quot;, # Output only. The unique identifier of the response. It can be used to locate a response in the training example set or for reporting issues.
  &quot;responseType&quot;: &quot;A String&quot;, # Response type.
}</pre>
</div>

<div class="method">
    <code class="details" id="fulfillIntent">fulfillIntent(session, body=None, x__xgafv=None)</code>
  <pre>Fulfills a matched intent returned by MatchIntent. Must be called after MatchIntent, with input from MatchIntentResponse. Otherwise, the behavior is undefined.

Args:
  session: string, Required. The name of the session this query is sent to. Format: `projects//locations//agents//sessions/` or `projects//locations//agents//environments//sessions/`. If `Environment ID` is not specified, we assume default &#x27;draft&#x27; environment. It&#x27;s up to the API caller to choose an appropriate `Session ID`. It can be a random number or some type of session identifiers (preferably hashed). The length of the `Session ID` must not exceed 36 characters. For more information, see the [sessions guide](https://cloud.google.com/dialogflow/cx/docs/concept/session). (required)
  body: object, The request body.
    The object takes the form of:

{ # Request of FulfillIntent
  &quot;match&quot;: { # Represents one match result of MatchIntent. # The matched intent/event to fulfill.
    &quot;confidence&quot;: 3.14, # The confidence of this match. Values range from 0.0 (completely uncertain) to 1.0 (completely certain). This value is for informational purpose only and is only used to help match the best intent within the classification threshold. This value may change for the same end-user expression at any time due to a model retraining or change in implementation.
    &quot;event&quot;: &quot;A String&quot;, # The event that matched the query. Filled for `EVENT`, `NO_MATCH` and `NO_INPUT` match types.
    &quot;intent&quot;: { # An intent represents a user&#x27;s intent to interact with a conversational agent. You can provide information for the Dialogflow API to use to match user input to an intent by adding training phrases (i.e., examples of user input) to your intent. # The Intent that matched the query. Some, not all fields are filled in this message, including but not limited to: `name` and `display_name`. Only filled for `INTENT` match type.
      &quot;description&quot;: &quot;A String&quot;, # Human readable description for better understanding an intent like its scope, content, result etc. Maximum character limit: 140 characters.
      &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the intent, unique within the agent.
      &quot;isFallback&quot;: True or False, # Indicates whether this is a fallback intent. Currently only default fallback intent is allowed in the agent, which is added upon agent creation. Adding training phrases to fallback intent is useful in the case of requests that are mistakenly matched, since training phrases assigned to fallback intents act as negative examples that triggers no-match event.
      &quot;labels&quot;: { # The key/value metadata to label an intent. Labels can contain lowercase letters, digits and the symbols &#x27;-&#x27; and &#x27;_&#x27;. International characters are allowed, including letters from unicase alphabets. Keys must start with a letter. Keys and values can be no longer than 63 characters and no more than 128 bytes. Prefix &quot;sys-&quot; is reserved for Dialogflow defined labels. Currently allowed Dialogflow defined labels include: * sys-head * sys-contextual The above labels do not require value. &quot;sys-head&quot; means the intent is a head intent. &quot;sys-contextual&quot; means the intent is a contextual intent.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
      &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the intent. Required for the Intents.UpdateIntent method. Intents.CreateIntent populates the name automatically. Format: `projects//locations//agents//intents/`.
      &quot;parameters&quot;: [ # The collection of parameters associated with the intent.
        { # Represents an intent parameter.
          &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
          &quot;id&quot;: &quot;A String&quot;, # Required. The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
          &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
          &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
        },
      ],
      &quot;priority&quot;: 42, # The priority of this intent. Higher numbers represent higher priorities. - If the supplied value is unspecified or 0, the service translates the value to 500,000, which corresponds to the `Normal` priority in the console. - If the supplied value is negative, the intent is ignored in runtime detect intent requests.
      &quot;trainingPhrases&quot;: [ # The collection of training phrases the agent is trained on to identify the intent.
        { # Represents an example that the agent is trained on to identify the intent.
          &quot;id&quot;: &quot;A String&quot;, # Output only. The unique identifier of the training phrase.
          &quot;parts&quot;: [ # Required. The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase. Note: The API does not automatically annotate training phrases like the Dialogflow Console does. Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated. If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set. If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways: - `Part.text` is set to a part of the phrase that has no parameters. - `Part.text` is set to a part of the phrase that you want to annotate, and the `parameter_id` field is set.
            { # Represents a part of a training phrase.
              &quot;parameterId&quot;: &quot;A String&quot;, # The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
              &quot;text&quot;: &quot;A String&quot;, # Required. The text for this part.
            },
          ],
          &quot;repeatCount&quot;: 42, # Indicates how many times this example was added to the intent.
        },
      ],
    },
    &quot;matchType&quot;: &quot;A String&quot;, # Type of this Match.
    &quot;parameters&quot;: { # The collection of parameters extracted from the query. Depending on your protocol or client library language, this is a map, associative array, symbol table, dictionary, or JSON object composed of a collection of (MapKey, MapValue) pairs: * MapKey type: string * MapKey value: parameter name * MapValue type: If parameter&#x27;s entity type is a composite entity then use map, otherwise, depending on the parameter value type, it could be one of string, number, boolean, null, list or map. * MapValue value: If parameter&#x27;s entity type is a composite entity then use map from composite entity property names to property values, otherwise, use parameter value.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;resolvedInput&quot;: &quot;A String&quot;, # Final text input which was matched during MatchIntent. This value can be different from original input sent in request because of spelling correction or other processing.
  },
  &quot;matchIntentRequest&quot;: { # Request of MatchIntent. # Must be same as the corresponding MatchIntent request, otherwise the behavior is undefined.
    &quot;persistParameterChanges&quot;: True or False, # Persist session parameter changes from `query_params`.
    &quot;queryInput&quot;: { # Represents the query input. It can contain one of: 1. A conversational query in the form of text. 2. An intent query that specifies which intent to trigger. 3. Natural language speech audio to be processed. 4. An event to be triggered. 5. DTMF digits to invoke an intent and fill in parameter value. 6. The results of a tool executed by the client. # Required. The input specification.
      &quot;audio&quot;: { # Represents the natural speech audio to be processed. # The natural language speech audio to be processed.
        &quot;audio&quot;: &quot;A String&quot;, # The natural language speech audio to be processed. A single request can contain up to 2 minutes of speech audio data. The transcribed text cannot contain more than 256 bytes. For non-streaming audio detect intent, both `config` and `audio` must be provided. For streaming audio detect intent, `config` must be provided in the first request and `audio` must be provided in all following requests.
        &quot;config&quot;: { # Instructs the speech recognizer on how to process the audio content. # Required. Instructs the speech recognizer how to process the speech audio.
          &quot;audioEncoding&quot;: &quot;A String&quot;, # Required. Audio encoding of the audio content to process.
          &quot;bargeInConfig&quot;: { # Configuration of the barge-in behavior. Barge-in instructs the API to return a detected utterance at a proper time while the client is playing back the response audio from a previous request. When the client sees the utterance, it should stop the playback and immediately get ready for receiving the responses for the current request. The barge-in handling requires the client to start streaming audio input as soon as it starts playing back the audio from the previous response. The playback is modeled into two phases: * No barge-in phase: which goes first and during which speech detection should not be carried out. * Barge-in phase: which follows the no barge-in phase and during which the API starts speech detection and may inform the client that an utterance has been detected. Note that no-speech event is not expected in this phase. The client provides this configuration in terms of the durations of those two phases. The durations are measured in terms of the audio length from the the start of the input audio. No-speech event is a response with END_OF_UTTERANCE without any transcript following up. # Configuration of barge-in behavior during the streaming of input audio.
            &quot;noBargeInDuration&quot;: &quot;A String&quot;, # Duration that is not eligible for barge-in at the beginning of the input audio.
            &quot;totalDuration&quot;: &quot;A String&quot;, # Total duration for the playback at the beginning of the input audio.
          },
          &quot;enableWordInfo&quot;: True or False, # Optional. If `true`, Dialogflow returns SpeechWordInfo in StreamingRecognitionResult with information about the recognized speech words, e.g. start and end time offsets. If false or unspecified, Speech doesn&#x27;t return any word-level information.
          &quot;model&quot;: &quot;A String&quot;, # Optional. Which Speech model to select for the given request. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
          &quot;modelVariant&quot;: &quot;A String&quot;, # Optional. Which variant of the Speech model to use.
          &quot;optOutConformerModelMigration&quot;: True or False, # If `true`, the request will opt out for STT conformer model migration. This field will be deprecated once force migration takes place in June 2024. Please refer to [Dialogflow CX Speech model migration](https://cloud.google.com/dialogflow/cx/docs/concept/speech-model-migration).
          &quot;phraseHints&quot;: [ # Optional. A list of strings containing words and phrases that the speech recognizer should recognize with higher likelihood. See [the Cloud Speech documentation](https://cloud.google.com/speech-to-text/docs/basics#phrase-hints) for more details.
            &quot;A String&quot;,
          ],
          &quot;sampleRateHertz&quot;: 42, # Sample rate (in Hertz) of the audio content sent in the query. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics) for more details.
          &quot;singleUtterance&quot;: True or False, # Optional. If `false` (default), recognition does not cease until the client closes the stream. If `true`, the recognizer will detect a single spoken utterance in input audio. Recognition ceases when it detects the audio&#x27;s voice has stopped or paused. In this case, once a detected intent is received, the client should close the stream and start a new request with a new stream as needed. Note: This setting is relevant only for streaming methods.
        },
      },
      &quot;dtmf&quot;: { # Represents the input for dtmf event. # The DTMF event to be handled.
        &quot;digits&quot;: &quot;A String&quot;, # The dtmf digits.
        &quot;finishDigit&quot;: &quot;A String&quot;, # The finish digit (if any).
      },
      &quot;event&quot;: { # Represents the event to trigger. # The event to be triggered.
        &quot;event&quot;: &quot;A String&quot;, # Name of the event.
      },
      &quot;intent&quot;: { # Represents the intent to trigger programmatically rather than as a result of natural language processing. # The intent to be triggered.
        &quot;intent&quot;: &quot;A String&quot;, # Required. The unique identifier of the intent. Format: `projects//locations//agents//intents/`.
      },
      &quot;languageCode&quot;: &quot;A String&quot;, # Required. The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes. Note that queries in the same session do not necessarily need to specify the same language.
      &quot;text&quot;: { # Represents the natural language text to be processed. # The natural language text to be processed.
        &quot;text&quot;: &quot;A String&quot;, # Required. The UTF-8 encoded natural language text to be processed.
      },
      &quot;toolCallResult&quot;: { # The result of calling a tool&#x27;s action that has been executed by the client. # The results of a tool executed by the client.
        &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
        &quot;error&quot;: { # An error produced by the tool call. # The tool call&#x27;s error.
          &quot;message&quot;: &quot;A String&quot;, # Optional. The error message of the function.
        },
        &quot;outputParameters&quot;: { # The tool call&#x27;s output parameters.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
      },
    },
    &quot;queryParams&quot;: { # Represents the parameters of a conversational query. # The parameters of this query.
      &quot;analyzeQueryTextSentiment&quot;: True or False, # Configures whether sentiment analysis should be performed. If not provided, sentiment analysis is not performed.
      &quot;channel&quot;: &quot;A String&quot;, # The channel which this query is for. If specified, only the ResponseMessage associated with the channel will be returned. If no ResponseMessage is associated with the channel, it falls back to the ResponseMessage with unspecified channel. If unspecified, the ResponseMessage with unspecified channel will be returned.
      &quot;currentPage&quot;: &quot;A String&quot;, # The unique identifier of the page to override the current page in the session. Format: `projects//locations//agents//flows//pages/`. If `current_page` is specified, the previous state of the session will be ignored by Dialogflow, including the previous page and the previous session parameters. In most cases, current_page and parameters should be configured together to direct a session to a specific state.
      &quot;currentPlaybook&quot;: &quot;A String&quot;, # Optional. Start the session with the specified playbook. You can only specify the playbook at the beginning of the session. Otherwise, an error will be thrown. Format: `projects//locations//agents//playbooks/`.
      &quot;disableWebhook&quot;: True or False, # Whether to disable webhook calls for this request.
      &quot;endUserMetadata&quot;: { # Optional. Information about the end-user to improve the relevance and accuracy of generative answers. This will be interpreted and used by a language model, so, for good results, the data should be self-descriptive, and in a simple structure. Example: ```json { &quot;subscription plan&quot;: &quot;Business Premium Plus&quot;, &quot;devices owned&quot;: [ {&quot;model&quot;: &quot;Google Pixel 7&quot;}, {&quot;model&quot;: &quot;Google Pixel Tablet&quot;} ] } ```
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;flowVersions&quot;: [ # A list of flow versions to override for the request. Format: `projects//locations//agents//flows//versions/`. If version 1 of flow X is included in this list, the traffic of flow X will go through version 1 regardless of the version configuration in the environment. Each flow can have at most one version specified in this list.
        &quot;A String&quot;,
      ],
      &quot;geoLocation&quot;: { # An object that represents a latitude/longitude pair. This is expressed as a pair of doubles to represent degrees latitude and degrees longitude. Unless specified otherwise, this object must conform to the WGS84 standard. Values must be within normalized ranges. # The geo location of this conversational query.
        &quot;latitude&quot;: 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
        &quot;longitude&quot;: 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
      },
      &quot;llmModelSettings&quot;: { # Settings for LLM models. # Optional. Use the specified LLM model settings for processing the request.
        &quot;model&quot;: &quot;A String&quot;, # The selected LLM model.
        &quot;promptText&quot;: &quot;A String&quot;, # The custom prompt to use.
      },
      &quot;parameters&quot;: { # Additional parameters to be put into session parameters. To remove a parameter from the session, clients should explicitly set the parameter value to null. You can reference the session parameters in the agent with the following format: $session.params.parameter-id. Depending on your protocol or client library language, this is a map, associative array, symbol table, dictionary, or JSON object composed of a collection of (MapKey, MapValue) pairs: * MapKey type: string * MapKey value: parameter name * MapValue type: If parameter&#x27;s entity type is a composite entity then use map, otherwise, depending on the parameter value type, it could be one of string, number, boolean, null, list or map. * MapValue value: If parameter&#x27;s entity type is a composite entity then use map from composite entity property names to property values, otherwise, use parameter value.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;payload&quot;: { # This field can be used to pass custom data into the webhook associated with the agent. Arbitrary JSON objects are supported. Some integrations that query a Dialogflow agent may provide additional information in the payload. In particular, for the Dialogflow Phone Gateway integration, this field has the form: ``` { &quot;telephony&quot;: { &quot;caller_id&quot;: &quot;+18558363987&quot; } } ```
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;populateDataStoreConnectionSignals&quot;: True or False, # Optional. If set to true and data stores are involved in serving the request then DetectIntentResponse.query_result.data_store_connection_signals will be filled with data that can help evaluations.
      &quot;searchConfig&quot;: { # Search configuration for UCS search queries. # Optional. Search configuration for UCS search queries.
        &quot;boostSpecs&quot;: [ # Optional. Boosting configuration for the datastores.
          { # Boost specifications for data stores.
            &quot;dataStores&quot;: [ # Optional. Data Stores where the boosting configuration is applied. The full names of the referenced data stores. Formats: `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}` `projects/{project}/locations/{location}/dataStores/{data_store}
              &quot;A String&quot;,
            ],
            &quot;spec&quot;: [ # Optional. A list of boosting specifications.
              { # Boost specification to boost certain documents. A copy of google.cloud.discoveryengine.v1main.BoostSpec, field documentation is available at https://cloud.google.com/generative-ai-app-builder/docs/reference/rest/v1alpha/BoostSpec
                &quot;conditionBoostSpecs&quot;: [ # Optional. Condition boost specifications. If a document matches multiple conditions in the specifictions, boost scores from these specifications are all applied and combined in a non-linear way. Maximum number of specifications is 20.
                  { # Boost applies to documents which match a condition.
                    &quot;boost&quot;: 3.14, # Optional. Strength of the condition boost, which should be in [-1, 1]. Negative boost means demotion. Default is 0.0. Setting to 1.0 gives the document a big promotion. However, it does not necessarily mean that the boosted document will be the top result at all times, nor that other documents will be excluded. Results could still be shown even when none of them matches the condition. And results that are significantly more relevant to the search query can still trump your heavily favored but irrelevant documents. Setting to -1.0 gives the document a big demotion. However, results that are deeply relevant might still be shown. The document will have an upstream battle to get a fairly high ranking, but it is not blocked out completely. Setting to 0.0 means no boost applied. The boosting condition is ignored.
                    &quot;boostControlSpec&quot;: { # Specification for custom ranking based on customer specified attribute value. It provides more controls for customized ranking than the simple (condition, boost) combination above. # Optional. Complex specification for custom ranking based on customer defined attribute value.
                      &quot;attributeType&quot;: &quot;A String&quot;, # Optional. The attribute type to be used to determine the boost amount. The attribute value can be derived from the field value of the specified field_name. In the case of numerical it is straightforward i.e. attribute_value = numerical_field_value. In the case of freshness however, attribute_value = (time.now() - datetime_field_value).
                      &quot;controlPoints&quot;: [ # Optional. The control points used to define the curve. The monotonic function (defined through the interpolation_type above) passes through the control points listed here.
                        { # The control points used to define the curve. The curve defined through these control points can only be monotonically increasing or decreasing(constant values are acceptable).
                          &quot;attributeValue&quot;: &quot;A String&quot;, # Optional. Can be one of: 1. The numerical field value. 2. The duration spec for freshness: The value must be formatted as an XSD `dayTimeDuration` value (a restricted subset of an ISO 8601 duration value). The pattern for this is: `nDnM]`.
                          &quot;boostAmount&quot;: 3.14, # Optional. The value between -1 to 1 by which to boost the score if the attribute_value evaluates to the value specified above.
                        },
                      ],
                      &quot;fieldName&quot;: &quot;A String&quot;, # Optional. The name of the field whose value will be used to determine the boost amount.
                      &quot;interpolationType&quot;: &quot;A String&quot;, # Optional. The interpolation type to be applied to connect the control points listed below.
                    },
                    &quot;condition&quot;: &quot;A String&quot;, # Optional. An expression which specifies a boost condition. The syntax and supported fields are the same as a filter expression. Examples: * To boost documents with document ID &quot;doc_1&quot; or &quot;doc_2&quot;, and color &quot;Red&quot; or &quot;Blue&quot;: * (id: ANY(&quot;doc_1&quot;, &quot;doc_2&quot;)) AND (color: ANY(&quot;Red&quot;,&quot;Blue&quot;))
                  },
                ],
              },
            ],
          },
        ],
        &quot;filterSpecs&quot;: [ # Optional. Filter configuration for the datastores.
          { # Filter specifications for data stores.
            &quot;dataStores&quot;: [ # Optional. Data Stores where the boosting configuration is applied. The full names of the referenced data stores. Formats: `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}` `projects/{project}/locations/{location}/dataStores/{data_store}
              &quot;A String&quot;,
            ],
            &quot;filter&quot;: &quot;A String&quot;, # Optional. The filter expression to be applied. Expression syntax is documented at https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata#filter-expression-syntax
          },
        ],
      },
      &quot;sessionEntityTypes&quot;: [ # Additional session entity types to replace or extend developer entity types with. The entity synonyms apply to all languages and persist for the session of this query.
        { # Session entity types are referred to as **User** entity types and are entities that are built for an individual user such as favorites, preferences, playlists, and so on. You can redefine a session entity type at the session level to extend or replace a custom entity type at the user session level (we refer to the entity types defined at the agent level as &quot;custom entity types&quot;). Note: session entity types apply to all queries, regardless of the language. For more information about entity types, see the [Dialogflow documentation](https://cloud.google.com/dialogflow/docs/entities-overview).
          &quot;entities&quot;: [ # Required. The collection of entities to override or supplement the custom entity type.
            { # An **entity entry** for an associated entity type.
              &quot;synonyms&quot;: [ # Required. A collection of value synonyms. For example, if the entity type is *vegetable*, and `value` is *scallions*, a synonym could be *green onions*. For `KIND_LIST` entity types: * This collection must contain exactly one synonym equal to `value`.
                &quot;A String&quot;,
              ],
              &quot;value&quot;: &quot;A String&quot;, # Required. The primary value associated with this entity entry. For example, if the entity type is *vegetable*, the value could be *scallions*. For `KIND_MAP` entity types: * A canonical value to be used in place of synonyms. For `KIND_LIST` entity types: * A string that can contain references to other entity types (with or without aliases).
            },
          ],
          &quot;entityOverrideMode&quot;: &quot;A String&quot;, # Required. Indicates whether the additional data should override or supplement the custom entity type definition.
          &quot;name&quot;: &quot;A String&quot;, # Required. The unique identifier of the session entity type. Format: `projects//locations//agents//sessions//entityTypes/` or `projects//locations//agents//environments//sessions//entityTypes/`. If `Environment ID` is not specified, we assume default &#x27;draft&#x27; environment.
        },
      ],
      &quot;sessionTtl&quot;: &quot;A String&quot;, # Optional. Configure lifetime of the Dialogflow session. By default, a Dialogflow session remains active and its data is stored for 30 minutes after the last request is sent for the session. This value should be no longer than 1 day.
      &quot;timeZone&quot;: &quot;A String&quot;, # The time zone of this conversational query from the [time zone database](https://www.iana.org/time-zones), e.g., America/New_York, Europe/Paris. If not provided, the time zone specified in the agent is used.
      &quot;webhookHeaders&quot;: { # This field can be used to pass HTTP headers for a webhook call. These headers will be sent to webhook along with the headers that have been configured through Dialogflow web console. The headers defined within this field will overwrite the headers configured through Dialogflow console if there is a conflict. Header names are case-insensitive. Google&#x27;s specified headers are not allowed. Including: &quot;Host&quot;, &quot;Content-Length&quot;, &quot;Connection&quot;, &quot;From&quot;, &quot;User-Agent&quot;, &quot;Accept-Encoding&quot;, &quot;If-Modified-Since&quot;, &quot;If-None-Match&quot;, &quot;X-Forwarded-For&quot;, etc.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
    },
  },
  &quot;outputAudioConfig&quot;: { # Instructs the speech synthesizer how to generate the output audio content. # Instructs the speech synthesizer how to generate output audio.
    &quot;audioEncoding&quot;: &quot;A String&quot;, # Required. Audio encoding of the synthesized audio content.
    &quot;sampleRateHertz&quot;: 42, # Optional. The synthesis sample rate (in hertz) for this audio. If not provided, then the synthesizer will use the default sample rate based on the audio encoding. If this is different from the voice&#x27;s natural sample rate, then the synthesizer will honor this request by converting to the desired sample rate (which might result in worse audio quality).
    &quot;synthesizeSpeechConfig&quot;: { # Configuration of how speech should be synthesized. # Optional. Configuration of how speech should be synthesized. If not specified, Agent.text_to_speech_settings is applied.
      &quot;effectsProfileId&quot;: [ # Optional. An identifier which selects &#x27;audio effects&#x27; profiles that are applied on (post synthesized) text to speech. Effects are applied on top of each other in the order they are given.
        &quot;A String&quot;,
      ],
      &quot;pitch&quot;: 3.14, # Optional. Speaking pitch, in the range [-20.0, 20.0]. 20 means increase 20 semitones from the original pitch. -20 means decrease 20 semitones from the original pitch.
      &quot;speakingRate&quot;: 3.14, # Optional. Speaking rate/speed, in the range [0.25, 4.0]. 1.0 is the normal native speed supported by the specific voice. 2.0 is twice as fast, and 0.5 is half as fast. If unset(0.0), defaults to the native 1.0 speed. Any other values &lt; 0.25 or &gt; 4.0 will return an error.
      &quot;voice&quot;: { # Description of which voice to use for speech synthesis. # Optional. The desired voice of the synthesized audio.
        &quot;name&quot;: &quot;A String&quot;, # Optional. The name of the voice. If not set, the service will choose a voice based on the other parameters such as language_code and ssml_gender. For the list of available voices, please refer to [Supported voices and languages](https://cloud.google.com/text-to-speech/docs/voices).
        &quot;ssmlGender&quot;: &quot;A String&quot;, # Optional. The preferred gender of the voice. If not set, the service will choose a voice based on the other parameters such as language_code and name. Note that this is only a preference, not requirement. If a voice of the appropriate gender is not available, the synthesizer should substitute a voice with a different gender rather than failing the request.
      },
      &quot;volumeGainDb&quot;: 3.14, # Optional. Volume gain (in dB) of the normal native volume supported by the specific voice, in the range [-96.0, 16.0]. If unset, or set to a value of 0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB) will play at approximately half the amplitude of the normal native signal amplitude. A value of +6.0 (dB) will play at approximately twice the amplitude of the normal native signal amplitude. We strongly recommend not to exceed +10 (dB) as there&#x27;s usually no effective increase in loudness for any value greater than that.
    },
  },
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response of FulfillIntent
  &quot;outputAudio&quot;: &quot;A String&quot;, # The audio data bytes encoded as specified in the request. Note: The output audio is generated based on the values of default platform text responses found in the `query_result.response_messages` field. If multiple default text responses exist, they will be concatenated when generating audio. If no default platform text responses exist, the generated audio content will be empty. In some scenarios, multiple output audio fields may be present in the response structure. In these cases, only the top-most-level audio output has content.
  &quot;outputAudioConfig&quot;: { # Instructs the speech synthesizer how to generate the output audio content. # The config used by the speech synthesizer to generate the output audio.
    &quot;audioEncoding&quot;: &quot;A String&quot;, # Required. Audio encoding of the synthesized audio content.
    &quot;sampleRateHertz&quot;: 42, # Optional. The synthesis sample rate (in hertz) for this audio. If not provided, then the synthesizer will use the default sample rate based on the audio encoding. If this is different from the voice&#x27;s natural sample rate, then the synthesizer will honor this request by converting to the desired sample rate (which might result in worse audio quality).
    &quot;synthesizeSpeechConfig&quot;: { # Configuration of how speech should be synthesized. # Optional. Configuration of how speech should be synthesized. If not specified, Agent.text_to_speech_settings is applied.
      &quot;effectsProfileId&quot;: [ # Optional. An identifier which selects &#x27;audio effects&#x27; profiles that are applied on (post synthesized) text to speech. Effects are applied on top of each other in the order they are given.
        &quot;A String&quot;,
      ],
      &quot;pitch&quot;: 3.14, # Optional. Speaking pitch, in the range [-20.0, 20.0]. 20 means increase 20 semitones from the original pitch. -20 means decrease 20 semitones from the original pitch.
      &quot;speakingRate&quot;: 3.14, # Optional. Speaking rate/speed, in the range [0.25, 4.0]. 1.0 is the normal native speed supported by the specific voice. 2.0 is twice as fast, and 0.5 is half as fast. If unset(0.0), defaults to the native 1.0 speed. Any other values &lt; 0.25 or &gt; 4.0 will return an error.
      &quot;voice&quot;: { # Description of which voice to use for speech synthesis. # Optional. The desired voice of the synthesized audio.
        &quot;name&quot;: &quot;A String&quot;, # Optional. The name of the voice. If not set, the service will choose a voice based on the other parameters such as language_code and ssml_gender. For the list of available voices, please refer to [Supported voices and languages](https://cloud.google.com/text-to-speech/docs/voices).
        &quot;ssmlGender&quot;: &quot;A String&quot;, # Optional. The preferred gender of the voice. If not set, the service will choose a voice based on the other parameters such as language_code and name. Note that this is only a preference, not requirement. If a voice of the appropriate gender is not available, the synthesizer should substitute a voice with a different gender rather than failing the request.
      },
      &quot;volumeGainDb&quot;: 3.14, # Optional. Volume gain (in dB) of the normal native volume supported by the specific voice, in the range [-96.0, 16.0]. If unset, or set to a value of 0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB) will play at approximately half the amplitude of the normal native signal amplitude. A value of +6.0 (dB) will play at approximately twice the amplitude of the normal native signal amplitude. We strongly recommend not to exceed +10 (dB) as there&#x27;s usually no effective increase in loudness for any value greater than that.
    },
  },
  &quot;queryResult&quot;: { # Represents the result of a conversational query. # The result of the conversational query.
    &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Returns the current advanced settings including IVR settings. Even though the operations configured by these settings are performed by Dialogflow, the client may need to perform special logic at the moment. For example, if Dialogflow exports audio to Google Cloud Storage, then the client may need to wait for the resulting object to appear in the bucket before proceeding.
      &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
        &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
      },
      &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
        &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
        &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
        &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
        &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
      },
      &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
        &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
        &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
        &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
      },
      &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
        &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
        &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
          &quot;a_key&quot;: &quot;A String&quot;,
        },
        &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
        &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
      },
    },
    &quot;allowAnswerFeedback&quot;: True or False, # Indicates whether the Thumbs up/Thumbs down rating controls are need to be shown for the response in the Dialogflow Messenger widget.
    &quot;currentFlow&quot;: { # Flows represents the conversation flows when you build your chatbot agent. A flow consists of many pages connected by the transition routes. Conversations always start with the built-in Start Flow (with an all-0 ID). Transition routes can direct the conversation session from the current flow (parent flow) to another flow (sub flow). When the sub flow is finished, Dialogflow will bring the session back to the parent flow, where the sub flow is started. Usually, when a transition route is followed by a matched intent, the intent will be &quot;consumed&quot;. This means the intent won&#x27;t activate more transition routes. However, when the followed transition route moves the conversation session into a different flow, the matched intent can be carried over and to be consumed in the target flow. # The current Flow. Some, not all fields are filled in this message, including but not limited to `name` and `display_name`.
      &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this flow. The settings exposed at the lower level overrides the settings exposed at the higher level.
        &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
          &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
        },
        &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
          &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
          &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
          &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
          &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
          &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
        },
        &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
          &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
          &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
          &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
        },
        &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
          &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
          &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
          &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
        },
      },
      &quot;description&quot;: &quot;A String&quot;, # The description of the flow. The maximum length is 500 characters. If exceeded, the request is rejected.
      &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the flow.
      &quot;eventHandlers&quot;: [ # A flow&#x27;s event handlers serve two purposes: * They are responsible for handling events (e.g. no match, webhook errors) in the flow. * They are inherited by every page&#x27;s event handlers, which can be used to handle common events regardless of the current page. Event handlers defined in the page have higher priority than those defined in the flow. Unlike transition_routes, these handlers are evaluated on a first-match basis. The first one that matches the event get executed, with the rest being ignored.
        { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
          &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
          &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
          &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
          &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
          &quot;targetPlaybook&quot;: &quot;A String&quot;, # The target playbook to transition to. Format: `projects//locations//agents//playbooks/`.
          &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
            &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
              &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
                &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
              },
              &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
                &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
                &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
                &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
                &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
                &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
              },
              &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
                &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
                &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
                &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
              },
              &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
                &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
                &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                  &quot;a_key&quot;: &quot;A String&quot;,
                },
                &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
                &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
              },
            },
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                              &quot;A String&quot;,
                            ],
                          },
                          &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                            &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                            &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                            &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                    &quot;A String&quot;,
                  ],
                },
                &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                  &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                  &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                  &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                },
              },
            ],
            &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
        },
      ],
      &quot;knowledgeConnectorSettings&quot;: { # The Knowledge Connector settings for this page or flow. This includes information such as the attached Knowledge Bases, and the way to execute fulfillment. # Optional. Knowledge connector configuration.
        &quot;dataStoreConnections&quot;: [ # Optional. List of related data store connections.
          { # A data store connection. It represents a data store in Discovery Engine and the type of the contents it contains.
            &quot;dataStore&quot;: &quot;A String&quot;, # The full name of the referenced data store. Formats: `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}` `projects/{project}/locations/{location}/dataStores/{data_store}`
            &quot;dataStoreType&quot;: &quot;A String&quot;, # The type of the connected data store.
          },
        ],
        &quot;enabled&quot;: True or False, # Whether Knowledge Connector is enabled or not.
        &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
        &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
        &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to be triggered. When the answers from the Knowledge Connector are selected by Dialogflow, you can utitlize the request scoped parameter `$request.knowledge.answers` (contains up to the 5 highest confidence answers) and `$request.knowledge.questions` (contains the corresponding questions) to construct the fulfillment.
          &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
            &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
              &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
            },
            &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
              &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
              &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
              &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
              &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
              &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
            },
            &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
              &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
              &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
              &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
            },
            &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
              &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
              &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
              &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
            },
          },
          &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
            { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
              &quot;cases&quot;: [ # A list of cascading if-else conditions.
                { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                  &quot;caseContent&quot;: [ # A list of case content.
                    { # The list of messages or conditional cases to activate for this case.
                      &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                      &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                        },
                        &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                        },
                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                            { # Represents one segment of audio.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                            },
                          ],
                        },
                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                        },
                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                        },
                        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                        },
                        &quot;text&quot;: { # The text response message. # Returns a text response.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                            &quot;A String&quot;,
                          ],
                        },
                        &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                          &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                          &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                        },
                      },
                    },
                  ],
                  &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                },
              ],
            },
          ],
          &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
          &quot;messages&quot;: [ # The list of rich message responses to present to the user.
            { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
              },
              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
              },
              &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
              },
              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
              },
              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                &quot;segments&quot;: [ # Segments this audio response is composed of.
                  { # Represents one segment of audio.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                  },
                ],
              },
              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
              },
              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
              },
              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
              },
              &quot;text&quot;: { # The text response message. # Returns a text response.
                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                  &quot;A String&quot;,
                ],
              },
              &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
              },
            },
          ],
          &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
          &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
            { # Setting a parameter value.
              &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
              &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
            },
          ],
          &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
          &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
        },
      },
      &quot;locked&quot;: True or False, # Indicates whether the flow is locked for changes. If the flow is locked, modifications to the flow will be rejected.
      &quot;multiLanguageSettings&quot;: { # Settings for multi-lingual agents. # Optional. Multi-lingual agent settings for this flow.
        &quot;enableMultiLanguageDetection&quot;: True or False, # Optional. Enable multi-language detection for this flow. This can be set only if agent level multi language setting is enabled.
        &quot;supportedResponseLanguageCodes&quot;: [ # Optional. Agent will respond in the detected language if the detected language code is in the supported resolved languages for this flow. This will be used only if multi-language training is enabled in the agent and multi-language detection is enabled in the flow. The supported languages must be a subset of the languages supported by the agent.
          &quot;A String&quot;,
        ],
      },
      &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the flow. Format: `projects//locations//agents//flows/`.
      &quot;nluSettings&quot;: { # Settings related to NLU. # NLU related settings of the flow.
        &quot;classificationThreshold&quot;: 3.14, # To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold. If the returned score value is less than the threshold value, then a no-match event will be triggered. The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used. You can set a separate classification threshold for the flow in each language enabled for the agent.
        &quot;modelTrainingMode&quot;: &quot;A String&quot;, # Indicates NLU model training mode.
        &quot;modelType&quot;: &quot;A String&quot;, # Indicates the type of NLU model.
      },
      &quot;transitionRouteGroups&quot;: [ # A flow&#x27;s transition route group serve two purposes: * They are responsible for matching the user&#x27;s first utterances in the flow. * They are inherited by every page&#x27;s transition route groups. Transition route groups defined in the page have higher priority than those defined in the flow. Format:`projects//locations//agents//flows//transitionRouteGroups/` or `projects//locations//agents//transitionRouteGroups/` for agent-level groups.
        &quot;A String&quot;,
      ],
      &quot;transitionRoutes&quot;: [ # A flow&#x27;s transition routes serve two purposes: * They are responsible for matching the user&#x27;s first utterances in the flow. * They are inherited by every page&#x27;s transition routes and can support use cases such as the user saying &quot;help&quot; or &quot;can I talk to a human?&quot;, which can be handled in a common way regardless of the current page. Transition routes defined in the page have higher priority than those defined in the flow. TransitionRoutes are evalauted in the following order: * TransitionRoutes with intent specified. * TransitionRoutes with only condition specified. TransitionRoutes with intent specified are inherited by pages in the flow.
        { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
          &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
          &quot;description&quot;: &quot;A String&quot;, # Optional. The description of the transition route. The maximum length is 500 characters.
          &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
          &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
          &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
          &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
          &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
            &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
              &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
                &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
              },
              &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
                &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
                &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
                &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
                &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
                &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
              },
              &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
                &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
                &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
                &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
              },
              &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
                &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
                &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                  &quot;a_key&quot;: &quot;A String&quot;,
                },
                &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
                &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
              },
            },
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                              &quot;A String&quot;,
                            ],
                          },
                          &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                            &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                            &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                            &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                    &quot;A String&quot;,
                  ],
                },
                &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                  &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                  &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                  &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                },
              },
            ],
            &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
        },
      ],
    },
    &quot;currentPage&quot;: { # A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page). # The current Page. Some, not all fields are filled in this message, including but not limited to `name` and `display_name`.
      &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this page. The settings exposed at the lower level overrides the settings exposed at the higher level.
        &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
          &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
        },
        &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
          &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
          &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
          &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
          &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
          &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
        },
        &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
          &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
          &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
          &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
        },
        &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
          &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
          &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
          &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
        },
      },
      &quot;description&quot;: &quot;A String&quot;, # The description of the page. The maximum length is 500 characters.
      &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the page, unique within the flow.
      &quot;entryFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the session is entering the page.
        &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
          &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
            &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
          },
          &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
            &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
            &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
            &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
            &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
            &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
          },
          &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
            &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
            &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
            &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
          },
          &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
            &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
            &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
              &quot;a_key&quot;: &quot;A String&quot;,
            },
            &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
            &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
          },
        },
        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
            &quot;cases&quot;: [ # A list of cascading if-else conditions.
              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                &quot;caseContent&quot;: [ # A list of case content.
                  { # The list of messages or conditional cases to activate for this case.
                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                          &quot;A String&quot;,
                        ],
                      },
                      &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                        &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                        &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                        &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                      },
                    },
                  },
                ],
                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
              },
            ],
          },
        ],
        &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
            },
            &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
            },
            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
              &quot;segments&quot;: [ # Segments this audio response is composed of.
                { # Represents one segment of audio.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                },
              ],
            },
            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
            },
            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
            },
            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
            },
            &quot;text&quot;: { # The text response message. # Returns a text response.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                &quot;A String&quot;,
              ],
            },
            &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
              &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
              &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
            },
          },
        ],
        &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
          { # Setting a parameter value.
            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
          },
        ],
        &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
      },
      &quot;eventHandlers&quot;: [ # Handlers associated with the page to handle events such as webhook errors, no match or no input.
        { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
          &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
          &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
          &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
          &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
          &quot;targetPlaybook&quot;: &quot;A String&quot;, # The target playbook to transition to. Format: `projects//locations//agents//playbooks/`.
          &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
            &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
              &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
                &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
              },
              &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
                &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
                &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
                &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
                &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
                &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
              },
              &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
                &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
                &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
                &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
              },
              &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
                &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
                &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                  &quot;a_key&quot;: &quot;A String&quot;,
                },
                &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
                &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
              },
            },
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                              &quot;A String&quot;,
                            ],
                          },
                          &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                            &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                            &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                            &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                    &quot;A String&quot;,
                  ],
                },
                &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                  &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                  &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                  &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                },
              },
            ],
            &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
        },
      ],
      &quot;form&quot;: { # A form is a data model that groups related parameters that can be collected from the user. The process in which the agent prompts the user and collects parameter values from the user is called form filling. A form can be added to a page. When form filling is done, the filled parameters will be written to the session. # The form associated with the page, used for collecting parameters relevant to the page.
        &quot;parameters&quot;: [ # Parameters to collect from the user.
          { # Represents a form parameter.
            &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this parameter. The settings exposed at the lower level overrides the settings exposed at the higher level.
              &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
                &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
              },
              &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
                &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
                &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
                &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
                &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
                &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
              },
              &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
                &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
                &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
                &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
              },
              &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
                &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
                &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                  &quot;a_key&quot;: &quot;A String&quot;,
                },
                &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
                &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
              },
            },
            &quot;defaultValue&quot;: &quot;&quot;, # The default value of an optional parameter. If the parameter is required, the default value will be ignored.
            &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the parameter, unique within the form.
            &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
            &quot;fillBehavior&quot;: { # Configuration for how the filling of a parameter should be handled. # Required. Defines fill behavior for the parameter.
              &quot;initialPromptFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # Required. The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
                &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
                  &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
                    &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
                  },
                  &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
                    &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
                    &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
                    &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
                    &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
                    &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
                  },
                  &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
                    &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
                    &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
                    &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
                  },
                  &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
                    &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
                    &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                      &quot;a_key&quot;: &quot;A String&quot;,
                    },
                    &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
                    &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
                  },
                },
                &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                  { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                    &quot;cases&quot;: [ # A list of cascading if-else conditions.
                      { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                        &quot;caseContent&quot;: [ # A list of case content.
                          { # The list of messages or conditional cases to activate for this case.
                            &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                            &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                                  &quot;A String&quot;,
                                ],
                              },
                              &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                                &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                                &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                                &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                              },
                            },
                          },
                        ],
                        &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                      },
                    ],
                  },
                ],
                &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
                &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                  { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                    &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                    },
                    &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                    },
                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                        { # Represents one segment of audio.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                        },
                      ],
                    },
                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                    },
                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                    },
                    &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                      &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                    },
                    &quot;text&quot;: { # The text response message. # Returns a text response.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                        &quot;A String&quot;,
                      ],
                    },
                    &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                      &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                      &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                    },
                  },
                ],
                &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                  { # Setting a parameter value.
                    &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                    &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                  },
                ],
                &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
              },
              &quot;repromptEventHandlers&quot;: [ # The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are: * `sys.no-match-`, where N can be from 1 to 6 * `sys.no-match-default` * `sys.no-input-`, where N can be from 1 to 6 * `sys.no-input-default` * `sys.invalid-parameter` `initial_prompt_fulfillment` provides the first prompt for the parameter. If the user&#x27;s response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the `sys.no-match-1`/`sys.no-input-1` handler (if defined) will be called to provide a prompt. The `sys.no-match-2`/`sys.no-input-2` handler (if defined) will respond to the next no-match/no-input event, and so on. A `sys.no-match-default` or `sys.no-input-default` handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed. A `sys.invalid-parameter` handler can be defined to handle the case where the parameter values have been `invalidated` by webhook. For example, if the user&#x27;s response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the `sys.invalid-parameter` handler (if defined) will be called to provide a prompt. If the event handler for the corresponding event can&#x27;t be found on the parameter, `initial_prompt_fulfillment` will be re-prompted.
                { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                  &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                  &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                  &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                  &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                  &quot;targetPlaybook&quot;: &quot;A String&quot;, # The target playbook to transition to. Format: `projects//locations//agents//playbooks/`.
                  &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                    &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
                      &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
                        &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
                      },
                      &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
                        &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
                        &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
                        &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
                        &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
                        &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
                      },
                      &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
                        &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
                        &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
                        &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
                      },
                      &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
                        &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
                        &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                          &quot;a_key&quot;: &quot;A String&quot;,
                        },
                        &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
                        &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
                      },
                    },
                    &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                      { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                        &quot;cases&quot;: [ # A list of cascading if-else conditions.
                          { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                            &quot;caseContent&quot;: [ # A list of case content.
                              { # The list of messages or conditional cases to activate for this case.
                                &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                                &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                  &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                  &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                    &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                  },
                                  &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                  },
                                  &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                                  },
                                  &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                    &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                  },
                                  &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                    &quot;segments&quot;: [ # Segments this audio response is composed of.
                                      { # Represents one segment of audio.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                        &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                        &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                      },
                                    ],
                                  },
                                  &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                    &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                  },
                                  &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                  &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                  },
                                  &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                    &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                  },
                                  &quot;text&quot;: { # The text response message. # Returns a text response.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                                      &quot;A String&quot;,
                                    ],
                                  },
                                  &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                                    &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                                    &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                    &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                                  },
                                },
                              },
                            ],
                            &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                          },
                        ],
                      },
                    ],
                    &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
                    &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                      { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                        },
                        &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                        },
                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                            { # Represents one segment of audio.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                            },
                          ],
                        },
                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                        },
                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                        },
                        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                        },
                        &quot;text&quot;: { # The text response message. # Returns a text response.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                            &quot;A String&quot;,
                          ],
                        },
                        &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                          &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                          &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                        },
                      },
                    ],
                    &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                    &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                      { # Setting a parameter value.
                        &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                        &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                      },
                    ],
                    &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                    &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                  },
                },
              ],
            },
            &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
            &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
            &quot;required&quot;: True or False, # Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them. Required parameters must be filled before form filling concludes.
          },
        ],
      },
      &quot;knowledgeConnectorSettings&quot;: { # The Knowledge Connector settings for this page or flow. This includes information such as the attached Knowledge Bases, and the way to execute fulfillment. # Optional. Knowledge connector configuration.
        &quot;dataStoreConnections&quot;: [ # Optional. List of related data store connections.
          { # A data store connection. It represents a data store in Discovery Engine and the type of the contents it contains.
            &quot;dataStore&quot;: &quot;A String&quot;, # The full name of the referenced data store. Formats: `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}` `projects/{project}/locations/{location}/dataStores/{data_store}`
            &quot;dataStoreType&quot;: &quot;A String&quot;, # The type of the connected data store.
          },
        ],
        &quot;enabled&quot;: True or False, # Whether Knowledge Connector is enabled or not.
        &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
        &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
        &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to be triggered. When the answers from the Knowledge Connector are selected by Dialogflow, you can utitlize the request scoped parameter `$request.knowledge.answers` (contains up to the 5 highest confidence answers) and `$request.knowledge.questions` (contains the corresponding questions) to construct the fulfillment.
          &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
            &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
              &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
            },
            &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
              &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
              &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
              &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
              &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
              &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
            },
            &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
              &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
              &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
              &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
            },
            &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
              &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
              &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
              &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
            },
          },
          &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
            { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
              &quot;cases&quot;: [ # A list of cascading if-else conditions.
                { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                  &quot;caseContent&quot;: [ # A list of case content.
                    { # The list of messages or conditional cases to activate for this case.
                      &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                      &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                        },
                        &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                        },
                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                            { # Represents one segment of audio.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                            },
                          ],
                        },
                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                        },
                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                        },
                        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                        },
                        &quot;text&quot;: { # The text response message. # Returns a text response.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                            &quot;A String&quot;,
                          ],
                        },
                        &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                          &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                          &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                        },
                      },
                    },
                  ],
                  &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                },
              ],
            },
          ],
          &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
          &quot;messages&quot;: [ # The list of rich message responses to present to the user.
            { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
              },
              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
              },
              &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
              },
              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
              },
              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                &quot;segments&quot;: [ # Segments this audio response is composed of.
                  { # Represents one segment of audio.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                  },
                ],
              },
              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
              },
              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
              },
              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
              },
              &quot;text&quot;: { # The text response message. # Returns a text response.
                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                  &quot;A String&quot;,
                ],
              },
              &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
              },
            },
          ],
          &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
          &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
            { # Setting a parameter value.
              &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
              &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
            },
          ],
          &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
          &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
        },
      },
      &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the page. Required for the Pages.UpdatePage method. Pages.CreatePage populates the name automatically. Format: `projects//locations//agents//flows//pages/`.
      &quot;transitionRouteGroups&quot;: [ # Ordered list of `TransitionRouteGroups` added to the page. Transition route groups must be unique within a page. If the page links both flow-level transition route groups and agent-level transition route groups, the flow-level ones will have higher priority and will be put before the agent-level ones. * If multiple transition routes within a page scope refer to the same intent, then the precedence order is: page&#x27;s transition route -&gt; page&#x27;s transition route group -&gt; flow&#x27;s transition routes. * If multiple transition route groups within a page contain the same intent, then the first group in the ordered list takes precedence. Format:`projects//locations//agents//flows//transitionRouteGroups/` or `projects//locations//agents//transitionRouteGroups/` for agent-level groups.
        &quot;A String&quot;,
      ],
      &quot;transitionRoutes&quot;: [ # A list of transitions for the transition rules of this page. They route the conversation to another page in the same flow, or another flow. When we are in a certain page, the TransitionRoutes are evalauted in the following order: * TransitionRoutes defined in the page with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in flow with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in the page with only condition specified. * TransitionRoutes defined in the transition route groups with only condition specified.
        { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
          &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
          &quot;description&quot;: &quot;A String&quot;, # Optional. The description of the transition route. The maximum length is 500 characters.
          &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
          &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
          &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
          &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
          &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
            &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
              &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
                &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
              },
              &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
                &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
                &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
                &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
                &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
                &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
              },
              &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
                &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
                &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
                &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
              },
              &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
                &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
                &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                  &quot;a_key&quot;: &quot;A String&quot;,
                },
                &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
                &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
              },
            },
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                              &quot;A String&quot;,
                            ],
                          },
                          &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                            &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                            &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                            &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                    &quot;A String&quot;,
                  ],
                },
                &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                  &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                  &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                  &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                },
              },
            ],
            &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
        },
      ],
    },
    &quot;dataStoreConnectionSignals&quot;: { # Data store connection feature output signals. Might be only partially field if processing stop before the final answer. Reasons for this can be, but are not limited to: empty UCS search results, positive RAI check outcome, grounding failure, ... # Optional. Data store connection feature output signals. Filled only when data stores are involved in serving the query and DetectIntentRequest.populate_data_store_connection_signals is set to true in the request.
      &quot;answer&quot;: &quot;A String&quot;, # Optional. The final compiled answer.
      &quot;answerGenerationModelCallSignals&quot;: { # Diagnostic info related to the answer generation model call. # Optional. Diagnostic info related to the answer generation model call.
        &quot;model&quot;: &quot;A String&quot;, # Name of the generative model. For example, &quot;gemini-ultra&quot;, &quot;gemini-pro&quot;, &quot;gemini-1.5-flash&quot; etc. Defaults to &quot;Other&quot; if the model is unknown.
        &quot;modelOutput&quot;: &quot;A String&quot;, # Output of the generative model.
        &quot;renderedPrompt&quot;: &quot;A String&quot;, # Prompt as sent to the model.
      },
      &quot;answerParts&quot;: [ # Optional. Answer parts with relevant citations. Concatenation of texts should add up the `answer` (not counting whitespaces).
        { # Answer part with citation.
          &quot;supportingIndices&quot;: [ # Citations for this answer part. Indices of `search_snippets`.
            42,
          ],
          &quot;text&quot;: &quot;A String&quot;, # Substring of the answer.
        },
      ],
      &quot;citedSnippets&quot;: [ # Optional. Snippets cited by the answer generation model from the most to least relevant.
        { # Snippet cited by the answer generation model.
          &quot;searchSnippet&quot;: { # Search snippet details. # Details of the snippet.
            &quot;documentTitle&quot;: &quot;A String&quot;, # Title of the enclosing document.
            &quot;documentUri&quot;: &quot;A String&quot;, # Uri for the document. Present if specified for the document.
            &quot;text&quot;: &quot;A String&quot;, # Text included in the prompt.
          },
          &quot;snippetIndex&quot;: 42, # Index of the snippet in `search_snippets` field.
        },
      ],
      &quot;groundingSignals&quot;: { # Grounding signals. # Optional. Grounding signals.
        &quot;decision&quot;: &quot;A String&quot;, # Represents the decision of the grounding check.
        &quot;score&quot;: &quot;A String&quot;, # Grounding score bucket setting.
      },
      &quot;rewriterModelCallSignals&quot;: { # Diagnostic info related to the rewriter model call. # Optional. Diagnostic info related to the rewriter model call.
        &quot;model&quot;: &quot;A String&quot;, # Name of the generative model. For example, &quot;gemini-ultra&quot;, &quot;gemini-pro&quot;, &quot;gemini-1.5-flash&quot; etc. Defaults to &quot;Other&quot; if the model is unknown.
        &quot;modelOutput&quot;: &quot;A String&quot;, # Output of the generative model.
        &quot;renderedPrompt&quot;: &quot;A String&quot;, # Prompt as sent to the model.
      },
      &quot;rewrittenQuery&quot;: &quot;A String&quot;, # Optional. Rewritten string query used for search.
      &quot;safetySignals&quot;: { # Safety check results. # Optional. Safety check result.
        &quot;bannedPhraseMatch&quot;: &quot;A String&quot;, # Specifies banned phrase match subject.
        &quot;decision&quot;: &quot;A String&quot;, # Safety decision.
        &quot;matchedBannedPhrase&quot;: &quot;A String&quot;, # The matched banned phrase if there was a match.
      },
      &quot;searchSnippets&quot;: [ # Optional. Search snippets included in the answer generation prompt.
        { # Search snippet details.
          &quot;documentTitle&quot;: &quot;A String&quot;, # Title of the enclosing document.
          &quot;documentUri&quot;: &quot;A String&quot;, # Uri for the document. Present if specified for the document.
          &quot;text&quot;: &quot;A String&quot;, # Text included in the prompt.
        },
      ],
    },
    &quot;diagnosticInfo&quot;: { # The free-form diagnostic info. For example, this field could contain webhook call latency. The fields of this data can change without notice, so you should not write code that depends on its structure. One of the fields is called &quot;Alternative Matched Intents&quot;, which may aid with debugging. The following describes these intent results: - The list is empty if no intent was matched to end-user input. - Only intents that are referenced in the currently active flow are included. - The matched intent is included. - Other intents that could have matched end-user input, but did not match because they are referenced by intent routes that are out of [scope](https://cloud.google.com/dialogflow/cx/docs/concept/handler#scope), are included. - Other intents referenced by intent routes in scope that matched end-user input, but had a lower confidence score.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;dtmf&quot;: { # Represents the input for dtmf event. # If a DTMF was provided as input, this field will contain a copy of the DtmfInput.
      &quot;digits&quot;: &quot;A String&quot;, # The dtmf digits.
      &quot;finishDigit&quot;: &quot;A String&quot;, # The finish digit (if any).
    },
    &quot;generativeInfo&quot;: { # Represents the information of a query if handled by generative agent resources. # The information of a query if handled by generative agent resources.
      &quot;actionTracingInfo&quot;: { # Example represents a sample execution of the playbook in the conversation. An example consists of a list of ordered actions performed by end user or Dialogflow agent according the playbook instructions to fulfill the task. # The actions performed by the generative playbook for the current agent response.
        &quot;actions&quot;: [ # Required. The ordered list of actions performed by the end user and the Dialogflow agent.
          { # Action performed by end user or Dialogflow agent in the conversation.
            &quot;agentUtterance&quot;: { # AgentUtterance represents one message sent by the agent. # Optional. Action performed by the agent as a message.
              &quot;text&quot;: &quot;A String&quot;, # Required. Message content in text.
            },
            &quot;flowInvocation&quot;: { # Stores metadata of the invocation of a CX flow. Next Id: 7 # Optional. Action performed on behalf of the agent by invoking a CX flow.
              &quot;flow&quot;: &quot;A String&quot;, # Required. The unique identifier of the flow. Format: `projects//locations//agents//flows/`.
              &quot;flowState&quot;: &quot;A String&quot;, # Required. Flow invocation&#x27;s output state.
              &quot;inputActionParameters&quot;: { # Optional. A list of input parameters for the flow.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;outputActionParameters&quot;: { # Optional. A list of output parameters generated by the flow invocation.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;playbookInvocation&quot;: { # Stores metadata of the invocation of a child playbook. Next Id: 5 # Optional. Action performed on behalf of the agent by invoking a child playbook.
              &quot;playbook&quot;: &quot;A String&quot;, # Required. The unique identifier of the playbook. Format: `projects//locations//agents//playbooks/`.
              &quot;playbookInput&quot;: { # Input of the playbook. # Optional. Input of the child playbook invocation.
                &quot;actionParameters&quot;: { # Optional. A list of input parameters for the action.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;precedingConversationSummary&quot;: &quot;A String&quot;, # Optional. Summary string of the preceding conversation for the child playbook invocation.
              },
              &quot;playbookOutput&quot;: { # Output of the playbook. # Optional. Output of the child playbook invocation.
                &quot;actionParameters&quot;: { # Optional. A Struct object of output parameters for the action.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;executionSummary&quot;: &quot;A String&quot;, # Optional. Summary string of the execution result of the child playbook.
              },
              &quot;playbookState&quot;: &quot;A String&quot;, # Required. Playbook invocation&#x27;s output state.
            },
            &quot;toolUse&quot;: { # Stores metadata of the invocation of an action supported by a tool. # Optional. Action performed on behalf of the agent by calling a plugin tool.
              &quot;action&quot;: &quot;A String&quot;, # Optional. Name of the action to be called during the tool use.
              &quot;inputActionParameters&quot;: { # Optional. A list of input parameters for the action.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;outputActionParameters&quot;: { # Optional. A list of output parameters generated by the action.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;tool&quot;: &quot;A String&quot;, # Required. The tool that should be used. Format: `projects//locations//agents//tools/`.
            },
            &quot;userUtterance&quot;: { # UserUtterance represents one message sent by the customer. # Optional. Agent obtained a message from the customer.
              &quot;text&quot;: &quot;A String&quot;, # Required. Message content in text.
            },
          },
        ],
        &quot;conversationState&quot;: &quot;A String&quot;, # Required. Example&#x27;s output state.
        &quot;createTime&quot;: &quot;A String&quot;, # Output only. The timestamp of initial example creation.
        &quot;description&quot;: &quot;A String&quot;, # Optional. The high level concise description of the example. The max number of characters is 200.
        &quot;displayName&quot;: &quot;A String&quot;, # Required. The display name of the example.
        &quot;languageCode&quot;: &quot;A String&quot;, # Optional. The language code of the example. If not specified, the agent&#x27;s default language is used. Note: languages must be enabled in the agent before they can be used. Note: example&#x27;s language code is not currently used in dialogflow agents.
        &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the playbook example. Format: `projects//locations//agents//playbooks//examples/`.
        &quot;playbookInput&quot;: { # Input of the playbook. # Optional. The input to the playbook in the example.
          &quot;actionParameters&quot;: { # Optional. A list of input parameters for the action.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;precedingConversationSummary&quot;: &quot;A String&quot;, # Optional. Summary string of the preceding conversation for the child playbook invocation.
        },
        &quot;playbookOutput&quot;: { # Output of the playbook. # Optional. The output of the playbook in the example.
          &quot;actionParameters&quot;: { # Optional. A Struct object of output parameters for the action.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;executionSummary&quot;: &quot;A String&quot;, # Optional. Summary string of the execution result of the child playbook.
        },
        &quot;tokenCount&quot;: &quot;A String&quot;, # Output only. Estimated number of tokes current example takes when sent to the LLM.
        &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Last time the example was updated.
      },
      &quot;currentPlaybooks&quot;: [ # The stack of playbooks that the conversation has currently entered, with the most recent one on the top.
        &quot;A String&quot;,
      ],
    },
    &quot;intent&quot;: { # An intent represents a user&#x27;s intent to interact with a conversational agent. You can provide information for the Dialogflow API to use to match user input to an intent by adding training phrases (i.e., examples of user input) to your intent. # The Intent that matched the conversational query. Some, not all fields are filled in this message, including but not limited to: `name` and `display_name`. This field is deprecated, please use QueryResult.match instead.
      &quot;description&quot;: &quot;A String&quot;, # Human readable description for better understanding an intent like its scope, content, result etc. Maximum character limit: 140 characters.
      &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the intent, unique within the agent.
      &quot;isFallback&quot;: True or False, # Indicates whether this is a fallback intent. Currently only default fallback intent is allowed in the agent, which is added upon agent creation. Adding training phrases to fallback intent is useful in the case of requests that are mistakenly matched, since training phrases assigned to fallback intents act as negative examples that triggers no-match event.
      &quot;labels&quot;: { # The key/value metadata to label an intent. Labels can contain lowercase letters, digits and the symbols &#x27;-&#x27; and &#x27;_&#x27;. International characters are allowed, including letters from unicase alphabets. Keys must start with a letter. Keys and values can be no longer than 63 characters and no more than 128 bytes. Prefix &quot;sys-&quot; is reserved for Dialogflow defined labels. Currently allowed Dialogflow defined labels include: * sys-head * sys-contextual The above labels do not require value. &quot;sys-head&quot; means the intent is a head intent. &quot;sys-contextual&quot; means the intent is a contextual intent.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
      &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the intent. Required for the Intents.UpdateIntent method. Intents.CreateIntent populates the name automatically. Format: `projects//locations//agents//intents/`.
      &quot;parameters&quot;: [ # The collection of parameters associated with the intent.
        { # Represents an intent parameter.
          &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
          &quot;id&quot;: &quot;A String&quot;, # Required. The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
          &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
          &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
        },
      ],
      &quot;priority&quot;: 42, # The priority of this intent. Higher numbers represent higher priorities. - If the supplied value is unspecified or 0, the service translates the value to 500,000, which corresponds to the `Normal` priority in the console. - If the supplied value is negative, the intent is ignored in runtime detect intent requests.
      &quot;trainingPhrases&quot;: [ # The collection of training phrases the agent is trained on to identify the intent.
        { # Represents an example that the agent is trained on to identify the intent.
          &quot;id&quot;: &quot;A String&quot;, # Output only. The unique identifier of the training phrase.
          &quot;parts&quot;: [ # Required. The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase. Note: The API does not automatically annotate training phrases like the Dialogflow Console does. Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated. If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set. If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways: - `Part.text` is set to a part of the phrase that has no parameters. - `Part.text` is set to a part of the phrase that you want to annotate, and the `parameter_id` field is set.
            { # Represents a part of a training phrase.
              &quot;parameterId&quot;: &quot;A String&quot;, # The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
              &quot;text&quot;: &quot;A String&quot;, # Required. The text for this part.
            },
          ],
          &quot;repeatCount&quot;: 42, # Indicates how many times this example was added to the intent.
        },
      ],
    },
    &quot;intentDetectionConfidence&quot;: 3.14, # The intent detection confidence. Values range from 0.0 (completely uncertain) to 1.0 (completely certain). This value is for informational purpose only and is only used to help match the best intent within the classification threshold. This value may change for the same end-user expression at any time due to a model retraining or change in implementation. This field is deprecated, please use QueryResult.match instead.
    &quot;languageCode&quot;: &quot;A String&quot;, # The language that was triggered during intent detection. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes.
    &quot;match&quot;: { # Represents one match result of MatchIntent. # Intent match result, could be an intent or an event.
      &quot;confidence&quot;: 3.14, # The confidence of this match. Values range from 0.0 (completely uncertain) to 1.0 (completely certain). This value is for informational purpose only and is only used to help match the best intent within the classification threshold. This value may change for the same end-user expression at any time due to a model retraining or change in implementation.
      &quot;event&quot;: &quot;A String&quot;, # The event that matched the query. Filled for `EVENT`, `NO_MATCH` and `NO_INPUT` match types.
      &quot;intent&quot;: { # An intent represents a user&#x27;s intent to interact with a conversational agent. You can provide information for the Dialogflow API to use to match user input to an intent by adding training phrases (i.e., examples of user input) to your intent. # The Intent that matched the query. Some, not all fields are filled in this message, including but not limited to: `name` and `display_name`. Only filled for `INTENT` match type.
        &quot;description&quot;: &quot;A String&quot;, # Human readable description for better understanding an intent like its scope, content, result etc. Maximum character limit: 140 characters.
        &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the intent, unique within the agent.
        &quot;isFallback&quot;: True or False, # Indicates whether this is a fallback intent. Currently only default fallback intent is allowed in the agent, which is added upon agent creation. Adding training phrases to fallback intent is useful in the case of requests that are mistakenly matched, since training phrases assigned to fallback intents act as negative examples that triggers no-match event.
        &quot;labels&quot;: { # The key/value metadata to label an intent. Labels can contain lowercase letters, digits and the symbols &#x27;-&#x27; and &#x27;_&#x27;. International characters are allowed, including letters from unicase alphabets. Keys must start with a letter. Keys and values can be no longer than 63 characters and no more than 128 bytes. Prefix &quot;sys-&quot; is reserved for Dialogflow defined labels. Currently allowed Dialogflow defined labels include: * sys-head * sys-contextual The above labels do not require value. &quot;sys-head&quot; means the intent is a head intent. &quot;sys-contextual&quot; means the intent is a contextual intent.
          &quot;a_key&quot;: &quot;A String&quot;,
        },
        &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the intent. Required for the Intents.UpdateIntent method. Intents.CreateIntent populates the name automatically. Format: `projects//locations//agents//intents/`.
        &quot;parameters&quot;: [ # The collection of parameters associated with the intent.
          { # Represents an intent parameter.
            &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
            &quot;id&quot;: &quot;A String&quot;, # Required. The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
            &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
            &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
          },
        ],
        &quot;priority&quot;: 42, # The priority of this intent. Higher numbers represent higher priorities. - If the supplied value is unspecified or 0, the service translates the value to 500,000, which corresponds to the `Normal` priority in the console. - If the supplied value is negative, the intent is ignored in runtime detect intent requests.
        &quot;trainingPhrases&quot;: [ # The collection of training phrases the agent is trained on to identify the intent.
          { # Represents an example that the agent is trained on to identify the intent.
            &quot;id&quot;: &quot;A String&quot;, # Output only. The unique identifier of the training phrase.
            &quot;parts&quot;: [ # Required. The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase. Note: The API does not automatically annotate training phrases like the Dialogflow Console does. Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated. If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set. If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways: - `Part.text` is set to a part of the phrase that has no parameters. - `Part.text` is set to a part of the phrase that you want to annotate, and the `parameter_id` field is set.
              { # Represents a part of a training phrase.
                &quot;parameterId&quot;: &quot;A String&quot;, # The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
                &quot;text&quot;: &quot;A String&quot;, # Required. The text for this part.
              },
            ],
            &quot;repeatCount&quot;: 42, # Indicates how many times this example was added to the intent.
          },
        ],
      },
      &quot;matchType&quot;: &quot;A String&quot;, # Type of this Match.
      &quot;parameters&quot;: { # The collection of parameters extracted from the query. Depending on your protocol or client library language, this is a map, associative array, symbol table, dictionary, or JSON object composed of a collection of (MapKey, MapValue) pairs: * MapKey type: string * MapKey value: parameter name * MapValue type: If parameter&#x27;s entity type is a composite entity then use map, otherwise, depending on the parameter value type, it could be one of string, number, boolean, null, list or map. * MapValue value: If parameter&#x27;s entity type is a composite entity then use map from composite entity property names to property values, otherwise, use parameter value.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;resolvedInput&quot;: &quot;A String&quot;, # Final text input which was matched during MatchIntent. This value can be different from original input sent in request because of spelling correction or other processing.
    },
    &quot;parameters&quot;: { # The collected session parameters. Depending on your protocol or client library language, this is a map, associative array, symbol table, dictionary, or JSON object composed of a collection of (MapKey, MapValue) pairs: * MapKey type: string * MapKey value: parameter name * MapValue type: If parameter&#x27;s entity type is a composite entity then use map, otherwise, depending on the parameter value type, it could be one of string, number, boolean, null, list or map. * MapValue value: If parameter&#x27;s entity type is a composite entity then use map from composite entity property names to property values, otherwise, use parameter value.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;responseMessages&quot;: [ # The list of rich messages returned to the client. Responses vary from simple text messages to more sophisticated, structured payloads used to drive complex logic.
      { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
        },
        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
        },
        &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
        },
        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
        },
        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
          &quot;segments&quot;: [ # Segments this audio response is composed of.
            { # Represents one segment of audio.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
            },
          ],
        },
        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
        },
        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        },
        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
        },
        &quot;text&quot;: { # The text response message. # Returns a text response.
          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
          &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
            &quot;A String&quot;,
          ],
        },
        &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
          &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
          &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
        },
      },
    ],
    &quot;sentimentAnalysisResult&quot;: { # The result of sentiment analysis. Sentiment analysis inspects user input and identifies the prevailing subjective opinion, especially to determine a user&#x27;s attitude as positive, negative, or neutral. # The sentiment analyss result, which depends on `analyze_query_text_sentiment`, specified in the request.
      &quot;magnitude&quot;: 3.14, # A non-negative number in the [0, +inf) range, which represents the absolute magnitude of sentiment, regardless of score (positive or negative).
      &quot;score&quot;: 3.14, # Sentiment score between -1.0 (negative sentiment) and 1.0 (positive sentiment).
    },
    &quot;text&quot;: &quot;A String&quot;, # If natural language text was provided as input, this field will contain a copy of the text.
    &quot;transcript&quot;: &quot;A String&quot;, # If natural language speech audio was provided as input, this field will contain the transcript for the audio.
    &quot;triggerEvent&quot;: &quot;A String&quot;, # If an event was provided as input, this field will contain the name of the event.
    &quot;triggerIntent&quot;: &quot;A String&quot;, # If an intent was provided as input, this field will contain a copy of the intent identifier. Format: `projects//locations//agents//intents/`.
    &quot;webhookDisplayNames&quot;: [ # The list of webhook display names in the order of call sequence.
      &quot;A String&quot;,
    ],
    &quot;webhookIds&quot;: [ # The list of webhook ids in the order of call sequence.
      &quot;A String&quot;,
    ],
    &quot;webhookLatencies&quot;: [ # The list of webhook latencies in the order of call sequence.
      &quot;A String&quot;,
    ],
    &quot;webhookPayloads&quot;: [ # The list of webhook payload in WebhookResponse.payload, in the order of call sequence. If some webhook call fails or doesn&#x27;t return any payload, an empty `Struct` would be used instead.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
    ],
    &quot;webhookStatuses&quot;: [ # The list of webhook call status in the order of call sequence.
      { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
        &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
        &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
          {
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
          },
        ],
        &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
      },
    ],
    &quot;webhookTags&quot;: [ # The list of webhook tags in the order of call sequence.
      &quot;A String&quot;,
    ],
  },
  &quot;responseId&quot;: &quot;A String&quot;, # Output only. The unique identifier of the response. It can be used to locate a response in the training example set or for reporting issues.
}</pre>
</div>

<div class="method">
    <code class="details" id="matchIntent">matchIntent(session, body=None, x__xgafv=None)</code>
  <pre>Returns preliminary intent match results, doesn&#x27;t change the session status.

Args:
  session: string, Required. The name of the session this query is sent to. Format: `projects//locations//agents//sessions/` or `projects//locations//agents//environments//sessions/`. If `Environment ID` is not specified, we assume default &#x27;draft&#x27; environment. It&#x27;s up to the API caller to choose an appropriate `Session ID`. It can be a random number or some type of session identifiers (preferably hashed). The length of the `Session ID` must not exceed 36 characters. For more information, see the [sessions guide](https://cloud.google.com/dialogflow/cx/docs/concept/session). (required)
  body: object, The request body.
    The object takes the form of:

{ # Request of MatchIntent.
  &quot;persistParameterChanges&quot;: True or False, # Persist session parameter changes from `query_params`.
  &quot;queryInput&quot;: { # Represents the query input. It can contain one of: 1. A conversational query in the form of text. 2. An intent query that specifies which intent to trigger. 3. Natural language speech audio to be processed. 4. An event to be triggered. 5. DTMF digits to invoke an intent and fill in parameter value. 6. The results of a tool executed by the client. # Required. The input specification.
    &quot;audio&quot;: { # Represents the natural speech audio to be processed. # The natural language speech audio to be processed.
      &quot;audio&quot;: &quot;A String&quot;, # The natural language speech audio to be processed. A single request can contain up to 2 minutes of speech audio data. The transcribed text cannot contain more than 256 bytes. For non-streaming audio detect intent, both `config` and `audio` must be provided. For streaming audio detect intent, `config` must be provided in the first request and `audio` must be provided in all following requests.
      &quot;config&quot;: { # Instructs the speech recognizer on how to process the audio content. # Required. Instructs the speech recognizer how to process the speech audio.
        &quot;audioEncoding&quot;: &quot;A String&quot;, # Required. Audio encoding of the audio content to process.
        &quot;bargeInConfig&quot;: { # Configuration of the barge-in behavior. Barge-in instructs the API to return a detected utterance at a proper time while the client is playing back the response audio from a previous request. When the client sees the utterance, it should stop the playback and immediately get ready for receiving the responses for the current request. The barge-in handling requires the client to start streaming audio input as soon as it starts playing back the audio from the previous response. The playback is modeled into two phases: * No barge-in phase: which goes first and during which speech detection should not be carried out. * Barge-in phase: which follows the no barge-in phase and during which the API starts speech detection and may inform the client that an utterance has been detected. Note that no-speech event is not expected in this phase. The client provides this configuration in terms of the durations of those two phases. The durations are measured in terms of the audio length from the the start of the input audio. No-speech event is a response with END_OF_UTTERANCE without any transcript following up. # Configuration of barge-in behavior during the streaming of input audio.
          &quot;noBargeInDuration&quot;: &quot;A String&quot;, # Duration that is not eligible for barge-in at the beginning of the input audio.
          &quot;totalDuration&quot;: &quot;A String&quot;, # Total duration for the playback at the beginning of the input audio.
        },
        &quot;enableWordInfo&quot;: True or False, # Optional. If `true`, Dialogflow returns SpeechWordInfo in StreamingRecognitionResult with information about the recognized speech words, e.g. start and end time offsets. If false or unspecified, Speech doesn&#x27;t return any word-level information.
        &quot;model&quot;: &quot;A String&quot;, # Optional. Which Speech model to select for the given request. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
        &quot;modelVariant&quot;: &quot;A String&quot;, # Optional. Which variant of the Speech model to use.
        &quot;optOutConformerModelMigration&quot;: True or False, # If `true`, the request will opt out for STT conformer model migration. This field will be deprecated once force migration takes place in June 2024. Please refer to [Dialogflow CX Speech model migration](https://cloud.google.com/dialogflow/cx/docs/concept/speech-model-migration).
        &quot;phraseHints&quot;: [ # Optional. A list of strings containing words and phrases that the speech recognizer should recognize with higher likelihood. See [the Cloud Speech documentation](https://cloud.google.com/speech-to-text/docs/basics#phrase-hints) for more details.
          &quot;A String&quot;,
        ],
        &quot;sampleRateHertz&quot;: 42, # Sample rate (in Hertz) of the audio content sent in the query. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics) for more details.
        &quot;singleUtterance&quot;: True or False, # Optional. If `false` (default), recognition does not cease until the client closes the stream. If `true`, the recognizer will detect a single spoken utterance in input audio. Recognition ceases when it detects the audio&#x27;s voice has stopped or paused. In this case, once a detected intent is received, the client should close the stream and start a new request with a new stream as needed. Note: This setting is relevant only for streaming methods.
      },
    },
    &quot;dtmf&quot;: { # Represents the input for dtmf event. # The DTMF event to be handled.
      &quot;digits&quot;: &quot;A String&quot;, # The dtmf digits.
      &quot;finishDigit&quot;: &quot;A String&quot;, # The finish digit (if any).
    },
    &quot;event&quot;: { # Represents the event to trigger. # The event to be triggered.
      &quot;event&quot;: &quot;A String&quot;, # Name of the event.
    },
    &quot;intent&quot;: { # Represents the intent to trigger programmatically rather than as a result of natural language processing. # The intent to be triggered.
      &quot;intent&quot;: &quot;A String&quot;, # Required. The unique identifier of the intent. Format: `projects//locations//agents//intents/`.
    },
    &quot;languageCode&quot;: &quot;A String&quot;, # Required. The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes. Note that queries in the same session do not necessarily need to specify the same language.
    &quot;text&quot;: { # Represents the natural language text to be processed. # The natural language text to be processed.
      &quot;text&quot;: &quot;A String&quot;, # Required. The UTF-8 encoded natural language text to be processed.
    },
    &quot;toolCallResult&quot;: { # The result of calling a tool&#x27;s action that has been executed by the client. # The results of a tool executed by the client.
      &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
      &quot;error&quot;: { # An error produced by the tool call. # The tool call&#x27;s error.
        &quot;message&quot;: &quot;A String&quot;, # Optional. The error message of the function.
      },
      &quot;outputParameters&quot;: { # The tool call&#x27;s output parameters.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
    },
  },
  &quot;queryParams&quot;: { # Represents the parameters of a conversational query. # The parameters of this query.
    &quot;analyzeQueryTextSentiment&quot;: True or False, # Configures whether sentiment analysis should be performed. If not provided, sentiment analysis is not performed.
    &quot;channel&quot;: &quot;A String&quot;, # The channel which this query is for. If specified, only the ResponseMessage associated with the channel will be returned. If no ResponseMessage is associated with the channel, it falls back to the ResponseMessage with unspecified channel. If unspecified, the ResponseMessage with unspecified channel will be returned.
    &quot;currentPage&quot;: &quot;A String&quot;, # The unique identifier of the page to override the current page in the session. Format: `projects//locations//agents//flows//pages/`. If `current_page` is specified, the previous state of the session will be ignored by Dialogflow, including the previous page and the previous session parameters. In most cases, current_page and parameters should be configured together to direct a session to a specific state.
    &quot;currentPlaybook&quot;: &quot;A String&quot;, # Optional. Start the session with the specified playbook. You can only specify the playbook at the beginning of the session. Otherwise, an error will be thrown. Format: `projects//locations//agents//playbooks/`.
    &quot;disableWebhook&quot;: True or False, # Whether to disable webhook calls for this request.
    &quot;endUserMetadata&quot;: { # Optional. Information about the end-user to improve the relevance and accuracy of generative answers. This will be interpreted and used by a language model, so, for good results, the data should be self-descriptive, and in a simple structure. Example: ```json { &quot;subscription plan&quot;: &quot;Business Premium Plus&quot;, &quot;devices owned&quot;: [ {&quot;model&quot;: &quot;Google Pixel 7&quot;}, {&quot;model&quot;: &quot;Google Pixel Tablet&quot;} ] } ```
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;flowVersions&quot;: [ # A list of flow versions to override for the request. Format: `projects//locations//agents//flows//versions/`. If version 1 of flow X is included in this list, the traffic of flow X will go through version 1 regardless of the version configuration in the environment. Each flow can have at most one version specified in this list.
      &quot;A String&quot;,
    ],
    &quot;geoLocation&quot;: { # An object that represents a latitude/longitude pair. This is expressed as a pair of doubles to represent degrees latitude and degrees longitude. Unless specified otherwise, this object must conform to the WGS84 standard. Values must be within normalized ranges. # The geo location of this conversational query.
      &quot;latitude&quot;: 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
      &quot;longitude&quot;: 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
    },
    &quot;llmModelSettings&quot;: { # Settings for LLM models. # Optional. Use the specified LLM model settings for processing the request.
      &quot;model&quot;: &quot;A String&quot;, # The selected LLM model.
      &quot;promptText&quot;: &quot;A String&quot;, # The custom prompt to use.
    },
    &quot;parameters&quot;: { # Additional parameters to be put into session parameters. To remove a parameter from the session, clients should explicitly set the parameter value to null. You can reference the session parameters in the agent with the following format: $session.params.parameter-id. Depending on your protocol or client library language, this is a map, associative array, symbol table, dictionary, or JSON object composed of a collection of (MapKey, MapValue) pairs: * MapKey type: string * MapKey value: parameter name * MapValue type: If parameter&#x27;s entity type is a composite entity then use map, otherwise, depending on the parameter value type, it could be one of string, number, boolean, null, list or map. * MapValue value: If parameter&#x27;s entity type is a composite entity then use map from composite entity property names to property values, otherwise, use parameter value.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;payload&quot;: { # This field can be used to pass custom data into the webhook associated with the agent. Arbitrary JSON objects are supported. Some integrations that query a Dialogflow agent may provide additional information in the payload. In particular, for the Dialogflow Phone Gateway integration, this field has the form: ``` { &quot;telephony&quot;: { &quot;caller_id&quot;: &quot;+18558363987&quot; } } ```
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;populateDataStoreConnectionSignals&quot;: True or False, # Optional. If set to true and data stores are involved in serving the request then DetectIntentResponse.query_result.data_store_connection_signals will be filled with data that can help evaluations.
    &quot;searchConfig&quot;: { # Search configuration for UCS search queries. # Optional. Search configuration for UCS search queries.
      &quot;boostSpecs&quot;: [ # Optional. Boosting configuration for the datastores.
        { # Boost specifications for data stores.
          &quot;dataStores&quot;: [ # Optional. Data Stores where the boosting configuration is applied. The full names of the referenced data stores. Formats: `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}` `projects/{project}/locations/{location}/dataStores/{data_store}
            &quot;A String&quot;,
          ],
          &quot;spec&quot;: [ # Optional. A list of boosting specifications.
            { # Boost specification to boost certain documents. A copy of google.cloud.discoveryengine.v1main.BoostSpec, field documentation is available at https://cloud.google.com/generative-ai-app-builder/docs/reference/rest/v1alpha/BoostSpec
              &quot;conditionBoostSpecs&quot;: [ # Optional. Condition boost specifications. If a document matches multiple conditions in the specifictions, boost scores from these specifications are all applied and combined in a non-linear way. Maximum number of specifications is 20.
                { # Boost applies to documents which match a condition.
                  &quot;boost&quot;: 3.14, # Optional. Strength of the condition boost, which should be in [-1, 1]. Negative boost means demotion. Default is 0.0. Setting to 1.0 gives the document a big promotion. However, it does not necessarily mean that the boosted document will be the top result at all times, nor that other documents will be excluded. Results could still be shown even when none of them matches the condition. And results that are significantly more relevant to the search query can still trump your heavily favored but irrelevant documents. Setting to -1.0 gives the document a big demotion. However, results that are deeply relevant might still be shown. The document will have an upstream battle to get a fairly high ranking, but it is not blocked out completely. Setting to 0.0 means no boost applied. The boosting condition is ignored.
                  &quot;boostControlSpec&quot;: { # Specification for custom ranking based on customer specified attribute value. It provides more controls for customized ranking than the simple (condition, boost) combination above. # Optional. Complex specification for custom ranking based on customer defined attribute value.
                    &quot;attributeType&quot;: &quot;A String&quot;, # Optional. The attribute type to be used to determine the boost amount. The attribute value can be derived from the field value of the specified field_name. In the case of numerical it is straightforward i.e. attribute_value = numerical_field_value. In the case of freshness however, attribute_value = (time.now() - datetime_field_value).
                    &quot;controlPoints&quot;: [ # Optional. The control points used to define the curve. The monotonic function (defined through the interpolation_type above) passes through the control points listed here.
                      { # The control points used to define the curve. The curve defined through these control points can only be monotonically increasing or decreasing(constant values are acceptable).
                        &quot;attributeValue&quot;: &quot;A String&quot;, # Optional. Can be one of: 1. The numerical field value. 2. The duration spec for freshness: The value must be formatted as an XSD `dayTimeDuration` value (a restricted subset of an ISO 8601 duration value). The pattern for this is: `nDnM]`.
                        &quot;boostAmount&quot;: 3.14, # Optional. The value between -1 to 1 by which to boost the score if the attribute_value evaluates to the value specified above.
                      },
                    ],
                    &quot;fieldName&quot;: &quot;A String&quot;, # Optional. The name of the field whose value will be used to determine the boost amount.
                    &quot;interpolationType&quot;: &quot;A String&quot;, # Optional. The interpolation type to be applied to connect the control points listed below.
                  },
                  &quot;condition&quot;: &quot;A String&quot;, # Optional. An expression which specifies a boost condition. The syntax and supported fields are the same as a filter expression. Examples: * To boost documents with document ID &quot;doc_1&quot; or &quot;doc_2&quot;, and color &quot;Red&quot; or &quot;Blue&quot;: * (id: ANY(&quot;doc_1&quot;, &quot;doc_2&quot;)) AND (color: ANY(&quot;Red&quot;,&quot;Blue&quot;))
                },
              ],
            },
          ],
        },
      ],
      &quot;filterSpecs&quot;: [ # Optional. Filter configuration for the datastores.
        { # Filter specifications for data stores.
          &quot;dataStores&quot;: [ # Optional. Data Stores where the boosting configuration is applied. The full names of the referenced data stores. Formats: `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}` `projects/{project}/locations/{location}/dataStores/{data_store}
            &quot;A String&quot;,
          ],
          &quot;filter&quot;: &quot;A String&quot;, # Optional. The filter expression to be applied. Expression syntax is documented at https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata#filter-expression-syntax
        },
      ],
    },
    &quot;sessionEntityTypes&quot;: [ # Additional session entity types to replace or extend developer entity types with. The entity synonyms apply to all languages and persist for the session of this query.
      { # Session entity types are referred to as **User** entity types and are entities that are built for an individual user such as favorites, preferences, playlists, and so on. You can redefine a session entity type at the session level to extend or replace a custom entity type at the user session level (we refer to the entity types defined at the agent level as &quot;custom entity types&quot;). Note: session entity types apply to all queries, regardless of the language. For more information about entity types, see the [Dialogflow documentation](https://cloud.google.com/dialogflow/docs/entities-overview).
        &quot;entities&quot;: [ # Required. The collection of entities to override or supplement the custom entity type.
          { # An **entity entry** for an associated entity type.
            &quot;synonyms&quot;: [ # Required. A collection of value synonyms. For example, if the entity type is *vegetable*, and `value` is *scallions*, a synonym could be *green onions*. For `KIND_LIST` entity types: * This collection must contain exactly one synonym equal to `value`.
              &quot;A String&quot;,
            ],
            &quot;value&quot;: &quot;A String&quot;, # Required. The primary value associated with this entity entry. For example, if the entity type is *vegetable*, the value could be *scallions*. For `KIND_MAP` entity types: * A canonical value to be used in place of synonyms. For `KIND_LIST` entity types: * A string that can contain references to other entity types (with or without aliases).
          },
        ],
        &quot;entityOverrideMode&quot;: &quot;A String&quot;, # Required. Indicates whether the additional data should override or supplement the custom entity type definition.
        &quot;name&quot;: &quot;A String&quot;, # Required. The unique identifier of the session entity type. Format: `projects//locations//agents//sessions//entityTypes/` or `projects//locations//agents//environments//sessions//entityTypes/`. If `Environment ID` is not specified, we assume default &#x27;draft&#x27; environment.
      },
    ],
    &quot;sessionTtl&quot;: &quot;A String&quot;, # Optional. Configure lifetime of the Dialogflow session. By default, a Dialogflow session remains active and its data is stored for 30 minutes after the last request is sent for the session. This value should be no longer than 1 day.
    &quot;timeZone&quot;: &quot;A String&quot;, # The time zone of this conversational query from the [time zone database](https://www.iana.org/time-zones), e.g., America/New_York, Europe/Paris. If not provided, the time zone specified in the agent is used.
    &quot;webhookHeaders&quot;: { # This field can be used to pass HTTP headers for a webhook call. These headers will be sent to webhook along with the headers that have been configured through Dialogflow web console. The headers defined within this field will overwrite the headers configured through Dialogflow console if there is a conflict. Header names are case-insensitive. Google&#x27;s specified headers are not allowed. Including: &quot;Host&quot;, &quot;Content-Length&quot;, &quot;Connection&quot;, &quot;From&quot;, &quot;User-Agent&quot;, &quot;Accept-Encoding&quot;, &quot;If-Modified-Since&quot;, &quot;If-None-Match&quot;, &quot;X-Forwarded-For&quot;, etc.
      &quot;a_key&quot;: &quot;A String&quot;,
    },
  },
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response of MatchIntent.
  &quot;currentPage&quot;: { # A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page). # The current Page. Some, not all fields are filled in this message, including but not limited to `name` and `display_name`.
    &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this page. The settings exposed at the lower level overrides the settings exposed at the higher level.
      &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
        &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
      },
      &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
        &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
        &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
        &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
        &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
      },
      &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
        &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
        &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
        &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
      },
      &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
        &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
        &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
          &quot;a_key&quot;: &quot;A String&quot;,
        },
        &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
        &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
      },
    },
    &quot;description&quot;: &quot;A String&quot;, # The description of the page. The maximum length is 500 characters.
    &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the page, unique within the flow.
    &quot;entryFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the session is entering the page.
      &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
        &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
          &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
        },
        &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
          &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
          &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
          &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
          &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
          &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
        },
        &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
          &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
          &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
          &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
        },
        &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
          &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
          &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
          &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
        },
      },
      &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
        { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
          &quot;cases&quot;: [ # A list of cascading if-else conditions.
            { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
              &quot;caseContent&quot;: [ # A list of case content.
                { # The list of messages or conditional cases to activate for this case.
                  &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                  &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                    &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                    },
                    &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                    },
                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                        { # Represents one segment of audio.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                        },
                      ],
                    },
                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                    },
                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                    },
                    &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                      &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                    },
                    &quot;text&quot;: { # The text response message. # Returns a text response.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                        &quot;A String&quot;,
                      ],
                    },
                    &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                      &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                      &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                    },
                  },
                },
              ],
              &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
            },
          ],
        },
      ],
      &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
      &quot;messages&quot;: [ # The list of rich message responses to present to the user.
        { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
          },
          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
          },
          &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
          },
          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
          },
          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
            &quot;segments&quot;: [ # Segments this audio response is composed of.
              { # Represents one segment of audio.
                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
              },
            ],
          },
          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
          },
          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
          },
          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
          },
          &quot;text&quot;: { # The text response message. # Returns a text response.
            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
            &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
              &quot;A String&quot;,
            ],
          },
          &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
            &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
            &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
          },
        },
      ],
      &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
      &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
        { # Setting a parameter value.
          &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
          &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
        },
      ],
      &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
      &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
    },
    &quot;eventHandlers&quot;: [ # Handlers associated with the page to handle events such as webhook errors, no match or no input.
      { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
        &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
        &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
        &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
        &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
        &quot;targetPlaybook&quot;: &quot;A String&quot;, # The target playbook to transition to. Format: `projects//locations//agents//playbooks/`.
        &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
          &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
            &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
              &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
            },
            &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
              &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
              &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
              &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
              &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
              &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
            },
            &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
              &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
              &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
              &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
            },
            &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
              &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
              &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
              &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
            },
          },
          &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
            { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
              &quot;cases&quot;: [ # A list of cascading if-else conditions.
                { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                  &quot;caseContent&quot;: [ # A list of case content.
                    { # The list of messages or conditional cases to activate for this case.
                      &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                      &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                        },
                        &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                        },
                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                            { # Represents one segment of audio.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                            },
                          ],
                        },
                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                        },
                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                        },
                        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                        },
                        &quot;text&quot;: { # The text response message. # Returns a text response.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                            &quot;A String&quot;,
                          ],
                        },
                        &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                          &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                          &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                        },
                      },
                    },
                  ],
                  &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                },
              ],
            },
          ],
          &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
          &quot;messages&quot;: [ # The list of rich message responses to present to the user.
            { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
              },
              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
              },
              &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
              },
              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
              },
              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                &quot;segments&quot;: [ # Segments this audio response is composed of.
                  { # Represents one segment of audio.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                  },
                ],
              },
              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
              },
              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
              },
              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
              },
              &quot;text&quot;: { # The text response message. # Returns a text response.
                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                  &quot;A String&quot;,
                ],
              },
              &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
              },
            },
          ],
          &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
          &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
            { # Setting a parameter value.
              &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
              &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
            },
          ],
          &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
          &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
        },
      },
    ],
    &quot;form&quot;: { # A form is a data model that groups related parameters that can be collected from the user. The process in which the agent prompts the user and collects parameter values from the user is called form filling. A form can be added to a page. When form filling is done, the filled parameters will be written to the session. # The form associated with the page, used for collecting parameters relevant to the page.
      &quot;parameters&quot;: [ # Parameters to collect from the user.
        { # Represents a form parameter.
          &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this parameter. The settings exposed at the lower level overrides the settings exposed at the higher level.
            &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
              &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
            },
            &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
              &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
              &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
              &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
              &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
              &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
            },
            &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
              &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
              &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
              &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
            },
            &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
              &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
              &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
              &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
            },
          },
          &quot;defaultValue&quot;: &quot;&quot;, # The default value of an optional parameter. If the parameter is required, the default value will be ignored.
          &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the parameter, unique within the form.
          &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
          &quot;fillBehavior&quot;: { # Configuration for how the filling of a parameter should be handled. # Required. Defines fill behavior for the parameter.
            &quot;initialPromptFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # Required. The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
              &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
                &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
                  &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
                },
                &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
                  &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
                  &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
                  &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
                  &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
                  &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
                },
                &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
                  &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
                  &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
                  &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
                },
                &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
                  &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
                  &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                    &quot;a_key&quot;: &quot;A String&quot;,
                  },
                  &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
                  &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
                },
              },
              &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                  &quot;cases&quot;: [ # A list of cascading if-else conditions.
                    { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                      &quot;caseContent&quot;: [ # A list of case content.
                        { # The list of messages or conditional cases to activate for this case.
                          &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                          &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                            },
                            &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                            },
                            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                              &quot;segments&quot;: [ # Segments this audio response is composed of.
                                { # Represents one segment of audio.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                },
                              ],
                            },
                            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                            },
                            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                            },
                            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                            },
                            &quot;text&quot;: { # The text response message. # Returns a text response.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                                &quot;A String&quot;,
                              ],
                            },
                            &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                              &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                              &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                            },
                          },
                        },
                      ],
                      &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                    },
                  ],
                },
              ],
              &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
              &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                  &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                  &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                    &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                  },
                  &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                  },
                  &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                  },
                  &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                    &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                  },
                  &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                    &quot;segments&quot;: [ # Segments this audio response is composed of.
                      { # Represents one segment of audio.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                        &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                        &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                      },
                    ],
                  },
                  &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                    &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                  },
                  &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                  &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                  },
                  &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                    &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                  },
                  &quot;text&quot;: { # The text response message. # Returns a text response.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                      &quot;A String&quot;,
                    ],
                  },
                  &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                    &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                    &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                  },
                },
              ],
              &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
              &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                { # Setting a parameter value.
                  &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                  &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                },
              ],
              &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
              &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
            },
            &quot;repromptEventHandlers&quot;: [ # The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are: * `sys.no-match-`, where N can be from 1 to 6 * `sys.no-match-default` * `sys.no-input-`, where N can be from 1 to 6 * `sys.no-input-default` * `sys.invalid-parameter` `initial_prompt_fulfillment` provides the first prompt for the parameter. If the user&#x27;s response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the `sys.no-match-1`/`sys.no-input-1` handler (if defined) will be called to provide a prompt. The `sys.no-match-2`/`sys.no-input-2` handler (if defined) will respond to the next no-match/no-input event, and so on. A `sys.no-match-default` or `sys.no-input-default` handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed. A `sys.invalid-parameter` handler can be defined to handle the case where the parameter values have been `invalidated` by webhook. For example, if the user&#x27;s response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the `sys.invalid-parameter` handler (if defined) will be called to provide a prompt. If the event handler for the corresponding event can&#x27;t be found on the parameter, `initial_prompt_fulfillment` will be re-prompted.
              { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                &quot;targetPlaybook&quot;: &quot;A String&quot;, # The target playbook to transition to. Format: `projects//locations//agents//playbooks/`.
                &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                  &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
                    &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
                      &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
                    },
                    &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
                      &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
                      &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
                      &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
                      &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
                      &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
                    },
                    &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
                      &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
                      &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
                      &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
                    },
                    &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
                      &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
                      &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                        &quot;a_key&quot;: &quot;A String&quot;,
                      },
                      &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
                      &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
                    },
                  },
                  &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                    { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                      &quot;cases&quot;: [ # A list of cascading if-else conditions.
                        { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                          &quot;caseContent&quot;: [ # A list of case content.
                            { # The list of messages or conditional cases to activate for this case.
                              &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                              &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                },
                                &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                                },
                                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                                    { # Represents one segment of audio.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                    },
                                  ],
                                },
                                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                },
                                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                },
                                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                },
                                &quot;text&quot;: { # The text response message. # Returns a text response.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                                    &quot;A String&quot;,
                                  ],
                                },
                                &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                                  &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                                  &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                  &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                                },
                              },
                            },
                          ],
                          &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                        },
                      ],
                    },
                  ],
                  &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
                  &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                    { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                          &quot;A String&quot;,
                        ],
                      },
                      &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                        &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                        &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                        &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                      },
                    },
                  ],
                  &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                  &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                    { # Setting a parameter value.
                      &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                      &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                    },
                  ],
                  &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                  &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                },
              },
            ],
          },
          &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
          &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
          &quot;required&quot;: True or False, # Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them. Required parameters must be filled before form filling concludes.
        },
      ],
    },
    &quot;knowledgeConnectorSettings&quot;: { # The Knowledge Connector settings for this page or flow. This includes information such as the attached Knowledge Bases, and the way to execute fulfillment. # Optional. Knowledge connector configuration.
      &quot;dataStoreConnections&quot;: [ # Optional. List of related data store connections.
        { # A data store connection. It represents a data store in Discovery Engine and the type of the contents it contains.
          &quot;dataStore&quot;: &quot;A String&quot;, # The full name of the referenced data store. Formats: `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}` `projects/{project}/locations/{location}/dataStores/{data_store}`
          &quot;dataStoreType&quot;: &quot;A String&quot;, # The type of the connected data store.
        },
      ],
      &quot;enabled&quot;: True or False, # Whether Knowledge Connector is enabled or not.
      &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
      &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
      &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to be triggered. When the answers from the Knowledge Connector are selected by Dialogflow, you can utitlize the request scoped parameter `$request.knowledge.answers` (contains up to the 5 highest confidence answers) and `$request.knowledge.questions` (contains the corresponding questions) to construct the fulfillment.
        &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
          &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
            &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
          },
          &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
            &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
            &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
            &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
            &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
            &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
          },
          &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
            &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
            &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
            &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
          },
          &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
            &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
            &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
              &quot;a_key&quot;: &quot;A String&quot;,
            },
            &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
            &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
          },
        },
        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
            &quot;cases&quot;: [ # A list of cascading if-else conditions.
              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                &quot;caseContent&quot;: [ # A list of case content.
                  { # The list of messages or conditional cases to activate for this case.
                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                          &quot;A String&quot;,
                        ],
                      },
                      &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                        &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                        &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                        &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                      },
                    },
                  },
                ],
                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
              },
            ],
          },
        ],
        &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
            },
            &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
            },
            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
              &quot;segments&quot;: [ # Segments this audio response is composed of.
                { # Represents one segment of audio.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                },
              ],
            },
            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
            },
            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
            },
            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
            },
            &quot;text&quot;: { # The text response message. # Returns a text response.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                &quot;A String&quot;,
              ],
            },
            &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
              &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
              &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
            },
          },
        ],
        &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
          { # Setting a parameter value.
            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
          },
        ],
        &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
      },
    },
    &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the page. Required for the Pages.UpdatePage method. Pages.CreatePage populates the name automatically. Format: `projects//locations//agents//flows//pages/`.
    &quot;transitionRouteGroups&quot;: [ # Ordered list of `TransitionRouteGroups` added to the page. Transition route groups must be unique within a page. If the page links both flow-level transition route groups and agent-level transition route groups, the flow-level ones will have higher priority and will be put before the agent-level ones. * If multiple transition routes within a page scope refer to the same intent, then the precedence order is: page&#x27;s transition route -&gt; page&#x27;s transition route group -&gt; flow&#x27;s transition routes. * If multiple transition route groups within a page contain the same intent, then the first group in the ordered list takes precedence. Format:`projects//locations//agents//flows//transitionRouteGroups/` or `projects//locations//agents//transitionRouteGroups/` for agent-level groups.
      &quot;A String&quot;,
    ],
    &quot;transitionRoutes&quot;: [ # A list of transitions for the transition rules of this page. They route the conversation to another page in the same flow, or another flow. When we are in a certain page, the TransitionRoutes are evalauted in the following order: * TransitionRoutes defined in the page with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in flow with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in the page with only condition specified. * TransitionRoutes defined in the transition route groups with only condition specified.
      { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
        &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
        &quot;description&quot;: &quot;A String&quot;, # Optional. The description of the transition route. The maximum length is 500 characters.
        &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
        &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
        &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
        &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
        &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
          &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
            &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
              &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
            },
            &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
              &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
              &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
              &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
              &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
              &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
            },
            &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
              &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
              &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
              &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
            },
            &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
              &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
              &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
              &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
            },
          },
          &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
            { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
              &quot;cases&quot;: [ # A list of cascading if-else conditions.
                { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                  &quot;caseContent&quot;: [ # A list of case content.
                    { # The list of messages or conditional cases to activate for this case.
                      &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                      &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                        },
                        &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                        },
                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                            { # Represents one segment of audio.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                            },
                          ],
                        },
                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                        },
                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                        },
                        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                        },
                        &quot;text&quot;: { # The text response message. # Returns a text response.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                            &quot;A String&quot;,
                          ],
                        },
                        &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                          &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                          &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                        },
                      },
                    },
                  ],
                  &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                },
              ],
            },
          ],
          &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
          &quot;messages&quot;: [ # The list of rich message responses to present to the user.
            { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
              },
              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
              },
              &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
              },
              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
              },
              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                &quot;segments&quot;: [ # Segments this audio response is composed of.
                  { # Represents one segment of audio.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                  },
                ],
              },
              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
              },
              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
              },
              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
              },
              &quot;text&quot;: { # The text response message. # Returns a text response.
                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                  &quot;A String&quot;,
                ],
              },
              &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
              },
            },
          ],
          &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
          &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
            { # Setting a parameter value.
              &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
              &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
            },
          ],
          &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
          &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
        },
      },
    ],
  },
  &quot;matches&quot;: [ # Match results, if more than one, ordered descendingly by the confidence we have that the particular intent matches the query.
    { # Represents one match result of MatchIntent.
      &quot;confidence&quot;: 3.14, # The confidence of this match. Values range from 0.0 (completely uncertain) to 1.0 (completely certain). This value is for informational purpose only and is only used to help match the best intent within the classification threshold. This value may change for the same end-user expression at any time due to a model retraining or change in implementation.
      &quot;event&quot;: &quot;A String&quot;, # The event that matched the query. Filled for `EVENT`, `NO_MATCH` and `NO_INPUT` match types.
      &quot;intent&quot;: { # An intent represents a user&#x27;s intent to interact with a conversational agent. You can provide information for the Dialogflow API to use to match user input to an intent by adding training phrases (i.e., examples of user input) to your intent. # The Intent that matched the query. Some, not all fields are filled in this message, including but not limited to: `name` and `display_name`. Only filled for `INTENT` match type.
        &quot;description&quot;: &quot;A String&quot;, # Human readable description for better understanding an intent like its scope, content, result etc. Maximum character limit: 140 characters.
        &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the intent, unique within the agent.
        &quot;isFallback&quot;: True or False, # Indicates whether this is a fallback intent. Currently only default fallback intent is allowed in the agent, which is added upon agent creation. Adding training phrases to fallback intent is useful in the case of requests that are mistakenly matched, since training phrases assigned to fallback intents act as negative examples that triggers no-match event.
        &quot;labels&quot;: { # The key/value metadata to label an intent. Labels can contain lowercase letters, digits and the symbols &#x27;-&#x27; and &#x27;_&#x27;. International characters are allowed, including letters from unicase alphabets. Keys must start with a letter. Keys and values can be no longer than 63 characters and no more than 128 bytes. Prefix &quot;sys-&quot; is reserved for Dialogflow defined labels. Currently allowed Dialogflow defined labels include: * sys-head * sys-contextual The above labels do not require value. &quot;sys-head&quot; means the intent is a head intent. &quot;sys-contextual&quot; means the intent is a contextual intent.
          &quot;a_key&quot;: &quot;A String&quot;,
        },
        &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the intent. Required for the Intents.UpdateIntent method. Intents.CreateIntent populates the name automatically. Format: `projects//locations//agents//intents/`.
        &quot;parameters&quot;: [ # The collection of parameters associated with the intent.
          { # Represents an intent parameter.
            &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
            &quot;id&quot;: &quot;A String&quot;, # Required. The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
            &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
            &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
          },
        ],
        &quot;priority&quot;: 42, # The priority of this intent. Higher numbers represent higher priorities. - If the supplied value is unspecified or 0, the service translates the value to 500,000, which corresponds to the `Normal` priority in the console. - If the supplied value is negative, the intent is ignored in runtime detect intent requests.
        &quot;trainingPhrases&quot;: [ # The collection of training phrases the agent is trained on to identify the intent.
          { # Represents an example that the agent is trained on to identify the intent.
            &quot;id&quot;: &quot;A String&quot;, # Output only. The unique identifier of the training phrase.
            &quot;parts&quot;: [ # Required. The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase. Note: The API does not automatically annotate training phrases like the Dialogflow Console does. Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated. If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set. If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways: - `Part.text` is set to a part of the phrase that has no parameters. - `Part.text` is set to a part of the phrase that you want to annotate, and the `parameter_id` field is set.
              { # Represents a part of a training phrase.
                &quot;parameterId&quot;: &quot;A String&quot;, # The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
                &quot;text&quot;: &quot;A String&quot;, # Required. The text for this part.
              },
            ],
            &quot;repeatCount&quot;: 42, # Indicates how many times this example was added to the intent.
          },
        ],
      },
      &quot;matchType&quot;: &quot;A String&quot;, # Type of this Match.
      &quot;parameters&quot;: { # The collection of parameters extracted from the query. Depending on your protocol or client library language, this is a map, associative array, symbol table, dictionary, or JSON object composed of a collection of (MapKey, MapValue) pairs: * MapKey type: string * MapKey value: parameter name * MapValue type: If parameter&#x27;s entity type is a composite entity then use map, otherwise, depending on the parameter value type, it could be one of string, number, boolean, null, list or map. * MapValue value: If parameter&#x27;s entity type is a composite entity then use map from composite entity property names to property values, otherwise, use parameter value.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;resolvedInput&quot;: &quot;A String&quot;, # Final text input which was matched during MatchIntent. This value can be different from original input sent in request because of spelling correction or other processing.
    },
  ],
  &quot;text&quot;: &quot;A String&quot;, # If natural language text was provided as input, this field will contain a copy of the text.
  &quot;transcript&quot;: &quot;A String&quot;, # If natural language speech audio was provided as input, this field will contain the transcript for the audio.
  &quot;triggerEvent&quot;: &quot;A String&quot;, # If an event was provided as input, this field will contain a copy of the event name.
  &quot;triggerIntent&quot;: &quot;A String&quot;, # If an intent was provided as input, this field will contain a copy of the intent identifier. Format: `projects//locations//agents//intents/`.
}</pre>
</div>

<div class="method">
    <code class="details" id="serverStreamingDetectIntent">serverStreamingDetectIntent(session, body=None, x__xgafv=None)</code>
  <pre>Processes a natural language query and returns structured, actionable data as a result through server-side streaming. Server-side streaming allows Dialogflow to send [partial responses](https://cloud.google.com/dialogflow/cx/docs/concept/fulfillment#partial-response) earlier in a single request.

Args:
  session: string, Required. The name of the session this query is sent to. Format: `projects//locations//agents//sessions/` or `projects//locations//agents//environments//sessions/`. If `Environment ID` is not specified, we assume default &#x27;draft&#x27; environment. It&#x27;s up to the API caller to choose an appropriate `Session ID`. It can be a random number or some type of session identifiers (preferably hashed). The length of the `Session ID` must not exceed 36 characters. For more information, see the [sessions guide](https://cloud.google.com/dialogflow/cx/docs/concept/session). Note: Always use agent versions for production traffic. See [Versions and environments](https://cloud.google.com/dialogflow/cx/docs/concept/version). (required)
  body: object, The request body.
    The object takes the form of:

{ # The request to detect user&#x27;s intent.
  &quot;outputAudioConfig&quot;: { # Instructs the speech synthesizer how to generate the output audio content. # Instructs the speech synthesizer how to generate the output audio.
    &quot;audioEncoding&quot;: &quot;A String&quot;, # Required. Audio encoding of the synthesized audio content.
    &quot;sampleRateHertz&quot;: 42, # Optional. The synthesis sample rate (in hertz) for this audio. If not provided, then the synthesizer will use the default sample rate based on the audio encoding. If this is different from the voice&#x27;s natural sample rate, then the synthesizer will honor this request by converting to the desired sample rate (which might result in worse audio quality).
    &quot;synthesizeSpeechConfig&quot;: { # Configuration of how speech should be synthesized. # Optional. Configuration of how speech should be synthesized. If not specified, Agent.text_to_speech_settings is applied.
      &quot;effectsProfileId&quot;: [ # Optional. An identifier which selects &#x27;audio effects&#x27; profiles that are applied on (post synthesized) text to speech. Effects are applied on top of each other in the order they are given.
        &quot;A String&quot;,
      ],
      &quot;pitch&quot;: 3.14, # Optional. Speaking pitch, in the range [-20.0, 20.0]. 20 means increase 20 semitones from the original pitch. -20 means decrease 20 semitones from the original pitch.
      &quot;speakingRate&quot;: 3.14, # Optional. Speaking rate/speed, in the range [0.25, 4.0]. 1.0 is the normal native speed supported by the specific voice. 2.0 is twice as fast, and 0.5 is half as fast. If unset(0.0), defaults to the native 1.0 speed. Any other values &lt; 0.25 or &gt; 4.0 will return an error.
      &quot;voice&quot;: { # Description of which voice to use for speech synthesis. # Optional. The desired voice of the synthesized audio.
        &quot;name&quot;: &quot;A String&quot;, # Optional. The name of the voice. If not set, the service will choose a voice based on the other parameters such as language_code and ssml_gender. For the list of available voices, please refer to [Supported voices and languages](https://cloud.google.com/text-to-speech/docs/voices).
        &quot;ssmlGender&quot;: &quot;A String&quot;, # Optional. The preferred gender of the voice. If not set, the service will choose a voice based on the other parameters such as language_code and name. Note that this is only a preference, not requirement. If a voice of the appropriate gender is not available, the synthesizer should substitute a voice with a different gender rather than failing the request.
      },
      &quot;volumeGainDb&quot;: 3.14, # Optional. Volume gain (in dB) of the normal native volume supported by the specific voice, in the range [-96.0, 16.0]. If unset, or set to a value of 0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB) will play at approximately half the amplitude of the normal native signal amplitude. A value of +6.0 (dB) will play at approximately twice the amplitude of the normal native signal amplitude. We strongly recommend not to exceed +10 (dB) as there&#x27;s usually no effective increase in loudness for any value greater than that.
    },
  },
  &quot;queryInput&quot;: { # Represents the query input. It can contain one of: 1. A conversational query in the form of text. 2. An intent query that specifies which intent to trigger. 3. Natural language speech audio to be processed. 4. An event to be triggered. 5. DTMF digits to invoke an intent and fill in parameter value. 6. The results of a tool executed by the client. # Required. The input specification.
    &quot;audio&quot;: { # Represents the natural speech audio to be processed. # The natural language speech audio to be processed.
      &quot;audio&quot;: &quot;A String&quot;, # The natural language speech audio to be processed. A single request can contain up to 2 minutes of speech audio data. The transcribed text cannot contain more than 256 bytes. For non-streaming audio detect intent, both `config` and `audio` must be provided. For streaming audio detect intent, `config` must be provided in the first request and `audio` must be provided in all following requests.
      &quot;config&quot;: { # Instructs the speech recognizer on how to process the audio content. # Required. Instructs the speech recognizer how to process the speech audio.
        &quot;audioEncoding&quot;: &quot;A String&quot;, # Required. Audio encoding of the audio content to process.
        &quot;bargeInConfig&quot;: { # Configuration of the barge-in behavior. Barge-in instructs the API to return a detected utterance at a proper time while the client is playing back the response audio from a previous request. When the client sees the utterance, it should stop the playback and immediately get ready for receiving the responses for the current request. The barge-in handling requires the client to start streaming audio input as soon as it starts playing back the audio from the previous response. The playback is modeled into two phases: * No barge-in phase: which goes first and during which speech detection should not be carried out. * Barge-in phase: which follows the no barge-in phase and during which the API starts speech detection and may inform the client that an utterance has been detected. Note that no-speech event is not expected in this phase. The client provides this configuration in terms of the durations of those two phases. The durations are measured in terms of the audio length from the the start of the input audio. No-speech event is a response with END_OF_UTTERANCE without any transcript following up. # Configuration of barge-in behavior during the streaming of input audio.
          &quot;noBargeInDuration&quot;: &quot;A String&quot;, # Duration that is not eligible for barge-in at the beginning of the input audio.
          &quot;totalDuration&quot;: &quot;A String&quot;, # Total duration for the playback at the beginning of the input audio.
        },
        &quot;enableWordInfo&quot;: True or False, # Optional. If `true`, Dialogflow returns SpeechWordInfo in StreamingRecognitionResult with information about the recognized speech words, e.g. start and end time offsets. If false or unspecified, Speech doesn&#x27;t return any word-level information.
        &quot;model&quot;: &quot;A String&quot;, # Optional. Which Speech model to select for the given request. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
        &quot;modelVariant&quot;: &quot;A String&quot;, # Optional. Which variant of the Speech model to use.
        &quot;optOutConformerModelMigration&quot;: True or False, # If `true`, the request will opt out for STT conformer model migration. This field will be deprecated once force migration takes place in June 2024. Please refer to [Dialogflow CX Speech model migration](https://cloud.google.com/dialogflow/cx/docs/concept/speech-model-migration).
        &quot;phraseHints&quot;: [ # Optional. A list of strings containing words and phrases that the speech recognizer should recognize with higher likelihood. See [the Cloud Speech documentation](https://cloud.google.com/speech-to-text/docs/basics#phrase-hints) for more details.
          &quot;A String&quot;,
        ],
        &quot;sampleRateHertz&quot;: 42, # Sample rate (in Hertz) of the audio content sent in the query. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics) for more details.
        &quot;singleUtterance&quot;: True or False, # Optional. If `false` (default), recognition does not cease until the client closes the stream. If `true`, the recognizer will detect a single spoken utterance in input audio. Recognition ceases when it detects the audio&#x27;s voice has stopped or paused. In this case, once a detected intent is received, the client should close the stream and start a new request with a new stream as needed. Note: This setting is relevant only for streaming methods.
      },
    },
    &quot;dtmf&quot;: { # Represents the input for dtmf event. # The DTMF event to be handled.
      &quot;digits&quot;: &quot;A String&quot;, # The dtmf digits.
      &quot;finishDigit&quot;: &quot;A String&quot;, # The finish digit (if any).
    },
    &quot;event&quot;: { # Represents the event to trigger. # The event to be triggered.
      &quot;event&quot;: &quot;A String&quot;, # Name of the event.
    },
    &quot;intent&quot;: { # Represents the intent to trigger programmatically rather than as a result of natural language processing. # The intent to be triggered.
      &quot;intent&quot;: &quot;A String&quot;, # Required. The unique identifier of the intent. Format: `projects//locations//agents//intents/`.
    },
    &quot;languageCode&quot;: &quot;A String&quot;, # Required. The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes. Note that queries in the same session do not necessarily need to specify the same language.
    &quot;text&quot;: { # Represents the natural language text to be processed. # The natural language text to be processed.
      &quot;text&quot;: &quot;A String&quot;, # Required. The UTF-8 encoded natural language text to be processed.
    },
    &quot;toolCallResult&quot;: { # The result of calling a tool&#x27;s action that has been executed by the client. # The results of a tool executed by the client.
      &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
      &quot;error&quot;: { # An error produced by the tool call. # The tool call&#x27;s error.
        &quot;message&quot;: &quot;A String&quot;, # Optional. The error message of the function.
      },
      &quot;outputParameters&quot;: { # The tool call&#x27;s output parameters.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
    },
  },
  &quot;queryParams&quot;: { # Represents the parameters of a conversational query. # The parameters of this query.
    &quot;analyzeQueryTextSentiment&quot;: True or False, # Configures whether sentiment analysis should be performed. If not provided, sentiment analysis is not performed.
    &quot;channel&quot;: &quot;A String&quot;, # The channel which this query is for. If specified, only the ResponseMessage associated with the channel will be returned. If no ResponseMessage is associated with the channel, it falls back to the ResponseMessage with unspecified channel. If unspecified, the ResponseMessage with unspecified channel will be returned.
    &quot;currentPage&quot;: &quot;A String&quot;, # The unique identifier of the page to override the current page in the session. Format: `projects//locations//agents//flows//pages/`. If `current_page` is specified, the previous state of the session will be ignored by Dialogflow, including the previous page and the previous session parameters. In most cases, current_page and parameters should be configured together to direct a session to a specific state.
    &quot;currentPlaybook&quot;: &quot;A String&quot;, # Optional. Start the session with the specified playbook. You can only specify the playbook at the beginning of the session. Otherwise, an error will be thrown. Format: `projects//locations//agents//playbooks/`.
    &quot;disableWebhook&quot;: True or False, # Whether to disable webhook calls for this request.
    &quot;endUserMetadata&quot;: { # Optional. Information about the end-user to improve the relevance and accuracy of generative answers. This will be interpreted and used by a language model, so, for good results, the data should be self-descriptive, and in a simple structure. Example: ```json { &quot;subscription plan&quot;: &quot;Business Premium Plus&quot;, &quot;devices owned&quot;: [ {&quot;model&quot;: &quot;Google Pixel 7&quot;}, {&quot;model&quot;: &quot;Google Pixel Tablet&quot;} ] } ```
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;flowVersions&quot;: [ # A list of flow versions to override for the request. Format: `projects//locations//agents//flows//versions/`. If version 1 of flow X is included in this list, the traffic of flow X will go through version 1 regardless of the version configuration in the environment. Each flow can have at most one version specified in this list.
      &quot;A String&quot;,
    ],
    &quot;geoLocation&quot;: { # An object that represents a latitude/longitude pair. This is expressed as a pair of doubles to represent degrees latitude and degrees longitude. Unless specified otherwise, this object must conform to the WGS84 standard. Values must be within normalized ranges. # The geo location of this conversational query.
      &quot;latitude&quot;: 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
      &quot;longitude&quot;: 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
    },
    &quot;llmModelSettings&quot;: { # Settings for LLM models. # Optional. Use the specified LLM model settings for processing the request.
      &quot;model&quot;: &quot;A String&quot;, # The selected LLM model.
      &quot;promptText&quot;: &quot;A String&quot;, # The custom prompt to use.
    },
    &quot;parameters&quot;: { # Additional parameters to be put into session parameters. To remove a parameter from the session, clients should explicitly set the parameter value to null. You can reference the session parameters in the agent with the following format: $session.params.parameter-id. Depending on your protocol or client library language, this is a map, associative array, symbol table, dictionary, or JSON object composed of a collection of (MapKey, MapValue) pairs: * MapKey type: string * MapKey value: parameter name * MapValue type: If parameter&#x27;s entity type is a composite entity then use map, otherwise, depending on the parameter value type, it could be one of string, number, boolean, null, list or map. * MapValue value: If parameter&#x27;s entity type is a composite entity then use map from composite entity property names to property values, otherwise, use parameter value.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;payload&quot;: { # This field can be used to pass custom data into the webhook associated with the agent. Arbitrary JSON objects are supported. Some integrations that query a Dialogflow agent may provide additional information in the payload. In particular, for the Dialogflow Phone Gateway integration, this field has the form: ``` { &quot;telephony&quot;: { &quot;caller_id&quot;: &quot;+18558363987&quot; } } ```
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;populateDataStoreConnectionSignals&quot;: True or False, # Optional. If set to true and data stores are involved in serving the request then DetectIntentResponse.query_result.data_store_connection_signals will be filled with data that can help evaluations.
    &quot;searchConfig&quot;: { # Search configuration for UCS search queries. # Optional. Search configuration for UCS search queries.
      &quot;boostSpecs&quot;: [ # Optional. Boosting configuration for the datastores.
        { # Boost specifications for data stores.
          &quot;dataStores&quot;: [ # Optional. Data Stores where the boosting configuration is applied. The full names of the referenced data stores. Formats: `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}` `projects/{project}/locations/{location}/dataStores/{data_store}
            &quot;A String&quot;,
          ],
          &quot;spec&quot;: [ # Optional. A list of boosting specifications.
            { # Boost specification to boost certain documents. A copy of google.cloud.discoveryengine.v1main.BoostSpec, field documentation is available at https://cloud.google.com/generative-ai-app-builder/docs/reference/rest/v1alpha/BoostSpec
              &quot;conditionBoostSpecs&quot;: [ # Optional. Condition boost specifications. If a document matches multiple conditions in the specifictions, boost scores from these specifications are all applied and combined in a non-linear way. Maximum number of specifications is 20.
                { # Boost applies to documents which match a condition.
                  &quot;boost&quot;: 3.14, # Optional. Strength of the condition boost, which should be in [-1, 1]. Negative boost means demotion. Default is 0.0. Setting to 1.0 gives the document a big promotion. However, it does not necessarily mean that the boosted document will be the top result at all times, nor that other documents will be excluded. Results could still be shown even when none of them matches the condition. And results that are significantly more relevant to the search query can still trump your heavily favored but irrelevant documents. Setting to -1.0 gives the document a big demotion. However, results that are deeply relevant might still be shown. The document will have an upstream battle to get a fairly high ranking, but it is not blocked out completely. Setting to 0.0 means no boost applied. The boosting condition is ignored.
                  &quot;boostControlSpec&quot;: { # Specification for custom ranking based on customer specified attribute value. It provides more controls for customized ranking than the simple (condition, boost) combination above. # Optional. Complex specification for custom ranking based on customer defined attribute value.
                    &quot;attributeType&quot;: &quot;A String&quot;, # Optional. The attribute type to be used to determine the boost amount. The attribute value can be derived from the field value of the specified field_name. In the case of numerical it is straightforward i.e. attribute_value = numerical_field_value. In the case of freshness however, attribute_value = (time.now() - datetime_field_value).
                    &quot;controlPoints&quot;: [ # Optional. The control points used to define the curve. The monotonic function (defined through the interpolation_type above) passes through the control points listed here.
                      { # The control points used to define the curve. The curve defined through these control points can only be monotonically increasing or decreasing(constant values are acceptable).
                        &quot;attributeValue&quot;: &quot;A String&quot;, # Optional. Can be one of: 1. The numerical field value. 2. The duration spec for freshness: The value must be formatted as an XSD `dayTimeDuration` value (a restricted subset of an ISO 8601 duration value). The pattern for this is: `nDnM]`.
                        &quot;boostAmount&quot;: 3.14, # Optional. The value between -1 to 1 by which to boost the score if the attribute_value evaluates to the value specified above.
                      },
                    ],
                    &quot;fieldName&quot;: &quot;A String&quot;, # Optional. The name of the field whose value will be used to determine the boost amount.
                    &quot;interpolationType&quot;: &quot;A String&quot;, # Optional. The interpolation type to be applied to connect the control points listed below.
                  },
                  &quot;condition&quot;: &quot;A String&quot;, # Optional. An expression which specifies a boost condition. The syntax and supported fields are the same as a filter expression. Examples: * To boost documents with document ID &quot;doc_1&quot; or &quot;doc_2&quot;, and color &quot;Red&quot; or &quot;Blue&quot;: * (id: ANY(&quot;doc_1&quot;, &quot;doc_2&quot;)) AND (color: ANY(&quot;Red&quot;,&quot;Blue&quot;))
                },
              ],
            },
          ],
        },
      ],
      &quot;filterSpecs&quot;: [ # Optional. Filter configuration for the datastores.
        { # Filter specifications for data stores.
          &quot;dataStores&quot;: [ # Optional. Data Stores where the boosting configuration is applied. The full names of the referenced data stores. Formats: `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}` `projects/{project}/locations/{location}/dataStores/{data_store}
            &quot;A String&quot;,
          ],
          &quot;filter&quot;: &quot;A String&quot;, # Optional. The filter expression to be applied. Expression syntax is documented at https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata#filter-expression-syntax
        },
      ],
    },
    &quot;sessionEntityTypes&quot;: [ # Additional session entity types to replace or extend developer entity types with. The entity synonyms apply to all languages and persist for the session of this query.
      { # Session entity types are referred to as **User** entity types and are entities that are built for an individual user such as favorites, preferences, playlists, and so on. You can redefine a session entity type at the session level to extend or replace a custom entity type at the user session level (we refer to the entity types defined at the agent level as &quot;custom entity types&quot;). Note: session entity types apply to all queries, regardless of the language. For more information about entity types, see the [Dialogflow documentation](https://cloud.google.com/dialogflow/docs/entities-overview).
        &quot;entities&quot;: [ # Required. The collection of entities to override or supplement the custom entity type.
          { # An **entity entry** for an associated entity type.
            &quot;synonyms&quot;: [ # Required. A collection of value synonyms. For example, if the entity type is *vegetable*, and `value` is *scallions*, a synonym could be *green onions*. For `KIND_LIST` entity types: * This collection must contain exactly one synonym equal to `value`.
              &quot;A String&quot;,
            ],
            &quot;value&quot;: &quot;A String&quot;, # Required. The primary value associated with this entity entry. For example, if the entity type is *vegetable*, the value could be *scallions*. For `KIND_MAP` entity types: * A canonical value to be used in place of synonyms. For `KIND_LIST` entity types: * A string that can contain references to other entity types (with or without aliases).
          },
        ],
        &quot;entityOverrideMode&quot;: &quot;A String&quot;, # Required. Indicates whether the additional data should override or supplement the custom entity type definition.
        &quot;name&quot;: &quot;A String&quot;, # Required. The unique identifier of the session entity type. Format: `projects//locations//agents//sessions//entityTypes/` or `projects//locations//agents//environments//sessions//entityTypes/`. If `Environment ID` is not specified, we assume default &#x27;draft&#x27; environment.
      },
    ],
    &quot;sessionTtl&quot;: &quot;A String&quot;, # Optional. Configure lifetime of the Dialogflow session. By default, a Dialogflow session remains active and its data is stored for 30 minutes after the last request is sent for the session. This value should be no longer than 1 day.
    &quot;timeZone&quot;: &quot;A String&quot;, # The time zone of this conversational query from the [time zone database](https://www.iana.org/time-zones), e.g., America/New_York, Europe/Paris. If not provided, the time zone specified in the agent is used.
    &quot;webhookHeaders&quot;: { # This field can be used to pass HTTP headers for a webhook call. These headers will be sent to webhook along with the headers that have been configured through Dialogflow web console. The headers defined within this field will overwrite the headers configured through Dialogflow console if there is a conflict. Header names are case-insensitive. Google&#x27;s specified headers are not allowed. Including: &quot;Host&quot;, &quot;Content-Length&quot;, &quot;Connection&quot;, &quot;From&quot;, &quot;User-Agent&quot;, &quot;Accept-Encoding&quot;, &quot;If-Modified-Since&quot;, &quot;If-None-Match&quot;, &quot;X-Forwarded-For&quot;, etc.
      &quot;a_key&quot;: &quot;A String&quot;,
    },
  },
  &quot;session&quot;: &quot;A String&quot;, # Required. The name of the session this query is sent to. Format: `projects//locations//agents//sessions/` or `projects//locations//agents//environments//sessions/`. If `Environment ID` is not specified, we assume default &#x27;draft&#x27; environment. It&#x27;s up to the API caller to choose an appropriate `Session ID`. It can be a random number or some type of session identifiers (preferably hashed). The length of the `Session ID` must not exceed 36 characters. For more information, see the [sessions guide](https://cloud.google.com/dialogflow/cx/docs/concept/session). Note: Always use agent versions for production traffic. See [Versions and environments](https://cloud.google.com/dialogflow/cx/docs/concept/version).
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The message returned from the DetectIntent method.
  &quot;allowCancellation&quot;: True or False, # Indicates whether the partial response can be cancelled when a later response arrives. e.g. if the agent specified some music as partial response, it can be cancelled.
  &quot;outputAudio&quot;: &quot;A String&quot;, # The audio data bytes encoded as specified in the request. Note: The output audio is generated based on the values of default platform text responses found in the `query_result.response_messages` field. If multiple default text responses exist, they will be concatenated when generating audio. If no default platform text responses exist, the generated audio content will be empty. In some scenarios, multiple output audio fields may be present in the response structure. In these cases, only the top-most-level audio output has content.
  &quot;outputAudioConfig&quot;: { # Instructs the speech synthesizer how to generate the output audio content. # The config used by the speech synthesizer to generate the output audio.
    &quot;audioEncoding&quot;: &quot;A String&quot;, # Required. Audio encoding of the synthesized audio content.
    &quot;sampleRateHertz&quot;: 42, # Optional. The synthesis sample rate (in hertz) for this audio. If not provided, then the synthesizer will use the default sample rate based on the audio encoding. If this is different from the voice&#x27;s natural sample rate, then the synthesizer will honor this request by converting to the desired sample rate (which might result in worse audio quality).
    &quot;synthesizeSpeechConfig&quot;: { # Configuration of how speech should be synthesized. # Optional. Configuration of how speech should be synthesized. If not specified, Agent.text_to_speech_settings is applied.
      &quot;effectsProfileId&quot;: [ # Optional. An identifier which selects &#x27;audio effects&#x27; profiles that are applied on (post synthesized) text to speech. Effects are applied on top of each other in the order they are given.
        &quot;A String&quot;,
      ],
      &quot;pitch&quot;: 3.14, # Optional. Speaking pitch, in the range [-20.0, 20.0]. 20 means increase 20 semitones from the original pitch. -20 means decrease 20 semitones from the original pitch.
      &quot;speakingRate&quot;: 3.14, # Optional. Speaking rate/speed, in the range [0.25, 4.0]. 1.0 is the normal native speed supported by the specific voice. 2.0 is twice as fast, and 0.5 is half as fast. If unset(0.0), defaults to the native 1.0 speed. Any other values &lt; 0.25 or &gt; 4.0 will return an error.
      &quot;voice&quot;: { # Description of which voice to use for speech synthesis. # Optional. The desired voice of the synthesized audio.
        &quot;name&quot;: &quot;A String&quot;, # Optional. The name of the voice. If not set, the service will choose a voice based on the other parameters such as language_code and ssml_gender. For the list of available voices, please refer to [Supported voices and languages](https://cloud.google.com/text-to-speech/docs/voices).
        &quot;ssmlGender&quot;: &quot;A String&quot;, # Optional. The preferred gender of the voice. If not set, the service will choose a voice based on the other parameters such as language_code and name. Note that this is only a preference, not requirement. If a voice of the appropriate gender is not available, the synthesizer should substitute a voice with a different gender rather than failing the request.
      },
      &quot;volumeGainDb&quot;: 3.14, # Optional. Volume gain (in dB) of the normal native volume supported by the specific voice, in the range [-96.0, 16.0]. If unset, or set to a value of 0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB) will play at approximately half the amplitude of the normal native signal amplitude. A value of +6.0 (dB) will play at approximately twice the amplitude of the normal native signal amplitude. We strongly recommend not to exceed +10 (dB) as there&#x27;s usually no effective increase in loudness for any value greater than that.
    },
  },
  &quot;queryResult&quot;: { # Represents the result of a conversational query. # The result of the conversational query.
    &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Returns the current advanced settings including IVR settings. Even though the operations configured by these settings are performed by Dialogflow, the client may need to perform special logic at the moment. For example, if Dialogflow exports audio to Google Cloud Storage, then the client may need to wait for the resulting object to appear in the bucket before proceeding.
      &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
        &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
      },
      &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
        &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
        &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
        &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
        &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
      },
      &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
        &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
        &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
        &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
      },
      &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
        &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
        &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
          &quot;a_key&quot;: &quot;A String&quot;,
        },
        &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
        &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
      },
    },
    &quot;allowAnswerFeedback&quot;: True or False, # Indicates whether the Thumbs up/Thumbs down rating controls are need to be shown for the response in the Dialogflow Messenger widget.
    &quot;currentFlow&quot;: { # Flows represents the conversation flows when you build your chatbot agent. A flow consists of many pages connected by the transition routes. Conversations always start with the built-in Start Flow (with an all-0 ID). Transition routes can direct the conversation session from the current flow (parent flow) to another flow (sub flow). When the sub flow is finished, Dialogflow will bring the session back to the parent flow, where the sub flow is started. Usually, when a transition route is followed by a matched intent, the intent will be &quot;consumed&quot;. This means the intent won&#x27;t activate more transition routes. However, when the followed transition route moves the conversation session into a different flow, the matched intent can be carried over and to be consumed in the target flow. # The current Flow. Some, not all fields are filled in this message, including but not limited to `name` and `display_name`.
      &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this flow. The settings exposed at the lower level overrides the settings exposed at the higher level.
        &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
          &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
        },
        &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
          &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
          &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
          &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
          &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
          &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
        },
        &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
          &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
          &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
          &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
        },
        &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
          &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
          &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
          &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
        },
      },
      &quot;description&quot;: &quot;A String&quot;, # The description of the flow. The maximum length is 500 characters. If exceeded, the request is rejected.
      &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the flow.
      &quot;eventHandlers&quot;: [ # A flow&#x27;s event handlers serve two purposes: * They are responsible for handling events (e.g. no match, webhook errors) in the flow. * They are inherited by every page&#x27;s event handlers, which can be used to handle common events regardless of the current page. Event handlers defined in the page have higher priority than those defined in the flow. Unlike transition_routes, these handlers are evaluated on a first-match basis. The first one that matches the event get executed, with the rest being ignored.
        { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
          &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
          &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
          &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
          &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
          &quot;targetPlaybook&quot;: &quot;A String&quot;, # The target playbook to transition to. Format: `projects//locations//agents//playbooks/`.
          &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
            &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
              &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
                &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
              },
              &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
                &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
                &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
                &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
                &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
                &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
              },
              &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
                &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
                &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
                &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
              },
              &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
                &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
                &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                  &quot;a_key&quot;: &quot;A String&quot;,
                },
                &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
                &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
              },
            },
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                              &quot;A String&quot;,
                            ],
                          },
                          &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                            &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                            &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                            &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                    &quot;A String&quot;,
                  ],
                },
                &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                  &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                  &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                  &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                },
              },
            ],
            &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
        },
      ],
      &quot;knowledgeConnectorSettings&quot;: { # The Knowledge Connector settings for this page or flow. This includes information such as the attached Knowledge Bases, and the way to execute fulfillment. # Optional. Knowledge connector configuration.
        &quot;dataStoreConnections&quot;: [ # Optional. List of related data store connections.
          { # A data store connection. It represents a data store in Discovery Engine and the type of the contents it contains.
            &quot;dataStore&quot;: &quot;A String&quot;, # The full name of the referenced data store. Formats: `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}` `projects/{project}/locations/{location}/dataStores/{data_store}`
            &quot;dataStoreType&quot;: &quot;A String&quot;, # The type of the connected data store.
          },
        ],
        &quot;enabled&quot;: True or False, # Whether Knowledge Connector is enabled or not.
        &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
        &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
        &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to be triggered. When the answers from the Knowledge Connector are selected by Dialogflow, you can utitlize the request scoped parameter `$request.knowledge.answers` (contains up to the 5 highest confidence answers) and `$request.knowledge.questions` (contains the corresponding questions) to construct the fulfillment.
          &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
            &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
              &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
            },
            &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
              &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
              &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
              &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
              &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
              &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
            },
            &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
              &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
              &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
              &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
            },
            &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
              &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
              &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
              &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
            },
          },
          &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
            { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
              &quot;cases&quot;: [ # A list of cascading if-else conditions.
                { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                  &quot;caseContent&quot;: [ # A list of case content.
                    { # The list of messages or conditional cases to activate for this case.
                      &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                      &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                        },
                        &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                        },
                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                            { # Represents one segment of audio.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                            },
                          ],
                        },
                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                        },
                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                        },
                        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                        },
                        &quot;text&quot;: { # The text response message. # Returns a text response.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                            &quot;A String&quot;,
                          ],
                        },
                        &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                          &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                          &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                        },
                      },
                    },
                  ],
                  &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                },
              ],
            },
          ],
          &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
          &quot;messages&quot;: [ # The list of rich message responses to present to the user.
            { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
              },
              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
              },
              &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
              },
              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
              },
              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                &quot;segments&quot;: [ # Segments this audio response is composed of.
                  { # Represents one segment of audio.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                  },
                ],
              },
              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
              },
              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
              },
              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
              },
              &quot;text&quot;: { # The text response message. # Returns a text response.
                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                  &quot;A String&quot;,
                ],
              },
              &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
              },
            },
          ],
          &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
          &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
            { # Setting a parameter value.
              &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
              &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
            },
          ],
          &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
          &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
        },
      },
      &quot;locked&quot;: True or False, # Indicates whether the flow is locked for changes. If the flow is locked, modifications to the flow will be rejected.
      &quot;multiLanguageSettings&quot;: { # Settings for multi-lingual agents. # Optional. Multi-lingual agent settings for this flow.
        &quot;enableMultiLanguageDetection&quot;: True or False, # Optional. Enable multi-language detection for this flow. This can be set only if agent level multi language setting is enabled.
        &quot;supportedResponseLanguageCodes&quot;: [ # Optional. Agent will respond in the detected language if the detected language code is in the supported resolved languages for this flow. This will be used only if multi-language training is enabled in the agent and multi-language detection is enabled in the flow. The supported languages must be a subset of the languages supported by the agent.
          &quot;A String&quot;,
        ],
      },
      &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the flow. Format: `projects//locations//agents//flows/`.
      &quot;nluSettings&quot;: { # Settings related to NLU. # NLU related settings of the flow.
        &quot;classificationThreshold&quot;: 3.14, # To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold. If the returned score value is less than the threshold value, then a no-match event will be triggered. The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used. You can set a separate classification threshold for the flow in each language enabled for the agent.
        &quot;modelTrainingMode&quot;: &quot;A String&quot;, # Indicates NLU model training mode.
        &quot;modelType&quot;: &quot;A String&quot;, # Indicates the type of NLU model.
      },
      &quot;transitionRouteGroups&quot;: [ # A flow&#x27;s transition route group serve two purposes: * They are responsible for matching the user&#x27;s first utterances in the flow. * They are inherited by every page&#x27;s transition route groups. Transition route groups defined in the page have higher priority than those defined in the flow. Format:`projects//locations//agents//flows//transitionRouteGroups/` or `projects//locations//agents//transitionRouteGroups/` for agent-level groups.
        &quot;A String&quot;,
      ],
      &quot;transitionRoutes&quot;: [ # A flow&#x27;s transition routes serve two purposes: * They are responsible for matching the user&#x27;s first utterances in the flow. * They are inherited by every page&#x27;s transition routes and can support use cases such as the user saying &quot;help&quot; or &quot;can I talk to a human?&quot;, which can be handled in a common way regardless of the current page. Transition routes defined in the page have higher priority than those defined in the flow. TransitionRoutes are evalauted in the following order: * TransitionRoutes with intent specified. * TransitionRoutes with only condition specified. TransitionRoutes with intent specified are inherited by pages in the flow.
        { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
          &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
          &quot;description&quot;: &quot;A String&quot;, # Optional. The description of the transition route. The maximum length is 500 characters.
          &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
          &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
          &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
          &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
          &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
            &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
              &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
                &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
              },
              &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
                &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
                &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
                &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
                &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
                &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
              },
              &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
                &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
                &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
                &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
              },
              &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
                &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
                &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                  &quot;a_key&quot;: &quot;A String&quot;,
                },
                &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
                &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
              },
            },
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                              &quot;A String&quot;,
                            ],
                          },
                          &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                            &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                            &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                            &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                    &quot;A String&quot;,
                  ],
                },
                &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                  &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                  &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                  &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                },
              },
            ],
            &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
        },
      ],
    },
    &quot;currentPage&quot;: { # A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page). # The current Page. Some, not all fields are filled in this message, including but not limited to `name` and `display_name`.
      &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this page. The settings exposed at the lower level overrides the settings exposed at the higher level.
        &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
          &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
        },
        &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
          &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
          &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
          &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
          &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
          &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
        },
        &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
          &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
          &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
          &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
        },
        &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
          &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
          &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
          &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
        },
      },
      &quot;description&quot;: &quot;A String&quot;, # The description of the page. The maximum length is 500 characters.
      &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the page, unique within the flow.
      &quot;entryFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the session is entering the page.
        &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
          &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
            &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
          },
          &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
            &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
            &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
            &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
            &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
            &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
          },
          &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
            &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
            &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
            &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
          },
          &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
            &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
            &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
              &quot;a_key&quot;: &quot;A String&quot;,
            },
            &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
            &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
          },
        },
        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
            &quot;cases&quot;: [ # A list of cascading if-else conditions.
              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                &quot;caseContent&quot;: [ # A list of case content.
                  { # The list of messages or conditional cases to activate for this case.
                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                          &quot;A String&quot;,
                        ],
                      },
                      &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                        &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                        &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                        &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                      },
                    },
                  },
                ],
                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
              },
            ],
          },
        ],
        &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
            },
            &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
            },
            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
              &quot;segments&quot;: [ # Segments this audio response is composed of.
                { # Represents one segment of audio.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                },
              ],
            },
            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
            },
            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
            },
            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
            },
            &quot;text&quot;: { # The text response message. # Returns a text response.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                &quot;A String&quot;,
              ],
            },
            &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
              &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
              &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
            },
          },
        ],
        &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
          { # Setting a parameter value.
            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
          },
        ],
        &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
      },
      &quot;eventHandlers&quot;: [ # Handlers associated with the page to handle events such as webhook errors, no match or no input.
        { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
          &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
          &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
          &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
          &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
          &quot;targetPlaybook&quot;: &quot;A String&quot;, # The target playbook to transition to. Format: `projects//locations//agents//playbooks/`.
          &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
            &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
              &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
                &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
              },
              &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
                &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
                &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
                &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
                &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
                &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
              },
              &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
                &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
                &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
                &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
              },
              &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
                &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
                &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                  &quot;a_key&quot;: &quot;A String&quot;,
                },
                &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
                &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
              },
            },
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                              &quot;A String&quot;,
                            ],
                          },
                          &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                            &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                            &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                            &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                    &quot;A String&quot;,
                  ],
                },
                &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                  &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                  &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                  &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                },
              },
            ],
            &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
        },
      ],
      &quot;form&quot;: { # A form is a data model that groups related parameters that can be collected from the user. The process in which the agent prompts the user and collects parameter values from the user is called form filling. A form can be added to a page. When form filling is done, the filled parameters will be written to the session. # The form associated with the page, used for collecting parameters relevant to the page.
        &quot;parameters&quot;: [ # Parameters to collect from the user.
          { # Represents a form parameter.
            &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this parameter. The settings exposed at the lower level overrides the settings exposed at the higher level.
              &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
                &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
              },
              &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
                &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
                &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
                &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
                &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
                &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
              },
              &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
                &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
                &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
                &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
              },
              &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
                &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
                &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                  &quot;a_key&quot;: &quot;A String&quot;,
                },
                &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
                &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
              },
            },
            &quot;defaultValue&quot;: &quot;&quot;, # The default value of an optional parameter. If the parameter is required, the default value will be ignored.
            &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the parameter, unique within the form.
            &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
            &quot;fillBehavior&quot;: { # Configuration for how the filling of a parameter should be handled. # Required. Defines fill behavior for the parameter.
              &quot;initialPromptFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # Required. The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
                &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
                  &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
                    &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
                  },
                  &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
                    &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
                    &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
                    &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
                    &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
                    &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
                  },
                  &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
                    &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
                    &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
                    &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
                  },
                  &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
                    &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
                    &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                      &quot;a_key&quot;: &quot;A String&quot;,
                    },
                    &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
                    &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
                  },
                },
                &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                  { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                    &quot;cases&quot;: [ # A list of cascading if-else conditions.
                      { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                        &quot;caseContent&quot;: [ # A list of case content.
                          { # The list of messages or conditional cases to activate for this case.
                            &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                            &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                                  &quot;A String&quot;,
                                ],
                              },
                              &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                                &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                                &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                                &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                              },
                            },
                          },
                        ],
                        &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                      },
                    ],
                  },
                ],
                &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
                &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                  { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                    &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                    },
                    &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                    },
                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                        { # Represents one segment of audio.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                        },
                      ],
                    },
                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                    },
                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                    },
                    &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                      &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                    },
                    &quot;text&quot;: { # The text response message. # Returns a text response.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                        &quot;A String&quot;,
                      ],
                    },
                    &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                      &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                      &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                    },
                  },
                ],
                &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                  { # Setting a parameter value.
                    &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                    &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                  },
                ],
                &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
              },
              &quot;repromptEventHandlers&quot;: [ # The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are: * `sys.no-match-`, where N can be from 1 to 6 * `sys.no-match-default` * `sys.no-input-`, where N can be from 1 to 6 * `sys.no-input-default` * `sys.invalid-parameter` `initial_prompt_fulfillment` provides the first prompt for the parameter. If the user&#x27;s response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the `sys.no-match-1`/`sys.no-input-1` handler (if defined) will be called to provide a prompt. The `sys.no-match-2`/`sys.no-input-2` handler (if defined) will respond to the next no-match/no-input event, and so on. A `sys.no-match-default` or `sys.no-input-default` handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed. A `sys.invalid-parameter` handler can be defined to handle the case where the parameter values have been `invalidated` by webhook. For example, if the user&#x27;s response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the `sys.invalid-parameter` handler (if defined) will be called to provide a prompt. If the event handler for the corresponding event can&#x27;t be found on the parameter, `initial_prompt_fulfillment` will be re-prompted.
                { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                  &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                  &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                  &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                  &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                  &quot;targetPlaybook&quot;: &quot;A String&quot;, # The target playbook to transition to. Format: `projects//locations//agents//playbooks/`.
                  &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                    &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
                      &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
                        &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
                      },
                      &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
                        &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
                        &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
                        &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
                        &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
                        &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
                      },
                      &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
                        &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
                        &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
                        &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
                      },
                      &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
                        &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
                        &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                          &quot;a_key&quot;: &quot;A String&quot;,
                        },
                        &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
                        &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
                      },
                    },
                    &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                      { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                        &quot;cases&quot;: [ # A list of cascading if-else conditions.
                          { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                            &quot;caseContent&quot;: [ # A list of case content.
                              { # The list of messages or conditional cases to activate for this case.
                                &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                                &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                  &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                  &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                    &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                  },
                                  &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                  },
                                  &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                                  },
                                  &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                    &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                  },
                                  &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                    &quot;segments&quot;: [ # Segments this audio response is composed of.
                                      { # Represents one segment of audio.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                        &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                        &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                      },
                                    ],
                                  },
                                  &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                    &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                  },
                                  &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                  &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                  },
                                  &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                    &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                  },
                                  &quot;text&quot;: { # The text response message. # Returns a text response.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                                      &quot;A String&quot;,
                                    ],
                                  },
                                  &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                                    &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                                    &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                    &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                                  },
                                },
                              },
                            ],
                            &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                          },
                        ],
                      },
                    ],
                    &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
                    &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                      { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                        },
                        &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                        },
                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                            { # Represents one segment of audio.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                            },
                          ],
                        },
                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                        },
                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                        },
                        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                        },
                        &quot;text&quot;: { # The text response message. # Returns a text response.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                            &quot;A String&quot;,
                          ],
                        },
                        &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                          &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                          &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                        },
                      },
                    ],
                    &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                    &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                      { # Setting a parameter value.
                        &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                        &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                      },
                    ],
                    &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                    &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                  },
                },
              ],
            },
            &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
            &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
            &quot;required&quot;: True or False, # Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them. Required parameters must be filled before form filling concludes.
          },
        ],
      },
      &quot;knowledgeConnectorSettings&quot;: { # The Knowledge Connector settings for this page or flow. This includes information such as the attached Knowledge Bases, and the way to execute fulfillment. # Optional. Knowledge connector configuration.
        &quot;dataStoreConnections&quot;: [ # Optional. List of related data store connections.
          { # A data store connection. It represents a data store in Discovery Engine and the type of the contents it contains.
            &quot;dataStore&quot;: &quot;A String&quot;, # The full name of the referenced data store. Formats: `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}` `projects/{project}/locations/{location}/dataStores/{data_store}`
            &quot;dataStoreType&quot;: &quot;A String&quot;, # The type of the connected data store.
          },
        ],
        &quot;enabled&quot;: True or False, # Whether Knowledge Connector is enabled or not.
        &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
        &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
        &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to be triggered. When the answers from the Knowledge Connector are selected by Dialogflow, you can utitlize the request scoped parameter `$request.knowledge.answers` (contains up to the 5 highest confidence answers) and `$request.knowledge.questions` (contains the corresponding questions) to construct the fulfillment.
          &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
            &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
              &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
            },
            &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
              &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
              &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
              &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
              &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
              &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
            },
            &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
              &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
              &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
              &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
            },
            &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
              &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
              &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
              &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
            },
          },
          &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
            { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
              &quot;cases&quot;: [ # A list of cascading if-else conditions.
                { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                  &quot;caseContent&quot;: [ # A list of case content.
                    { # The list of messages or conditional cases to activate for this case.
                      &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                      &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                        },
                        &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                        },
                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                            { # Represents one segment of audio.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                            },
                          ],
                        },
                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                        },
                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                        },
                        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                        },
                        &quot;text&quot;: { # The text response message. # Returns a text response.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                            &quot;A String&quot;,
                          ],
                        },
                        &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                          &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                          &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                        },
                      },
                    },
                  ],
                  &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                },
              ],
            },
          ],
          &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
          &quot;messages&quot;: [ # The list of rich message responses to present to the user.
            { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
              },
              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
              },
              &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
              },
              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
              },
              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                &quot;segments&quot;: [ # Segments this audio response is composed of.
                  { # Represents one segment of audio.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                  },
                ],
              },
              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
              },
              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
              },
              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
              },
              &quot;text&quot;: { # The text response message. # Returns a text response.
                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                  &quot;A String&quot;,
                ],
              },
              &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
              },
            },
          ],
          &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
          &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
            { # Setting a parameter value.
              &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
              &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
            },
          ],
          &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
          &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
        },
      },
      &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the page. Required for the Pages.UpdatePage method. Pages.CreatePage populates the name automatically. Format: `projects//locations//agents//flows//pages/`.
      &quot;transitionRouteGroups&quot;: [ # Ordered list of `TransitionRouteGroups` added to the page. Transition route groups must be unique within a page. If the page links both flow-level transition route groups and agent-level transition route groups, the flow-level ones will have higher priority and will be put before the agent-level ones. * If multiple transition routes within a page scope refer to the same intent, then the precedence order is: page&#x27;s transition route -&gt; page&#x27;s transition route group -&gt; flow&#x27;s transition routes. * If multiple transition route groups within a page contain the same intent, then the first group in the ordered list takes precedence. Format:`projects//locations//agents//flows//transitionRouteGroups/` or `projects//locations//agents//transitionRouteGroups/` for agent-level groups.
        &quot;A String&quot;,
      ],
      &quot;transitionRoutes&quot;: [ # A list of transitions for the transition rules of this page. They route the conversation to another page in the same flow, or another flow. When we are in a certain page, the TransitionRoutes are evalauted in the following order: * TransitionRoutes defined in the page with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in flow with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in the page with only condition specified. * TransitionRoutes defined in the transition route groups with only condition specified.
        { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
          &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
          &quot;description&quot;: &quot;A String&quot;, # Optional. The description of the transition route. The maximum length is 500 characters.
          &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
          &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
          &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
          &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
          &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
            &quot;advancedSettings&quot;: { # Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playback_interruption_settings at fulfillment level only overrides the playback_interruption_settings at the agent level, leaving other settings at the agent level unchanged. DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Hierarchy: Agent-&gt;Flow-&gt;Page-&gt;Fulfillment/Parameter. # Hierarchical advanced settings for this fulfillment. The settings exposed at the lower level overrides the settings exposed at the higher level.
              &quot;audioExportGcsDestination&quot;: { # Google Cloud Storage location for a Dialogflow operation that writes or exports objects (e.g. exported agent or transcripts) outside of Dialogflow. # If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels: - Agent level - Flow level
                &quot;uri&quot;: &quot;A String&quot;, # Required. The Google Cloud Storage URI for the exported objects. A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
              },
              &quot;dtmfSettings&quot;: { # Define behaviors for DTMF (dual tone multi frequency). # Settings for DTMF. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level.
                &quot;enabled&quot;: True or False, # If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a &quot;3&quot; was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
                &quot;endpointingTimeoutDuration&quot;: &quot;A String&quot;, # Endpoint timeout setting for matching dtmf input to regex.
                &quot;finishDigit&quot;: &quot;A String&quot;, # The digit that terminates a DTMF digit sequence.
                &quot;interdigitTimeoutDuration&quot;: &quot;A String&quot;, # Interdigit timeout setting for matching dtmf input to regex.
                &quot;maxDigits&quot;: 42, # Max length of DTMF digits.
              },
              &quot;loggingSettings&quot;: { # Define behaviors on logging. # Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels: - Agent level.
                &quot;enableConsentBasedRedaction&quot;: True or False, # Enables consent-based end-user input redaction, if true, a pre-defined session parameter `$session.params.conversation-redaction` will be used to determine if the utterance should be redacted.
                &quot;enableInteractionLogging&quot;: True or False, # Enables DF Interaction logging.
                &quot;enableStackdriverLogging&quot;: True or False, # Enables Google Cloud Logging.
              },
              &quot;speechSettings&quot;: { # Define behaviors of speech to text detection. # Settings for speech to text detection. Exposed at the following levels: - Agent level - Flow level - Page level - Parameter level
                &quot;endpointerSensitivity&quot;: 42, # Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
                &quot;models&quot;: { # Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
                  &quot;a_key&quot;: &quot;A String&quot;,
                },
                &quot;noSpeechTimeout&quot;: &quot;A String&quot;, # Timeout before detecting no speech.
                &quot;useTimeoutBasedEndpointing&quot;: True or False, # Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
              },
            },
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3beta1FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                              &quot;A String&quot;,
                            ],
                          },
                          &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                            &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                            &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                            &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;enableGenerativeFallback&quot;: True or False, # If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
                    &quot;A String&quot;,
                  ],
                },
                &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
                  &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
                  &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                  &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
                },
              },
            ],
            &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
        },
      ],
    },
    &quot;dataStoreConnectionSignals&quot;: { # Data store connection feature output signals. Might be only partially field if processing stop before the final answer. Reasons for this can be, but are not limited to: empty UCS search results, positive RAI check outcome, grounding failure, ... # Optional. Data store connection feature output signals. Filled only when data stores are involved in serving the query and DetectIntentRequest.populate_data_store_connection_signals is set to true in the request.
      &quot;answer&quot;: &quot;A String&quot;, # Optional. The final compiled answer.
      &quot;answerGenerationModelCallSignals&quot;: { # Diagnostic info related to the answer generation model call. # Optional. Diagnostic info related to the answer generation model call.
        &quot;model&quot;: &quot;A String&quot;, # Name of the generative model. For example, &quot;gemini-ultra&quot;, &quot;gemini-pro&quot;, &quot;gemini-1.5-flash&quot; etc. Defaults to &quot;Other&quot; if the model is unknown.
        &quot;modelOutput&quot;: &quot;A String&quot;, # Output of the generative model.
        &quot;renderedPrompt&quot;: &quot;A String&quot;, # Prompt as sent to the model.
      },
      &quot;answerParts&quot;: [ # Optional. Answer parts with relevant citations. Concatenation of texts should add up the `answer` (not counting whitespaces).
        { # Answer part with citation.
          &quot;supportingIndices&quot;: [ # Citations for this answer part. Indices of `search_snippets`.
            42,
          ],
          &quot;text&quot;: &quot;A String&quot;, # Substring of the answer.
        },
      ],
      &quot;citedSnippets&quot;: [ # Optional. Snippets cited by the answer generation model from the most to least relevant.
        { # Snippet cited by the answer generation model.
          &quot;searchSnippet&quot;: { # Search snippet details. # Details of the snippet.
            &quot;documentTitle&quot;: &quot;A String&quot;, # Title of the enclosing document.
            &quot;documentUri&quot;: &quot;A String&quot;, # Uri for the document. Present if specified for the document.
            &quot;text&quot;: &quot;A String&quot;, # Text included in the prompt.
          },
          &quot;snippetIndex&quot;: 42, # Index of the snippet in `search_snippets` field.
        },
      ],
      &quot;groundingSignals&quot;: { # Grounding signals. # Optional. Grounding signals.
        &quot;decision&quot;: &quot;A String&quot;, # Represents the decision of the grounding check.
        &quot;score&quot;: &quot;A String&quot;, # Grounding score bucket setting.
      },
      &quot;rewriterModelCallSignals&quot;: { # Diagnostic info related to the rewriter model call. # Optional. Diagnostic info related to the rewriter model call.
        &quot;model&quot;: &quot;A String&quot;, # Name of the generative model. For example, &quot;gemini-ultra&quot;, &quot;gemini-pro&quot;, &quot;gemini-1.5-flash&quot; etc. Defaults to &quot;Other&quot; if the model is unknown.
        &quot;modelOutput&quot;: &quot;A String&quot;, # Output of the generative model.
        &quot;renderedPrompt&quot;: &quot;A String&quot;, # Prompt as sent to the model.
      },
      &quot;rewrittenQuery&quot;: &quot;A String&quot;, # Optional. Rewritten string query used for search.
      &quot;safetySignals&quot;: { # Safety check results. # Optional. Safety check result.
        &quot;bannedPhraseMatch&quot;: &quot;A String&quot;, # Specifies banned phrase match subject.
        &quot;decision&quot;: &quot;A String&quot;, # Safety decision.
        &quot;matchedBannedPhrase&quot;: &quot;A String&quot;, # The matched banned phrase if there was a match.
      },
      &quot;searchSnippets&quot;: [ # Optional. Search snippets included in the answer generation prompt.
        { # Search snippet details.
          &quot;documentTitle&quot;: &quot;A String&quot;, # Title of the enclosing document.
          &quot;documentUri&quot;: &quot;A String&quot;, # Uri for the document. Present if specified for the document.
          &quot;text&quot;: &quot;A String&quot;, # Text included in the prompt.
        },
      ],
    },
    &quot;diagnosticInfo&quot;: { # The free-form diagnostic info. For example, this field could contain webhook call latency. The fields of this data can change without notice, so you should not write code that depends on its structure. One of the fields is called &quot;Alternative Matched Intents&quot;, which may aid with debugging. The following describes these intent results: - The list is empty if no intent was matched to end-user input. - Only intents that are referenced in the currently active flow are included. - The matched intent is included. - Other intents that could have matched end-user input, but did not match because they are referenced by intent routes that are out of [scope](https://cloud.google.com/dialogflow/cx/docs/concept/handler#scope), are included. - Other intents referenced by intent routes in scope that matched end-user input, but had a lower confidence score.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;dtmf&quot;: { # Represents the input for dtmf event. # If a DTMF was provided as input, this field will contain a copy of the DtmfInput.
      &quot;digits&quot;: &quot;A String&quot;, # The dtmf digits.
      &quot;finishDigit&quot;: &quot;A String&quot;, # The finish digit (if any).
    },
    &quot;generativeInfo&quot;: { # Represents the information of a query if handled by generative agent resources. # The information of a query if handled by generative agent resources.
      &quot;actionTracingInfo&quot;: { # Example represents a sample execution of the playbook in the conversation. An example consists of a list of ordered actions performed by end user or Dialogflow agent according the playbook instructions to fulfill the task. # The actions performed by the generative playbook for the current agent response.
        &quot;actions&quot;: [ # Required. The ordered list of actions performed by the end user and the Dialogflow agent.
          { # Action performed by end user or Dialogflow agent in the conversation.
            &quot;agentUtterance&quot;: { # AgentUtterance represents one message sent by the agent. # Optional. Action performed by the agent as a message.
              &quot;text&quot;: &quot;A String&quot;, # Required. Message content in text.
            },
            &quot;flowInvocation&quot;: { # Stores metadata of the invocation of a CX flow. Next Id: 7 # Optional. Action performed on behalf of the agent by invoking a CX flow.
              &quot;flow&quot;: &quot;A String&quot;, # Required. The unique identifier of the flow. Format: `projects//locations//agents//flows/`.
              &quot;flowState&quot;: &quot;A String&quot;, # Required. Flow invocation&#x27;s output state.
              &quot;inputActionParameters&quot;: { # Optional. A list of input parameters for the flow.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;outputActionParameters&quot;: { # Optional. A list of output parameters generated by the flow invocation.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
            },
            &quot;playbookInvocation&quot;: { # Stores metadata of the invocation of a child playbook. Next Id: 5 # Optional. Action performed on behalf of the agent by invoking a child playbook.
              &quot;playbook&quot;: &quot;A String&quot;, # Required. The unique identifier of the playbook. Format: `projects//locations//agents//playbooks/`.
              &quot;playbookInput&quot;: { # Input of the playbook. # Optional. Input of the child playbook invocation.
                &quot;actionParameters&quot;: { # Optional. A list of input parameters for the action.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;precedingConversationSummary&quot;: &quot;A String&quot;, # Optional. Summary string of the preceding conversation for the child playbook invocation.
              },
              &quot;playbookOutput&quot;: { # Output of the playbook. # Optional. Output of the child playbook invocation.
                &quot;actionParameters&quot;: { # Optional. A Struct object of output parameters for the action.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;executionSummary&quot;: &quot;A String&quot;, # Optional. Summary string of the execution result of the child playbook.
              },
              &quot;playbookState&quot;: &quot;A String&quot;, # Required. Playbook invocation&#x27;s output state.
            },
            &quot;toolUse&quot;: { # Stores metadata of the invocation of an action supported by a tool. # Optional. Action performed on behalf of the agent by calling a plugin tool.
              &quot;action&quot;: &quot;A String&quot;, # Optional. Name of the action to be called during the tool use.
              &quot;inputActionParameters&quot;: { # Optional. A list of input parameters for the action.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;outputActionParameters&quot;: { # Optional. A list of output parameters generated by the action.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;tool&quot;: &quot;A String&quot;, # Required. The tool that should be used. Format: `projects//locations//agents//tools/`.
            },
            &quot;userUtterance&quot;: { # UserUtterance represents one message sent by the customer. # Optional. Agent obtained a message from the customer.
              &quot;text&quot;: &quot;A String&quot;, # Required. Message content in text.
            },
          },
        ],
        &quot;conversationState&quot;: &quot;A String&quot;, # Required. Example&#x27;s output state.
        &quot;createTime&quot;: &quot;A String&quot;, # Output only. The timestamp of initial example creation.
        &quot;description&quot;: &quot;A String&quot;, # Optional. The high level concise description of the example. The max number of characters is 200.
        &quot;displayName&quot;: &quot;A String&quot;, # Required. The display name of the example.
        &quot;languageCode&quot;: &quot;A String&quot;, # Optional. The language code of the example. If not specified, the agent&#x27;s default language is used. Note: languages must be enabled in the agent before they can be used. Note: example&#x27;s language code is not currently used in dialogflow agents.
        &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the playbook example. Format: `projects//locations//agents//playbooks//examples/`.
        &quot;playbookInput&quot;: { # Input of the playbook. # Optional. The input to the playbook in the example.
          &quot;actionParameters&quot;: { # Optional. A list of input parameters for the action.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;precedingConversationSummary&quot;: &quot;A String&quot;, # Optional. Summary string of the preceding conversation for the child playbook invocation.
        },
        &quot;playbookOutput&quot;: { # Output of the playbook. # Optional. The output of the playbook in the example.
          &quot;actionParameters&quot;: { # Optional. A Struct object of output parameters for the action.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;executionSummary&quot;: &quot;A String&quot;, # Optional. Summary string of the execution result of the child playbook.
        },
        &quot;tokenCount&quot;: &quot;A String&quot;, # Output only. Estimated number of tokes current example takes when sent to the LLM.
        &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Last time the example was updated.
      },
      &quot;currentPlaybooks&quot;: [ # The stack of playbooks that the conversation has currently entered, with the most recent one on the top.
        &quot;A String&quot;,
      ],
    },
    &quot;intent&quot;: { # An intent represents a user&#x27;s intent to interact with a conversational agent. You can provide information for the Dialogflow API to use to match user input to an intent by adding training phrases (i.e., examples of user input) to your intent. # The Intent that matched the conversational query. Some, not all fields are filled in this message, including but not limited to: `name` and `display_name`. This field is deprecated, please use QueryResult.match instead.
      &quot;description&quot;: &quot;A String&quot;, # Human readable description for better understanding an intent like its scope, content, result etc. Maximum character limit: 140 characters.
      &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the intent, unique within the agent.
      &quot;isFallback&quot;: True or False, # Indicates whether this is a fallback intent. Currently only default fallback intent is allowed in the agent, which is added upon agent creation. Adding training phrases to fallback intent is useful in the case of requests that are mistakenly matched, since training phrases assigned to fallback intents act as negative examples that triggers no-match event.
      &quot;labels&quot;: { # The key/value metadata to label an intent. Labels can contain lowercase letters, digits and the symbols &#x27;-&#x27; and &#x27;_&#x27;. International characters are allowed, including letters from unicase alphabets. Keys must start with a letter. Keys and values can be no longer than 63 characters and no more than 128 bytes. Prefix &quot;sys-&quot; is reserved for Dialogflow defined labels. Currently allowed Dialogflow defined labels include: * sys-head * sys-contextual The above labels do not require value. &quot;sys-head&quot; means the intent is a head intent. &quot;sys-contextual&quot; means the intent is a contextual intent.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
      &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the intent. Required for the Intents.UpdateIntent method. Intents.CreateIntent populates the name automatically. Format: `projects//locations//agents//intents/`.
      &quot;parameters&quot;: [ # The collection of parameters associated with the intent.
        { # Represents an intent parameter.
          &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
          &quot;id&quot;: &quot;A String&quot;, # Required. The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
          &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
          &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
        },
      ],
      &quot;priority&quot;: 42, # The priority of this intent. Higher numbers represent higher priorities. - If the supplied value is unspecified or 0, the service translates the value to 500,000, which corresponds to the `Normal` priority in the console. - If the supplied value is negative, the intent is ignored in runtime detect intent requests.
      &quot;trainingPhrases&quot;: [ # The collection of training phrases the agent is trained on to identify the intent.
        { # Represents an example that the agent is trained on to identify the intent.
          &quot;id&quot;: &quot;A String&quot;, # Output only. The unique identifier of the training phrase.
          &quot;parts&quot;: [ # Required. The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase. Note: The API does not automatically annotate training phrases like the Dialogflow Console does. Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated. If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set. If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways: - `Part.text` is set to a part of the phrase that has no parameters. - `Part.text` is set to a part of the phrase that you want to annotate, and the `parameter_id` field is set.
            { # Represents a part of a training phrase.
              &quot;parameterId&quot;: &quot;A String&quot;, # The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
              &quot;text&quot;: &quot;A String&quot;, # Required. The text for this part.
            },
          ],
          &quot;repeatCount&quot;: 42, # Indicates how many times this example was added to the intent.
        },
      ],
    },
    &quot;intentDetectionConfidence&quot;: 3.14, # The intent detection confidence. Values range from 0.0 (completely uncertain) to 1.0 (completely certain). This value is for informational purpose only and is only used to help match the best intent within the classification threshold. This value may change for the same end-user expression at any time due to a model retraining or change in implementation. This field is deprecated, please use QueryResult.match instead.
    &quot;languageCode&quot;: &quot;A String&quot;, # The language that was triggered during intent detection. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes.
    &quot;match&quot;: { # Represents one match result of MatchIntent. # Intent match result, could be an intent or an event.
      &quot;confidence&quot;: 3.14, # The confidence of this match. Values range from 0.0 (completely uncertain) to 1.0 (completely certain). This value is for informational purpose only and is only used to help match the best intent within the classification threshold. This value may change for the same end-user expression at any time due to a model retraining or change in implementation.
      &quot;event&quot;: &quot;A String&quot;, # The event that matched the query. Filled for `EVENT`, `NO_MATCH` and `NO_INPUT` match types.
      &quot;intent&quot;: { # An intent represents a user&#x27;s intent to interact with a conversational agent. You can provide information for the Dialogflow API to use to match user input to an intent by adding training phrases (i.e., examples of user input) to your intent. # The Intent that matched the query. Some, not all fields are filled in this message, including but not limited to: `name` and `display_name`. Only filled for `INTENT` match type.
        &quot;description&quot;: &quot;A String&quot;, # Human readable description for better understanding an intent like its scope, content, result etc. Maximum character limit: 140 characters.
        &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the intent, unique within the agent.
        &quot;isFallback&quot;: True or False, # Indicates whether this is a fallback intent. Currently only default fallback intent is allowed in the agent, which is added upon agent creation. Adding training phrases to fallback intent is useful in the case of requests that are mistakenly matched, since training phrases assigned to fallback intents act as negative examples that triggers no-match event.
        &quot;labels&quot;: { # The key/value metadata to label an intent. Labels can contain lowercase letters, digits and the symbols &#x27;-&#x27; and &#x27;_&#x27;. International characters are allowed, including letters from unicase alphabets. Keys must start with a letter. Keys and values can be no longer than 63 characters and no more than 128 bytes. Prefix &quot;sys-&quot; is reserved for Dialogflow defined labels. Currently allowed Dialogflow defined labels include: * sys-head * sys-contextual The above labels do not require value. &quot;sys-head&quot; means the intent is a head intent. &quot;sys-contextual&quot; means the intent is a contextual intent.
          &quot;a_key&quot;: &quot;A String&quot;,
        },
        &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the intent. Required for the Intents.UpdateIntent method. Intents.CreateIntent populates the name automatically. Format: `projects//locations//agents//intents/`.
        &quot;parameters&quot;: [ # The collection of parameters associated with the intent.
          { # Represents an intent parameter.
            &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
            &quot;id&quot;: &quot;A String&quot;, # Required. The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
            &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
            &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
          },
        ],
        &quot;priority&quot;: 42, # The priority of this intent. Higher numbers represent higher priorities. - If the supplied value is unspecified or 0, the service translates the value to 500,000, which corresponds to the `Normal` priority in the console. - If the supplied value is negative, the intent is ignored in runtime detect intent requests.
        &quot;trainingPhrases&quot;: [ # The collection of training phrases the agent is trained on to identify the intent.
          { # Represents an example that the agent is trained on to identify the intent.
            &quot;id&quot;: &quot;A String&quot;, # Output only. The unique identifier of the training phrase.
            &quot;parts&quot;: [ # Required. The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase. Note: The API does not automatically annotate training phrases like the Dialogflow Console does. Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated. If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set. If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways: - `Part.text` is set to a part of the phrase that has no parameters. - `Part.text` is set to a part of the phrase that you want to annotate, and the `parameter_id` field is set.
              { # Represents a part of a training phrase.
                &quot;parameterId&quot;: &quot;A String&quot;, # The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
                &quot;text&quot;: &quot;A String&quot;, # Required. The text for this part.
              },
            ],
            &quot;repeatCount&quot;: 42, # Indicates how many times this example was added to the intent.
          },
        ],
      },
      &quot;matchType&quot;: &quot;A String&quot;, # Type of this Match.
      &quot;parameters&quot;: { # The collection of parameters extracted from the query. Depending on your protocol or client library language, this is a map, associative array, symbol table, dictionary, or JSON object composed of a collection of (MapKey, MapValue) pairs: * MapKey type: string * MapKey value: parameter name * MapValue type: If parameter&#x27;s entity type is a composite entity then use map, otherwise, depending on the parameter value type, it could be one of string, number, boolean, null, list or map. * MapValue value: If parameter&#x27;s entity type is a composite entity then use map from composite entity property names to property values, otherwise, use parameter value.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;resolvedInput&quot;: &quot;A String&quot;, # Final text input which was matched during MatchIntent. This value can be different from original input sent in request because of spelling correction or other processing.
    },
    &quot;parameters&quot;: { # The collected session parameters. Depending on your protocol or client library language, this is a map, associative array, symbol table, dictionary, or JSON object composed of a collection of (MapKey, MapValue) pairs: * MapKey type: string * MapKey value: parameter name * MapValue type: If parameter&#x27;s entity type is a composite entity then use map, otherwise, depending on the parameter value type, it could be one of string, number, boolean, null, list or map. * MapValue value: If parameter&#x27;s entity type is a composite entity then use map from composite entity property names to property values, otherwise, use parameter value.
      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
    },
    &quot;responseMessages&quot;: [ # The list of rich messages returned to the client. Responses vary from simple text messages to more sophisticated, structured payloads used to drive complex logic.
      { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
        },
        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
        },
        &quot;knowledgeInfoCard&quot;: { # Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card. Otherwise, the info card response is skipped. # Represents info card for knowledge answers, to be better rendered in Dialogflow Messenger.
        },
        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
        },
        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
          &quot;segments&quot;: [ # Segments this audio response is composed of.
            { # Represents one segment of audio.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
            },
          ],
        },
        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
        },
        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        },
        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
        },
        &quot;text&quot;: { # The text response message. # Returns a text response.
          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
          &quot;text&quot;: [ # Required. A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
            &quot;A String&quot;,
          ],
        },
        &quot;toolCall&quot;: { # Represents a call of a specific tool&#x27;s action with the specified inputs. # Returns the definition of a tool call that should be executed by the client.
          &quot;action&quot;: &quot;A String&quot;, # Required. The name of the tool&#x27;s action associated with this call.
          &quot;inputParameters&quot;: { # Optional. The action&#x27;s input parameters.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;tool&quot;: &quot;A String&quot;, # Required. The tool associated with this call. Format: `projects//locations//agents//tools/`.
        },
      },
    ],
    &quot;sentimentAnalysisResult&quot;: { # The result of sentiment analysis. Sentiment analysis inspects user input and identifies the prevailing subjective opinion, especially to determine a user&#x27;s attitude as positive, negative, or neutral. # The sentiment analyss result, which depends on `analyze_query_text_sentiment`, specified in the request.
      &quot;magnitude&quot;: 3.14, # A non-negative number in the [0, +inf) range, which represents the absolute magnitude of sentiment, regardless of score (positive or negative).
      &quot;score&quot;: 3.14, # Sentiment score between -1.0 (negative sentiment) and 1.0 (positive sentiment).
    },
    &quot;text&quot;: &quot;A String&quot;, # If natural language text was provided as input, this field will contain a copy of the text.
    &quot;transcript&quot;: &quot;A String&quot;, # If natural language speech audio was provided as input, this field will contain the transcript for the audio.
    &quot;triggerEvent&quot;: &quot;A String&quot;, # If an event was provided as input, this field will contain the name of the event.
    &quot;triggerIntent&quot;: &quot;A String&quot;, # If an intent was provided as input, this field will contain a copy of the intent identifier. Format: `projects//locations//agents//intents/`.
    &quot;webhookDisplayNames&quot;: [ # The list of webhook display names in the order of call sequence.
      &quot;A String&quot;,
    ],
    &quot;webhookIds&quot;: [ # The list of webhook ids in the order of call sequence.
      &quot;A String&quot;,
    ],
    &quot;webhookLatencies&quot;: [ # The list of webhook latencies in the order of call sequence.
      &quot;A String&quot;,
    ],
    &quot;webhookPayloads&quot;: [ # The list of webhook payload in WebhookResponse.payload, in the order of call sequence. If some webhook call fails or doesn&#x27;t return any payload, an empty `Struct` would be used instead.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
    ],
    &quot;webhookStatuses&quot;: [ # The list of webhook call status in the order of call sequence.
      { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
        &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
        &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
          {
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
          },
        ],
        &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
      },
    ],
    &quot;webhookTags&quot;: [ # The list of webhook tags in the order of call sequence.
      &quot;A String&quot;,
    ],
  },
  &quot;responseId&quot;: &quot;A String&quot;, # Output only. The unique identifier of the response. It can be used to locate a response in the training example set or for reporting issues.
  &quot;responseType&quot;: &quot;A String&quot;, # Response type.
}</pre>
</div>

</body></html>