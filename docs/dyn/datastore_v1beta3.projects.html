<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="datastore_v1beta3.html">Google Cloud Datastore API</a> . <a href="datastore_v1beta3.projects.html">projects</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#allocateIds">allocateIds(projectId, body, x__xgafv=None)</a></code></p>
<p class="firstline">Allocates IDs for the given keys, which is useful for referencing an entity</p>
<p class="toc_element">
  <code><a href="#beginTransaction">beginTransaction(projectId, body, x__xgafv=None)</a></code></p>
<p class="firstline">Begins a new transaction.</p>
<p class="toc_element">
  <code><a href="#commit">commit(projectId, body, x__xgafv=None)</a></code></p>
<p class="firstline">Commits a transaction, optionally creating, deleting or modifying some</p>
<p class="toc_element">
  <code><a href="#lookup">lookup(projectId, body, x__xgafv=None)</a></code></p>
<p class="firstline">Looks up entities by key.</p>
<p class="toc_element">
  <code><a href="#rollback">rollback(projectId, body, x__xgafv=None)</a></code></p>
<p class="firstline">Rolls back a transaction.</p>
<p class="toc_element">
  <code><a href="#runQuery">runQuery(projectId, body, x__xgafv=None)</a></code></p>
<p class="firstline">Queries for entities.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="allocateIds">allocateIds(projectId, body, x__xgafv=None)</code>
  <pre>Allocates IDs for the given keys, which is useful for referencing an entity
before it is inserted.

Args:
  projectId: string, The ID of the project against which to make the request. (required)
  body: object, The request body. (required)
    The object takes the form of:

{ # The request for Datastore.AllocateIds.
    "keys": [ # A list of keys with incomplete key paths for which to allocate IDs.
        # No key may be reserved/read-only.
      { # A unique identifier for an entity.
          # If a key's partition ID or any of its path kinds or names are
          # reserved/read-only, the key is reserved/read-only.
          # A reserved/read-only key is forbidden in certain documented contexts.
        "path": [ # The entity path.
            # An entity path consists of one or more elements composed of a kind and a
            # string or numerical identifier, which identify entities. The first
            # element identifies a _root entity_, the second element identifies
            # a _child_ of the root entity, the third element identifies a child of the
            # second entity, and so forth. The entities identified by all prefixes of
            # the path are called the element's _ancestors_.
            #
            # An entity path is always fully complete: *all* of the entity's ancestors
            # are required to be in the path along with the entity identifier itself.
            # The only exception is that in some documented cases, the identifier in the
            # last path element (for the entity) itself may be omitted. For example,
            # the last path element of the key of `Mutation.insert` may have no
            # identifier.
            #
            # A path can never be empty, and a path can have at most 100 elements.
          { # A (kind, ID/name) pair used to construct a key path.
              #
              # If either name or ID is set, the element is complete.
              # If neither is set, the element is incomplete.
            "kind": "A String", # The kind of the entity.
                # A kind matching regex `__.*__` is reserved/read-only.
                # A kind must not contain more than 1500 bytes when UTF-8 encoded.
                # Cannot be `""`.
            "id": "A String", # The auto-allocated ID of the entity.
                # Never equal to zero. Values less than zero are discouraged and may not
                # be supported in the future.
            "name": "A String", # The name of the entity.
                # A name matching regex `__.*__` is reserved/read-only.
                # A name must not be more than 1500 bytes when UTF-8 encoded.
                # Cannot be `""`.
          },
        ],
        "partitionId": { # A partition ID identifies a grouping of entities. The grouping is always # Entities are partitioned into subsets, currently identified by a project
            # ID and namespace ID.
            # Queries are scoped to a single partition.
            # by project and namespace, however the namespace ID may be empty.
            #
            # A partition ID contains several dimensions:
            # project ID and namespace ID.
            #
            # Partition dimensions:
            #
            # - May be `""`.
            # - Must be valid UTF-8 bytes.
            # - Must have values that match regex `[A-Za-z\d\.\-_]{1,100}`
            # If the value of any dimension matches regex `__.*__`, the partition is
            # reserved/read-only.
            # A reserved/read-only partition ID is forbidden in certain documented
            # contexts.
            #
            # Foreign partition IDs (in which the project ID does
            # not match the context project ID ) are discouraged.
            # Reads and writes of foreign partition IDs may fail if the project is not in an active state.
          "projectId": "A String", # The ID of the project to which the entities belong.
          "namespaceId": "A String", # If not empty, the ID of the namespace to which the entities belong.
        },
      },
    ],
  }

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The response for Datastore.AllocateIds.
    "keys": [ # The keys specified in the request (in the same order), each with
        # its key path completed with a newly allocated ID.
      { # A unique identifier for an entity.
          # If a key's partition ID or any of its path kinds or names are
          # reserved/read-only, the key is reserved/read-only.
          # A reserved/read-only key is forbidden in certain documented contexts.
        "path": [ # The entity path.
            # An entity path consists of one or more elements composed of a kind and a
            # string or numerical identifier, which identify entities. The first
            # element identifies a _root entity_, the second element identifies
            # a _child_ of the root entity, the third element identifies a child of the
            # second entity, and so forth. The entities identified by all prefixes of
            # the path are called the element's _ancestors_.
            #
            # An entity path is always fully complete: *all* of the entity's ancestors
            # are required to be in the path along with the entity identifier itself.
            # The only exception is that in some documented cases, the identifier in the
            # last path element (for the entity) itself may be omitted. For example,
            # the last path element of the key of `Mutation.insert` may have no
            # identifier.
            #
            # A path can never be empty, and a path can have at most 100 elements.
          { # A (kind, ID/name) pair used to construct a key path.
              #
              # If either name or ID is set, the element is complete.
              # If neither is set, the element is incomplete.
            "kind": "A String", # The kind of the entity.
                # A kind matching regex `__.*__` is reserved/read-only.
                # A kind must not contain more than 1500 bytes when UTF-8 encoded.
                # Cannot be `""`.
            "id": "A String", # The auto-allocated ID of the entity.
                # Never equal to zero. Values less than zero are discouraged and may not
                # be supported in the future.
            "name": "A String", # The name of the entity.
                # A name matching regex `__.*__` is reserved/read-only.
                # A name must not be more than 1500 bytes when UTF-8 encoded.
                # Cannot be `""`.
          },
        ],
        "partitionId": { # A partition ID identifies a grouping of entities. The grouping is always # Entities are partitioned into subsets, currently identified by a project
            # ID and namespace ID.
            # Queries are scoped to a single partition.
            # by project and namespace, however the namespace ID may be empty.
            #
            # A partition ID contains several dimensions:
            # project ID and namespace ID.
            #
            # Partition dimensions:
            #
            # - May be `""`.
            # - Must be valid UTF-8 bytes.
            # - Must have values that match regex `[A-Za-z\d\.\-_]{1,100}`
            # If the value of any dimension matches regex `__.*__`, the partition is
            # reserved/read-only.
            # A reserved/read-only partition ID is forbidden in certain documented
            # contexts.
            #
            # Foreign partition IDs (in which the project ID does
            # not match the context project ID ) are discouraged.
            # Reads and writes of foreign partition IDs may fail if the project is not in an active state.
          "projectId": "A String", # The ID of the project to which the entities belong.
          "namespaceId": "A String", # If not empty, the ID of the namespace to which the entities belong.
        },
      },
    ],
  }</pre>
</div>

<div class="method">
    <code class="details" id="beginTransaction">beginTransaction(projectId, body, x__xgafv=None)</code>
  <pre>Begins a new transaction.

Args:
  projectId: string, The ID of the project against which to make the request. (required)
  body: object, The request body. (required)
    The object takes the form of:

{ # The request for Datastore.BeginTransaction.
  }

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The response for Datastore.BeginTransaction.
    "transaction": "A String", # The transaction identifier (always present).
  }</pre>
</div>

<div class="method">
    <code class="details" id="commit">commit(projectId, body, x__xgafv=None)</code>
  <pre>Commits a transaction, optionally creating, deleting or modifying some
entities.

Args:
  projectId: string, The ID of the project against which to make the request. (required)
  body: object, The request body. (required)
    The object takes the form of:

{ # The request for Datastore.Commit.
    "transaction": "A String", # The identifier of the transaction associated with the commit. A
        # transaction identifier is returned by a call to
        # Datastore.BeginTransaction.
    "mutations": [ # The mutations to perform.
        # 
        # When mode is `TRANSACTIONAL`, mutations affecting a single entity are
        # applied in order. The following sequences of mutations affecting a single
        # entity are not permitted in a single `Commit` request:
        # 
        # - `insert` followed by `insert`
        # - `update` followed by `insert`
        # - `upsert` followed by `insert`
        # - `delete` followed by `update`
        # 
        # When mode is `NON_TRANSACTIONAL`, no two mutations may affect a single
        # entity.
      { # A mutation to apply to an entity.
        "insert": { # A Datastore data object. # The entity to insert. The entity must not already exist.
            # The entity key's final path element may be incomplete.
            #
            # An entity is limited to 1 megabyte when stored. That _roughly_
            # corresponds to a limit of 1 megabyte for the serialized form of this
            # message.
          "properties": { # The entity's properties.
              # The map's keys are property names.
              # A property name matching regex `__.*__` is reserved.
              # A reserved property name is forbidden in certain documented contexts.
              # The name must not contain more than 500 characters.
              # The name cannot be `""`.
            "a_key": { # A message that can hold any of the supported value types and associated
                # metadata.
              "entityValue": # Object with schema name: Entity # An entity value.
                  #
                  # - May have no key.
                  # - May have a key with an incomplete key path.
                  # - May have a reserved/read-only key.
              "timestampValue": "A String", # A timestamp value.
                  # When stored in the Datastore, precise only to microseconds;
                  # any additional precision is rounded down.
              "nullValue": "A String", # A null value.
              "excludeFromIndexes": True or False, # If the value should be excluded from all indexes including those defined
                  # explicitly.
              "doubleValue": 3.14, # A double value.
              "meaning": 42, # The `meaning` field should only be populated for backwards compatibility.
              "keyValue": { # A unique identifier for an entity. # A key value.
                  # If a key's partition ID or any of its path kinds or names are
                  # reserved/read-only, the key is reserved/read-only.
                  # A reserved/read-only key is forbidden in certain documented contexts.
                "path": [ # The entity path.
                    # An entity path consists of one or more elements composed of a kind and a
                    # string or numerical identifier, which identify entities. The first
                    # element identifies a _root entity_, the second element identifies
                    # a _child_ of the root entity, the third element identifies a child of the
                    # second entity, and so forth. The entities identified by all prefixes of
                    # the path are called the element's _ancestors_.
                    #
                    # An entity path is always fully complete: *all* of the entity's ancestors
                    # are required to be in the path along with the entity identifier itself.
                    # The only exception is that in some documented cases, the identifier in the
                    # last path element (for the entity) itself may be omitted. For example,
                    # the last path element of the key of `Mutation.insert` may have no
                    # identifier.
                    #
                    # A path can never be empty, and a path can have at most 100 elements.
                  { # A (kind, ID/name) pair used to construct a key path.
                      #
                      # If either name or ID is set, the element is complete.
                      # If neither is set, the element is incomplete.
                    "kind": "A String", # The kind of the entity.
                        # A kind matching regex `__.*__` is reserved/read-only.
                        # A kind must not contain more than 1500 bytes when UTF-8 encoded.
                        # Cannot be `""`.
                    "id": "A String", # The auto-allocated ID of the entity.
                        # Never equal to zero. Values less than zero are discouraged and may not
                        # be supported in the future.
                    "name": "A String", # The name of the entity.
                        # A name matching regex `__.*__` is reserved/read-only.
                        # A name must not be more than 1500 bytes when UTF-8 encoded.
                        # Cannot be `""`.
                  },
                ],
                "partitionId": { # A partition ID identifies a grouping of entities. The grouping is always # Entities are partitioned into subsets, currently identified by a project
                    # ID and namespace ID.
                    # Queries are scoped to a single partition.
                    # by project and namespace, however the namespace ID may be empty.
                    #
                    # A partition ID contains several dimensions:
                    # project ID and namespace ID.
                    #
                    # Partition dimensions:
                    #
                    # - May be `""`.
                    # - Must be valid UTF-8 bytes.
                    # - Must have values that match regex `[A-Za-z\d\.\-_]{1,100}`
                    # If the value of any dimension matches regex `__.*__`, the partition is
                    # reserved/read-only.
                    # A reserved/read-only partition ID is forbidden in certain documented
                    # contexts.
                    #
                    # Foreign partition IDs (in which the project ID does
                    # not match the context project ID ) are discouraged.
                    # Reads and writes of foreign partition IDs may fail if the project is not in an active state.
                  "projectId": "A String", # The ID of the project to which the entities belong.
                  "namespaceId": "A String", # If not empty, the ID of the namespace to which the entities belong.
                },
              },
              "stringValue": "A String", # A UTF-8 encoded string value.
                  # When `exclude_from_indexes` is false (it is indexed) , may have at most 1500 bytes.
                  # Otherwise, may be set to at least 1,000,000 bytes.
              "blobValue": "A String", # A blob value.
                  # May have at most 1,000,000 bytes.
                  # When `exclude_from_indexes` is false, may have at most 1500 bytes.
                  # In JSON requests, must be base64-encoded.
              "booleanValue": True or False, # A boolean value.
              "arrayValue": { # An array value. # An array value.
                  # Cannot contain another array value.
                  # A `Value` instance that sets field `array_value` must not set fields
                  # `meaning` or `exclude_from_indexes`.
                "values": [ # Values in the array.
                    # The order of this array may not be preserved if it contains a mix of
                    # indexed and unindexed values.
                  # Object with schema name: Value
                ],
              },
              "integerValue": "A String", # An integer value.
              "geoPointValue": { # An object representing a latitude/longitude pair. This is expressed as a pair # A geo point value representing a point on the surface of Earth.
                  # of doubles representing degrees latitude and degrees longitude. Unless
                  # specified otherwise, this must conform to the
                  # <a href="http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf">WGS84
                  # standard</a>. Values must be within normalized ranges.
                  #
                  # Example of normalization code in Python:
                  #
                  #     def NormalizeLongitude(longitude):
                  #       """Wraps decimal degrees longitude to [-180.0, 180.0]."""
                  #       q, r = divmod(longitude, 360.0)
                  #       if r > 180.0 or (r == 180.0 and q <= -1.0):
                  #         return r - 360.0
                  #       return r
                  #
                  #     def NormalizeLatLng(latitude, longitude):
                  #       """Wraps decimal degrees latitude and longitude to
                  #       [-90.0, 90.0] and [-180.0, 180.0], respectively."""
                  #       r = latitude % 360.0
                  #       if r <= 90.0:
                  #         return r, NormalizeLongitude(longitude)
                  #       elif r >= 270.0:
                  #         return r - 360, NormalizeLongitude(longitude)
                  #       else:
                  #         return 180 - r, NormalizeLongitude(longitude + 180.0)
                  #
                  #     assert 180.0 == NormalizeLongitude(180.0)
                  #     assert -180.0 == NormalizeLongitude(-180.0)
                  #     assert -179.0 == NormalizeLongitude(181.0)
                  #     assert (0.0, 0.0) == NormalizeLatLng(360.0, 0.0)
                  #     assert (0.0, 0.0) == NormalizeLatLng(-360.0, 0.0)
                  #     assert (85.0, 180.0) == NormalizeLatLng(95.0, 0.0)
                  #     assert (-85.0, -170.0) == NormalizeLatLng(-95.0, 10.0)
                  #     assert (90.0, 10.0) == NormalizeLatLng(90.0, 10.0)
                  #     assert (-90.0, -10.0) == NormalizeLatLng(-90.0, -10.0)
                  #     assert (0.0, -170.0) == NormalizeLatLng(-180.0, 10.0)
                  #     assert (0.0, -170.0) == NormalizeLatLng(180.0, 10.0)
                  #     assert (-90.0, 10.0) == NormalizeLatLng(270.0, 10.0)
                  #     assert (90.0, 10.0) == NormalizeLatLng(-270.0, 10.0)
                "latitude": 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
                "longitude": 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
              },
            },
          },
          "key": { # A unique identifier for an entity. # The entity's key.
              #
              # An entity must have a key, unless otherwise documented (for example,
              # an entity in `Value.entity_value` may have no key).
              # An entity's kind is its key path's last element's kind,
              # or null if it has no key.
              # If a key's partition ID or any of its path kinds or names are
              # reserved/read-only, the key is reserved/read-only.
              # A reserved/read-only key is forbidden in certain documented contexts.
            "path": [ # The entity path.
                # An entity path consists of one or more elements composed of a kind and a
                # string or numerical identifier, which identify entities. The first
                # element identifies a _root entity_, the second element identifies
                # a _child_ of the root entity, the third element identifies a child of the
                # second entity, and so forth. The entities identified by all prefixes of
                # the path are called the element's _ancestors_.
                #
                # An entity path is always fully complete: *all* of the entity's ancestors
                # are required to be in the path along with the entity identifier itself.
                # The only exception is that in some documented cases, the identifier in the
                # last path element (for the entity) itself may be omitted. For example,
                # the last path element of the key of `Mutation.insert` may have no
                # identifier.
                #
                # A path can never be empty, and a path can have at most 100 elements.
              { # A (kind, ID/name) pair used to construct a key path.
                  #
                  # If either name or ID is set, the element is complete.
                  # If neither is set, the element is incomplete.
                "kind": "A String", # The kind of the entity.
                    # A kind matching regex `__.*__` is reserved/read-only.
                    # A kind must not contain more than 1500 bytes when UTF-8 encoded.
                    # Cannot be `""`.
                "id": "A String", # The auto-allocated ID of the entity.
                    # Never equal to zero. Values less than zero are discouraged and may not
                    # be supported in the future.
                "name": "A String", # The name of the entity.
                    # A name matching regex `__.*__` is reserved/read-only.
                    # A name must not be more than 1500 bytes when UTF-8 encoded.
                    # Cannot be `""`.
              },
            ],
            "partitionId": { # A partition ID identifies a grouping of entities. The grouping is always # Entities are partitioned into subsets, currently identified by a project
                # ID and namespace ID.
                # Queries are scoped to a single partition.
                # by project and namespace, however the namespace ID may be empty.
                #
                # A partition ID contains several dimensions:
                # project ID and namespace ID.
                #
                # Partition dimensions:
                #
                # - May be `""`.
                # - Must be valid UTF-8 bytes.
                # - Must have values that match regex `[A-Za-z\d\.\-_]{1,100}`
                # If the value of any dimension matches regex `__.*__`, the partition is
                # reserved/read-only.
                # A reserved/read-only partition ID is forbidden in certain documented
                # contexts.
                #
                # Foreign partition IDs (in which the project ID does
                # not match the context project ID ) are discouraged.
                # Reads and writes of foreign partition IDs may fail if the project is not in an active state.
              "projectId": "A String", # The ID of the project to which the entities belong.
              "namespaceId": "A String", # If not empty, the ID of the namespace to which the entities belong.
            },
          },
        },
        "upsert": { # A Datastore data object. # The entity to upsert. The entity may or may not already exist.
            # The entity key's final path element may be incomplete.
            #
            # An entity is limited to 1 megabyte when stored. That _roughly_
            # corresponds to a limit of 1 megabyte for the serialized form of this
            # message.
          "properties": { # The entity's properties.
              # The map's keys are property names.
              # A property name matching regex `__.*__` is reserved.
              # A reserved property name is forbidden in certain documented contexts.
              # The name must not contain more than 500 characters.
              # The name cannot be `""`.
            "a_key": { # A message that can hold any of the supported value types and associated
                # metadata.
              "entityValue": # Object with schema name: Entity # An entity value.
                  #
                  # - May have no key.
                  # - May have a key with an incomplete key path.
                  # - May have a reserved/read-only key.
              "timestampValue": "A String", # A timestamp value.
                  # When stored in the Datastore, precise only to microseconds;
                  # any additional precision is rounded down.
              "nullValue": "A String", # A null value.
              "excludeFromIndexes": True or False, # If the value should be excluded from all indexes including those defined
                  # explicitly.
              "doubleValue": 3.14, # A double value.
              "meaning": 42, # The `meaning` field should only be populated for backwards compatibility.
              "keyValue": { # A unique identifier for an entity. # A key value.
                  # If a key's partition ID or any of its path kinds or names are
                  # reserved/read-only, the key is reserved/read-only.
                  # A reserved/read-only key is forbidden in certain documented contexts.
                "path": [ # The entity path.
                    # An entity path consists of one or more elements composed of a kind and a
                    # string or numerical identifier, which identify entities. The first
                    # element identifies a _root entity_, the second element identifies
                    # a _child_ of the root entity, the third element identifies a child of the
                    # second entity, and so forth. The entities identified by all prefixes of
                    # the path are called the element's _ancestors_.
                    #
                    # An entity path is always fully complete: *all* of the entity's ancestors
                    # are required to be in the path along with the entity identifier itself.
                    # The only exception is that in some documented cases, the identifier in the
                    # last path element (for the entity) itself may be omitted. For example,
                    # the last path element of the key of `Mutation.insert` may have no
                    # identifier.
                    #
                    # A path can never be empty, and a path can have at most 100 elements.
                  { # A (kind, ID/name) pair used to construct a key path.
                      #
                      # If either name or ID is set, the element is complete.
                      # If neither is set, the element is incomplete.
                    "kind": "A String", # The kind of the entity.
                        # A kind matching regex `__.*__` is reserved/read-only.
                        # A kind must not contain more than 1500 bytes when UTF-8 encoded.
                        # Cannot be `""`.
                    "id": "A String", # The auto-allocated ID of the entity.
                        # Never equal to zero. Values less than zero are discouraged and may not
                        # be supported in the future.
                    "name": "A String", # The name of the entity.
                        # A name matching regex `__.*__` is reserved/read-only.
                        # A name must not be more than 1500 bytes when UTF-8 encoded.
                        # Cannot be `""`.
                  },
                ],
                "partitionId": { # A partition ID identifies a grouping of entities. The grouping is always # Entities are partitioned into subsets, currently identified by a project
                    # ID and namespace ID.
                    # Queries are scoped to a single partition.
                    # by project and namespace, however the namespace ID may be empty.
                    #
                    # A partition ID contains several dimensions:
                    # project ID and namespace ID.
                    #
                    # Partition dimensions:
                    #
                    # - May be `""`.
                    # - Must be valid UTF-8 bytes.
                    # - Must have values that match regex `[A-Za-z\d\.\-_]{1,100}`
                    # If the value of any dimension matches regex `__.*__`, the partition is
                    # reserved/read-only.
                    # A reserved/read-only partition ID is forbidden in certain documented
                    # contexts.
                    #
                    # Foreign partition IDs (in which the project ID does
                    # not match the context project ID ) are discouraged.
                    # Reads and writes of foreign partition IDs may fail if the project is not in an active state.
                  "projectId": "A String", # The ID of the project to which the entities belong.
                  "namespaceId": "A String", # If not empty, the ID of the namespace to which the entities belong.
                },
              },
              "stringValue": "A String", # A UTF-8 encoded string value.
                  # When `exclude_from_indexes` is false (it is indexed) , may have at most 1500 bytes.
                  # Otherwise, may be set to at least 1,000,000 bytes.
              "blobValue": "A String", # A blob value.
                  # May have at most 1,000,000 bytes.
                  # When `exclude_from_indexes` is false, may have at most 1500 bytes.
                  # In JSON requests, must be base64-encoded.
              "booleanValue": True or False, # A boolean value.
              "arrayValue": { # An array value. # An array value.
                  # Cannot contain another array value.
                  # A `Value` instance that sets field `array_value` must not set fields
                  # `meaning` or `exclude_from_indexes`.
                "values": [ # Values in the array.
                    # The order of this array may not be preserved if it contains a mix of
                    # indexed and unindexed values.
                  # Object with schema name: Value
                ],
              },
              "integerValue": "A String", # An integer value.
              "geoPointValue": { # An object representing a latitude/longitude pair. This is expressed as a pair # A geo point value representing a point on the surface of Earth.
                  # of doubles representing degrees latitude and degrees longitude. Unless
                  # specified otherwise, this must conform to the
                  # <a href="http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf">WGS84
                  # standard</a>. Values must be within normalized ranges.
                  #
                  # Example of normalization code in Python:
                  #
                  #     def NormalizeLongitude(longitude):
                  #       """Wraps decimal degrees longitude to [-180.0, 180.0]."""
                  #       q, r = divmod(longitude, 360.0)
                  #       if r > 180.0 or (r == 180.0 and q <= -1.0):
                  #         return r - 360.0
                  #       return r
                  #
                  #     def NormalizeLatLng(latitude, longitude):
                  #       """Wraps decimal degrees latitude and longitude to
                  #       [-90.0, 90.0] and [-180.0, 180.0], respectively."""
                  #       r = latitude % 360.0
                  #       if r <= 90.0:
                  #         return r, NormalizeLongitude(longitude)
                  #       elif r >= 270.0:
                  #         return r - 360, NormalizeLongitude(longitude)
                  #       else:
                  #         return 180 - r, NormalizeLongitude(longitude + 180.0)
                  #
                  #     assert 180.0 == NormalizeLongitude(180.0)
                  #     assert -180.0 == NormalizeLongitude(-180.0)
                  #     assert -179.0 == NormalizeLongitude(181.0)
                  #     assert (0.0, 0.0) == NormalizeLatLng(360.0, 0.0)
                  #     assert (0.0, 0.0) == NormalizeLatLng(-360.0, 0.0)
                  #     assert (85.0, 180.0) == NormalizeLatLng(95.0, 0.0)
                  #     assert (-85.0, -170.0) == NormalizeLatLng(-95.0, 10.0)
                  #     assert (90.0, 10.0) == NormalizeLatLng(90.0, 10.0)
                  #     assert (-90.0, -10.0) == NormalizeLatLng(-90.0, -10.0)
                  #     assert (0.0, -170.0) == NormalizeLatLng(-180.0, 10.0)
                  #     assert (0.0, -170.0) == NormalizeLatLng(180.0, 10.0)
                  #     assert (-90.0, 10.0) == NormalizeLatLng(270.0, 10.0)
                  #     assert (90.0, 10.0) == NormalizeLatLng(-270.0, 10.0)
                "latitude": 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
                "longitude": 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
              },
            },
          },
          "key": { # A unique identifier for an entity. # The entity's key.
              #
              # An entity must have a key, unless otherwise documented (for example,
              # an entity in `Value.entity_value` may have no key).
              # An entity's kind is its key path's last element's kind,
              # or null if it has no key.
              # If a key's partition ID or any of its path kinds or names are
              # reserved/read-only, the key is reserved/read-only.
              # A reserved/read-only key is forbidden in certain documented contexts.
            "path": [ # The entity path.
                # An entity path consists of one or more elements composed of a kind and a
                # string or numerical identifier, which identify entities. The first
                # element identifies a _root entity_, the second element identifies
                # a _child_ of the root entity, the third element identifies a child of the
                # second entity, and so forth. The entities identified by all prefixes of
                # the path are called the element's _ancestors_.
                #
                # An entity path is always fully complete: *all* of the entity's ancestors
                # are required to be in the path along with the entity identifier itself.
                # The only exception is that in some documented cases, the identifier in the
                # last path element (for the entity) itself may be omitted. For example,
                # the last path element of the key of `Mutation.insert` may have no
                # identifier.
                #
                # A path can never be empty, and a path can have at most 100 elements.
              { # A (kind, ID/name) pair used to construct a key path.
                  #
                  # If either name or ID is set, the element is complete.
                  # If neither is set, the element is incomplete.
                "kind": "A String", # The kind of the entity.
                    # A kind matching regex `__.*__` is reserved/read-only.
                    # A kind must not contain more than 1500 bytes when UTF-8 encoded.
                    # Cannot be `""`.
                "id": "A String", # The auto-allocated ID of the entity.
                    # Never equal to zero. Values less than zero are discouraged and may not
                    # be supported in the future.
                "name": "A String", # The name of the entity.
                    # A name matching regex `__.*__` is reserved/read-only.
                    # A name must not be more than 1500 bytes when UTF-8 encoded.
                    # Cannot be `""`.
              },
            ],
            "partitionId": { # A partition ID identifies a grouping of entities. The grouping is always # Entities are partitioned into subsets, currently identified by a project
                # ID and namespace ID.
                # Queries are scoped to a single partition.
                # by project and namespace, however the namespace ID may be empty.
                #
                # A partition ID contains several dimensions:
                # project ID and namespace ID.
                #
                # Partition dimensions:
                #
                # - May be `""`.
                # - Must be valid UTF-8 bytes.
                # - Must have values that match regex `[A-Za-z\d\.\-_]{1,100}`
                # If the value of any dimension matches regex `__.*__`, the partition is
                # reserved/read-only.
                # A reserved/read-only partition ID is forbidden in certain documented
                # contexts.
                #
                # Foreign partition IDs (in which the project ID does
                # not match the context project ID ) are discouraged.
                # Reads and writes of foreign partition IDs may fail if the project is not in an active state.
              "projectId": "A String", # The ID of the project to which the entities belong.
              "namespaceId": "A String", # If not empty, the ID of the namespace to which the entities belong.
            },
          },
        },
        "update": { # A Datastore data object. # The entity to update. The entity must already exist.
            # Must have a complete key path.
            #
            # An entity is limited to 1 megabyte when stored. That _roughly_
            # corresponds to a limit of 1 megabyte for the serialized form of this
            # message.
          "properties": { # The entity's properties.
              # The map's keys are property names.
              # A property name matching regex `__.*__` is reserved.
              # A reserved property name is forbidden in certain documented contexts.
              # The name must not contain more than 500 characters.
              # The name cannot be `""`.
            "a_key": { # A message that can hold any of the supported value types and associated
                # metadata.
              "entityValue": # Object with schema name: Entity # An entity value.
                  #
                  # - May have no key.
                  # - May have a key with an incomplete key path.
                  # - May have a reserved/read-only key.
              "timestampValue": "A String", # A timestamp value.
                  # When stored in the Datastore, precise only to microseconds;
                  # any additional precision is rounded down.
              "nullValue": "A String", # A null value.
              "excludeFromIndexes": True or False, # If the value should be excluded from all indexes including those defined
                  # explicitly.
              "doubleValue": 3.14, # A double value.
              "meaning": 42, # The `meaning` field should only be populated for backwards compatibility.
              "keyValue": { # A unique identifier for an entity. # A key value.
                  # If a key's partition ID or any of its path kinds or names are
                  # reserved/read-only, the key is reserved/read-only.
                  # A reserved/read-only key is forbidden in certain documented contexts.
                "path": [ # The entity path.
                    # An entity path consists of one or more elements composed of a kind and a
                    # string or numerical identifier, which identify entities. The first
                    # element identifies a _root entity_, the second element identifies
                    # a _child_ of the root entity, the third element identifies a child of the
                    # second entity, and so forth. The entities identified by all prefixes of
                    # the path are called the element's _ancestors_.
                    #
                    # An entity path is always fully complete: *all* of the entity's ancestors
                    # are required to be in the path along with the entity identifier itself.
                    # The only exception is that in some documented cases, the identifier in the
                    # last path element (for the entity) itself may be omitted. For example,
                    # the last path element of the key of `Mutation.insert` may have no
                    # identifier.
                    #
                    # A path can never be empty, and a path can have at most 100 elements.
                  { # A (kind, ID/name) pair used to construct a key path.
                      #
                      # If either name or ID is set, the element is complete.
                      # If neither is set, the element is incomplete.
                    "kind": "A String", # The kind of the entity.
                        # A kind matching regex `__.*__` is reserved/read-only.
                        # A kind must not contain more than 1500 bytes when UTF-8 encoded.
                        # Cannot be `""`.
                    "id": "A String", # The auto-allocated ID of the entity.
                        # Never equal to zero. Values less than zero are discouraged and may not
                        # be supported in the future.
                    "name": "A String", # The name of the entity.
                        # A name matching regex `__.*__` is reserved/read-only.
                        # A name must not be more than 1500 bytes when UTF-8 encoded.
                        # Cannot be `""`.
                  },
                ],
                "partitionId": { # A partition ID identifies a grouping of entities. The grouping is always # Entities are partitioned into subsets, currently identified by a project
                    # ID and namespace ID.
                    # Queries are scoped to a single partition.
                    # by project and namespace, however the namespace ID may be empty.
                    #
                    # A partition ID contains several dimensions:
                    # project ID and namespace ID.
                    #
                    # Partition dimensions:
                    #
                    # - May be `""`.
                    # - Must be valid UTF-8 bytes.
                    # - Must have values that match regex `[A-Za-z\d\.\-_]{1,100}`
                    # If the value of any dimension matches regex `__.*__`, the partition is
                    # reserved/read-only.
                    # A reserved/read-only partition ID is forbidden in certain documented
                    # contexts.
                    #
                    # Foreign partition IDs (in which the project ID does
                    # not match the context project ID ) are discouraged.
                    # Reads and writes of foreign partition IDs may fail if the project is not in an active state.
                  "projectId": "A String", # The ID of the project to which the entities belong.
                  "namespaceId": "A String", # If not empty, the ID of the namespace to which the entities belong.
                },
              },
              "stringValue": "A String", # A UTF-8 encoded string value.
                  # When `exclude_from_indexes` is false (it is indexed) , may have at most 1500 bytes.
                  # Otherwise, may be set to at least 1,000,000 bytes.
              "blobValue": "A String", # A blob value.
                  # May have at most 1,000,000 bytes.
                  # When `exclude_from_indexes` is false, may have at most 1500 bytes.
                  # In JSON requests, must be base64-encoded.
              "booleanValue": True or False, # A boolean value.
              "arrayValue": { # An array value. # An array value.
                  # Cannot contain another array value.
                  # A `Value` instance that sets field `array_value` must not set fields
                  # `meaning` or `exclude_from_indexes`.
                "values": [ # Values in the array.
                    # The order of this array may not be preserved if it contains a mix of
                    # indexed and unindexed values.
                  # Object with schema name: Value
                ],
              },
              "integerValue": "A String", # An integer value.
              "geoPointValue": { # An object representing a latitude/longitude pair. This is expressed as a pair # A geo point value representing a point on the surface of Earth.
                  # of doubles representing degrees latitude and degrees longitude. Unless
                  # specified otherwise, this must conform to the
                  # <a href="http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf">WGS84
                  # standard</a>. Values must be within normalized ranges.
                  #
                  # Example of normalization code in Python:
                  #
                  #     def NormalizeLongitude(longitude):
                  #       """Wraps decimal degrees longitude to [-180.0, 180.0]."""
                  #       q, r = divmod(longitude, 360.0)
                  #       if r > 180.0 or (r == 180.0 and q <= -1.0):
                  #         return r - 360.0
                  #       return r
                  #
                  #     def NormalizeLatLng(latitude, longitude):
                  #       """Wraps decimal degrees latitude and longitude to
                  #       [-90.0, 90.0] and [-180.0, 180.0], respectively."""
                  #       r = latitude % 360.0
                  #       if r <= 90.0:
                  #         return r, NormalizeLongitude(longitude)
                  #       elif r >= 270.0:
                  #         return r - 360, NormalizeLongitude(longitude)
                  #       else:
                  #         return 180 - r, NormalizeLongitude(longitude + 180.0)
                  #
                  #     assert 180.0 == NormalizeLongitude(180.0)
                  #     assert -180.0 == NormalizeLongitude(-180.0)
                  #     assert -179.0 == NormalizeLongitude(181.0)
                  #     assert (0.0, 0.0) == NormalizeLatLng(360.0, 0.0)
                  #     assert (0.0, 0.0) == NormalizeLatLng(-360.0, 0.0)
                  #     assert (85.0, 180.0) == NormalizeLatLng(95.0, 0.0)
                  #     assert (-85.0, -170.0) == NormalizeLatLng(-95.0, 10.0)
                  #     assert (90.0, 10.0) == NormalizeLatLng(90.0, 10.0)
                  #     assert (-90.0, -10.0) == NormalizeLatLng(-90.0, -10.0)
                  #     assert (0.0, -170.0) == NormalizeLatLng(-180.0, 10.0)
                  #     assert (0.0, -170.0) == NormalizeLatLng(180.0, 10.0)
                  #     assert (-90.0, 10.0) == NormalizeLatLng(270.0, 10.0)
                  #     assert (90.0, 10.0) == NormalizeLatLng(-270.0, 10.0)
                "latitude": 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
                "longitude": 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
              },
            },
          },
          "key": { # A unique identifier for an entity. # The entity's key.
              #
              # An entity must have a key, unless otherwise documented (for example,
              # an entity in `Value.entity_value` may have no key).
              # An entity's kind is its key path's last element's kind,
              # or null if it has no key.
              # If a key's partition ID or any of its path kinds or names are
              # reserved/read-only, the key is reserved/read-only.
              # A reserved/read-only key is forbidden in certain documented contexts.
            "path": [ # The entity path.
                # An entity path consists of one or more elements composed of a kind and a
                # string or numerical identifier, which identify entities. The first
                # element identifies a _root entity_, the second element identifies
                # a _child_ of the root entity, the third element identifies a child of the
                # second entity, and so forth. The entities identified by all prefixes of
                # the path are called the element's _ancestors_.
                #
                # An entity path is always fully complete: *all* of the entity's ancestors
                # are required to be in the path along with the entity identifier itself.
                # The only exception is that in some documented cases, the identifier in the
                # last path element (for the entity) itself may be omitted. For example,
                # the last path element of the key of `Mutation.insert` may have no
                # identifier.
                #
                # A path can never be empty, and a path can have at most 100 elements.
              { # A (kind, ID/name) pair used to construct a key path.
                  #
                  # If either name or ID is set, the element is complete.
                  # If neither is set, the element is incomplete.
                "kind": "A String", # The kind of the entity.
                    # A kind matching regex `__.*__` is reserved/read-only.
                    # A kind must not contain more than 1500 bytes when UTF-8 encoded.
                    # Cannot be `""`.
                "id": "A String", # The auto-allocated ID of the entity.
                    # Never equal to zero. Values less than zero are discouraged and may not
                    # be supported in the future.
                "name": "A String", # The name of the entity.
                    # A name matching regex `__.*__` is reserved/read-only.
                    # A name must not be more than 1500 bytes when UTF-8 encoded.
                    # Cannot be `""`.
              },
            ],
            "partitionId": { # A partition ID identifies a grouping of entities. The grouping is always # Entities are partitioned into subsets, currently identified by a project
                # ID and namespace ID.
                # Queries are scoped to a single partition.
                # by project and namespace, however the namespace ID may be empty.
                #
                # A partition ID contains several dimensions:
                # project ID and namespace ID.
                #
                # Partition dimensions:
                #
                # - May be `""`.
                # - Must be valid UTF-8 bytes.
                # - Must have values that match regex `[A-Za-z\d\.\-_]{1,100}`
                # If the value of any dimension matches regex `__.*__`, the partition is
                # reserved/read-only.
                # A reserved/read-only partition ID is forbidden in certain documented
                # contexts.
                #
                # Foreign partition IDs (in which the project ID does
                # not match the context project ID ) are discouraged.
                # Reads and writes of foreign partition IDs may fail if the project is not in an active state.
              "projectId": "A String", # The ID of the project to which the entities belong.
              "namespaceId": "A String", # If not empty, the ID of the namespace to which the entities belong.
            },
          },
        },
        "baseVersion": "A String", # The version of the entity that this mutation is being applied to. If this
            # does not match the current version on the server, the mutation conflicts.
        "delete": { # A unique identifier for an entity. # The key of the entity to delete. The entity may or may not already exist.
            # Must have a complete key path and must not be reserved/read-only.
            # If a key's partition ID or any of its path kinds or names are
            # reserved/read-only, the key is reserved/read-only.
            # A reserved/read-only key is forbidden in certain documented contexts.
          "path": [ # The entity path.
              # An entity path consists of one or more elements composed of a kind and a
              # string or numerical identifier, which identify entities. The first
              # element identifies a _root entity_, the second element identifies
              # a _child_ of the root entity, the third element identifies a child of the
              # second entity, and so forth. The entities identified by all prefixes of
              # the path are called the element's _ancestors_.
              #
              # An entity path is always fully complete: *all* of the entity's ancestors
              # are required to be in the path along with the entity identifier itself.
              # The only exception is that in some documented cases, the identifier in the
              # last path element (for the entity) itself may be omitted. For example,
              # the last path element of the key of `Mutation.insert` may have no
              # identifier.
              #
              # A path can never be empty, and a path can have at most 100 elements.
            { # A (kind, ID/name) pair used to construct a key path.
                #
                # If either name or ID is set, the element is complete.
                # If neither is set, the element is incomplete.
              "kind": "A String", # The kind of the entity.
                  # A kind matching regex `__.*__` is reserved/read-only.
                  # A kind must not contain more than 1500 bytes when UTF-8 encoded.
                  # Cannot be `""`.
              "id": "A String", # The auto-allocated ID of the entity.
                  # Never equal to zero. Values less than zero are discouraged and may not
                  # be supported in the future.
              "name": "A String", # The name of the entity.
                  # A name matching regex `__.*__` is reserved/read-only.
                  # A name must not be more than 1500 bytes when UTF-8 encoded.
                  # Cannot be `""`.
            },
          ],
          "partitionId": { # A partition ID identifies a grouping of entities. The grouping is always # Entities are partitioned into subsets, currently identified by a project
              # ID and namespace ID.
              # Queries are scoped to a single partition.
              # by project and namespace, however the namespace ID may be empty.
              #
              # A partition ID contains several dimensions:
              # project ID and namespace ID.
              #
              # Partition dimensions:
              #
              # - May be `""`.
              # - Must be valid UTF-8 bytes.
              # - Must have values that match regex `[A-Za-z\d\.\-_]{1,100}`
              # If the value of any dimension matches regex `__.*__`, the partition is
              # reserved/read-only.
              # A reserved/read-only partition ID is forbidden in certain documented
              # contexts.
              #
              # Foreign partition IDs (in which the project ID does
              # not match the context project ID ) are discouraged.
              # Reads and writes of foreign partition IDs may fail if the project is not in an active state.
            "projectId": "A String", # The ID of the project to which the entities belong.
            "namespaceId": "A String", # If not empty, the ID of the namespace to which the entities belong.
          },
        },
      },
    ],
    "mode": "A String", # The type of commit to perform. Defaults to `TRANSACTIONAL`.
  }

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The response for Datastore.Commit.
    "indexUpdates": 42, # The number of index entries updated during the commit, or zero if none were
        # updated.
    "mutationResults": [ # The result of performing the mutations.
        # The i-th mutation result corresponds to the i-th mutation in the request.
      { # The result of applying a mutation.
        "version": "A String", # The version of the entity on the server after processing the mutation. If
            # the mutation doesn't change anything on the server, then the version will
            # be the version of the current entity or, if no entity is present, a version
            # that is strictly greater than the version of any previous entity and less
            # than the version of any possible future entity.
        "conflictDetected": True or False, # Whether a conflict was detected for this mutation. Always false when a
            # conflict detection strategy field is not set in the mutation.
        "key": { # A unique identifier for an entity. # The automatically allocated key.
            # Set only when the mutation allocated a key.
            # If a key's partition ID or any of its path kinds or names are
            # reserved/read-only, the key is reserved/read-only.
            # A reserved/read-only key is forbidden in certain documented contexts.
          "path": [ # The entity path.
              # An entity path consists of one or more elements composed of a kind and a
              # string or numerical identifier, which identify entities. The first
              # element identifies a _root entity_, the second element identifies
              # a _child_ of the root entity, the third element identifies a child of the
              # second entity, and so forth. The entities identified by all prefixes of
              # the path are called the element's _ancestors_.
              #
              # An entity path is always fully complete: *all* of the entity's ancestors
              # are required to be in the path along with the entity identifier itself.
              # The only exception is that in some documented cases, the identifier in the
              # last path element (for the entity) itself may be omitted. For example,
              # the last path element of the key of `Mutation.insert` may have no
              # identifier.
              #
              # A path can never be empty, and a path can have at most 100 elements.
            { # A (kind, ID/name) pair used to construct a key path.
                #
                # If either name or ID is set, the element is complete.
                # If neither is set, the element is incomplete.
              "kind": "A String", # The kind of the entity.
                  # A kind matching regex `__.*__` is reserved/read-only.
                  # A kind must not contain more than 1500 bytes when UTF-8 encoded.
                  # Cannot be `""`.
              "id": "A String", # The auto-allocated ID of the entity.
                  # Never equal to zero. Values less than zero are discouraged and may not
                  # be supported in the future.
              "name": "A String", # The name of the entity.
                  # A name matching regex `__.*__` is reserved/read-only.
                  # A name must not be more than 1500 bytes when UTF-8 encoded.
                  # Cannot be `""`.
            },
          ],
          "partitionId": { # A partition ID identifies a grouping of entities. The grouping is always # Entities are partitioned into subsets, currently identified by a project
              # ID and namespace ID.
              # Queries are scoped to a single partition.
              # by project and namespace, however the namespace ID may be empty.
              #
              # A partition ID contains several dimensions:
              # project ID and namespace ID.
              #
              # Partition dimensions:
              #
              # - May be `""`.
              # - Must be valid UTF-8 bytes.
              # - Must have values that match regex `[A-Za-z\d\.\-_]{1,100}`
              # If the value of any dimension matches regex `__.*__`, the partition is
              # reserved/read-only.
              # A reserved/read-only partition ID is forbidden in certain documented
              # contexts.
              #
              # Foreign partition IDs (in which the project ID does
              # not match the context project ID ) are discouraged.
              # Reads and writes of foreign partition IDs may fail if the project is not in an active state.
            "projectId": "A String", # The ID of the project to which the entities belong.
            "namespaceId": "A String", # If not empty, the ID of the namespace to which the entities belong.
          },
        },
      },
    ],
  }</pre>
</div>

<div class="method">
    <code class="details" id="lookup">lookup(projectId, body, x__xgafv=None)</code>
  <pre>Looks up entities by key.

Args:
  projectId: string, The ID of the project against which to make the request. (required)
  body: object, The request body. (required)
    The object takes the form of:

{ # The request for Datastore.Lookup.
    "keys": [ # Keys of entities to look up.
      { # A unique identifier for an entity.
          # If a key's partition ID or any of its path kinds or names are
          # reserved/read-only, the key is reserved/read-only.
          # A reserved/read-only key is forbidden in certain documented contexts.
        "path": [ # The entity path.
            # An entity path consists of one or more elements composed of a kind and a
            # string or numerical identifier, which identify entities. The first
            # element identifies a _root entity_, the second element identifies
            # a _child_ of the root entity, the third element identifies a child of the
            # second entity, and so forth. The entities identified by all prefixes of
            # the path are called the element's _ancestors_.
            #
            # An entity path is always fully complete: *all* of the entity's ancestors
            # are required to be in the path along with the entity identifier itself.
            # The only exception is that in some documented cases, the identifier in the
            # last path element (for the entity) itself may be omitted. For example,
            # the last path element of the key of `Mutation.insert` may have no
            # identifier.
            #
            # A path can never be empty, and a path can have at most 100 elements.
          { # A (kind, ID/name) pair used to construct a key path.
              #
              # If either name or ID is set, the element is complete.
              # If neither is set, the element is incomplete.
            "kind": "A String", # The kind of the entity.
                # A kind matching regex `__.*__` is reserved/read-only.
                # A kind must not contain more than 1500 bytes when UTF-8 encoded.
                # Cannot be `""`.
            "id": "A String", # The auto-allocated ID of the entity.
                # Never equal to zero. Values less than zero are discouraged and may not
                # be supported in the future.
            "name": "A String", # The name of the entity.
                # A name matching regex `__.*__` is reserved/read-only.
                # A name must not be more than 1500 bytes when UTF-8 encoded.
                # Cannot be `""`.
          },
        ],
        "partitionId": { # A partition ID identifies a grouping of entities. The grouping is always # Entities are partitioned into subsets, currently identified by a project
            # ID and namespace ID.
            # Queries are scoped to a single partition.
            # by project and namespace, however the namespace ID may be empty.
            #
            # A partition ID contains several dimensions:
            # project ID and namespace ID.
            #
            # Partition dimensions:
            #
            # - May be `""`.
            # - Must be valid UTF-8 bytes.
            # - Must have values that match regex `[A-Za-z\d\.\-_]{1,100}`
            # If the value of any dimension matches regex `__.*__`, the partition is
            # reserved/read-only.
            # A reserved/read-only partition ID is forbidden in certain documented
            # contexts.
            #
            # Foreign partition IDs (in which the project ID does
            # not match the context project ID ) are discouraged.
            # Reads and writes of foreign partition IDs may fail if the project is not in an active state.
          "projectId": "A String", # The ID of the project to which the entities belong.
          "namespaceId": "A String", # If not empty, the ID of the namespace to which the entities belong.
        },
      },
    ],
    "readOptions": { # The options shared by read requests. # The options for this lookup request.
      "transaction": "A String", # The identifier of the transaction in which to read. A
          # transaction identifier is returned by a call to
          # Datastore.BeginTransaction.
      "readConsistency": "A String", # The non-transactional read consistency to use.
          # Cannot be set to `STRONG` for global queries.
    },
  }

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The response for Datastore.Lookup.
    "found": [ # Entities found as `ResultType.FULL` entities. The order of results in this
        # field is undefined and has no relation to the order of the keys in the
        # input.
      { # The result of fetching an entity from Datastore.
        "cursor": "A String", # A cursor that points to the position after the result entity.
            # Set only when the `EntityResult` is part of a `QueryResultBatch` message.
        "version": "A String", # The version of the entity, a strictly positive number that monotonically
            # increases with changes to the entity.
            #
            # This field is set for `FULL` entity
            # results.
            #
            # For missing entities in `LookupResponse`, this
            # is the version of the snapshot that was used to look up the entity, and it
            # is always set except for eventually consistent reads.
        "entity": { # A Datastore data object. # The resulting entity.
            #
            # An entity is limited to 1 megabyte when stored. That _roughly_
            # corresponds to a limit of 1 megabyte for the serialized form of this
            # message.
          "properties": { # The entity's properties.
              # The map's keys are property names.
              # A property name matching regex `__.*__` is reserved.
              # A reserved property name is forbidden in certain documented contexts.
              # The name must not contain more than 500 characters.
              # The name cannot be `""`.
            "a_key": { # A message that can hold any of the supported value types and associated
                # metadata.
              "entityValue": # Object with schema name: Entity # An entity value.
                  #
                  # - May have no key.
                  # - May have a key with an incomplete key path.
                  # - May have a reserved/read-only key.
              "timestampValue": "A String", # A timestamp value.
                  # When stored in the Datastore, precise only to microseconds;
                  # any additional precision is rounded down.
              "nullValue": "A String", # A null value.
              "excludeFromIndexes": True or False, # If the value should be excluded from all indexes including those defined
                  # explicitly.
              "doubleValue": 3.14, # A double value.
              "meaning": 42, # The `meaning` field should only be populated for backwards compatibility.
              "keyValue": { # A unique identifier for an entity. # A key value.
                  # If a key's partition ID or any of its path kinds or names are
                  # reserved/read-only, the key is reserved/read-only.
                  # A reserved/read-only key is forbidden in certain documented contexts.
                "path": [ # The entity path.
                    # An entity path consists of one or more elements composed of a kind and a
                    # string or numerical identifier, which identify entities. The first
                    # element identifies a _root entity_, the second element identifies
                    # a _child_ of the root entity, the third element identifies a child of the
                    # second entity, and so forth. The entities identified by all prefixes of
                    # the path are called the element's _ancestors_.
                    #
                    # An entity path is always fully complete: *all* of the entity's ancestors
                    # are required to be in the path along with the entity identifier itself.
                    # The only exception is that in some documented cases, the identifier in the
                    # last path element (for the entity) itself may be omitted. For example,
                    # the last path element of the key of `Mutation.insert` may have no
                    # identifier.
                    #
                    # A path can never be empty, and a path can have at most 100 elements.
                  { # A (kind, ID/name) pair used to construct a key path.
                      #
                      # If either name or ID is set, the element is complete.
                      # If neither is set, the element is incomplete.
                    "kind": "A String", # The kind of the entity.
                        # A kind matching regex `__.*__` is reserved/read-only.
                        # A kind must not contain more than 1500 bytes when UTF-8 encoded.
                        # Cannot be `""`.
                    "id": "A String", # The auto-allocated ID of the entity.
                        # Never equal to zero. Values less than zero are discouraged and may not
                        # be supported in the future.
                    "name": "A String", # The name of the entity.
                        # A name matching regex `__.*__` is reserved/read-only.
                        # A name must not be more than 1500 bytes when UTF-8 encoded.
                        # Cannot be `""`.
                  },
                ],
                "partitionId": { # A partition ID identifies a grouping of entities. The grouping is always # Entities are partitioned into subsets, currently identified by a project
                    # ID and namespace ID.
                    # Queries are scoped to a single partition.
                    # by project and namespace, however the namespace ID may be empty.
                    #
                    # A partition ID contains several dimensions:
                    # project ID and namespace ID.
                    #
                    # Partition dimensions:
                    #
                    # - May be `""`.
                    # - Must be valid UTF-8 bytes.
                    # - Must have values that match regex `[A-Za-z\d\.\-_]{1,100}`
                    # If the value of any dimension matches regex `__.*__`, the partition is
                    # reserved/read-only.
                    # A reserved/read-only partition ID is forbidden in certain documented
                    # contexts.
                    #
                    # Foreign partition IDs (in which the project ID does
                    # not match the context project ID ) are discouraged.
                    # Reads and writes of foreign partition IDs may fail if the project is not in an active state.
                  "projectId": "A String", # The ID of the project to which the entities belong.
                  "namespaceId": "A String", # If not empty, the ID of the namespace to which the entities belong.
                },
              },
              "stringValue": "A String", # A UTF-8 encoded string value.
                  # When `exclude_from_indexes` is false (it is indexed) , may have at most 1500 bytes.
                  # Otherwise, may be set to at least 1,000,000 bytes.
              "blobValue": "A String", # A blob value.
                  # May have at most 1,000,000 bytes.
                  # When `exclude_from_indexes` is false, may have at most 1500 bytes.
                  # In JSON requests, must be base64-encoded.
              "booleanValue": True or False, # A boolean value.
              "arrayValue": { # An array value. # An array value.
                  # Cannot contain another array value.
                  # A `Value` instance that sets field `array_value` must not set fields
                  # `meaning` or `exclude_from_indexes`.
                "values": [ # Values in the array.
                    # The order of this array may not be preserved if it contains a mix of
                    # indexed and unindexed values.
                  # Object with schema name: Value
                ],
              },
              "integerValue": "A String", # An integer value.
              "geoPointValue": { # An object representing a latitude/longitude pair. This is expressed as a pair # A geo point value representing a point on the surface of Earth.
                  # of doubles representing degrees latitude and degrees longitude. Unless
                  # specified otherwise, this must conform to the
                  # <a href="http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf">WGS84
                  # standard</a>. Values must be within normalized ranges.
                  #
                  # Example of normalization code in Python:
                  #
                  #     def NormalizeLongitude(longitude):
                  #       """Wraps decimal degrees longitude to [-180.0, 180.0]."""
                  #       q, r = divmod(longitude, 360.0)
                  #       if r > 180.0 or (r == 180.0 and q <= -1.0):
                  #         return r - 360.0
                  #       return r
                  #
                  #     def NormalizeLatLng(latitude, longitude):
                  #       """Wraps decimal degrees latitude and longitude to
                  #       [-90.0, 90.0] and [-180.0, 180.0], respectively."""
                  #       r = latitude % 360.0
                  #       if r <= 90.0:
                  #         return r, NormalizeLongitude(longitude)
                  #       elif r >= 270.0:
                  #         return r - 360, NormalizeLongitude(longitude)
                  #       else:
                  #         return 180 - r, NormalizeLongitude(longitude + 180.0)
                  #
                  #     assert 180.0 == NormalizeLongitude(180.0)
                  #     assert -180.0 == NormalizeLongitude(-180.0)
                  #     assert -179.0 == NormalizeLongitude(181.0)
                  #     assert (0.0, 0.0) == NormalizeLatLng(360.0, 0.0)
                  #     assert (0.0, 0.0) == NormalizeLatLng(-360.0, 0.0)
                  #     assert (85.0, 180.0) == NormalizeLatLng(95.0, 0.0)
                  #     assert (-85.0, -170.0) == NormalizeLatLng(-95.0, 10.0)
                  #     assert (90.0, 10.0) == NormalizeLatLng(90.0, 10.0)
                  #     assert (-90.0, -10.0) == NormalizeLatLng(-90.0, -10.0)
                  #     assert (0.0, -170.0) == NormalizeLatLng(-180.0, 10.0)
                  #     assert (0.0, -170.0) == NormalizeLatLng(180.0, 10.0)
                  #     assert (-90.0, 10.0) == NormalizeLatLng(270.0, 10.0)
                  #     assert (90.0, 10.0) == NormalizeLatLng(-270.0, 10.0)
                "latitude": 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
                "longitude": 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
              },
            },
          },
          "key": { # A unique identifier for an entity. # The entity's key.
              #
              # An entity must have a key, unless otherwise documented (for example,
              # an entity in `Value.entity_value` may have no key).
              # An entity's kind is its key path's last element's kind,
              # or null if it has no key.
              # If a key's partition ID or any of its path kinds or names are
              # reserved/read-only, the key is reserved/read-only.
              # A reserved/read-only key is forbidden in certain documented contexts.
            "path": [ # The entity path.
                # An entity path consists of one or more elements composed of a kind and a
                # string or numerical identifier, which identify entities. The first
                # element identifies a _root entity_, the second element identifies
                # a _child_ of the root entity, the third element identifies a child of the
                # second entity, and so forth. The entities identified by all prefixes of
                # the path are called the element's _ancestors_.
                #
                # An entity path is always fully complete: *all* of the entity's ancestors
                # are required to be in the path along with the entity identifier itself.
                # The only exception is that in some documented cases, the identifier in the
                # last path element (for the entity) itself may be omitted. For example,
                # the last path element of the key of `Mutation.insert` may have no
                # identifier.
                #
                # A path can never be empty, and a path can have at most 100 elements.
              { # A (kind, ID/name) pair used to construct a key path.
                  #
                  # If either name or ID is set, the element is complete.
                  # If neither is set, the element is incomplete.
                "kind": "A String", # The kind of the entity.
                    # A kind matching regex `__.*__` is reserved/read-only.
                    # A kind must not contain more than 1500 bytes when UTF-8 encoded.
                    # Cannot be `""`.
                "id": "A String", # The auto-allocated ID of the entity.
                    # Never equal to zero. Values less than zero are discouraged and may not
                    # be supported in the future.
                "name": "A String", # The name of the entity.
                    # A name matching regex `__.*__` is reserved/read-only.
                    # A name must not be more than 1500 bytes when UTF-8 encoded.
                    # Cannot be `""`.
              },
            ],
            "partitionId": { # A partition ID identifies a grouping of entities. The grouping is always # Entities are partitioned into subsets, currently identified by a project
                # ID and namespace ID.
                # Queries are scoped to a single partition.
                # by project and namespace, however the namespace ID may be empty.
                #
                # A partition ID contains several dimensions:
                # project ID and namespace ID.
                #
                # Partition dimensions:
                #
                # - May be `""`.
                # - Must be valid UTF-8 bytes.
                # - Must have values that match regex `[A-Za-z\d\.\-_]{1,100}`
                # If the value of any dimension matches regex `__.*__`, the partition is
                # reserved/read-only.
                # A reserved/read-only partition ID is forbidden in certain documented
                # contexts.
                #
                # Foreign partition IDs (in which the project ID does
                # not match the context project ID ) are discouraged.
                # Reads and writes of foreign partition IDs may fail if the project is not in an active state.
              "projectId": "A String", # The ID of the project to which the entities belong.
              "namespaceId": "A String", # If not empty, the ID of the namespace to which the entities belong.
            },
          },
        },
      },
    ],
    "deferred": [ # A list of keys that were not looked up due to resource constraints. The
        # order of results in this field is undefined and has no relation to the
        # order of the keys in the input.
      { # A unique identifier for an entity.
          # If a key's partition ID or any of its path kinds or names are
          # reserved/read-only, the key is reserved/read-only.
          # A reserved/read-only key is forbidden in certain documented contexts.
        "path": [ # The entity path.
            # An entity path consists of one or more elements composed of a kind and a
            # string or numerical identifier, which identify entities. The first
            # element identifies a _root entity_, the second element identifies
            # a _child_ of the root entity, the third element identifies a child of the
            # second entity, and so forth. The entities identified by all prefixes of
            # the path are called the element's _ancestors_.
            #
            # An entity path is always fully complete: *all* of the entity's ancestors
            # are required to be in the path along with the entity identifier itself.
            # The only exception is that in some documented cases, the identifier in the
            # last path element (for the entity) itself may be omitted. For example,
            # the last path element of the key of `Mutation.insert` may have no
            # identifier.
            #
            # A path can never be empty, and a path can have at most 100 elements.
          { # A (kind, ID/name) pair used to construct a key path.
              #
              # If either name or ID is set, the element is complete.
              # If neither is set, the element is incomplete.
            "kind": "A String", # The kind of the entity.
                # A kind matching regex `__.*__` is reserved/read-only.
                # A kind must not contain more than 1500 bytes when UTF-8 encoded.
                # Cannot be `""`.
            "id": "A String", # The auto-allocated ID of the entity.
                # Never equal to zero. Values less than zero are discouraged and may not
                # be supported in the future.
            "name": "A String", # The name of the entity.
                # A name matching regex `__.*__` is reserved/read-only.
                # A name must not be more than 1500 bytes when UTF-8 encoded.
                # Cannot be `""`.
          },
        ],
        "partitionId": { # A partition ID identifies a grouping of entities. The grouping is always # Entities are partitioned into subsets, currently identified by a project
            # ID and namespace ID.
            # Queries are scoped to a single partition.
            # by project and namespace, however the namespace ID may be empty.
            #
            # A partition ID contains several dimensions:
            # project ID and namespace ID.
            #
            # Partition dimensions:
            #
            # - May be `""`.
            # - Must be valid UTF-8 bytes.
            # - Must have values that match regex `[A-Za-z\d\.\-_]{1,100}`
            # If the value of any dimension matches regex `__.*__`, the partition is
            # reserved/read-only.
            # A reserved/read-only partition ID is forbidden in certain documented
            # contexts.
            #
            # Foreign partition IDs (in which the project ID does
            # not match the context project ID ) are discouraged.
            # Reads and writes of foreign partition IDs may fail if the project is not in an active state.
          "projectId": "A String", # The ID of the project to which the entities belong.
          "namespaceId": "A String", # If not empty, the ID of the namespace to which the entities belong.
        },
      },
    ],
    "missing": [ # Entities not found as `ResultType.KEY_ONLY` entities. The order of results
        # in this field is undefined and has no relation to the order of the keys
        # in the input.
      { # The result of fetching an entity from Datastore.
        "cursor": "A String", # A cursor that points to the position after the result entity.
            # Set only when the `EntityResult` is part of a `QueryResultBatch` message.
        "version": "A String", # The version of the entity, a strictly positive number that monotonically
            # increases with changes to the entity.
            #
            # This field is set for `FULL` entity
            # results.
            #
            # For missing entities in `LookupResponse`, this
            # is the version of the snapshot that was used to look up the entity, and it
            # is always set except for eventually consistent reads.
        "entity": { # A Datastore data object. # The resulting entity.
            #
            # An entity is limited to 1 megabyte when stored. That _roughly_
            # corresponds to a limit of 1 megabyte for the serialized form of this
            # message.
          "properties": { # The entity's properties.
              # The map's keys are property names.
              # A property name matching regex `__.*__` is reserved.
              # A reserved property name is forbidden in certain documented contexts.
              # The name must not contain more than 500 characters.
              # The name cannot be `""`.
            "a_key": { # A message that can hold any of the supported value types and associated
                # metadata.
              "entityValue": # Object with schema name: Entity # An entity value.
                  #
                  # - May have no key.
                  # - May have a key with an incomplete key path.
                  # - May have a reserved/read-only key.
              "timestampValue": "A String", # A timestamp value.
                  # When stored in the Datastore, precise only to microseconds;
                  # any additional precision is rounded down.
              "nullValue": "A String", # A null value.
              "excludeFromIndexes": True or False, # If the value should be excluded from all indexes including those defined
                  # explicitly.
              "doubleValue": 3.14, # A double value.
              "meaning": 42, # The `meaning` field should only be populated for backwards compatibility.
              "keyValue": { # A unique identifier for an entity. # A key value.
                  # If a key's partition ID or any of its path kinds or names are
                  # reserved/read-only, the key is reserved/read-only.
                  # A reserved/read-only key is forbidden in certain documented contexts.
                "path": [ # The entity path.
                    # An entity path consists of one or more elements composed of a kind and a
                    # string or numerical identifier, which identify entities. The first
                    # element identifies a _root entity_, the second element identifies
                    # a _child_ of the root entity, the third element identifies a child of the
                    # second entity, and so forth. The entities identified by all prefixes of
                    # the path are called the element's _ancestors_.
                    #
                    # An entity path is always fully complete: *all* of the entity's ancestors
                    # are required to be in the path along with the entity identifier itself.
                    # The only exception is that in some documented cases, the identifier in the
                    # last path element (for the entity) itself may be omitted. For example,
                    # the last path element of the key of `Mutation.insert` may have no
                    # identifier.
                    #
                    # A path can never be empty, and a path can have at most 100 elements.
                  { # A (kind, ID/name) pair used to construct a key path.
                      #
                      # If either name or ID is set, the element is complete.
                      # If neither is set, the element is incomplete.
                    "kind": "A String", # The kind of the entity.
                        # A kind matching regex `__.*__` is reserved/read-only.
                        # A kind must not contain more than 1500 bytes when UTF-8 encoded.
                        # Cannot be `""`.
                    "id": "A String", # The auto-allocated ID of the entity.
                        # Never equal to zero. Values less than zero are discouraged and may not
                        # be supported in the future.
                    "name": "A String", # The name of the entity.
                        # A name matching regex `__.*__` is reserved/read-only.
                        # A name must not be more than 1500 bytes when UTF-8 encoded.
                        # Cannot be `""`.
                  },
                ],
                "partitionId": { # A partition ID identifies a grouping of entities. The grouping is always # Entities are partitioned into subsets, currently identified by a project
                    # ID and namespace ID.
                    # Queries are scoped to a single partition.
                    # by project and namespace, however the namespace ID may be empty.
                    #
                    # A partition ID contains several dimensions:
                    # project ID and namespace ID.
                    #
                    # Partition dimensions:
                    #
                    # - May be `""`.
                    # - Must be valid UTF-8 bytes.
                    # - Must have values that match regex `[A-Za-z\d\.\-_]{1,100}`
                    # If the value of any dimension matches regex `__.*__`, the partition is
                    # reserved/read-only.
                    # A reserved/read-only partition ID is forbidden in certain documented
                    # contexts.
                    #
                    # Foreign partition IDs (in which the project ID does
                    # not match the context project ID ) are discouraged.
                    # Reads and writes of foreign partition IDs may fail if the project is not in an active state.
                  "projectId": "A String", # The ID of the project to which the entities belong.
                  "namespaceId": "A String", # If not empty, the ID of the namespace to which the entities belong.
                },
              },
              "stringValue": "A String", # A UTF-8 encoded string value.
                  # When `exclude_from_indexes` is false (it is indexed) , may have at most 1500 bytes.
                  # Otherwise, may be set to at least 1,000,000 bytes.
              "blobValue": "A String", # A blob value.
                  # May have at most 1,000,000 bytes.
                  # When `exclude_from_indexes` is false, may have at most 1500 bytes.
                  # In JSON requests, must be base64-encoded.
              "booleanValue": True or False, # A boolean value.
              "arrayValue": { # An array value. # An array value.
                  # Cannot contain another array value.
                  # A `Value` instance that sets field `array_value` must not set fields
                  # `meaning` or `exclude_from_indexes`.
                "values": [ # Values in the array.
                    # The order of this array may not be preserved if it contains a mix of
                    # indexed and unindexed values.
                  # Object with schema name: Value
                ],
              },
              "integerValue": "A String", # An integer value.
              "geoPointValue": { # An object representing a latitude/longitude pair. This is expressed as a pair # A geo point value representing a point on the surface of Earth.
                  # of doubles representing degrees latitude and degrees longitude. Unless
                  # specified otherwise, this must conform to the
                  # <a href="http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf">WGS84
                  # standard</a>. Values must be within normalized ranges.
                  #
                  # Example of normalization code in Python:
                  #
                  #     def NormalizeLongitude(longitude):
                  #       """Wraps decimal degrees longitude to [-180.0, 180.0]."""
                  #       q, r = divmod(longitude, 360.0)
                  #       if r > 180.0 or (r == 180.0 and q <= -1.0):
                  #         return r - 360.0
                  #       return r
                  #
                  #     def NormalizeLatLng(latitude, longitude):
                  #       """Wraps decimal degrees latitude and longitude to
                  #       [-90.0, 90.0] and [-180.0, 180.0], respectively."""
                  #       r = latitude % 360.0
                  #       if r <= 90.0:
                  #         return r, NormalizeLongitude(longitude)
                  #       elif r >= 270.0:
                  #         return r - 360, NormalizeLongitude(longitude)
                  #       else:
                  #         return 180 - r, NormalizeLongitude(longitude + 180.0)
                  #
                  #     assert 180.0 == NormalizeLongitude(180.0)
                  #     assert -180.0 == NormalizeLongitude(-180.0)
                  #     assert -179.0 == NormalizeLongitude(181.0)
                  #     assert (0.0, 0.0) == NormalizeLatLng(360.0, 0.0)
                  #     assert (0.0, 0.0) == NormalizeLatLng(-360.0, 0.0)
                  #     assert (85.0, 180.0) == NormalizeLatLng(95.0, 0.0)
                  #     assert (-85.0, -170.0) == NormalizeLatLng(-95.0, 10.0)
                  #     assert (90.0, 10.0) == NormalizeLatLng(90.0, 10.0)
                  #     assert (-90.0, -10.0) == NormalizeLatLng(-90.0, -10.0)
                  #     assert (0.0, -170.0) == NormalizeLatLng(-180.0, 10.0)
                  #     assert (0.0, -170.0) == NormalizeLatLng(180.0, 10.0)
                  #     assert (-90.0, 10.0) == NormalizeLatLng(270.0, 10.0)
                  #     assert (90.0, 10.0) == NormalizeLatLng(-270.0, 10.0)
                "latitude": 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
                "longitude": 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
              },
            },
          },
          "key": { # A unique identifier for an entity. # The entity's key.
              #
              # An entity must have a key, unless otherwise documented (for example,
              # an entity in `Value.entity_value` may have no key).
              # An entity's kind is its key path's last element's kind,
              # or null if it has no key.
              # If a key's partition ID or any of its path kinds or names are
              # reserved/read-only, the key is reserved/read-only.
              # A reserved/read-only key is forbidden in certain documented contexts.
            "path": [ # The entity path.
                # An entity path consists of one or more elements composed of a kind and a
                # string or numerical identifier, which identify entities. The first
                # element identifies a _root entity_, the second element identifies
                # a _child_ of the root entity, the third element identifies a child of the
                # second entity, and so forth. The entities identified by all prefixes of
                # the path are called the element's _ancestors_.
                #
                # An entity path is always fully complete: *all* of the entity's ancestors
                # are required to be in the path along with the entity identifier itself.
                # The only exception is that in some documented cases, the identifier in the
                # last path element (for the entity) itself may be omitted. For example,
                # the last path element of the key of `Mutation.insert` may have no
                # identifier.
                #
                # A path can never be empty, and a path can have at most 100 elements.
              { # A (kind, ID/name) pair used to construct a key path.
                  #
                  # If either name or ID is set, the element is complete.
                  # If neither is set, the element is incomplete.
                "kind": "A String", # The kind of the entity.
                    # A kind matching regex `__.*__` is reserved/read-only.
                    # A kind must not contain more than 1500 bytes when UTF-8 encoded.
                    # Cannot be `""`.
                "id": "A String", # The auto-allocated ID of the entity.
                    # Never equal to zero. Values less than zero are discouraged and may not
                    # be supported in the future.
                "name": "A String", # The name of the entity.
                    # A name matching regex `__.*__` is reserved/read-only.
                    # A name must not be more than 1500 bytes when UTF-8 encoded.
                    # Cannot be `""`.
              },
            ],
            "partitionId": { # A partition ID identifies a grouping of entities. The grouping is always # Entities are partitioned into subsets, currently identified by a project
                # ID and namespace ID.
                # Queries are scoped to a single partition.
                # by project and namespace, however the namespace ID may be empty.
                #
                # A partition ID contains several dimensions:
                # project ID and namespace ID.
                #
                # Partition dimensions:
                #
                # - May be `""`.
                # - Must be valid UTF-8 bytes.
                # - Must have values that match regex `[A-Za-z\d\.\-_]{1,100}`
                # If the value of any dimension matches regex `__.*__`, the partition is
                # reserved/read-only.
                # A reserved/read-only partition ID is forbidden in certain documented
                # contexts.
                #
                # Foreign partition IDs (in which the project ID does
                # not match the context project ID ) are discouraged.
                # Reads and writes of foreign partition IDs may fail if the project is not in an active state.
              "projectId": "A String", # The ID of the project to which the entities belong.
              "namespaceId": "A String", # If not empty, the ID of the namespace to which the entities belong.
            },
          },
        },
      },
    ],
  }</pre>
</div>

<div class="method">
    <code class="details" id="rollback">rollback(projectId, body, x__xgafv=None)</code>
  <pre>Rolls back a transaction.

Args:
  projectId: string, The ID of the project against which to make the request. (required)
  body: object, The request body. (required)
    The object takes the form of:

{ # The request for Datastore.Rollback.
    "transaction": "A String", # The transaction identifier, returned by a call to
        # Datastore.BeginTransaction.
  }

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The response for Datastore.Rollback.
      # (an empty message).
  }</pre>
</div>

<div class="method">
    <code class="details" id="runQuery">runQuery(projectId, body, x__xgafv=None)</code>
  <pre>Queries for entities.

Args:
  projectId: string, The ID of the project against which to make the request. (required)
  body: object, The request body. (required)
    The object takes the form of:

{ # The request for Datastore.RunQuery.
    "query": { # A query for entities. # The query to run.
      "startCursor": "A String", # A starting point for the query results. Query cursors are
          # returned in query result batches and
          # [can only be used to continue the same query](https://cloud.google.com/datastore/docs/concepts/queries#cursors_limits_and_offsets).
      "kind": [ # The kinds to query (if empty, returns entities of all kinds).
          # Currently at most 1 kind may be specified.
        { # A representation of a kind.
          "name": "A String", # The name of the kind.
        },
      ],
      "projection": [ # The projection to return. Defaults to returning all properties.
        { # A representation of a property in a projection.
          "property": { # A reference to a property relative to the kind expressions. # The property to project.
            "name": "A String", # The name of the property.
                # If name includes "."s, it may be interpreted as a property name path.
          },
        },
      ],
      "distinctOn": [ # The properties to make distinct. The query results will contain the first
          # result for each distinct combination of values for the given properties
          # (if empty, all results are returned).
        { # A reference to a property relative to the kind expressions.
          "name": "A String", # The name of the property.
              # If name includes "."s, it may be interpreted as a property name path.
        },
      ],
      "filter": { # A holder for any type of filter. # The filter to apply.
        "compositeFilter": { # A filter that merges multiple other filters using the given operator. # A composite filter.
          "filters": [ # The list of filters to combine.
              # Must contain at least one filter.
            # Object with schema name: Filter
          ],
          "op": "A String", # The operator for combining multiple filters.
        },
        "propertyFilter": { # A filter on a specific property. # A filter on a property.
          "property": { # A reference to a property relative to the kind expressions. # The property to filter by.
            "name": "A String", # The name of the property.
                # If name includes "."s, it may be interpreted as a property name path.
          },
          "value": { # A message that can hold any of the supported value types and associated # The value to compare the property to.
              # metadata.
            "entityValue": # Object with schema name: Entity # An entity value.
                #
                # - May have no key.
                # - May have a key with an incomplete key path.
                # - May have a reserved/read-only key.
            "timestampValue": "A String", # A timestamp value.
                # When stored in the Datastore, precise only to microseconds;
                # any additional precision is rounded down.
            "nullValue": "A String", # A null value.
            "excludeFromIndexes": True or False, # If the value should be excluded from all indexes including those defined
                # explicitly.
            "doubleValue": 3.14, # A double value.
            "meaning": 42, # The `meaning` field should only be populated for backwards compatibility.
            "keyValue": { # A unique identifier for an entity. # A key value.
                # If a key's partition ID or any of its path kinds or names are
                # reserved/read-only, the key is reserved/read-only.
                # A reserved/read-only key is forbidden in certain documented contexts.
              "path": [ # The entity path.
                  # An entity path consists of one or more elements composed of a kind and a
                  # string or numerical identifier, which identify entities. The first
                  # element identifies a _root entity_, the second element identifies
                  # a _child_ of the root entity, the third element identifies a child of the
                  # second entity, and so forth. The entities identified by all prefixes of
                  # the path are called the element's _ancestors_.
                  #
                  # An entity path is always fully complete: *all* of the entity's ancestors
                  # are required to be in the path along with the entity identifier itself.
                  # The only exception is that in some documented cases, the identifier in the
                  # last path element (for the entity) itself may be omitted. For example,
                  # the last path element of the key of `Mutation.insert` may have no
                  # identifier.
                  #
                  # A path can never be empty, and a path can have at most 100 elements.
                { # A (kind, ID/name) pair used to construct a key path.
                    #
                    # If either name or ID is set, the element is complete.
                    # If neither is set, the element is incomplete.
                  "kind": "A String", # The kind of the entity.
                      # A kind matching regex `__.*__` is reserved/read-only.
                      # A kind must not contain more than 1500 bytes when UTF-8 encoded.
                      # Cannot be `""`.
                  "id": "A String", # The auto-allocated ID of the entity.
                      # Never equal to zero. Values less than zero are discouraged and may not
                      # be supported in the future.
                  "name": "A String", # The name of the entity.
                      # A name matching regex `__.*__` is reserved/read-only.
                      # A name must not be more than 1500 bytes when UTF-8 encoded.
                      # Cannot be `""`.
                },
              ],
              "partitionId": { # A partition ID identifies a grouping of entities. The grouping is always # Entities are partitioned into subsets, currently identified by a project
                  # ID and namespace ID.
                  # Queries are scoped to a single partition.
                  # by project and namespace, however the namespace ID may be empty.
                  #
                  # A partition ID contains several dimensions:
                  # project ID and namespace ID.
                  #
                  # Partition dimensions:
                  #
                  # - May be `""`.
                  # - Must be valid UTF-8 bytes.
                  # - Must have values that match regex `[A-Za-z\d\.\-_]{1,100}`
                  # If the value of any dimension matches regex `__.*__`, the partition is
                  # reserved/read-only.
                  # A reserved/read-only partition ID is forbidden in certain documented
                  # contexts.
                  #
                  # Foreign partition IDs (in which the project ID does
                  # not match the context project ID ) are discouraged.
                  # Reads and writes of foreign partition IDs may fail if the project is not in an active state.
                "projectId": "A String", # The ID of the project to which the entities belong.
                "namespaceId": "A String", # If not empty, the ID of the namespace to which the entities belong.
              },
            },
            "stringValue": "A String", # A UTF-8 encoded string value.
                # When `exclude_from_indexes` is false (it is indexed) , may have at most 1500 bytes.
                # Otherwise, may be set to at least 1,000,000 bytes.
            "blobValue": "A String", # A blob value.
                # May have at most 1,000,000 bytes.
                # When `exclude_from_indexes` is false, may have at most 1500 bytes.
                # In JSON requests, must be base64-encoded.
            "booleanValue": True or False, # A boolean value.
            "arrayValue": { # An array value. # An array value.
                # Cannot contain another array value.
                # A `Value` instance that sets field `array_value` must not set fields
                # `meaning` or `exclude_from_indexes`.
              "values": [ # Values in the array.
                  # The order of this array may not be preserved if it contains a mix of
                  # indexed and unindexed values.
                # Object with schema name: Value
              ],
            },
            "integerValue": "A String", # An integer value.
            "geoPointValue": { # An object representing a latitude/longitude pair. This is expressed as a pair # A geo point value representing a point on the surface of Earth.
                # of doubles representing degrees latitude and degrees longitude. Unless
                # specified otherwise, this must conform to the
                # <a href="http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf">WGS84
                # standard</a>. Values must be within normalized ranges.
                #
                # Example of normalization code in Python:
                #
                #     def NormalizeLongitude(longitude):
                #       """Wraps decimal degrees longitude to [-180.0, 180.0]."""
                #       q, r = divmod(longitude, 360.0)
                #       if r > 180.0 or (r == 180.0 and q <= -1.0):
                #         return r - 360.0
                #       return r
                #
                #     def NormalizeLatLng(latitude, longitude):
                #       """Wraps decimal degrees latitude and longitude to
                #       [-90.0, 90.0] and [-180.0, 180.0], respectively."""
                #       r = latitude % 360.0
                #       if r <= 90.0:
                #         return r, NormalizeLongitude(longitude)
                #       elif r >= 270.0:
                #         return r - 360, NormalizeLongitude(longitude)
                #       else:
                #         return 180 - r, NormalizeLongitude(longitude + 180.0)
                #
                #     assert 180.0 == NormalizeLongitude(180.0)
                #     assert -180.0 == NormalizeLongitude(-180.0)
                #     assert -179.0 == NormalizeLongitude(181.0)
                #     assert (0.0, 0.0) == NormalizeLatLng(360.0, 0.0)
                #     assert (0.0, 0.0) == NormalizeLatLng(-360.0, 0.0)
                #     assert (85.0, 180.0) == NormalizeLatLng(95.0, 0.0)
                #     assert (-85.0, -170.0) == NormalizeLatLng(-95.0, 10.0)
                #     assert (90.0, 10.0) == NormalizeLatLng(90.0, 10.0)
                #     assert (-90.0, -10.0) == NormalizeLatLng(-90.0, -10.0)
                #     assert (0.0, -170.0) == NormalizeLatLng(-180.0, 10.0)
                #     assert (0.0, -170.0) == NormalizeLatLng(180.0, 10.0)
                #     assert (-90.0, 10.0) == NormalizeLatLng(270.0, 10.0)
                #     assert (90.0, 10.0) == NormalizeLatLng(-270.0, 10.0)
              "latitude": 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
              "longitude": 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
            },
          },
          "op": "A String", # The operator to filter by.
        },
      },
      "limit": 42, # The maximum number of results to return. Applies after all other
          # constraints. Optional.
          # Unspecified is interpreted as no limit.
          # Must be >= 0 if specified.
      "offset": 42, # The number of results to skip. Applies before limit, but after all other
          # constraints. Optional. Must be >= 0 if specified.
      "endCursor": "A String", # An ending point for the query results. Query cursors are
          # returned in query result batches and
          # [can only be used to limit the same query](https://cloud.google.com/datastore/docs/concepts/queries#cursors_limits_and_offsets).
      "order": [ # The order to apply to the query results (if empty, order is unspecified).
        { # The desired order for a specific property.
          "direction": "A String", # The direction to order by. Defaults to `ASCENDING`.
          "property": { # A reference to a property relative to the kind expressions. # The property to order by.
            "name": "A String", # The name of the property.
                # If name includes "."s, it may be interpreted as a property name path.
          },
        },
      ],
    },
    "partitionId": { # A partition ID identifies a grouping of entities. The grouping is always # Entities are partitioned into subsets, identified by a partition ID.
        # Queries are scoped to a single partition.
        # This partition ID is normalized with the standard default context
        # partition ID.
        # by project and namespace, however the namespace ID may be empty.
        #
        # A partition ID contains several dimensions:
        # project ID and namespace ID.
        #
        # Partition dimensions:
        #
        # - May be `""`.
        # - Must be valid UTF-8 bytes.
        # - Must have values that match regex `[A-Za-z\d\.\-_]{1,100}`
        # If the value of any dimension matches regex `__.*__`, the partition is
        # reserved/read-only.
        # A reserved/read-only partition ID is forbidden in certain documented
        # contexts.
        #
        # Foreign partition IDs (in which the project ID does
        # not match the context project ID ) are discouraged.
        # Reads and writes of foreign partition IDs may fail if the project is not in an active state.
      "projectId": "A String", # The ID of the project to which the entities belong.
      "namespaceId": "A String", # If not empty, the ID of the namespace to which the entities belong.
    },
    "gqlQuery": { # A [GQL query](https://cloud.google.com/datastore/docs/apis/gql/gql_reference). # The GQL query to run.
      "namedBindings": { # For each non-reserved named binding site in the query string, there must be
          # a named parameter with that name, but not necessarily the inverse.
          #
          # Key must match regex `A-Za-z_$*`, must not match regex
          # `__.*__`, and must not be `""`.
        "a_key": { # A binding parameter for a GQL query.
          "cursor": "A String", # A query cursor. Query cursors are returned in query
              # result batches.
          "value": { # A message that can hold any of the supported value types and associated # A value parameter.
              # metadata.
            "entityValue": # Object with schema name: Entity # An entity value.
                #
                # - May have no key.
                # - May have a key with an incomplete key path.
                # - May have a reserved/read-only key.
            "timestampValue": "A String", # A timestamp value.
                # When stored in the Datastore, precise only to microseconds;
                # any additional precision is rounded down.
            "nullValue": "A String", # A null value.
            "excludeFromIndexes": True or False, # If the value should be excluded from all indexes including those defined
                # explicitly.
            "doubleValue": 3.14, # A double value.
            "meaning": 42, # The `meaning` field should only be populated for backwards compatibility.
            "keyValue": { # A unique identifier for an entity. # A key value.
                # If a key's partition ID or any of its path kinds or names are
                # reserved/read-only, the key is reserved/read-only.
                # A reserved/read-only key is forbidden in certain documented contexts.
              "path": [ # The entity path.
                  # An entity path consists of one or more elements composed of a kind and a
                  # string or numerical identifier, which identify entities. The first
                  # element identifies a _root entity_, the second element identifies
                  # a _child_ of the root entity, the third element identifies a child of the
                  # second entity, and so forth. The entities identified by all prefixes of
                  # the path are called the element's _ancestors_.
                  #
                  # An entity path is always fully complete: *all* of the entity's ancestors
                  # are required to be in the path along with the entity identifier itself.
                  # The only exception is that in some documented cases, the identifier in the
                  # last path element (for the entity) itself may be omitted. For example,
                  # the last path element of the key of `Mutation.insert` may have no
                  # identifier.
                  #
                  # A path can never be empty, and a path can have at most 100 elements.
                { # A (kind, ID/name) pair used to construct a key path.
                    #
                    # If either name or ID is set, the element is complete.
                    # If neither is set, the element is incomplete.
                  "kind": "A String", # The kind of the entity.
                      # A kind matching regex `__.*__` is reserved/read-only.
                      # A kind must not contain more than 1500 bytes when UTF-8 encoded.
                      # Cannot be `""`.
                  "id": "A String", # The auto-allocated ID of the entity.
                      # Never equal to zero. Values less than zero are discouraged and may not
                      # be supported in the future.
                  "name": "A String", # The name of the entity.
                      # A name matching regex `__.*__` is reserved/read-only.
                      # A name must not be more than 1500 bytes when UTF-8 encoded.
                      # Cannot be `""`.
                },
              ],
              "partitionId": { # A partition ID identifies a grouping of entities. The grouping is always # Entities are partitioned into subsets, currently identified by a project
                  # ID and namespace ID.
                  # Queries are scoped to a single partition.
                  # by project and namespace, however the namespace ID may be empty.
                  #
                  # A partition ID contains several dimensions:
                  # project ID and namespace ID.
                  #
                  # Partition dimensions:
                  #
                  # - May be `""`.
                  # - Must be valid UTF-8 bytes.
                  # - Must have values that match regex `[A-Za-z\d\.\-_]{1,100}`
                  # If the value of any dimension matches regex `__.*__`, the partition is
                  # reserved/read-only.
                  # A reserved/read-only partition ID is forbidden in certain documented
                  # contexts.
                  #
                  # Foreign partition IDs (in which the project ID does
                  # not match the context project ID ) are discouraged.
                  # Reads and writes of foreign partition IDs may fail if the project is not in an active state.
                "projectId": "A String", # The ID of the project to which the entities belong.
                "namespaceId": "A String", # If not empty, the ID of the namespace to which the entities belong.
              },
            },
            "stringValue": "A String", # A UTF-8 encoded string value.
                # When `exclude_from_indexes` is false (it is indexed) , may have at most 1500 bytes.
                # Otherwise, may be set to at least 1,000,000 bytes.
            "blobValue": "A String", # A blob value.
                # May have at most 1,000,000 bytes.
                # When `exclude_from_indexes` is false, may have at most 1500 bytes.
                # In JSON requests, must be base64-encoded.
            "booleanValue": True or False, # A boolean value.
            "arrayValue": { # An array value. # An array value.
                # Cannot contain another array value.
                # A `Value` instance that sets field `array_value` must not set fields
                # `meaning` or `exclude_from_indexes`.
              "values": [ # Values in the array.
                  # The order of this array may not be preserved if it contains a mix of
                  # indexed and unindexed values.
                # Object with schema name: Value
              ],
            },
            "integerValue": "A String", # An integer value.
            "geoPointValue": { # An object representing a latitude/longitude pair. This is expressed as a pair # A geo point value representing a point on the surface of Earth.
                # of doubles representing degrees latitude and degrees longitude. Unless
                # specified otherwise, this must conform to the
                # <a href="http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf">WGS84
                # standard</a>. Values must be within normalized ranges.
                #
                # Example of normalization code in Python:
                #
                #     def NormalizeLongitude(longitude):
                #       """Wraps decimal degrees longitude to [-180.0, 180.0]."""
                #       q, r = divmod(longitude, 360.0)
                #       if r > 180.0 or (r == 180.0 and q <= -1.0):
                #         return r - 360.0
                #       return r
                #
                #     def NormalizeLatLng(latitude, longitude):
                #       """Wraps decimal degrees latitude and longitude to
                #       [-90.0, 90.0] and [-180.0, 180.0], respectively."""
                #       r = latitude % 360.0
                #       if r <= 90.0:
                #         return r, NormalizeLongitude(longitude)
                #       elif r >= 270.0:
                #         return r - 360, NormalizeLongitude(longitude)
                #       else:
                #         return 180 - r, NormalizeLongitude(longitude + 180.0)
                #
                #     assert 180.0 == NormalizeLongitude(180.0)
                #     assert -180.0 == NormalizeLongitude(-180.0)
                #     assert -179.0 == NormalizeLongitude(181.0)
                #     assert (0.0, 0.0) == NormalizeLatLng(360.0, 0.0)
                #     assert (0.0, 0.0) == NormalizeLatLng(-360.0, 0.0)
                #     assert (85.0, 180.0) == NormalizeLatLng(95.0, 0.0)
                #     assert (-85.0, -170.0) == NormalizeLatLng(-95.0, 10.0)
                #     assert (90.0, 10.0) == NormalizeLatLng(90.0, 10.0)
                #     assert (-90.0, -10.0) == NormalizeLatLng(-90.0, -10.0)
                #     assert (0.0, -170.0) == NormalizeLatLng(-180.0, 10.0)
                #     assert (0.0, -170.0) == NormalizeLatLng(180.0, 10.0)
                #     assert (-90.0, 10.0) == NormalizeLatLng(270.0, 10.0)
                #     assert (90.0, 10.0) == NormalizeLatLng(-270.0, 10.0)
              "latitude": 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
              "longitude": 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
            },
          },
        },
      },
      "positionalBindings": [ # Numbered binding site @1 references the first numbered parameter,
          # effectively using 1-based indexing, rather than the usual 0.
          #
          # For each binding site numbered i in `query_string`, there must be an i-th
          # numbered parameter. The inverse must also be true.
        { # A binding parameter for a GQL query.
          "cursor": "A String", # A query cursor. Query cursors are returned in query
              # result batches.
          "value": { # A message that can hold any of the supported value types and associated # A value parameter.
              # metadata.
            "entityValue": # Object with schema name: Entity # An entity value.
                #
                # - May have no key.
                # - May have a key with an incomplete key path.
                # - May have a reserved/read-only key.
            "timestampValue": "A String", # A timestamp value.
                # When stored in the Datastore, precise only to microseconds;
                # any additional precision is rounded down.
            "nullValue": "A String", # A null value.
            "excludeFromIndexes": True or False, # If the value should be excluded from all indexes including those defined
                # explicitly.
            "doubleValue": 3.14, # A double value.
            "meaning": 42, # The `meaning` field should only be populated for backwards compatibility.
            "keyValue": { # A unique identifier for an entity. # A key value.
                # If a key's partition ID or any of its path kinds or names are
                # reserved/read-only, the key is reserved/read-only.
                # A reserved/read-only key is forbidden in certain documented contexts.
              "path": [ # The entity path.
                  # An entity path consists of one or more elements composed of a kind and a
                  # string or numerical identifier, which identify entities. The first
                  # element identifies a _root entity_, the second element identifies
                  # a _child_ of the root entity, the third element identifies a child of the
                  # second entity, and so forth. The entities identified by all prefixes of
                  # the path are called the element's _ancestors_.
                  #
                  # An entity path is always fully complete: *all* of the entity's ancestors
                  # are required to be in the path along with the entity identifier itself.
                  # The only exception is that in some documented cases, the identifier in the
                  # last path element (for the entity) itself may be omitted. For example,
                  # the last path element of the key of `Mutation.insert` may have no
                  # identifier.
                  #
                  # A path can never be empty, and a path can have at most 100 elements.
                { # A (kind, ID/name) pair used to construct a key path.
                    #
                    # If either name or ID is set, the element is complete.
                    # If neither is set, the element is incomplete.
                  "kind": "A String", # The kind of the entity.
                      # A kind matching regex `__.*__` is reserved/read-only.
                      # A kind must not contain more than 1500 bytes when UTF-8 encoded.
                      # Cannot be `""`.
                  "id": "A String", # The auto-allocated ID of the entity.
                      # Never equal to zero. Values less than zero are discouraged and may not
                      # be supported in the future.
                  "name": "A String", # The name of the entity.
                      # A name matching regex `__.*__` is reserved/read-only.
                      # A name must not be more than 1500 bytes when UTF-8 encoded.
                      # Cannot be `""`.
                },
              ],
              "partitionId": { # A partition ID identifies a grouping of entities. The grouping is always # Entities are partitioned into subsets, currently identified by a project
                  # ID and namespace ID.
                  # Queries are scoped to a single partition.
                  # by project and namespace, however the namespace ID may be empty.
                  #
                  # A partition ID contains several dimensions:
                  # project ID and namespace ID.
                  #
                  # Partition dimensions:
                  #
                  # - May be `""`.
                  # - Must be valid UTF-8 bytes.
                  # - Must have values that match regex `[A-Za-z\d\.\-_]{1,100}`
                  # If the value of any dimension matches regex `__.*__`, the partition is
                  # reserved/read-only.
                  # A reserved/read-only partition ID is forbidden in certain documented
                  # contexts.
                  #
                  # Foreign partition IDs (in which the project ID does
                  # not match the context project ID ) are discouraged.
                  # Reads and writes of foreign partition IDs may fail if the project is not in an active state.
                "projectId": "A String", # The ID of the project to which the entities belong.
                "namespaceId": "A String", # If not empty, the ID of the namespace to which the entities belong.
              },
            },
            "stringValue": "A String", # A UTF-8 encoded string value.
                # When `exclude_from_indexes` is false (it is indexed) , may have at most 1500 bytes.
                # Otherwise, may be set to at least 1,000,000 bytes.
            "blobValue": "A String", # A blob value.
                # May have at most 1,000,000 bytes.
                # When `exclude_from_indexes` is false, may have at most 1500 bytes.
                # In JSON requests, must be base64-encoded.
            "booleanValue": True or False, # A boolean value.
            "arrayValue": { # An array value. # An array value.
                # Cannot contain another array value.
                # A `Value` instance that sets field `array_value` must not set fields
                # `meaning` or `exclude_from_indexes`.
              "values": [ # Values in the array.
                  # The order of this array may not be preserved if it contains a mix of
                  # indexed and unindexed values.
                # Object with schema name: Value
              ],
            },
            "integerValue": "A String", # An integer value.
            "geoPointValue": { # An object representing a latitude/longitude pair. This is expressed as a pair # A geo point value representing a point on the surface of Earth.
                # of doubles representing degrees latitude and degrees longitude. Unless
                # specified otherwise, this must conform to the
                # <a href="http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf">WGS84
                # standard</a>. Values must be within normalized ranges.
                #
                # Example of normalization code in Python:
                #
                #     def NormalizeLongitude(longitude):
                #       """Wraps decimal degrees longitude to [-180.0, 180.0]."""
                #       q, r = divmod(longitude, 360.0)
                #       if r > 180.0 or (r == 180.0 and q <= -1.0):
                #         return r - 360.0
                #       return r
                #
                #     def NormalizeLatLng(latitude, longitude):
                #       """Wraps decimal degrees latitude and longitude to
                #       [-90.0, 90.0] and [-180.0, 180.0], respectively."""
                #       r = latitude % 360.0
                #       if r <= 90.0:
                #         return r, NormalizeLongitude(longitude)
                #       elif r >= 270.0:
                #         return r - 360, NormalizeLongitude(longitude)
                #       else:
                #         return 180 - r, NormalizeLongitude(longitude + 180.0)
                #
                #     assert 180.0 == NormalizeLongitude(180.0)
                #     assert -180.0 == NormalizeLongitude(-180.0)
                #     assert -179.0 == NormalizeLongitude(181.0)
                #     assert (0.0, 0.0) == NormalizeLatLng(360.0, 0.0)
                #     assert (0.0, 0.0) == NormalizeLatLng(-360.0, 0.0)
                #     assert (85.0, 180.0) == NormalizeLatLng(95.0, 0.0)
                #     assert (-85.0, -170.0) == NormalizeLatLng(-95.0, 10.0)
                #     assert (90.0, 10.0) == NormalizeLatLng(90.0, 10.0)
                #     assert (-90.0, -10.0) == NormalizeLatLng(-90.0, -10.0)
                #     assert (0.0, -170.0) == NormalizeLatLng(-180.0, 10.0)
                #     assert (0.0, -170.0) == NormalizeLatLng(180.0, 10.0)
                #     assert (-90.0, 10.0) == NormalizeLatLng(270.0, 10.0)
                #     assert (90.0, 10.0) == NormalizeLatLng(-270.0, 10.0)
              "latitude": 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
              "longitude": 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
            },
          },
        },
      ],
      "queryString": "A String", # A string of the format described
          # [here](https://cloud.google.com/datastore/docs/apis/gql/gql_reference).
      "allowLiterals": True or False, # When false, the query string must not contain any literals and instead must
          # bind all values. For example,
          # `SELECT * FROM Kind WHERE a = 'string literal'` is not allowed, while
          # `SELECT * FROM Kind WHERE a = @value` is.
    },
    "readOptions": { # The options shared by read requests. # The options for this query.
      "transaction": "A String", # The identifier of the transaction in which to read. A
          # transaction identifier is returned by a call to
          # Datastore.BeginTransaction.
      "readConsistency": "A String", # The non-transactional read consistency to use.
          # Cannot be set to `STRONG` for global queries.
    },
  }

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The response for Datastore.RunQuery.
    "query": { # A query for entities. # The parsed form of the `GqlQuery` from the request, if it was set.
      "startCursor": "A String", # A starting point for the query results. Query cursors are
          # returned in query result batches and
          # [can only be used to continue the same query](https://cloud.google.com/datastore/docs/concepts/queries#cursors_limits_and_offsets).
      "kind": [ # The kinds to query (if empty, returns entities of all kinds).
          # Currently at most 1 kind may be specified.
        { # A representation of a kind.
          "name": "A String", # The name of the kind.
        },
      ],
      "projection": [ # The projection to return. Defaults to returning all properties.
        { # A representation of a property in a projection.
          "property": { # A reference to a property relative to the kind expressions. # The property to project.
            "name": "A String", # The name of the property.
                # If name includes "."s, it may be interpreted as a property name path.
          },
        },
      ],
      "distinctOn": [ # The properties to make distinct. The query results will contain the first
          # result for each distinct combination of values for the given properties
          # (if empty, all results are returned).
        { # A reference to a property relative to the kind expressions.
          "name": "A String", # The name of the property.
              # If name includes "."s, it may be interpreted as a property name path.
        },
      ],
      "filter": { # A holder for any type of filter. # The filter to apply.
        "compositeFilter": { # A filter that merges multiple other filters using the given operator. # A composite filter.
          "filters": [ # The list of filters to combine.
              # Must contain at least one filter.
            # Object with schema name: Filter
          ],
          "op": "A String", # The operator for combining multiple filters.
        },
        "propertyFilter": { # A filter on a specific property. # A filter on a property.
          "property": { # A reference to a property relative to the kind expressions. # The property to filter by.
            "name": "A String", # The name of the property.
                # If name includes "."s, it may be interpreted as a property name path.
          },
          "value": { # A message that can hold any of the supported value types and associated # The value to compare the property to.
              # metadata.
            "entityValue": # Object with schema name: Entity # An entity value.
                #
                # - May have no key.
                # - May have a key with an incomplete key path.
                # - May have a reserved/read-only key.
            "timestampValue": "A String", # A timestamp value.
                # When stored in the Datastore, precise only to microseconds;
                # any additional precision is rounded down.
            "nullValue": "A String", # A null value.
            "excludeFromIndexes": True or False, # If the value should be excluded from all indexes including those defined
                # explicitly.
            "doubleValue": 3.14, # A double value.
            "meaning": 42, # The `meaning` field should only be populated for backwards compatibility.
            "keyValue": { # A unique identifier for an entity. # A key value.
                # If a key's partition ID or any of its path kinds or names are
                # reserved/read-only, the key is reserved/read-only.
                # A reserved/read-only key is forbidden in certain documented contexts.
              "path": [ # The entity path.
                  # An entity path consists of one or more elements composed of a kind and a
                  # string or numerical identifier, which identify entities. The first
                  # element identifies a _root entity_, the second element identifies
                  # a _child_ of the root entity, the third element identifies a child of the
                  # second entity, and so forth. The entities identified by all prefixes of
                  # the path are called the element's _ancestors_.
                  #
                  # An entity path is always fully complete: *all* of the entity's ancestors
                  # are required to be in the path along with the entity identifier itself.
                  # The only exception is that in some documented cases, the identifier in the
                  # last path element (for the entity) itself may be omitted. For example,
                  # the last path element of the key of `Mutation.insert` may have no
                  # identifier.
                  #
                  # A path can never be empty, and a path can have at most 100 elements.
                { # A (kind, ID/name) pair used to construct a key path.
                    #
                    # If either name or ID is set, the element is complete.
                    # If neither is set, the element is incomplete.
                  "kind": "A String", # The kind of the entity.
                      # A kind matching regex `__.*__` is reserved/read-only.
                      # A kind must not contain more than 1500 bytes when UTF-8 encoded.
                      # Cannot be `""`.
                  "id": "A String", # The auto-allocated ID of the entity.
                      # Never equal to zero. Values less than zero are discouraged and may not
                      # be supported in the future.
                  "name": "A String", # The name of the entity.
                      # A name matching regex `__.*__` is reserved/read-only.
                      # A name must not be more than 1500 bytes when UTF-8 encoded.
                      # Cannot be `""`.
                },
              ],
              "partitionId": { # A partition ID identifies a grouping of entities. The grouping is always # Entities are partitioned into subsets, currently identified by a project
                  # ID and namespace ID.
                  # Queries are scoped to a single partition.
                  # by project and namespace, however the namespace ID may be empty.
                  #
                  # A partition ID contains several dimensions:
                  # project ID and namespace ID.
                  #
                  # Partition dimensions:
                  #
                  # - May be `""`.
                  # - Must be valid UTF-8 bytes.
                  # - Must have values that match regex `[A-Za-z\d\.\-_]{1,100}`
                  # If the value of any dimension matches regex `__.*__`, the partition is
                  # reserved/read-only.
                  # A reserved/read-only partition ID is forbidden in certain documented
                  # contexts.
                  #
                  # Foreign partition IDs (in which the project ID does
                  # not match the context project ID ) are discouraged.
                  # Reads and writes of foreign partition IDs may fail if the project is not in an active state.
                "projectId": "A String", # The ID of the project to which the entities belong.
                "namespaceId": "A String", # If not empty, the ID of the namespace to which the entities belong.
              },
            },
            "stringValue": "A String", # A UTF-8 encoded string value.
                # When `exclude_from_indexes` is false (it is indexed) , may have at most 1500 bytes.
                # Otherwise, may be set to at least 1,000,000 bytes.
            "blobValue": "A String", # A blob value.
                # May have at most 1,000,000 bytes.
                # When `exclude_from_indexes` is false, may have at most 1500 bytes.
                # In JSON requests, must be base64-encoded.
            "booleanValue": True or False, # A boolean value.
            "arrayValue": { # An array value. # An array value.
                # Cannot contain another array value.
                # A `Value` instance that sets field `array_value` must not set fields
                # `meaning` or `exclude_from_indexes`.
              "values": [ # Values in the array.
                  # The order of this array may not be preserved if it contains a mix of
                  # indexed and unindexed values.
                # Object with schema name: Value
              ],
            },
            "integerValue": "A String", # An integer value.
            "geoPointValue": { # An object representing a latitude/longitude pair. This is expressed as a pair # A geo point value representing a point on the surface of Earth.
                # of doubles representing degrees latitude and degrees longitude. Unless
                # specified otherwise, this must conform to the
                # <a href="http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf">WGS84
                # standard</a>. Values must be within normalized ranges.
                #
                # Example of normalization code in Python:
                #
                #     def NormalizeLongitude(longitude):
                #       """Wraps decimal degrees longitude to [-180.0, 180.0]."""
                #       q, r = divmod(longitude, 360.0)
                #       if r > 180.0 or (r == 180.0 and q <= -1.0):
                #         return r - 360.0
                #       return r
                #
                #     def NormalizeLatLng(latitude, longitude):
                #       """Wraps decimal degrees latitude and longitude to
                #       [-90.0, 90.0] and [-180.0, 180.0], respectively."""
                #       r = latitude % 360.0
                #       if r <= 90.0:
                #         return r, NormalizeLongitude(longitude)
                #       elif r >= 270.0:
                #         return r - 360, NormalizeLongitude(longitude)
                #       else:
                #         return 180 - r, NormalizeLongitude(longitude + 180.0)
                #
                #     assert 180.0 == NormalizeLongitude(180.0)
                #     assert -180.0 == NormalizeLongitude(-180.0)
                #     assert -179.0 == NormalizeLongitude(181.0)
                #     assert (0.0, 0.0) == NormalizeLatLng(360.0, 0.0)
                #     assert (0.0, 0.0) == NormalizeLatLng(-360.0, 0.0)
                #     assert (85.0, 180.0) == NormalizeLatLng(95.0, 0.0)
                #     assert (-85.0, -170.0) == NormalizeLatLng(-95.0, 10.0)
                #     assert (90.0, 10.0) == NormalizeLatLng(90.0, 10.0)
                #     assert (-90.0, -10.0) == NormalizeLatLng(-90.0, -10.0)
                #     assert (0.0, -170.0) == NormalizeLatLng(-180.0, 10.0)
                #     assert (0.0, -170.0) == NormalizeLatLng(180.0, 10.0)
                #     assert (-90.0, 10.0) == NormalizeLatLng(270.0, 10.0)
                #     assert (90.0, 10.0) == NormalizeLatLng(-270.0, 10.0)
              "latitude": 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
              "longitude": 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
            },
          },
          "op": "A String", # The operator to filter by.
        },
      },
      "limit": 42, # The maximum number of results to return. Applies after all other
          # constraints. Optional.
          # Unspecified is interpreted as no limit.
          # Must be >= 0 if specified.
      "offset": 42, # The number of results to skip. Applies before limit, but after all other
          # constraints. Optional. Must be >= 0 if specified.
      "endCursor": "A String", # An ending point for the query results. Query cursors are
          # returned in query result batches and
          # [can only be used to limit the same query](https://cloud.google.com/datastore/docs/concepts/queries#cursors_limits_and_offsets).
      "order": [ # The order to apply to the query results (if empty, order is unspecified).
        { # The desired order for a specific property.
          "direction": "A String", # The direction to order by. Defaults to `ASCENDING`.
          "property": { # A reference to a property relative to the kind expressions. # The property to order by.
            "name": "A String", # The name of the property.
                # If name includes "."s, it may be interpreted as a property name path.
          },
        },
      ],
    },
    "batch": { # A batch of results produced by a query. # A batch of query results (always present).
      "entityResultType": "A String", # The result type for every entity in `entity_results`.
      "snapshotVersion": "A String", # The version number of the snapshot this batch was returned from.
          # This applies to the range of results from the query's `start_cursor` (or
          # the beginning of the query if no cursor was given) to this batch's
          # `end_cursor` (not the query's `end_cursor`).
          #
          # In a single transaction, subsequent query result batches for the same query
          # can have a greater snapshot version number. Each batch's snapshot version
          # is valid for all preceding batches.
          # The value will be zero for eventually consistent queries.
      "skippedResults": 42, # The number of results skipped, typically because of an offset.
      "entityResults": [ # The results for this batch.
        { # The result of fetching an entity from Datastore.
          "cursor": "A String", # A cursor that points to the position after the result entity.
              # Set only when the `EntityResult` is part of a `QueryResultBatch` message.
          "version": "A String", # The version of the entity, a strictly positive number that monotonically
              # increases with changes to the entity.
              #
              # This field is set for `FULL` entity
              # results.
              #
              # For missing entities in `LookupResponse`, this
              # is the version of the snapshot that was used to look up the entity, and it
              # is always set except for eventually consistent reads.
          "entity": { # A Datastore data object. # The resulting entity.
              #
              # An entity is limited to 1 megabyte when stored. That _roughly_
              # corresponds to a limit of 1 megabyte for the serialized form of this
              # message.
            "properties": { # The entity's properties.
                # The map's keys are property names.
                # A property name matching regex `__.*__` is reserved.
                # A reserved property name is forbidden in certain documented contexts.
                # The name must not contain more than 500 characters.
                # The name cannot be `""`.
              "a_key": { # A message that can hold any of the supported value types and associated
                  # metadata.
                "entityValue": # Object with schema name: Entity # An entity value.
                    #
                    # - May have no key.
                    # - May have a key with an incomplete key path.
                    # - May have a reserved/read-only key.
                "timestampValue": "A String", # A timestamp value.
                    # When stored in the Datastore, precise only to microseconds;
                    # any additional precision is rounded down.
                "nullValue": "A String", # A null value.
                "excludeFromIndexes": True or False, # If the value should be excluded from all indexes including those defined
                    # explicitly.
                "doubleValue": 3.14, # A double value.
                "meaning": 42, # The `meaning` field should only be populated for backwards compatibility.
                "keyValue": { # A unique identifier for an entity. # A key value.
                    # If a key's partition ID or any of its path kinds or names are
                    # reserved/read-only, the key is reserved/read-only.
                    # A reserved/read-only key is forbidden in certain documented contexts.
                  "path": [ # The entity path.
                      # An entity path consists of one or more elements composed of a kind and a
                      # string or numerical identifier, which identify entities. The first
                      # element identifies a _root entity_, the second element identifies
                      # a _child_ of the root entity, the third element identifies a child of the
                      # second entity, and so forth. The entities identified by all prefixes of
                      # the path are called the element's _ancestors_.
                      #
                      # An entity path is always fully complete: *all* of the entity's ancestors
                      # are required to be in the path along with the entity identifier itself.
                      # The only exception is that in some documented cases, the identifier in the
                      # last path element (for the entity) itself may be omitted. For example,
                      # the last path element of the key of `Mutation.insert` may have no
                      # identifier.
                      #
                      # A path can never be empty, and a path can have at most 100 elements.
                    { # A (kind, ID/name) pair used to construct a key path.
                        #
                        # If either name or ID is set, the element is complete.
                        # If neither is set, the element is incomplete.
                      "kind": "A String", # The kind of the entity.
                          # A kind matching regex `__.*__` is reserved/read-only.
                          # A kind must not contain more than 1500 bytes when UTF-8 encoded.
                          # Cannot be `""`.
                      "id": "A String", # The auto-allocated ID of the entity.
                          # Never equal to zero. Values less than zero are discouraged and may not
                          # be supported in the future.
                      "name": "A String", # The name of the entity.
                          # A name matching regex `__.*__` is reserved/read-only.
                          # A name must not be more than 1500 bytes when UTF-8 encoded.
                          # Cannot be `""`.
                    },
                  ],
                  "partitionId": { # A partition ID identifies a grouping of entities. The grouping is always # Entities are partitioned into subsets, currently identified by a project
                      # ID and namespace ID.
                      # Queries are scoped to a single partition.
                      # by project and namespace, however the namespace ID may be empty.
                      #
                      # A partition ID contains several dimensions:
                      # project ID and namespace ID.
                      #
                      # Partition dimensions:
                      #
                      # - May be `""`.
                      # - Must be valid UTF-8 bytes.
                      # - Must have values that match regex `[A-Za-z\d\.\-_]{1,100}`
                      # If the value of any dimension matches regex `__.*__`, the partition is
                      # reserved/read-only.
                      # A reserved/read-only partition ID is forbidden in certain documented
                      # contexts.
                      #
                      # Foreign partition IDs (in which the project ID does
                      # not match the context project ID ) are discouraged.
                      # Reads and writes of foreign partition IDs may fail if the project is not in an active state.
                    "projectId": "A String", # The ID of the project to which the entities belong.
                    "namespaceId": "A String", # If not empty, the ID of the namespace to which the entities belong.
                  },
                },
                "stringValue": "A String", # A UTF-8 encoded string value.
                    # When `exclude_from_indexes` is false (it is indexed) , may have at most 1500 bytes.
                    # Otherwise, may be set to at least 1,000,000 bytes.
                "blobValue": "A String", # A blob value.
                    # May have at most 1,000,000 bytes.
                    # When `exclude_from_indexes` is false, may have at most 1500 bytes.
                    # In JSON requests, must be base64-encoded.
                "booleanValue": True or False, # A boolean value.
                "arrayValue": { # An array value. # An array value.
                    # Cannot contain another array value.
                    # A `Value` instance that sets field `array_value` must not set fields
                    # `meaning` or `exclude_from_indexes`.
                  "values": [ # Values in the array.
                      # The order of this array may not be preserved if it contains a mix of
                      # indexed and unindexed values.
                    # Object with schema name: Value
                  ],
                },
                "integerValue": "A String", # An integer value.
                "geoPointValue": { # An object representing a latitude/longitude pair. This is expressed as a pair # A geo point value representing a point on the surface of Earth.
                    # of doubles representing degrees latitude and degrees longitude. Unless
                    # specified otherwise, this must conform to the
                    # <a href="http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf">WGS84
                    # standard</a>. Values must be within normalized ranges.
                    #
                    # Example of normalization code in Python:
                    #
                    #     def NormalizeLongitude(longitude):
                    #       """Wraps decimal degrees longitude to [-180.0, 180.0]."""
                    #       q, r = divmod(longitude, 360.0)
                    #       if r > 180.0 or (r == 180.0 and q <= -1.0):
                    #         return r - 360.0
                    #       return r
                    #
                    #     def NormalizeLatLng(latitude, longitude):
                    #       """Wraps decimal degrees latitude and longitude to
                    #       [-90.0, 90.0] and [-180.0, 180.0], respectively."""
                    #       r = latitude % 360.0
                    #       if r <= 90.0:
                    #         return r, NormalizeLongitude(longitude)
                    #       elif r >= 270.0:
                    #         return r - 360, NormalizeLongitude(longitude)
                    #       else:
                    #         return 180 - r, NormalizeLongitude(longitude + 180.0)
                    #
                    #     assert 180.0 == NormalizeLongitude(180.0)
                    #     assert -180.0 == NormalizeLongitude(-180.0)
                    #     assert -179.0 == NormalizeLongitude(181.0)
                    #     assert (0.0, 0.0) == NormalizeLatLng(360.0, 0.0)
                    #     assert (0.0, 0.0) == NormalizeLatLng(-360.0, 0.0)
                    #     assert (85.0, 180.0) == NormalizeLatLng(95.0, 0.0)
                    #     assert (-85.0, -170.0) == NormalizeLatLng(-95.0, 10.0)
                    #     assert (90.0, 10.0) == NormalizeLatLng(90.0, 10.0)
                    #     assert (-90.0, -10.0) == NormalizeLatLng(-90.0, -10.0)
                    #     assert (0.0, -170.0) == NormalizeLatLng(-180.0, 10.0)
                    #     assert (0.0, -170.0) == NormalizeLatLng(180.0, 10.0)
                    #     assert (-90.0, 10.0) == NormalizeLatLng(270.0, 10.0)
                    #     assert (90.0, 10.0) == NormalizeLatLng(-270.0, 10.0)
                  "latitude": 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
                  "longitude": 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
                },
              },
            },
            "key": { # A unique identifier for an entity. # The entity's key.
                #
                # An entity must have a key, unless otherwise documented (for example,
                # an entity in `Value.entity_value` may have no key).
                # An entity's kind is its key path's last element's kind,
                # or null if it has no key.
                # If a key's partition ID or any of its path kinds or names are
                # reserved/read-only, the key is reserved/read-only.
                # A reserved/read-only key is forbidden in certain documented contexts.
              "path": [ # The entity path.
                  # An entity path consists of one or more elements composed of a kind and a
                  # string or numerical identifier, which identify entities. The first
                  # element identifies a _root entity_, the second element identifies
                  # a _child_ of the root entity, the third element identifies a child of the
                  # second entity, and so forth. The entities identified by all prefixes of
                  # the path are called the element's _ancestors_.
                  #
                  # An entity path is always fully complete: *all* of the entity's ancestors
                  # are required to be in the path along with the entity identifier itself.
                  # The only exception is that in some documented cases, the identifier in the
                  # last path element (for the entity) itself may be omitted. For example,
                  # the last path element of the key of `Mutation.insert` may have no
                  # identifier.
                  #
                  # A path can never be empty, and a path can have at most 100 elements.
                { # A (kind, ID/name) pair used to construct a key path.
                    #
                    # If either name or ID is set, the element is complete.
                    # If neither is set, the element is incomplete.
                  "kind": "A String", # The kind of the entity.
                      # A kind matching regex `__.*__` is reserved/read-only.
                      # A kind must not contain more than 1500 bytes when UTF-8 encoded.
                      # Cannot be `""`.
                  "id": "A String", # The auto-allocated ID of the entity.
                      # Never equal to zero. Values less than zero are discouraged and may not
                      # be supported in the future.
                  "name": "A String", # The name of the entity.
                      # A name matching regex `__.*__` is reserved/read-only.
                      # A name must not be more than 1500 bytes when UTF-8 encoded.
                      # Cannot be `""`.
                },
              ],
              "partitionId": { # A partition ID identifies a grouping of entities. The grouping is always # Entities are partitioned into subsets, currently identified by a project
                  # ID and namespace ID.
                  # Queries are scoped to a single partition.
                  # by project and namespace, however the namespace ID may be empty.
                  #
                  # A partition ID contains several dimensions:
                  # project ID and namespace ID.
                  #
                  # Partition dimensions:
                  #
                  # - May be `""`.
                  # - Must be valid UTF-8 bytes.
                  # - Must have values that match regex `[A-Za-z\d\.\-_]{1,100}`
                  # If the value of any dimension matches regex `__.*__`, the partition is
                  # reserved/read-only.
                  # A reserved/read-only partition ID is forbidden in certain documented
                  # contexts.
                  #
                  # Foreign partition IDs (in which the project ID does
                  # not match the context project ID ) are discouraged.
                  # Reads and writes of foreign partition IDs may fail if the project is not in an active state.
                "projectId": "A String", # The ID of the project to which the entities belong.
                "namespaceId": "A String", # If not empty, the ID of the namespace to which the entities belong.
              },
            },
          },
        },
      ],
      "skippedCursor": "A String", # A cursor that points to the position after the last skipped result.
          # Will be set when `skipped_results` != 0.
      "moreResults": "A String", # The state of the query after the current batch.
      "endCursor": "A String", # A cursor that points to the position after the last result in the batch.
    },
  }</pre>
</div>

</body></html>