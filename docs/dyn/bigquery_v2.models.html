<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="bigquery_v2.html">BigQuery API</a> . <a href="bigquery_v2.models.html">models</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#delete">delete(projectId, datasetId, modelId)</a></code></p>
<p class="firstline">Deletes the model specified by modelId from the dataset.</p>
<p class="toc_element">
  <code><a href="#get">get(projectId, datasetId, modelId)</a></code></p>
<p class="firstline">Gets the specified model resource by model ID.</p>
<p class="toc_element">
  <code><a href="#list">list(projectId, datasetId, maxResults=None, pageToken=None)</a></code></p>
<p class="firstline">Lists all models in the specified dataset. Requires the READER dataset role.</p>
<p class="toc_element">
  <code><a href="#list_next">list_next(previous_request, previous_response)</a></code></p>
<p class="firstline">Retrieves the next page of results.</p>
<p class="toc_element">
  <code><a href="#patch">patch(projectId, datasetId, modelId, body=None)</a></code></p>
<p class="firstline">Patch specific fields in the specified model.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="delete">delete(projectId, datasetId, modelId)</code>
  <pre>Deletes the model specified by modelId from the dataset.

Args:
  projectId: string, Required. Project ID of the model to delete. (required)
  datasetId: string, Required. Dataset ID of the model to delete. (required)
  modelId: string, Required. Model ID of the model to delete. (required)
</pre>
</div>

<div class="method">
    <code class="details" id="get">get(projectId, datasetId, modelId)</code>
  <pre>Gets the specified model resource by model ID.

Args:
  projectId: string, Required. Project ID of the requested model. (required)
  datasetId: string, Required. Dataset ID of the requested model. (required)
  modelId: string, Required. Model ID of the requested model. (required)

Returns:
  An object of the form:

    {
  &quot;bestTrialId&quot;: &quot;A String&quot;, # The best trial_id across all training runs.
  &quot;creationTime&quot;: &quot;A String&quot;, # Output only. The time when this model was created, in millisecs since the epoch.
  &quot;description&quot;: &quot;A String&quot;, # Optional. A user-friendly description of this model.
  &quot;encryptionConfiguration&quot;: { # Custom encryption configuration (e.g., Cloud KMS keys). This shows the encryption configuration of the model data while stored in BigQuery storage. This field can be used with PatchModel to update encryption key for an already encrypted model.
    &quot;kmsKeyName&quot;: &quot;A String&quot;, # [Optional] Describes the Cloud KMS encryption key that will be used to protect destination BigQuery table. The BigQuery Service Account associated with your project requires access to this encryption key.
  },
  &quot;etag&quot;: &quot;A String&quot;, # Output only. A hash of this resource.
  &quot;expirationTime&quot;: &quot;A String&quot;, # Optional. The time when this model expires, in milliseconds since the epoch. If not present, the model will persist indefinitely. Expired models will be deleted and their storage reclaimed. The defaultTableExpirationMs property of the encapsulating dataset can be used to set a default expirationTime on newly created models.
  &quot;featureColumns&quot;: [ # Output only. Input feature columns that were used to train this model.
    { # A field or a column.
      &quot;name&quot;: &quot;A String&quot;, # Optional. The name of this field. Can be absent for struct fields.
      &quot;type&quot;: { # The type of a variable, e.g., a function argument. Examples: INT64: {type_kind=&quot;INT64&quot;} ARRAY: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;} STRUCT&gt;: {type_kind=&quot;STRUCT&quot;, struct_type={fields=[ {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}}, {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}} ]}} # Optional. The type of this parameter. Absent if not explicitly specified (e.g., CREATE FUNCTION statement can omit the return type; in this case the output parameter does not have this &quot;type&quot; field).
        &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
        &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
          &quot;fields&quot;: [
            # Object with schema name: StandardSqlField
          ],
        },
        &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field. Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
      },
    },
  ],
  &quot;friendlyName&quot;: &quot;A String&quot;, # Optional. A descriptive name for this model.
  &quot;labelColumns&quot;: [ # Output only. Label columns that were used to train this model. The output of the model will have a &quot;predicted_&quot; prefix to these columns.
    { # A field or a column.
      &quot;name&quot;: &quot;A String&quot;, # Optional. The name of this field. Can be absent for struct fields.
      &quot;type&quot;: { # The type of a variable, e.g., a function argument. Examples: INT64: {type_kind=&quot;INT64&quot;} ARRAY: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;} STRUCT&gt;: {type_kind=&quot;STRUCT&quot;, struct_type={fields=[ {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}}, {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}} ]}} # Optional. The type of this parameter. Absent if not explicitly specified (e.g., CREATE FUNCTION statement can omit the return type; in this case the output parameter does not have this &quot;type&quot; field).
        &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
        &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
          &quot;fields&quot;: [
            # Object with schema name: StandardSqlField
          ],
        },
        &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field. Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
      },
    },
  ],
  &quot;labels&quot;: { # The labels associated with this model. You can use these to organize and group your models. Label keys and values can be no longer than 63 characters, can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. Label values are optional. Label keys must start with a letter and each label in the list must have a different key.
    &quot;a_key&quot;: &quot;A String&quot;,
  },
  &quot;lastModifiedTime&quot;: &quot;A String&quot;, # Output only. The time when this model was last modified, in millisecs since the epoch.
  &quot;location&quot;: &quot;A String&quot;, # Output only. The geographic location where the model resides. This value is inherited from the dataset.
  &quot;modelReference&quot;: { # Required. Unique identifier for this model.
    &quot;datasetId&quot;: &quot;A String&quot;, # [Required] The ID of the dataset containing this model.
    &quot;modelId&quot;: &quot;A String&quot;, # [Required] The ID of the model. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 1,024 characters.
    &quot;projectId&quot;: &quot;A String&quot;, # [Required] The ID of the project containing this model.
  },
  &quot;modelType&quot;: &quot;A String&quot;, # Output only. Type of the model resource.
  &quot;trainingRuns&quot;: [ # Output only. Information for all training runs in increasing order of start_time.
    { # Information about a single training query run for the model.
      &quot;dataSplitResult&quot;: { # Data split result. This contains references to the training and evaluation data tables that were used to train the model. # Data split result of the training run. Only set when the input data is actually split.
        &quot;evaluationTable&quot;: { # Table reference of the evaluation data after split.
          &quot;datasetId&quot;: &quot;A String&quot;, # [Required] The ID of the dataset containing this table.
          &quot;projectId&quot;: &quot;A String&quot;, # [Required] The ID of the project containing this table.
          &quot;tableId&quot;: &quot;A String&quot;, # [Required] The ID of the table. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 1,024 characters.
        },
        &quot;trainingTable&quot;: { # Table reference of the training data after split.
          &quot;datasetId&quot;: &quot;A String&quot;, # [Required] The ID of the dataset containing this table.
          &quot;projectId&quot;: &quot;A String&quot;, # [Required] The ID of the project containing this table.
          &quot;tableId&quot;: &quot;A String&quot;, # [Required] The ID of the table. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 1,024 characters.
        },
      },
      &quot;evaluationMetrics&quot;: { # Evaluation metrics of a model. These are either computed on all training data or just the eval data based on whether eval data was used during training. These are not present for imported models. # The evaluation metrics over training/eval data that were computed at the end of training.
        &quot;arimaForecastingMetrics&quot;: { # Model evaluation metrics for ARIMA forecasting models. # Populated for ARIMA models.
          &quot;arimaFittingMetrics&quot;: [ # Arima model fitting metrics.
            { # ARIMA model fitting metrics.
              &quot;aic&quot;: 3.14, # AIC.
              &quot;logLikelihood&quot;: 3.14, # Log-likelihood.
              &quot;variance&quot;: 3.14, # Variance.
            },
          ],
          &quot;arimaSingleModelForecastingMetrics&quot;: [ # Repeated as there can be many metric sets (one for each model) in auto-arima and the large-scale case.
            { # Model evaluation metrics for a single ARIMA forecasting model.
              &quot;arimaFittingMetrics&quot;: { # ARIMA model fitting metrics. # Arima fitting metrics.
                &quot;aic&quot;: 3.14, # AIC.
                &quot;logLikelihood&quot;: 3.14, # Log-likelihood.
                &quot;variance&quot;: 3.14, # Variance.
              },
              &quot;hasDrift&quot;: True or False, # Is arima model fitted with drift or not. It is always false when d is not 1.
              &quot;hasHolidayEffect&quot;: True or False, # If true, holiday_effect is a part of time series decomposition result.
              &quot;hasSpikesAndDips&quot;: True or False, # If true, spikes_and_dips is a part of time series decomposition result.
              &quot;hasStepChanges&quot;: True or False, # If true, step_changes is a part of time series decomposition result.
              &quot;nonSeasonalOrder&quot;: { # Arima order, can be used for both non-seasonal and seasonal parts. # Non-seasonal order.
                &quot;d&quot;: &quot;A String&quot;, # Order of the differencing part.
                &quot;p&quot;: &quot;A String&quot;, # Order of the autoregressive part.
                &quot;q&quot;: &quot;A String&quot;, # Order of the moving-average part.
              },
              &quot;seasonalPeriods&quot;: [ # Seasonal periods. Repeated because multiple periods are supported for one time series.
                &quot;A String&quot;,
              ],
              &quot;timeSeriesId&quot;: &quot;A String&quot;, # The time_series_id value for this time series. It will be one of the unique values from the time_series_id_column specified during ARIMA model training. Only present when time_series_id_column training option was used.
              &quot;timeSeriesIds&quot;: [ # The tuple of time_series_ids identifying this time series. It will be one of the unique tuples of values present in the time_series_id_columns specified during ARIMA model training. Only present when time_series_id_columns training option was used and the order of values here are same as the order of time_series_id_columns.
                &quot;A String&quot;,
              ],
            },
          ],
          &quot;hasDrift&quot;: [ # Whether Arima model fitted with drift or not. It is always false when d is not 1.
            True or False,
          ],
          &quot;nonSeasonalOrder&quot;: [ # Non-seasonal order.
            { # Arima order, can be used for both non-seasonal and seasonal parts.
              &quot;d&quot;: &quot;A String&quot;, # Order of the differencing part.
              &quot;p&quot;: &quot;A String&quot;, # Order of the autoregressive part.
              &quot;q&quot;: &quot;A String&quot;, # Order of the moving-average part.
            },
          ],
          &quot;seasonalPeriods&quot;: [ # Seasonal periods. Repeated because multiple periods are supported for one time series.
            &quot;A String&quot;,
          ],
          &quot;timeSeriesId&quot;: [ # Id to differentiate different time series for the large-scale case.
            &quot;A String&quot;,
          ],
        },
        &quot;binaryClassificationMetrics&quot;: { # Evaluation metrics for binary classification/classifier models. # Populated for binary classification/classifier models.
          &quot;aggregateClassificationMetrics&quot;: { # Aggregate metrics for classification/classifier models. For multi-class models, the metrics are either macro-averaged or micro-averaged. When macro-averaged, the metrics are calculated for each label and then an unweighted average is taken of those values. When micro-averaged, the metric is calculated globally by counting the total number of correctly predicted rows. # Aggregate classification metrics.
            &quot;accuracy&quot;: 3.14, # Accuracy is the fraction of predictions given the correct label. For multiclass this is a micro-averaged metric.
            &quot;f1Score&quot;: 3.14, # The F1 score is an average of recall and precision. For multiclass this is a macro-averaged metric.
            &quot;logLoss&quot;: 3.14, # Logarithmic Loss. For multiclass this is a macro-averaged metric.
            &quot;precision&quot;: 3.14, # Precision is the fraction of actual positive predictions that had positive actual labels. For multiclass this is a macro-averaged metric treating each class as a binary classifier.
            &quot;recall&quot;: 3.14, # Recall is the fraction of actual positive labels that were given a positive prediction. For multiclass this is a macro-averaged metric.
            &quot;rocAuc&quot;: 3.14, # Area Under a ROC Curve. For multiclass this is a macro-averaged metric.
            &quot;threshold&quot;: 3.14, # Threshold at which the metrics are computed. For binary classification models this is the positive class threshold. For multi-class classfication models this is the confidence threshold.
          },
          &quot;binaryConfusionMatrixList&quot;: [ # Binary confusion matrix at multiple thresholds.
            { # Confusion matrix for binary classification models.
              &quot;accuracy&quot;: 3.14, # The fraction of predictions given the correct label.
              &quot;f1Score&quot;: 3.14, # The equally weighted average of recall and precision.
              &quot;falseNegatives&quot;: &quot;A String&quot;, # Number of false samples predicted as false.
              &quot;falsePositives&quot;: &quot;A String&quot;, # Number of false samples predicted as true.
              &quot;positiveClassThreshold&quot;: 3.14, # Threshold value used when computing each of the following metric.
              &quot;precision&quot;: 3.14, # The fraction of actual positive predictions that had positive actual labels.
              &quot;recall&quot;: 3.14, # The fraction of actual positive labels that were given a positive prediction.
              &quot;trueNegatives&quot;: &quot;A String&quot;, # Number of true samples predicted as false.
              &quot;truePositives&quot;: &quot;A String&quot;, # Number of true samples predicted as true.
            },
          ],
          &quot;negativeLabel&quot;: &quot;A String&quot;, # Label representing the negative class.
          &quot;positiveLabel&quot;: &quot;A String&quot;, # Label representing the positive class.
        },
        &quot;clusteringMetrics&quot;: { # Evaluation metrics for clustering models. # Populated for clustering models.
          &quot;clusters&quot;: [ # Information for all clusters.
            { # Message containing the information about one cluster.
              &quot;centroidId&quot;: &quot;A String&quot;, # Centroid id.
              &quot;count&quot;: &quot;A String&quot;, # Count of training data rows that were assigned to this cluster.
              &quot;featureValues&quot;: [ # Values of highly variant features for this cluster.
                { # Representative value of a single feature within the cluster.
                  &quot;categoricalValue&quot;: { # Representative value of a categorical feature. # The categorical feature value.
                    &quot;categoryCounts&quot;: [ # Counts of all categories for the categorical feature. If there are more than ten categories, we return top ten (by count) and return one more CategoryCount with category &quot;_OTHER_&quot; and count as aggregate counts of remaining categories.
                      { # Represents the count of a single category within the cluster.
                        &quot;category&quot;: &quot;A String&quot;, # The name of category.
                        &quot;count&quot;: &quot;A String&quot;, # The count of training samples matching the category within the cluster.
                      },
                    ],
                  },
                  &quot;featureColumn&quot;: &quot;A String&quot;, # The feature column name.
                  &quot;numericalValue&quot;: 3.14, # The numerical feature value. This is the centroid value for this feature.
                },
              ],
            },
          ],
          &quot;daviesBouldinIndex&quot;: 3.14, # Davies-Bouldin index.
          &quot;meanSquaredDistance&quot;: 3.14, # Mean of squared distances between each sample to its cluster centroid.
        },
        &quot;multiClassClassificationMetrics&quot;: { # Evaluation metrics for multi-class classification/classifier models. # Populated for multi-class classification/classifier models.
          &quot;aggregateClassificationMetrics&quot;: { # Aggregate metrics for classification/classifier models. For multi-class models, the metrics are either macro-averaged or micro-averaged. When macro-averaged, the metrics are calculated for each label and then an unweighted average is taken of those values. When micro-averaged, the metric is calculated globally by counting the total number of correctly predicted rows. # Aggregate classification metrics.
            &quot;accuracy&quot;: 3.14, # Accuracy is the fraction of predictions given the correct label. For multiclass this is a micro-averaged metric.
            &quot;f1Score&quot;: 3.14, # The F1 score is an average of recall and precision. For multiclass this is a macro-averaged metric.
            &quot;logLoss&quot;: 3.14, # Logarithmic Loss. For multiclass this is a macro-averaged metric.
            &quot;precision&quot;: 3.14, # Precision is the fraction of actual positive predictions that had positive actual labels. For multiclass this is a macro-averaged metric treating each class as a binary classifier.
            &quot;recall&quot;: 3.14, # Recall is the fraction of actual positive labels that were given a positive prediction. For multiclass this is a macro-averaged metric.
            &quot;rocAuc&quot;: 3.14, # Area Under a ROC Curve. For multiclass this is a macro-averaged metric.
            &quot;threshold&quot;: 3.14, # Threshold at which the metrics are computed. For binary classification models this is the positive class threshold. For multi-class classfication models this is the confidence threshold.
          },
          &quot;confusionMatrixList&quot;: [ # Confusion matrix at different thresholds.
            { # Confusion matrix for multi-class classification models.
              &quot;confidenceThreshold&quot;: 3.14, # Confidence threshold used when computing the entries of the confusion matrix.
              &quot;rows&quot;: [ # One row per actual label.
                { # A single row in the confusion matrix.
                  &quot;actualLabel&quot;: &quot;A String&quot;, # The original label of this row.
                  &quot;entries&quot;: [ # Info describing predicted label distribution.
                    { # A single entry in the confusion matrix.
                      &quot;itemCount&quot;: &quot;A String&quot;, # Number of items being predicted as this label.
                      &quot;predictedLabel&quot;: &quot;A String&quot;, # The predicted label. For confidence_threshold &gt; 0, we will also add an entry indicating the number of items under the confidence threshold.
                    },
                  ],
                },
              ],
            },
          ],
        },
        &quot;rankingMetrics&quot;: { # Evaluation metrics used by weighted-ALS models specified by feedback_type=implicit. # Populated for implicit feedback type matrix factorization models.
          &quot;averageRank&quot;: 3.14, # Determines the goodness of a ranking by computing the percentile rank from the predicted confidence and dividing it by the original rank.
          &quot;meanAveragePrecision&quot;: 3.14, # Calculates a precision per user for all the items by ranking them and then averages all the precisions across all the users.
          &quot;meanSquaredError&quot;: 3.14, # Similar to the mean squared error computed in regression and explicit recommendation models except instead of computing the rating directly, the output from evaluate is computed against a preference which is 1 or 0 depending on if the rating exists or not.
          &quot;normalizedDiscountedCumulativeGain&quot;: 3.14, # A metric to determine the goodness of a ranking calculated from the predicted confidence by comparing it to an ideal rank measured by the original ratings.
        },
        &quot;regressionMetrics&quot;: { # Evaluation metrics for regression and explicit feedback type matrix factorization models. # Populated for regression models and explicit feedback type matrix factorization models.
          &quot;meanAbsoluteError&quot;: 3.14, # Mean absolute error.
          &quot;meanSquaredError&quot;: 3.14, # Mean squared error.
          &quot;meanSquaredLogError&quot;: 3.14, # Mean squared log error.
          &quot;medianAbsoluteError&quot;: 3.14, # Median absolute error.
          &quot;rSquared&quot;: 3.14, # R^2 score. This corresponds to r2_score in ML.EVALUATE.
        },
      },
      &quot;globalExplanations&quot;: [ # Global explanations for important features of the model. For multi-class models, there is one entry for each label class. For other models, there is only one entry in the list.
        { # Global explanations containing the top most important features after training.
          &quot;classLabel&quot;: &quot;A String&quot;, # Class label for this set of global explanations. Will be empty/null for binary logistic and linear regression models. Sorted alphabetically in descending order.
          &quot;explanations&quot;: [ # A list of the top global explanations. Sorted by absolute value of attribution in descending order.
            { # Explanation for a single feature.
              &quot;attribution&quot;: 3.14, # Attribution of feature.
              &quot;featureName&quot;: &quot;A String&quot;, # Full name of the feature. For non-numerical features, will be formatted like .. Overall size of feature name will always be truncated to first 120 characters.
            },
          ],
        },
      ],
      &quot;results&quot;: [ # Output of each iteration run, results.size() &lt;= max_iterations.
        { # Information about a single iteration of the training run.
          &quot;arimaResult&quot;: { # (Auto-)arima fitting result. Wrap everything in ArimaResult for easier refactoring if we want to use model-specific iteration results.
            &quot;arimaModelInfo&quot;: [ # This message is repeated because there are multiple arima models fitted in auto-arima. For non-auto-arima model, its size is one.
              { # Arima model information.
                &quot;arimaCoefficients&quot;: { # Arima coefficients. # Arima coefficients.
                  &quot;autoRegressiveCoefficients&quot;: [ # Auto-regressive coefficients, an array of double.
                    3.14,
                  ],
                  &quot;interceptCoefficient&quot;: 3.14, # Intercept coefficient, just a double not an array.
                  &quot;movingAverageCoefficients&quot;: [ # Moving-average coefficients, an array of double.
                    3.14,
                  ],
                },
                &quot;arimaFittingMetrics&quot;: { # ARIMA model fitting metrics. # Arima fitting metrics.
                  &quot;aic&quot;: 3.14, # AIC.
                  &quot;logLikelihood&quot;: 3.14, # Log-likelihood.
                  &quot;variance&quot;: 3.14, # Variance.
                },
                &quot;hasDrift&quot;: True or False, # Whether Arima model fitted with drift or not. It is always false when d is not 1.
                &quot;hasHolidayEffect&quot;: True or False, # If true, holiday_effect is a part of time series decomposition result.
                &quot;hasSpikesAndDips&quot;: True or False, # If true, spikes_and_dips is a part of time series decomposition result.
                &quot;hasStepChanges&quot;: True or False, # If true, step_changes is a part of time series decomposition result.
                &quot;nonSeasonalOrder&quot;: { # Arima order, can be used for both non-seasonal and seasonal parts. # Non-seasonal order.
                  &quot;d&quot;: &quot;A String&quot;, # Order of the differencing part.
                  &quot;p&quot;: &quot;A String&quot;, # Order of the autoregressive part.
                  &quot;q&quot;: &quot;A String&quot;, # Order of the moving-average part.
                },
                &quot;seasonalPeriods&quot;: [ # Seasonal periods. Repeated because multiple periods are supported for one time series.
                  &quot;A String&quot;,
                ],
                &quot;timeSeriesId&quot;: &quot;A String&quot;, # The time_series_id value for this time series. It will be one of the unique values from the time_series_id_column specified during ARIMA model training. Only present when time_series_id_column training option was used.
                &quot;timeSeriesIds&quot;: [ # The tuple of time_series_ids identifying this time series. It will be one of the unique tuples of values present in the time_series_id_columns specified during ARIMA model training. Only present when time_series_id_columns training option was used and the order of values here are same as the order of time_series_id_columns.
                  &quot;A String&quot;,
                ],
              },
            ],
            &quot;seasonalPeriods&quot;: [ # Seasonal periods. Repeated because multiple periods are supported for one time series.
              &quot;A String&quot;,
            ],
          },
          &quot;clusterInfos&quot;: [ # Information about top clusters for clustering models.
            { # Information about a single cluster for clustering model.
              &quot;centroidId&quot;: &quot;A String&quot;, # Centroid id.
              &quot;clusterRadius&quot;: 3.14, # Cluster radius, the average distance from centroid to each point assigned to the cluster.
              &quot;clusterSize&quot;: &quot;A String&quot;, # Cluster size, the total number of points assigned to the cluster.
            },
          ],
          &quot;durationMs&quot;: &quot;A String&quot;, # Time taken to run the iteration in milliseconds.
          &quot;evalLoss&quot;: 3.14, # Loss computed on the eval data at the end of iteration.
          &quot;index&quot;: 42, # Index of the iteration, 0 based.
          &quot;learnRate&quot;: 3.14, # Learn rate used for this iteration.
          &quot;trainingLoss&quot;: 3.14, # Loss computed on the training data at the end of iteration.
        },
      ],
      &quot;startTime&quot;: &quot;A String&quot;, # The start time of this training run.
      &quot;trainingOptions&quot;: { # Options used in model training. # Options that were used for this training run, includes user specified and default options that were used.
        &quot;adjustStepChanges&quot;: True or False, # If true, detect step changes and make data adjustment in the input time series.
        &quot;autoArima&quot;: True or False, # Whether to enable auto ARIMA or not.
        &quot;autoArimaMaxOrder&quot;: &quot;A String&quot;, # The max value of non-seasonal p and q.
        &quot;batchSize&quot;: &quot;A String&quot;, # Batch size for dnn models.
        &quot;cleanSpikesAndDips&quot;: True or False, # If true, clean spikes and dips in the input time series.
        &quot;dataFrequency&quot;: &quot;A String&quot;, # The data frequency of a time series.
        &quot;dataSplitColumn&quot;: &quot;A String&quot;, # The column to split data with. This column won&#x27;t be used as a feature. 1. When data_split_method is CUSTOM, the corresponding column should be boolean. The rows with true value tag are eval data, and the false are training data. 2. When data_split_method is SEQ, the first DATA_SPLIT_EVAL_FRACTION rows (from smallest to largest) in the corresponding column are used as training data, and the rest are eval data. It respects the order in Orderable data types: https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#data-type-properties
        &quot;dataSplitEvalFraction&quot;: 3.14, # The fraction of evaluation data over the whole input data. The rest of data will be used as training data. The format should be double. Accurate to two decimal places. Default value is 0.2.
        &quot;dataSplitMethod&quot;: &quot;A String&quot;, # The data split type for training and evaluation, e.g. RANDOM.
        &quot;decomposeTimeSeries&quot;: True or False, # If true, perform decompose time series and save the results.
        &quot;distanceType&quot;: &quot;A String&quot;, # Distance type for clustering models.
        &quot;dropout&quot;: 3.14, # Dropout probability for dnn models.
        &quot;earlyStop&quot;: True or False, # Whether to stop early when the loss doesn&#x27;t improve significantly any more (compared to min_relative_progress). Used only for iterative training algorithms.
        &quot;feedbackType&quot;: &quot;A String&quot;, # Feedback type that specifies which algorithm to run for matrix factorization.
        &quot;hiddenUnits&quot;: [ # Hidden units for dnn models.
          &quot;A String&quot;,
        ],
        &quot;holidayRegion&quot;: &quot;A String&quot;, # The geographical region based on which the holidays are considered in time series modeling. If a valid value is specified, then holiday effects modeling is enabled.
        &quot;horizon&quot;: &quot;A String&quot;, # The number of periods ahead that need to be forecasted.
        &quot;includeDrift&quot;: True or False, # Include drift when fitting an ARIMA model.
        &quot;initialLearnRate&quot;: 3.14, # Specifies the initial learning rate for the line search learn rate strategy.
        &quot;inputLabelColumns&quot;: [ # Name of input label columns in training data.
          &quot;A String&quot;,
        ],
        &quot;itemColumn&quot;: &quot;A String&quot;, # Item column specified for matrix factorization models.
        &quot;kmeansInitializationColumn&quot;: &quot;A String&quot;, # The column used to provide the initial centroids for kmeans algorithm when kmeans_initialization_method is CUSTOM.
        &quot;kmeansInitializationMethod&quot;: &quot;A String&quot;, # The method used to initialize the centroids for kmeans algorithm.
        &quot;l1Regularization&quot;: 3.14, # L1 regularization coefficient.
        &quot;l2Regularization&quot;: 3.14, # L2 regularization coefficient.
        &quot;labelClassWeights&quot;: { # Weights associated with each label class, for rebalancing the training data. Only applicable for classification models.
          &quot;a_key&quot;: 3.14,
        },
        &quot;learnRate&quot;: 3.14, # Learning rate in training. Used only for iterative training algorithms.
        &quot;learnRateStrategy&quot;: &quot;A String&quot;, # The strategy to determine learn rate for the current iteration.
        &quot;lossType&quot;: &quot;A String&quot;, # Type of loss function used during training run.
        &quot;maxIterations&quot;: &quot;A String&quot;, # The maximum number of iterations in training. Used only for iterative training algorithms.
        &quot;maxTreeDepth&quot;: &quot;A String&quot;, # Maximum depth of a tree for boosted tree models.
        &quot;minRelativeProgress&quot;: 3.14, # When early_stop is true, stops training when accuracy improvement is less than &#x27;min_relative_progress&#x27;. Used only for iterative training algorithms.
        &quot;minSplitLoss&quot;: 3.14, # Minimum split loss for boosted tree models.
        &quot;modelUri&quot;: &quot;A String&quot;, # Google Cloud Storage URI from which the model was imported. Only applicable for imported models.
        &quot;nonSeasonalOrder&quot;: { # Arima order, can be used for both non-seasonal and seasonal parts. # A specification of the non-seasonal part of the ARIMA model: the three components (p, d, q) are the AR order, the degree of differencing, and the MA order.
          &quot;d&quot;: &quot;A String&quot;, # Order of the differencing part.
          &quot;p&quot;: &quot;A String&quot;, # Order of the autoregressive part.
          &quot;q&quot;: &quot;A String&quot;, # Order of the moving-average part.
        },
        &quot;numClusters&quot;: &quot;A String&quot;, # Number of clusters for clustering models.
        &quot;numFactors&quot;: &quot;A String&quot;, # Num factors specified for matrix factorization models.
        &quot;optimizationStrategy&quot;: &quot;A String&quot;, # Optimization strategy for training linear regression models.
        &quot;preserveInputStructs&quot;: True or False, # Whether to preserve the input structs in output feature names. Suppose there is a struct A with field b. When false (default), the output feature name is A_b. When true, the output feature name is A.b.
        &quot;subsample&quot;: 3.14, # Subsample fraction of the training data to grow tree to prevent overfitting for boosted tree models.
        &quot;timeSeriesDataColumn&quot;: &quot;A String&quot;, # Column to be designated as time series data for ARIMA model.
        &quot;timeSeriesIdColumn&quot;: &quot;A String&quot;, # The time series id column that was used during ARIMA model training.
        &quot;timeSeriesIdColumns&quot;: [ # The time series id columns that were used during ARIMA model training.
          &quot;A String&quot;,
        ],
        &quot;timeSeriesTimestampColumn&quot;: &quot;A String&quot;, # Column to be designated as time series timestamp for ARIMA model.
        &quot;userColumn&quot;: &quot;A String&quot;, # User column specified for matrix factorization models.
        &quot;walsAlpha&quot;: 3.14, # Hyperparameter for matrix factoration when implicit feedback type is specified.
        &quot;warmStart&quot;: True or False, # Whether to train a model from the last checkpoint.
      },
    },
  ],
}</pre>
</div>

<div class="method">
    <code class="details" id="list">list(projectId, datasetId, maxResults=None, pageToken=None)</code>
  <pre>Lists all models in the specified dataset. Requires the READER dataset role.

Args:
  projectId: string, Required. Project ID of the models to list. (required)
  datasetId: string, Required. Dataset ID of the models to list. (required)
  maxResults: integer, The maximum number of results to return in a single response page. Leverage the page tokens to iterate through the entire collection.
  pageToken: string, Page token, returned by a previous call to request the next page of results

Returns:
  An object of the form:

    {
  &quot;models&quot;: [ # Models in the requested dataset. Only the following fields are populated: model_reference, model_type, creation_time, last_modified_time and labels.
    {
      &quot;bestTrialId&quot;: &quot;A String&quot;, # The best trial_id across all training runs.
      &quot;creationTime&quot;: &quot;A String&quot;, # Output only. The time when this model was created, in millisecs since the epoch.
      &quot;description&quot;: &quot;A String&quot;, # Optional. A user-friendly description of this model.
      &quot;encryptionConfiguration&quot;: { # Custom encryption configuration (e.g., Cloud KMS keys). This shows the encryption configuration of the model data while stored in BigQuery storage. This field can be used with PatchModel to update encryption key for an already encrypted model.
        &quot;kmsKeyName&quot;: &quot;A String&quot;, # [Optional] Describes the Cloud KMS encryption key that will be used to protect destination BigQuery table. The BigQuery Service Account associated with your project requires access to this encryption key.
      },
      &quot;etag&quot;: &quot;A String&quot;, # Output only. A hash of this resource.
      &quot;expirationTime&quot;: &quot;A String&quot;, # Optional. The time when this model expires, in milliseconds since the epoch. If not present, the model will persist indefinitely. Expired models will be deleted and their storage reclaimed. The defaultTableExpirationMs property of the encapsulating dataset can be used to set a default expirationTime on newly created models.
      &quot;featureColumns&quot;: [ # Output only. Input feature columns that were used to train this model.
        { # A field or a column.
          &quot;name&quot;: &quot;A String&quot;, # Optional. The name of this field. Can be absent for struct fields.
          &quot;type&quot;: { # The type of a variable, e.g., a function argument. Examples: INT64: {type_kind=&quot;INT64&quot;} ARRAY: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;} STRUCT&gt;: {type_kind=&quot;STRUCT&quot;, struct_type={fields=[ {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}}, {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}} ]}} # Optional. The type of this parameter. Absent if not explicitly specified (e.g., CREATE FUNCTION statement can omit the return type; in this case the output parameter does not have this &quot;type&quot; field).
            &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
            &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
              &quot;fields&quot;: [
                # Object with schema name: StandardSqlField
              ],
            },
            &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field. Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
          },
        },
      ],
      &quot;friendlyName&quot;: &quot;A String&quot;, # Optional. A descriptive name for this model.
      &quot;labelColumns&quot;: [ # Output only. Label columns that were used to train this model. The output of the model will have a &quot;predicted_&quot; prefix to these columns.
        { # A field or a column.
          &quot;name&quot;: &quot;A String&quot;, # Optional. The name of this field. Can be absent for struct fields.
          &quot;type&quot;: { # The type of a variable, e.g., a function argument. Examples: INT64: {type_kind=&quot;INT64&quot;} ARRAY: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;} STRUCT&gt;: {type_kind=&quot;STRUCT&quot;, struct_type={fields=[ {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}}, {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}} ]}} # Optional. The type of this parameter. Absent if not explicitly specified (e.g., CREATE FUNCTION statement can omit the return type; in this case the output parameter does not have this &quot;type&quot; field).
            &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
            &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
              &quot;fields&quot;: [
                # Object with schema name: StandardSqlField
              ],
            },
            &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field. Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
          },
        },
      ],
      &quot;labels&quot;: { # The labels associated with this model. You can use these to organize and group your models. Label keys and values can be no longer than 63 characters, can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. Label values are optional. Label keys must start with a letter and each label in the list must have a different key.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
      &quot;lastModifiedTime&quot;: &quot;A String&quot;, # Output only. The time when this model was last modified, in millisecs since the epoch.
      &quot;location&quot;: &quot;A String&quot;, # Output only. The geographic location where the model resides. This value is inherited from the dataset.
      &quot;modelReference&quot;: { # Required. Unique identifier for this model.
        &quot;datasetId&quot;: &quot;A String&quot;, # [Required] The ID of the dataset containing this model.
        &quot;modelId&quot;: &quot;A String&quot;, # [Required] The ID of the model. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 1,024 characters.
        &quot;projectId&quot;: &quot;A String&quot;, # [Required] The ID of the project containing this model.
      },
      &quot;modelType&quot;: &quot;A String&quot;, # Output only. Type of the model resource.
      &quot;trainingRuns&quot;: [ # Output only. Information for all training runs in increasing order of start_time.
        { # Information about a single training query run for the model.
          &quot;dataSplitResult&quot;: { # Data split result. This contains references to the training and evaluation data tables that were used to train the model. # Data split result of the training run. Only set when the input data is actually split.
            &quot;evaluationTable&quot;: { # Table reference of the evaluation data after split.
              &quot;datasetId&quot;: &quot;A String&quot;, # [Required] The ID of the dataset containing this table.
              &quot;projectId&quot;: &quot;A String&quot;, # [Required] The ID of the project containing this table.
              &quot;tableId&quot;: &quot;A String&quot;, # [Required] The ID of the table. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 1,024 characters.
            },
            &quot;trainingTable&quot;: { # Table reference of the training data after split.
              &quot;datasetId&quot;: &quot;A String&quot;, # [Required] The ID of the dataset containing this table.
              &quot;projectId&quot;: &quot;A String&quot;, # [Required] The ID of the project containing this table.
              &quot;tableId&quot;: &quot;A String&quot;, # [Required] The ID of the table. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 1,024 characters.
            },
          },
          &quot;evaluationMetrics&quot;: { # Evaluation metrics of a model. These are either computed on all training data or just the eval data based on whether eval data was used during training. These are not present for imported models. # The evaluation metrics over training/eval data that were computed at the end of training.
            &quot;arimaForecastingMetrics&quot;: { # Model evaluation metrics for ARIMA forecasting models. # Populated for ARIMA models.
              &quot;arimaFittingMetrics&quot;: [ # Arima model fitting metrics.
                { # ARIMA model fitting metrics.
                  &quot;aic&quot;: 3.14, # AIC.
                  &quot;logLikelihood&quot;: 3.14, # Log-likelihood.
                  &quot;variance&quot;: 3.14, # Variance.
                },
              ],
              &quot;arimaSingleModelForecastingMetrics&quot;: [ # Repeated as there can be many metric sets (one for each model) in auto-arima and the large-scale case.
                { # Model evaluation metrics for a single ARIMA forecasting model.
                  &quot;arimaFittingMetrics&quot;: { # ARIMA model fitting metrics. # Arima fitting metrics.
                    &quot;aic&quot;: 3.14, # AIC.
                    &quot;logLikelihood&quot;: 3.14, # Log-likelihood.
                    &quot;variance&quot;: 3.14, # Variance.
                  },
                  &quot;hasDrift&quot;: True or False, # Is arima model fitted with drift or not. It is always false when d is not 1.
                  &quot;hasHolidayEffect&quot;: True or False, # If true, holiday_effect is a part of time series decomposition result.
                  &quot;hasSpikesAndDips&quot;: True or False, # If true, spikes_and_dips is a part of time series decomposition result.
                  &quot;hasStepChanges&quot;: True or False, # If true, step_changes is a part of time series decomposition result.
                  &quot;nonSeasonalOrder&quot;: { # Arima order, can be used for both non-seasonal and seasonal parts. # Non-seasonal order.
                    &quot;d&quot;: &quot;A String&quot;, # Order of the differencing part.
                    &quot;p&quot;: &quot;A String&quot;, # Order of the autoregressive part.
                    &quot;q&quot;: &quot;A String&quot;, # Order of the moving-average part.
                  },
                  &quot;seasonalPeriods&quot;: [ # Seasonal periods. Repeated because multiple periods are supported for one time series.
                    &quot;A String&quot;,
                  ],
                  &quot;timeSeriesId&quot;: &quot;A String&quot;, # The time_series_id value for this time series. It will be one of the unique values from the time_series_id_column specified during ARIMA model training. Only present when time_series_id_column training option was used.
                  &quot;timeSeriesIds&quot;: [ # The tuple of time_series_ids identifying this time series. It will be one of the unique tuples of values present in the time_series_id_columns specified during ARIMA model training. Only present when time_series_id_columns training option was used and the order of values here are same as the order of time_series_id_columns.
                    &quot;A String&quot;,
                  ],
                },
              ],
              &quot;hasDrift&quot;: [ # Whether Arima model fitted with drift or not. It is always false when d is not 1.
                True or False,
              ],
              &quot;nonSeasonalOrder&quot;: [ # Non-seasonal order.
                { # Arima order, can be used for both non-seasonal and seasonal parts.
                  &quot;d&quot;: &quot;A String&quot;, # Order of the differencing part.
                  &quot;p&quot;: &quot;A String&quot;, # Order of the autoregressive part.
                  &quot;q&quot;: &quot;A String&quot;, # Order of the moving-average part.
                },
              ],
              &quot;seasonalPeriods&quot;: [ # Seasonal periods. Repeated because multiple periods are supported for one time series.
                &quot;A String&quot;,
              ],
              &quot;timeSeriesId&quot;: [ # Id to differentiate different time series for the large-scale case.
                &quot;A String&quot;,
              ],
            },
            &quot;binaryClassificationMetrics&quot;: { # Evaluation metrics for binary classification/classifier models. # Populated for binary classification/classifier models.
              &quot;aggregateClassificationMetrics&quot;: { # Aggregate metrics for classification/classifier models. For multi-class models, the metrics are either macro-averaged or micro-averaged. When macro-averaged, the metrics are calculated for each label and then an unweighted average is taken of those values. When micro-averaged, the metric is calculated globally by counting the total number of correctly predicted rows. # Aggregate classification metrics.
                &quot;accuracy&quot;: 3.14, # Accuracy is the fraction of predictions given the correct label. For multiclass this is a micro-averaged metric.
                &quot;f1Score&quot;: 3.14, # The F1 score is an average of recall and precision. For multiclass this is a macro-averaged metric.
                &quot;logLoss&quot;: 3.14, # Logarithmic Loss. For multiclass this is a macro-averaged metric.
                &quot;precision&quot;: 3.14, # Precision is the fraction of actual positive predictions that had positive actual labels. For multiclass this is a macro-averaged metric treating each class as a binary classifier.
                &quot;recall&quot;: 3.14, # Recall is the fraction of actual positive labels that were given a positive prediction. For multiclass this is a macro-averaged metric.
                &quot;rocAuc&quot;: 3.14, # Area Under a ROC Curve. For multiclass this is a macro-averaged metric.
                &quot;threshold&quot;: 3.14, # Threshold at which the metrics are computed. For binary classification models this is the positive class threshold. For multi-class classfication models this is the confidence threshold.
              },
              &quot;binaryConfusionMatrixList&quot;: [ # Binary confusion matrix at multiple thresholds.
                { # Confusion matrix for binary classification models.
                  &quot;accuracy&quot;: 3.14, # The fraction of predictions given the correct label.
                  &quot;f1Score&quot;: 3.14, # The equally weighted average of recall and precision.
                  &quot;falseNegatives&quot;: &quot;A String&quot;, # Number of false samples predicted as false.
                  &quot;falsePositives&quot;: &quot;A String&quot;, # Number of false samples predicted as true.
                  &quot;positiveClassThreshold&quot;: 3.14, # Threshold value used when computing each of the following metric.
                  &quot;precision&quot;: 3.14, # The fraction of actual positive predictions that had positive actual labels.
                  &quot;recall&quot;: 3.14, # The fraction of actual positive labels that were given a positive prediction.
                  &quot;trueNegatives&quot;: &quot;A String&quot;, # Number of true samples predicted as false.
                  &quot;truePositives&quot;: &quot;A String&quot;, # Number of true samples predicted as true.
                },
              ],
              &quot;negativeLabel&quot;: &quot;A String&quot;, # Label representing the negative class.
              &quot;positiveLabel&quot;: &quot;A String&quot;, # Label representing the positive class.
            },
            &quot;clusteringMetrics&quot;: { # Evaluation metrics for clustering models. # Populated for clustering models.
              &quot;clusters&quot;: [ # Information for all clusters.
                { # Message containing the information about one cluster.
                  &quot;centroidId&quot;: &quot;A String&quot;, # Centroid id.
                  &quot;count&quot;: &quot;A String&quot;, # Count of training data rows that were assigned to this cluster.
                  &quot;featureValues&quot;: [ # Values of highly variant features for this cluster.
                    { # Representative value of a single feature within the cluster.
                      &quot;categoricalValue&quot;: { # Representative value of a categorical feature. # The categorical feature value.
                        &quot;categoryCounts&quot;: [ # Counts of all categories for the categorical feature. If there are more than ten categories, we return top ten (by count) and return one more CategoryCount with category &quot;_OTHER_&quot; and count as aggregate counts of remaining categories.
                          { # Represents the count of a single category within the cluster.
                            &quot;category&quot;: &quot;A String&quot;, # The name of category.
                            &quot;count&quot;: &quot;A String&quot;, # The count of training samples matching the category within the cluster.
                          },
                        ],
                      },
                      &quot;featureColumn&quot;: &quot;A String&quot;, # The feature column name.
                      &quot;numericalValue&quot;: 3.14, # The numerical feature value. This is the centroid value for this feature.
                    },
                  ],
                },
              ],
              &quot;daviesBouldinIndex&quot;: 3.14, # Davies-Bouldin index.
              &quot;meanSquaredDistance&quot;: 3.14, # Mean of squared distances between each sample to its cluster centroid.
            },
            &quot;multiClassClassificationMetrics&quot;: { # Evaluation metrics for multi-class classification/classifier models. # Populated for multi-class classification/classifier models.
              &quot;aggregateClassificationMetrics&quot;: { # Aggregate metrics for classification/classifier models. For multi-class models, the metrics are either macro-averaged or micro-averaged. When macro-averaged, the metrics are calculated for each label and then an unweighted average is taken of those values. When micro-averaged, the metric is calculated globally by counting the total number of correctly predicted rows. # Aggregate classification metrics.
                &quot;accuracy&quot;: 3.14, # Accuracy is the fraction of predictions given the correct label. For multiclass this is a micro-averaged metric.
                &quot;f1Score&quot;: 3.14, # The F1 score is an average of recall and precision. For multiclass this is a macro-averaged metric.
                &quot;logLoss&quot;: 3.14, # Logarithmic Loss. For multiclass this is a macro-averaged metric.
                &quot;precision&quot;: 3.14, # Precision is the fraction of actual positive predictions that had positive actual labels. For multiclass this is a macro-averaged metric treating each class as a binary classifier.
                &quot;recall&quot;: 3.14, # Recall is the fraction of actual positive labels that were given a positive prediction. For multiclass this is a macro-averaged metric.
                &quot;rocAuc&quot;: 3.14, # Area Under a ROC Curve. For multiclass this is a macro-averaged metric.
                &quot;threshold&quot;: 3.14, # Threshold at which the metrics are computed. For binary classification models this is the positive class threshold. For multi-class classfication models this is the confidence threshold.
              },
              &quot;confusionMatrixList&quot;: [ # Confusion matrix at different thresholds.
                { # Confusion matrix for multi-class classification models.
                  &quot;confidenceThreshold&quot;: 3.14, # Confidence threshold used when computing the entries of the confusion matrix.
                  &quot;rows&quot;: [ # One row per actual label.
                    { # A single row in the confusion matrix.
                      &quot;actualLabel&quot;: &quot;A String&quot;, # The original label of this row.
                      &quot;entries&quot;: [ # Info describing predicted label distribution.
                        { # A single entry in the confusion matrix.
                          &quot;itemCount&quot;: &quot;A String&quot;, # Number of items being predicted as this label.
                          &quot;predictedLabel&quot;: &quot;A String&quot;, # The predicted label. For confidence_threshold &gt; 0, we will also add an entry indicating the number of items under the confidence threshold.
                        },
                      ],
                    },
                  ],
                },
              ],
            },
            &quot;rankingMetrics&quot;: { # Evaluation metrics used by weighted-ALS models specified by feedback_type=implicit. # Populated for implicit feedback type matrix factorization models.
              &quot;averageRank&quot;: 3.14, # Determines the goodness of a ranking by computing the percentile rank from the predicted confidence and dividing it by the original rank.
              &quot;meanAveragePrecision&quot;: 3.14, # Calculates a precision per user for all the items by ranking them and then averages all the precisions across all the users.
              &quot;meanSquaredError&quot;: 3.14, # Similar to the mean squared error computed in regression and explicit recommendation models except instead of computing the rating directly, the output from evaluate is computed against a preference which is 1 or 0 depending on if the rating exists or not.
              &quot;normalizedDiscountedCumulativeGain&quot;: 3.14, # A metric to determine the goodness of a ranking calculated from the predicted confidence by comparing it to an ideal rank measured by the original ratings.
            },
            &quot;regressionMetrics&quot;: { # Evaluation metrics for regression and explicit feedback type matrix factorization models. # Populated for regression models and explicit feedback type matrix factorization models.
              &quot;meanAbsoluteError&quot;: 3.14, # Mean absolute error.
              &quot;meanSquaredError&quot;: 3.14, # Mean squared error.
              &quot;meanSquaredLogError&quot;: 3.14, # Mean squared log error.
              &quot;medianAbsoluteError&quot;: 3.14, # Median absolute error.
              &quot;rSquared&quot;: 3.14, # R^2 score. This corresponds to r2_score in ML.EVALUATE.
            },
          },
          &quot;globalExplanations&quot;: [ # Global explanations for important features of the model. For multi-class models, there is one entry for each label class. For other models, there is only one entry in the list.
            { # Global explanations containing the top most important features after training.
              &quot;classLabel&quot;: &quot;A String&quot;, # Class label for this set of global explanations. Will be empty/null for binary logistic and linear regression models. Sorted alphabetically in descending order.
              &quot;explanations&quot;: [ # A list of the top global explanations. Sorted by absolute value of attribution in descending order.
                { # Explanation for a single feature.
                  &quot;attribution&quot;: 3.14, # Attribution of feature.
                  &quot;featureName&quot;: &quot;A String&quot;, # Full name of the feature. For non-numerical features, will be formatted like .. Overall size of feature name will always be truncated to first 120 characters.
                },
              ],
            },
          ],
          &quot;results&quot;: [ # Output of each iteration run, results.size() &lt;= max_iterations.
            { # Information about a single iteration of the training run.
              &quot;arimaResult&quot;: { # (Auto-)arima fitting result. Wrap everything in ArimaResult for easier refactoring if we want to use model-specific iteration results.
                &quot;arimaModelInfo&quot;: [ # This message is repeated because there are multiple arima models fitted in auto-arima. For non-auto-arima model, its size is one.
                  { # Arima model information.
                    &quot;arimaCoefficients&quot;: { # Arima coefficients. # Arima coefficients.
                      &quot;autoRegressiveCoefficients&quot;: [ # Auto-regressive coefficients, an array of double.
                        3.14,
                      ],
                      &quot;interceptCoefficient&quot;: 3.14, # Intercept coefficient, just a double not an array.
                      &quot;movingAverageCoefficients&quot;: [ # Moving-average coefficients, an array of double.
                        3.14,
                      ],
                    },
                    &quot;arimaFittingMetrics&quot;: { # ARIMA model fitting metrics. # Arima fitting metrics.
                      &quot;aic&quot;: 3.14, # AIC.
                      &quot;logLikelihood&quot;: 3.14, # Log-likelihood.
                      &quot;variance&quot;: 3.14, # Variance.
                    },
                    &quot;hasDrift&quot;: True or False, # Whether Arima model fitted with drift or not. It is always false when d is not 1.
                    &quot;hasHolidayEffect&quot;: True or False, # If true, holiday_effect is a part of time series decomposition result.
                    &quot;hasSpikesAndDips&quot;: True or False, # If true, spikes_and_dips is a part of time series decomposition result.
                    &quot;hasStepChanges&quot;: True or False, # If true, step_changes is a part of time series decomposition result.
                    &quot;nonSeasonalOrder&quot;: { # Arima order, can be used for both non-seasonal and seasonal parts. # Non-seasonal order.
                      &quot;d&quot;: &quot;A String&quot;, # Order of the differencing part.
                      &quot;p&quot;: &quot;A String&quot;, # Order of the autoregressive part.
                      &quot;q&quot;: &quot;A String&quot;, # Order of the moving-average part.
                    },
                    &quot;seasonalPeriods&quot;: [ # Seasonal periods. Repeated because multiple periods are supported for one time series.
                      &quot;A String&quot;,
                    ],
                    &quot;timeSeriesId&quot;: &quot;A String&quot;, # The time_series_id value for this time series. It will be one of the unique values from the time_series_id_column specified during ARIMA model training. Only present when time_series_id_column training option was used.
                    &quot;timeSeriesIds&quot;: [ # The tuple of time_series_ids identifying this time series. It will be one of the unique tuples of values present in the time_series_id_columns specified during ARIMA model training. Only present when time_series_id_columns training option was used and the order of values here are same as the order of time_series_id_columns.
                      &quot;A String&quot;,
                    ],
                  },
                ],
                &quot;seasonalPeriods&quot;: [ # Seasonal periods. Repeated because multiple periods are supported for one time series.
                  &quot;A String&quot;,
                ],
              },
              &quot;clusterInfos&quot;: [ # Information about top clusters for clustering models.
                { # Information about a single cluster for clustering model.
                  &quot;centroidId&quot;: &quot;A String&quot;, # Centroid id.
                  &quot;clusterRadius&quot;: 3.14, # Cluster radius, the average distance from centroid to each point assigned to the cluster.
                  &quot;clusterSize&quot;: &quot;A String&quot;, # Cluster size, the total number of points assigned to the cluster.
                },
              ],
              &quot;durationMs&quot;: &quot;A String&quot;, # Time taken to run the iteration in milliseconds.
              &quot;evalLoss&quot;: 3.14, # Loss computed on the eval data at the end of iteration.
              &quot;index&quot;: 42, # Index of the iteration, 0 based.
              &quot;learnRate&quot;: 3.14, # Learn rate used for this iteration.
              &quot;trainingLoss&quot;: 3.14, # Loss computed on the training data at the end of iteration.
            },
          ],
          &quot;startTime&quot;: &quot;A String&quot;, # The start time of this training run.
          &quot;trainingOptions&quot;: { # Options used in model training. # Options that were used for this training run, includes user specified and default options that were used.
            &quot;adjustStepChanges&quot;: True or False, # If true, detect step changes and make data adjustment in the input time series.
            &quot;autoArima&quot;: True or False, # Whether to enable auto ARIMA or not.
            &quot;autoArimaMaxOrder&quot;: &quot;A String&quot;, # The max value of non-seasonal p and q.
            &quot;batchSize&quot;: &quot;A String&quot;, # Batch size for dnn models.
            &quot;cleanSpikesAndDips&quot;: True or False, # If true, clean spikes and dips in the input time series.
            &quot;dataFrequency&quot;: &quot;A String&quot;, # The data frequency of a time series.
            &quot;dataSplitColumn&quot;: &quot;A String&quot;, # The column to split data with. This column won&#x27;t be used as a feature. 1. When data_split_method is CUSTOM, the corresponding column should be boolean. The rows with true value tag are eval data, and the false are training data. 2. When data_split_method is SEQ, the first DATA_SPLIT_EVAL_FRACTION rows (from smallest to largest) in the corresponding column are used as training data, and the rest are eval data. It respects the order in Orderable data types: https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#data-type-properties
            &quot;dataSplitEvalFraction&quot;: 3.14, # The fraction of evaluation data over the whole input data. The rest of data will be used as training data. The format should be double. Accurate to two decimal places. Default value is 0.2.
            &quot;dataSplitMethod&quot;: &quot;A String&quot;, # The data split type for training and evaluation, e.g. RANDOM.
            &quot;decomposeTimeSeries&quot;: True or False, # If true, perform decompose time series and save the results.
            &quot;distanceType&quot;: &quot;A String&quot;, # Distance type for clustering models.
            &quot;dropout&quot;: 3.14, # Dropout probability for dnn models.
            &quot;earlyStop&quot;: True or False, # Whether to stop early when the loss doesn&#x27;t improve significantly any more (compared to min_relative_progress). Used only for iterative training algorithms.
            &quot;feedbackType&quot;: &quot;A String&quot;, # Feedback type that specifies which algorithm to run for matrix factorization.
            &quot;hiddenUnits&quot;: [ # Hidden units for dnn models.
              &quot;A String&quot;,
            ],
            &quot;holidayRegion&quot;: &quot;A String&quot;, # The geographical region based on which the holidays are considered in time series modeling. If a valid value is specified, then holiday effects modeling is enabled.
            &quot;horizon&quot;: &quot;A String&quot;, # The number of periods ahead that need to be forecasted.
            &quot;includeDrift&quot;: True or False, # Include drift when fitting an ARIMA model.
            &quot;initialLearnRate&quot;: 3.14, # Specifies the initial learning rate for the line search learn rate strategy.
            &quot;inputLabelColumns&quot;: [ # Name of input label columns in training data.
              &quot;A String&quot;,
            ],
            &quot;itemColumn&quot;: &quot;A String&quot;, # Item column specified for matrix factorization models.
            &quot;kmeansInitializationColumn&quot;: &quot;A String&quot;, # The column used to provide the initial centroids for kmeans algorithm when kmeans_initialization_method is CUSTOM.
            &quot;kmeansInitializationMethod&quot;: &quot;A String&quot;, # The method used to initialize the centroids for kmeans algorithm.
            &quot;l1Regularization&quot;: 3.14, # L1 regularization coefficient.
            &quot;l2Regularization&quot;: 3.14, # L2 regularization coefficient.
            &quot;labelClassWeights&quot;: { # Weights associated with each label class, for rebalancing the training data. Only applicable for classification models.
              &quot;a_key&quot;: 3.14,
            },
            &quot;learnRate&quot;: 3.14, # Learning rate in training. Used only for iterative training algorithms.
            &quot;learnRateStrategy&quot;: &quot;A String&quot;, # The strategy to determine learn rate for the current iteration.
            &quot;lossType&quot;: &quot;A String&quot;, # Type of loss function used during training run.
            &quot;maxIterations&quot;: &quot;A String&quot;, # The maximum number of iterations in training. Used only for iterative training algorithms.
            &quot;maxTreeDepth&quot;: &quot;A String&quot;, # Maximum depth of a tree for boosted tree models.
            &quot;minRelativeProgress&quot;: 3.14, # When early_stop is true, stops training when accuracy improvement is less than &#x27;min_relative_progress&#x27;. Used only for iterative training algorithms.
            &quot;minSplitLoss&quot;: 3.14, # Minimum split loss for boosted tree models.
            &quot;modelUri&quot;: &quot;A String&quot;, # Google Cloud Storage URI from which the model was imported. Only applicable for imported models.
            &quot;nonSeasonalOrder&quot;: { # Arima order, can be used for both non-seasonal and seasonal parts. # A specification of the non-seasonal part of the ARIMA model: the three components (p, d, q) are the AR order, the degree of differencing, and the MA order.
              &quot;d&quot;: &quot;A String&quot;, # Order of the differencing part.
              &quot;p&quot;: &quot;A String&quot;, # Order of the autoregressive part.
              &quot;q&quot;: &quot;A String&quot;, # Order of the moving-average part.
            },
            &quot;numClusters&quot;: &quot;A String&quot;, # Number of clusters for clustering models.
            &quot;numFactors&quot;: &quot;A String&quot;, # Num factors specified for matrix factorization models.
            &quot;optimizationStrategy&quot;: &quot;A String&quot;, # Optimization strategy for training linear regression models.
            &quot;preserveInputStructs&quot;: True or False, # Whether to preserve the input structs in output feature names. Suppose there is a struct A with field b. When false (default), the output feature name is A_b. When true, the output feature name is A.b.
            &quot;subsample&quot;: 3.14, # Subsample fraction of the training data to grow tree to prevent overfitting for boosted tree models.
            &quot;timeSeriesDataColumn&quot;: &quot;A String&quot;, # Column to be designated as time series data for ARIMA model.
            &quot;timeSeriesIdColumn&quot;: &quot;A String&quot;, # The time series id column that was used during ARIMA model training.
            &quot;timeSeriesIdColumns&quot;: [ # The time series id columns that were used during ARIMA model training.
              &quot;A String&quot;,
            ],
            &quot;timeSeriesTimestampColumn&quot;: &quot;A String&quot;, # Column to be designated as time series timestamp for ARIMA model.
            &quot;userColumn&quot;: &quot;A String&quot;, # User column specified for matrix factorization models.
            &quot;walsAlpha&quot;: 3.14, # Hyperparameter for matrix factoration when implicit feedback type is specified.
            &quot;warmStart&quot;: True or False, # Whether to train a model from the last checkpoint.
          },
        },
      ],
    },
  ],
  &quot;nextPageToken&quot;: &quot;A String&quot;, # A token to request the next page of results.
}</pre>
</div>

<div class="method">
    <code class="details" id="list_next">list_next(previous_request, previous_response)</code>
  <pre>Retrieves the next page of results.

Args:
  previous_request: The request for the previous page. (required)
  previous_response: The response from the request for the previous page. (required)

Returns:
  A request object that you can call &#x27;execute()&#x27; on to request the next
  page. Returns None if there are no more items in the collection.
    </pre>
</div>

<div class="method">
    <code class="details" id="patch">patch(projectId, datasetId, modelId, body=None)</code>
  <pre>Patch specific fields in the specified model.

Args:
  projectId: string, Required. Project ID of the model to patch. (required)
  datasetId: string, Required. Dataset ID of the model to patch. (required)
  modelId: string, Required. Model ID of the model to patch. (required)
  body: object, The request body.
    The object takes the form of:

{
  &quot;bestTrialId&quot;: &quot;A String&quot;, # The best trial_id across all training runs.
  &quot;creationTime&quot;: &quot;A String&quot;, # Output only. The time when this model was created, in millisecs since the epoch.
  &quot;description&quot;: &quot;A String&quot;, # Optional. A user-friendly description of this model.
  &quot;encryptionConfiguration&quot;: { # Custom encryption configuration (e.g., Cloud KMS keys). This shows the encryption configuration of the model data while stored in BigQuery storage. This field can be used with PatchModel to update encryption key for an already encrypted model.
    &quot;kmsKeyName&quot;: &quot;A String&quot;, # [Optional] Describes the Cloud KMS encryption key that will be used to protect destination BigQuery table. The BigQuery Service Account associated with your project requires access to this encryption key.
  },
  &quot;etag&quot;: &quot;A String&quot;, # Output only. A hash of this resource.
  &quot;expirationTime&quot;: &quot;A String&quot;, # Optional. The time when this model expires, in milliseconds since the epoch. If not present, the model will persist indefinitely. Expired models will be deleted and their storage reclaimed. The defaultTableExpirationMs property of the encapsulating dataset can be used to set a default expirationTime on newly created models.
  &quot;featureColumns&quot;: [ # Output only. Input feature columns that were used to train this model.
    { # A field or a column.
      &quot;name&quot;: &quot;A String&quot;, # Optional. The name of this field. Can be absent for struct fields.
      &quot;type&quot;: { # The type of a variable, e.g., a function argument. Examples: INT64: {type_kind=&quot;INT64&quot;} ARRAY: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;} STRUCT&gt;: {type_kind=&quot;STRUCT&quot;, struct_type={fields=[ {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}}, {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}} ]}} # Optional. The type of this parameter. Absent if not explicitly specified (e.g., CREATE FUNCTION statement can omit the return type; in this case the output parameter does not have this &quot;type&quot; field).
        &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
        &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
          &quot;fields&quot;: [
            # Object with schema name: StandardSqlField
          ],
        },
        &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field. Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
      },
    },
  ],
  &quot;friendlyName&quot;: &quot;A String&quot;, # Optional. A descriptive name for this model.
  &quot;labelColumns&quot;: [ # Output only. Label columns that were used to train this model. The output of the model will have a &quot;predicted_&quot; prefix to these columns.
    { # A field or a column.
      &quot;name&quot;: &quot;A String&quot;, # Optional. The name of this field. Can be absent for struct fields.
      &quot;type&quot;: { # The type of a variable, e.g., a function argument. Examples: INT64: {type_kind=&quot;INT64&quot;} ARRAY: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;} STRUCT&gt;: {type_kind=&quot;STRUCT&quot;, struct_type={fields=[ {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}}, {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}} ]}} # Optional. The type of this parameter. Absent if not explicitly specified (e.g., CREATE FUNCTION statement can omit the return type; in this case the output parameter does not have this &quot;type&quot; field).
        &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
        &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
          &quot;fields&quot;: [
            # Object with schema name: StandardSqlField
          ],
        },
        &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field. Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
      },
    },
  ],
  &quot;labels&quot;: { # The labels associated with this model. You can use these to organize and group your models. Label keys and values can be no longer than 63 characters, can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. Label values are optional. Label keys must start with a letter and each label in the list must have a different key.
    &quot;a_key&quot;: &quot;A String&quot;,
  },
  &quot;lastModifiedTime&quot;: &quot;A String&quot;, # Output only. The time when this model was last modified, in millisecs since the epoch.
  &quot;location&quot;: &quot;A String&quot;, # Output only. The geographic location where the model resides. This value is inherited from the dataset.
  &quot;modelReference&quot;: { # Required. Unique identifier for this model.
    &quot;datasetId&quot;: &quot;A String&quot;, # [Required] The ID of the dataset containing this model.
    &quot;modelId&quot;: &quot;A String&quot;, # [Required] The ID of the model. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 1,024 characters.
    &quot;projectId&quot;: &quot;A String&quot;, # [Required] The ID of the project containing this model.
  },
  &quot;modelType&quot;: &quot;A String&quot;, # Output only. Type of the model resource.
  &quot;trainingRuns&quot;: [ # Output only. Information for all training runs in increasing order of start_time.
    { # Information about a single training query run for the model.
      &quot;dataSplitResult&quot;: { # Data split result. This contains references to the training and evaluation data tables that were used to train the model. # Data split result of the training run. Only set when the input data is actually split.
        &quot;evaluationTable&quot;: { # Table reference of the evaluation data after split.
          &quot;datasetId&quot;: &quot;A String&quot;, # [Required] The ID of the dataset containing this table.
          &quot;projectId&quot;: &quot;A String&quot;, # [Required] The ID of the project containing this table.
          &quot;tableId&quot;: &quot;A String&quot;, # [Required] The ID of the table. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 1,024 characters.
        },
        &quot;trainingTable&quot;: { # Table reference of the training data after split.
          &quot;datasetId&quot;: &quot;A String&quot;, # [Required] The ID of the dataset containing this table.
          &quot;projectId&quot;: &quot;A String&quot;, # [Required] The ID of the project containing this table.
          &quot;tableId&quot;: &quot;A String&quot;, # [Required] The ID of the table. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 1,024 characters.
        },
      },
      &quot;evaluationMetrics&quot;: { # Evaluation metrics of a model. These are either computed on all training data or just the eval data based on whether eval data was used during training. These are not present for imported models. # The evaluation metrics over training/eval data that were computed at the end of training.
        &quot;arimaForecastingMetrics&quot;: { # Model evaluation metrics for ARIMA forecasting models. # Populated for ARIMA models.
          &quot;arimaFittingMetrics&quot;: [ # Arima model fitting metrics.
            { # ARIMA model fitting metrics.
              &quot;aic&quot;: 3.14, # AIC.
              &quot;logLikelihood&quot;: 3.14, # Log-likelihood.
              &quot;variance&quot;: 3.14, # Variance.
            },
          ],
          &quot;arimaSingleModelForecastingMetrics&quot;: [ # Repeated as there can be many metric sets (one for each model) in auto-arima and the large-scale case.
            { # Model evaluation metrics for a single ARIMA forecasting model.
              &quot;arimaFittingMetrics&quot;: { # ARIMA model fitting metrics. # Arima fitting metrics.
                &quot;aic&quot;: 3.14, # AIC.
                &quot;logLikelihood&quot;: 3.14, # Log-likelihood.
                &quot;variance&quot;: 3.14, # Variance.
              },
              &quot;hasDrift&quot;: True or False, # Is arima model fitted with drift or not. It is always false when d is not 1.
              &quot;hasHolidayEffect&quot;: True or False, # If true, holiday_effect is a part of time series decomposition result.
              &quot;hasSpikesAndDips&quot;: True or False, # If true, spikes_and_dips is a part of time series decomposition result.
              &quot;hasStepChanges&quot;: True or False, # If true, step_changes is a part of time series decomposition result.
              &quot;nonSeasonalOrder&quot;: { # Arima order, can be used for both non-seasonal and seasonal parts. # Non-seasonal order.
                &quot;d&quot;: &quot;A String&quot;, # Order of the differencing part.
                &quot;p&quot;: &quot;A String&quot;, # Order of the autoregressive part.
                &quot;q&quot;: &quot;A String&quot;, # Order of the moving-average part.
              },
              &quot;seasonalPeriods&quot;: [ # Seasonal periods. Repeated because multiple periods are supported for one time series.
                &quot;A String&quot;,
              ],
              &quot;timeSeriesId&quot;: &quot;A String&quot;, # The time_series_id value for this time series. It will be one of the unique values from the time_series_id_column specified during ARIMA model training. Only present when time_series_id_column training option was used.
              &quot;timeSeriesIds&quot;: [ # The tuple of time_series_ids identifying this time series. It will be one of the unique tuples of values present in the time_series_id_columns specified during ARIMA model training. Only present when time_series_id_columns training option was used and the order of values here are same as the order of time_series_id_columns.
                &quot;A String&quot;,
              ],
            },
          ],
          &quot;hasDrift&quot;: [ # Whether Arima model fitted with drift or not. It is always false when d is not 1.
            True or False,
          ],
          &quot;nonSeasonalOrder&quot;: [ # Non-seasonal order.
            { # Arima order, can be used for both non-seasonal and seasonal parts.
              &quot;d&quot;: &quot;A String&quot;, # Order of the differencing part.
              &quot;p&quot;: &quot;A String&quot;, # Order of the autoregressive part.
              &quot;q&quot;: &quot;A String&quot;, # Order of the moving-average part.
            },
          ],
          &quot;seasonalPeriods&quot;: [ # Seasonal periods. Repeated because multiple periods are supported for one time series.
            &quot;A String&quot;,
          ],
          &quot;timeSeriesId&quot;: [ # Id to differentiate different time series for the large-scale case.
            &quot;A String&quot;,
          ],
        },
        &quot;binaryClassificationMetrics&quot;: { # Evaluation metrics for binary classification/classifier models. # Populated for binary classification/classifier models.
          &quot;aggregateClassificationMetrics&quot;: { # Aggregate metrics for classification/classifier models. For multi-class models, the metrics are either macro-averaged or micro-averaged. When macro-averaged, the metrics are calculated for each label and then an unweighted average is taken of those values. When micro-averaged, the metric is calculated globally by counting the total number of correctly predicted rows. # Aggregate classification metrics.
            &quot;accuracy&quot;: 3.14, # Accuracy is the fraction of predictions given the correct label. For multiclass this is a micro-averaged metric.
            &quot;f1Score&quot;: 3.14, # The F1 score is an average of recall and precision. For multiclass this is a macro-averaged metric.
            &quot;logLoss&quot;: 3.14, # Logarithmic Loss. For multiclass this is a macro-averaged metric.
            &quot;precision&quot;: 3.14, # Precision is the fraction of actual positive predictions that had positive actual labels. For multiclass this is a macro-averaged metric treating each class as a binary classifier.
            &quot;recall&quot;: 3.14, # Recall is the fraction of actual positive labels that were given a positive prediction. For multiclass this is a macro-averaged metric.
            &quot;rocAuc&quot;: 3.14, # Area Under a ROC Curve. For multiclass this is a macro-averaged metric.
            &quot;threshold&quot;: 3.14, # Threshold at which the metrics are computed. For binary classification models this is the positive class threshold. For multi-class classfication models this is the confidence threshold.
          },
          &quot;binaryConfusionMatrixList&quot;: [ # Binary confusion matrix at multiple thresholds.
            { # Confusion matrix for binary classification models.
              &quot;accuracy&quot;: 3.14, # The fraction of predictions given the correct label.
              &quot;f1Score&quot;: 3.14, # The equally weighted average of recall and precision.
              &quot;falseNegatives&quot;: &quot;A String&quot;, # Number of false samples predicted as false.
              &quot;falsePositives&quot;: &quot;A String&quot;, # Number of false samples predicted as true.
              &quot;positiveClassThreshold&quot;: 3.14, # Threshold value used when computing each of the following metric.
              &quot;precision&quot;: 3.14, # The fraction of actual positive predictions that had positive actual labels.
              &quot;recall&quot;: 3.14, # The fraction of actual positive labels that were given a positive prediction.
              &quot;trueNegatives&quot;: &quot;A String&quot;, # Number of true samples predicted as false.
              &quot;truePositives&quot;: &quot;A String&quot;, # Number of true samples predicted as true.
            },
          ],
          &quot;negativeLabel&quot;: &quot;A String&quot;, # Label representing the negative class.
          &quot;positiveLabel&quot;: &quot;A String&quot;, # Label representing the positive class.
        },
        &quot;clusteringMetrics&quot;: { # Evaluation metrics for clustering models. # Populated for clustering models.
          &quot;clusters&quot;: [ # Information for all clusters.
            { # Message containing the information about one cluster.
              &quot;centroidId&quot;: &quot;A String&quot;, # Centroid id.
              &quot;count&quot;: &quot;A String&quot;, # Count of training data rows that were assigned to this cluster.
              &quot;featureValues&quot;: [ # Values of highly variant features for this cluster.
                { # Representative value of a single feature within the cluster.
                  &quot;categoricalValue&quot;: { # Representative value of a categorical feature. # The categorical feature value.
                    &quot;categoryCounts&quot;: [ # Counts of all categories for the categorical feature. If there are more than ten categories, we return top ten (by count) and return one more CategoryCount with category &quot;_OTHER_&quot; and count as aggregate counts of remaining categories.
                      { # Represents the count of a single category within the cluster.
                        &quot;category&quot;: &quot;A String&quot;, # The name of category.
                        &quot;count&quot;: &quot;A String&quot;, # The count of training samples matching the category within the cluster.
                      },
                    ],
                  },
                  &quot;featureColumn&quot;: &quot;A String&quot;, # The feature column name.
                  &quot;numericalValue&quot;: 3.14, # The numerical feature value. This is the centroid value for this feature.
                },
              ],
            },
          ],
          &quot;daviesBouldinIndex&quot;: 3.14, # Davies-Bouldin index.
          &quot;meanSquaredDistance&quot;: 3.14, # Mean of squared distances between each sample to its cluster centroid.
        },
        &quot;multiClassClassificationMetrics&quot;: { # Evaluation metrics for multi-class classification/classifier models. # Populated for multi-class classification/classifier models.
          &quot;aggregateClassificationMetrics&quot;: { # Aggregate metrics for classification/classifier models. For multi-class models, the metrics are either macro-averaged or micro-averaged. When macro-averaged, the metrics are calculated for each label and then an unweighted average is taken of those values. When micro-averaged, the metric is calculated globally by counting the total number of correctly predicted rows. # Aggregate classification metrics.
            &quot;accuracy&quot;: 3.14, # Accuracy is the fraction of predictions given the correct label. For multiclass this is a micro-averaged metric.
            &quot;f1Score&quot;: 3.14, # The F1 score is an average of recall and precision. For multiclass this is a macro-averaged metric.
            &quot;logLoss&quot;: 3.14, # Logarithmic Loss. For multiclass this is a macro-averaged metric.
            &quot;precision&quot;: 3.14, # Precision is the fraction of actual positive predictions that had positive actual labels. For multiclass this is a macro-averaged metric treating each class as a binary classifier.
            &quot;recall&quot;: 3.14, # Recall is the fraction of actual positive labels that were given a positive prediction. For multiclass this is a macro-averaged metric.
            &quot;rocAuc&quot;: 3.14, # Area Under a ROC Curve. For multiclass this is a macro-averaged metric.
            &quot;threshold&quot;: 3.14, # Threshold at which the metrics are computed. For binary classification models this is the positive class threshold. For multi-class classfication models this is the confidence threshold.
          },
          &quot;confusionMatrixList&quot;: [ # Confusion matrix at different thresholds.
            { # Confusion matrix for multi-class classification models.
              &quot;confidenceThreshold&quot;: 3.14, # Confidence threshold used when computing the entries of the confusion matrix.
              &quot;rows&quot;: [ # One row per actual label.
                { # A single row in the confusion matrix.
                  &quot;actualLabel&quot;: &quot;A String&quot;, # The original label of this row.
                  &quot;entries&quot;: [ # Info describing predicted label distribution.
                    { # A single entry in the confusion matrix.
                      &quot;itemCount&quot;: &quot;A String&quot;, # Number of items being predicted as this label.
                      &quot;predictedLabel&quot;: &quot;A String&quot;, # The predicted label. For confidence_threshold &gt; 0, we will also add an entry indicating the number of items under the confidence threshold.
                    },
                  ],
                },
              ],
            },
          ],
        },
        &quot;rankingMetrics&quot;: { # Evaluation metrics used by weighted-ALS models specified by feedback_type=implicit. # Populated for implicit feedback type matrix factorization models.
          &quot;averageRank&quot;: 3.14, # Determines the goodness of a ranking by computing the percentile rank from the predicted confidence and dividing it by the original rank.
          &quot;meanAveragePrecision&quot;: 3.14, # Calculates a precision per user for all the items by ranking them and then averages all the precisions across all the users.
          &quot;meanSquaredError&quot;: 3.14, # Similar to the mean squared error computed in regression and explicit recommendation models except instead of computing the rating directly, the output from evaluate is computed against a preference which is 1 or 0 depending on if the rating exists or not.
          &quot;normalizedDiscountedCumulativeGain&quot;: 3.14, # A metric to determine the goodness of a ranking calculated from the predicted confidence by comparing it to an ideal rank measured by the original ratings.
        },
        &quot;regressionMetrics&quot;: { # Evaluation metrics for regression and explicit feedback type matrix factorization models. # Populated for regression models and explicit feedback type matrix factorization models.
          &quot;meanAbsoluteError&quot;: 3.14, # Mean absolute error.
          &quot;meanSquaredError&quot;: 3.14, # Mean squared error.
          &quot;meanSquaredLogError&quot;: 3.14, # Mean squared log error.
          &quot;medianAbsoluteError&quot;: 3.14, # Median absolute error.
          &quot;rSquared&quot;: 3.14, # R^2 score. This corresponds to r2_score in ML.EVALUATE.
        },
      },
      &quot;globalExplanations&quot;: [ # Global explanations for important features of the model. For multi-class models, there is one entry for each label class. For other models, there is only one entry in the list.
        { # Global explanations containing the top most important features after training.
          &quot;classLabel&quot;: &quot;A String&quot;, # Class label for this set of global explanations. Will be empty/null for binary logistic and linear regression models. Sorted alphabetically in descending order.
          &quot;explanations&quot;: [ # A list of the top global explanations. Sorted by absolute value of attribution in descending order.
            { # Explanation for a single feature.
              &quot;attribution&quot;: 3.14, # Attribution of feature.
              &quot;featureName&quot;: &quot;A String&quot;, # Full name of the feature. For non-numerical features, will be formatted like .. Overall size of feature name will always be truncated to first 120 characters.
            },
          ],
        },
      ],
      &quot;results&quot;: [ # Output of each iteration run, results.size() &lt;= max_iterations.
        { # Information about a single iteration of the training run.
          &quot;arimaResult&quot;: { # (Auto-)arima fitting result. Wrap everything in ArimaResult for easier refactoring if we want to use model-specific iteration results.
            &quot;arimaModelInfo&quot;: [ # This message is repeated because there are multiple arima models fitted in auto-arima. For non-auto-arima model, its size is one.
              { # Arima model information.
                &quot;arimaCoefficients&quot;: { # Arima coefficients. # Arima coefficients.
                  &quot;autoRegressiveCoefficients&quot;: [ # Auto-regressive coefficients, an array of double.
                    3.14,
                  ],
                  &quot;interceptCoefficient&quot;: 3.14, # Intercept coefficient, just a double not an array.
                  &quot;movingAverageCoefficients&quot;: [ # Moving-average coefficients, an array of double.
                    3.14,
                  ],
                },
                &quot;arimaFittingMetrics&quot;: { # ARIMA model fitting metrics. # Arima fitting metrics.
                  &quot;aic&quot;: 3.14, # AIC.
                  &quot;logLikelihood&quot;: 3.14, # Log-likelihood.
                  &quot;variance&quot;: 3.14, # Variance.
                },
                &quot;hasDrift&quot;: True or False, # Whether Arima model fitted with drift or not. It is always false when d is not 1.
                &quot;hasHolidayEffect&quot;: True or False, # If true, holiday_effect is a part of time series decomposition result.
                &quot;hasSpikesAndDips&quot;: True or False, # If true, spikes_and_dips is a part of time series decomposition result.
                &quot;hasStepChanges&quot;: True or False, # If true, step_changes is a part of time series decomposition result.
                &quot;nonSeasonalOrder&quot;: { # Arima order, can be used for both non-seasonal and seasonal parts. # Non-seasonal order.
                  &quot;d&quot;: &quot;A String&quot;, # Order of the differencing part.
                  &quot;p&quot;: &quot;A String&quot;, # Order of the autoregressive part.
                  &quot;q&quot;: &quot;A String&quot;, # Order of the moving-average part.
                },
                &quot;seasonalPeriods&quot;: [ # Seasonal periods. Repeated because multiple periods are supported for one time series.
                  &quot;A String&quot;,
                ],
                &quot;timeSeriesId&quot;: &quot;A String&quot;, # The time_series_id value for this time series. It will be one of the unique values from the time_series_id_column specified during ARIMA model training. Only present when time_series_id_column training option was used.
                &quot;timeSeriesIds&quot;: [ # The tuple of time_series_ids identifying this time series. It will be one of the unique tuples of values present in the time_series_id_columns specified during ARIMA model training. Only present when time_series_id_columns training option was used and the order of values here are same as the order of time_series_id_columns.
                  &quot;A String&quot;,
                ],
              },
            ],
            &quot;seasonalPeriods&quot;: [ # Seasonal periods. Repeated because multiple periods are supported for one time series.
              &quot;A String&quot;,
            ],
          },
          &quot;clusterInfos&quot;: [ # Information about top clusters for clustering models.
            { # Information about a single cluster for clustering model.
              &quot;centroidId&quot;: &quot;A String&quot;, # Centroid id.
              &quot;clusterRadius&quot;: 3.14, # Cluster radius, the average distance from centroid to each point assigned to the cluster.
              &quot;clusterSize&quot;: &quot;A String&quot;, # Cluster size, the total number of points assigned to the cluster.
            },
          ],
          &quot;durationMs&quot;: &quot;A String&quot;, # Time taken to run the iteration in milliseconds.
          &quot;evalLoss&quot;: 3.14, # Loss computed on the eval data at the end of iteration.
          &quot;index&quot;: 42, # Index of the iteration, 0 based.
          &quot;learnRate&quot;: 3.14, # Learn rate used for this iteration.
          &quot;trainingLoss&quot;: 3.14, # Loss computed on the training data at the end of iteration.
        },
      ],
      &quot;startTime&quot;: &quot;A String&quot;, # The start time of this training run.
      &quot;trainingOptions&quot;: { # Options used in model training. # Options that were used for this training run, includes user specified and default options that were used.
        &quot;adjustStepChanges&quot;: True or False, # If true, detect step changes and make data adjustment in the input time series.
        &quot;autoArima&quot;: True or False, # Whether to enable auto ARIMA or not.
        &quot;autoArimaMaxOrder&quot;: &quot;A String&quot;, # The max value of non-seasonal p and q.
        &quot;batchSize&quot;: &quot;A String&quot;, # Batch size for dnn models.
        &quot;cleanSpikesAndDips&quot;: True or False, # If true, clean spikes and dips in the input time series.
        &quot;dataFrequency&quot;: &quot;A String&quot;, # The data frequency of a time series.
        &quot;dataSplitColumn&quot;: &quot;A String&quot;, # The column to split data with. This column won&#x27;t be used as a feature. 1. When data_split_method is CUSTOM, the corresponding column should be boolean. The rows with true value tag are eval data, and the false are training data. 2. When data_split_method is SEQ, the first DATA_SPLIT_EVAL_FRACTION rows (from smallest to largest) in the corresponding column are used as training data, and the rest are eval data. It respects the order in Orderable data types: https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#data-type-properties
        &quot;dataSplitEvalFraction&quot;: 3.14, # The fraction of evaluation data over the whole input data. The rest of data will be used as training data. The format should be double. Accurate to two decimal places. Default value is 0.2.
        &quot;dataSplitMethod&quot;: &quot;A String&quot;, # The data split type for training and evaluation, e.g. RANDOM.
        &quot;decomposeTimeSeries&quot;: True or False, # If true, perform decompose time series and save the results.
        &quot;distanceType&quot;: &quot;A String&quot;, # Distance type for clustering models.
        &quot;dropout&quot;: 3.14, # Dropout probability for dnn models.
        &quot;earlyStop&quot;: True or False, # Whether to stop early when the loss doesn&#x27;t improve significantly any more (compared to min_relative_progress). Used only for iterative training algorithms.
        &quot;feedbackType&quot;: &quot;A String&quot;, # Feedback type that specifies which algorithm to run for matrix factorization.
        &quot;hiddenUnits&quot;: [ # Hidden units for dnn models.
          &quot;A String&quot;,
        ],
        &quot;holidayRegion&quot;: &quot;A String&quot;, # The geographical region based on which the holidays are considered in time series modeling. If a valid value is specified, then holiday effects modeling is enabled.
        &quot;horizon&quot;: &quot;A String&quot;, # The number of periods ahead that need to be forecasted.
        &quot;includeDrift&quot;: True or False, # Include drift when fitting an ARIMA model.
        &quot;initialLearnRate&quot;: 3.14, # Specifies the initial learning rate for the line search learn rate strategy.
        &quot;inputLabelColumns&quot;: [ # Name of input label columns in training data.
          &quot;A String&quot;,
        ],
        &quot;itemColumn&quot;: &quot;A String&quot;, # Item column specified for matrix factorization models.
        &quot;kmeansInitializationColumn&quot;: &quot;A String&quot;, # The column used to provide the initial centroids for kmeans algorithm when kmeans_initialization_method is CUSTOM.
        &quot;kmeansInitializationMethod&quot;: &quot;A String&quot;, # The method used to initialize the centroids for kmeans algorithm.
        &quot;l1Regularization&quot;: 3.14, # L1 regularization coefficient.
        &quot;l2Regularization&quot;: 3.14, # L2 regularization coefficient.
        &quot;labelClassWeights&quot;: { # Weights associated with each label class, for rebalancing the training data. Only applicable for classification models.
          &quot;a_key&quot;: 3.14,
        },
        &quot;learnRate&quot;: 3.14, # Learning rate in training. Used only for iterative training algorithms.
        &quot;learnRateStrategy&quot;: &quot;A String&quot;, # The strategy to determine learn rate for the current iteration.
        &quot;lossType&quot;: &quot;A String&quot;, # Type of loss function used during training run.
        &quot;maxIterations&quot;: &quot;A String&quot;, # The maximum number of iterations in training. Used only for iterative training algorithms.
        &quot;maxTreeDepth&quot;: &quot;A String&quot;, # Maximum depth of a tree for boosted tree models.
        &quot;minRelativeProgress&quot;: 3.14, # When early_stop is true, stops training when accuracy improvement is less than &#x27;min_relative_progress&#x27;. Used only for iterative training algorithms.
        &quot;minSplitLoss&quot;: 3.14, # Minimum split loss for boosted tree models.
        &quot;modelUri&quot;: &quot;A String&quot;, # Google Cloud Storage URI from which the model was imported. Only applicable for imported models.
        &quot;nonSeasonalOrder&quot;: { # Arima order, can be used for both non-seasonal and seasonal parts. # A specification of the non-seasonal part of the ARIMA model: the three components (p, d, q) are the AR order, the degree of differencing, and the MA order.
          &quot;d&quot;: &quot;A String&quot;, # Order of the differencing part.
          &quot;p&quot;: &quot;A String&quot;, # Order of the autoregressive part.
          &quot;q&quot;: &quot;A String&quot;, # Order of the moving-average part.
        },
        &quot;numClusters&quot;: &quot;A String&quot;, # Number of clusters for clustering models.
        &quot;numFactors&quot;: &quot;A String&quot;, # Num factors specified for matrix factorization models.
        &quot;optimizationStrategy&quot;: &quot;A String&quot;, # Optimization strategy for training linear regression models.
        &quot;preserveInputStructs&quot;: True or False, # Whether to preserve the input structs in output feature names. Suppose there is a struct A with field b. When false (default), the output feature name is A_b. When true, the output feature name is A.b.
        &quot;subsample&quot;: 3.14, # Subsample fraction of the training data to grow tree to prevent overfitting for boosted tree models.
        &quot;timeSeriesDataColumn&quot;: &quot;A String&quot;, # Column to be designated as time series data for ARIMA model.
        &quot;timeSeriesIdColumn&quot;: &quot;A String&quot;, # The time series id column that was used during ARIMA model training.
        &quot;timeSeriesIdColumns&quot;: [ # The time series id columns that were used during ARIMA model training.
          &quot;A String&quot;,
        ],
        &quot;timeSeriesTimestampColumn&quot;: &quot;A String&quot;, # Column to be designated as time series timestamp for ARIMA model.
        &quot;userColumn&quot;: &quot;A String&quot;, # User column specified for matrix factorization models.
        &quot;walsAlpha&quot;: 3.14, # Hyperparameter for matrix factoration when implicit feedback type is specified.
        &quot;warmStart&quot;: True or False, # Whether to train a model from the last checkpoint.
      },
    },
  ],
}


Returns:
  An object of the form:

    {
  &quot;bestTrialId&quot;: &quot;A String&quot;, # The best trial_id across all training runs.
  &quot;creationTime&quot;: &quot;A String&quot;, # Output only. The time when this model was created, in millisecs since the epoch.
  &quot;description&quot;: &quot;A String&quot;, # Optional. A user-friendly description of this model.
  &quot;encryptionConfiguration&quot;: { # Custom encryption configuration (e.g., Cloud KMS keys). This shows the encryption configuration of the model data while stored in BigQuery storage. This field can be used with PatchModel to update encryption key for an already encrypted model.
    &quot;kmsKeyName&quot;: &quot;A String&quot;, # [Optional] Describes the Cloud KMS encryption key that will be used to protect destination BigQuery table. The BigQuery Service Account associated with your project requires access to this encryption key.
  },
  &quot;etag&quot;: &quot;A String&quot;, # Output only. A hash of this resource.
  &quot;expirationTime&quot;: &quot;A String&quot;, # Optional. The time when this model expires, in milliseconds since the epoch. If not present, the model will persist indefinitely. Expired models will be deleted and their storage reclaimed. The defaultTableExpirationMs property of the encapsulating dataset can be used to set a default expirationTime on newly created models.
  &quot;featureColumns&quot;: [ # Output only. Input feature columns that were used to train this model.
    { # A field or a column.
      &quot;name&quot;: &quot;A String&quot;, # Optional. The name of this field. Can be absent for struct fields.
      &quot;type&quot;: { # The type of a variable, e.g., a function argument. Examples: INT64: {type_kind=&quot;INT64&quot;} ARRAY: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;} STRUCT&gt;: {type_kind=&quot;STRUCT&quot;, struct_type={fields=[ {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}}, {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}} ]}} # Optional. The type of this parameter. Absent if not explicitly specified (e.g., CREATE FUNCTION statement can omit the return type; in this case the output parameter does not have this &quot;type&quot; field).
        &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
        &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
          &quot;fields&quot;: [
            # Object with schema name: StandardSqlField
          ],
        },
        &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field. Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
      },
    },
  ],
  &quot;friendlyName&quot;: &quot;A String&quot;, # Optional. A descriptive name for this model.
  &quot;labelColumns&quot;: [ # Output only. Label columns that were used to train this model. The output of the model will have a &quot;predicted_&quot; prefix to these columns.
    { # A field or a column.
      &quot;name&quot;: &quot;A String&quot;, # Optional. The name of this field. Can be absent for struct fields.
      &quot;type&quot;: { # The type of a variable, e.g., a function argument. Examples: INT64: {type_kind=&quot;INT64&quot;} ARRAY: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;} STRUCT&gt;: {type_kind=&quot;STRUCT&quot;, struct_type={fields=[ {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}}, {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}} ]}} # Optional. The type of this parameter. Absent if not explicitly specified (e.g., CREATE FUNCTION statement can omit the return type; in this case the output parameter does not have this &quot;type&quot; field).
        &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
        &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
          &quot;fields&quot;: [
            # Object with schema name: StandardSqlField
          ],
        },
        &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field. Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
      },
    },
  ],
  &quot;labels&quot;: { # The labels associated with this model. You can use these to organize and group your models. Label keys and values can be no longer than 63 characters, can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. Label values are optional. Label keys must start with a letter and each label in the list must have a different key.
    &quot;a_key&quot;: &quot;A String&quot;,
  },
  &quot;lastModifiedTime&quot;: &quot;A String&quot;, # Output only. The time when this model was last modified, in millisecs since the epoch.
  &quot;location&quot;: &quot;A String&quot;, # Output only. The geographic location where the model resides. This value is inherited from the dataset.
  &quot;modelReference&quot;: { # Required. Unique identifier for this model.
    &quot;datasetId&quot;: &quot;A String&quot;, # [Required] The ID of the dataset containing this model.
    &quot;modelId&quot;: &quot;A String&quot;, # [Required] The ID of the model. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 1,024 characters.
    &quot;projectId&quot;: &quot;A String&quot;, # [Required] The ID of the project containing this model.
  },
  &quot;modelType&quot;: &quot;A String&quot;, # Output only. Type of the model resource.
  &quot;trainingRuns&quot;: [ # Output only. Information for all training runs in increasing order of start_time.
    { # Information about a single training query run for the model.
      &quot;dataSplitResult&quot;: { # Data split result. This contains references to the training and evaluation data tables that were used to train the model. # Data split result of the training run. Only set when the input data is actually split.
        &quot;evaluationTable&quot;: { # Table reference of the evaluation data after split.
          &quot;datasetId&quot;: &quot;A String&quot;, # [Required] The ID of the dataset containing this table.
          &quot;projectId&quot;: &quot;A String&quot;, # [Required] The ID of the project containing this table.
          &quot;tableId&quot;: &quot;A String&quot;, # [Required] The ID of the table. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 1,024 characters.
        },
        &quot;trainingTable&quot;: { # Table reference of the training data after split.
          &quot;datasetId&quot;: &quot;A String&quot;, # [Required] The ID of the dataset containing this table.
          &quot;projectId&quot;: &quot;A String&quot;, # [Required] The ID of the project containing this table.
          &quot;tableId&quot;: &quot;A String&quot;, # [Required] The ID of the table. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 1,024 characters.
        },
      },
      &quot;evaluationMetrics&quot;: { # Evaluation metrics of a model. These are either computed on all training data or just the eval data based on whether eval data was used during training. These are not present for imported models. # The evaluation metrics over training/eval data that were computed at the end of training.
        &quot;arimaForecastingMetrics&quot;: { # Model evaluation metrics for ARIMA forecasting models. # Populated for ARIMA models.
          &quot;arimaFittingMetrics&quot;: [ # Arima model fitting metrics.
            { # ARIMA model fitting metrics.
              &quot;aic&quot;: 3.14, # AIC.
              &quot;logLikelihood&quot;: 3.14, # Log-likelihood.
              &quot;variance&quot;: 3.14, # Variance.
            },
          ],
          &quot;arimaSingleModelForecastingMetrics&quot;: [ # Repeated as there can be many metric sets (one for each model) in auto-arima and the large-scale case.
            { # Model evaluation metrics for a single ARIMA forecasting model.
              &quot;arimaFittingMetrics&quot;: { # ARIMA model fitting metrics. # Arima fitting metrics.
                &quot;aic&quot;: 3.14, # AIC.
                &quot;logLikelihood&quot;: 3.14, # Log-likelihood.
                &quot;variance&quot;: 3.14, # Variance.
              },
              &quot;hasDrift&quot;: True or False, # Is arima model fitted with drift or not. It is always false when d is not 1.
              &quot;hasHolidayEffect&quot;: True or False, # If true, holiday_effect is a part of time series decomposition result.
              &quot;hasSpikesAndDips&quot;: True or False, # If true, spikes_and_dips is a part of time series decomposition result.
              &quot;hasStepChanges&quot;: True or False, # If true, step_changes is a part of time series decomposition result.
              &quot;nonSeasonalOrder&quot;: { # Arima order, can be used for both non-seasonal and seasonal parts. # Non-seasonal order.
                &quot;d&quot;: &quot;A String&quot;, # Order of the differencing part.
                &quot;p&quot;: &quot;A String&quot;, # Order of the autoregressive part.
                &quot;q&quot;: &quot;A String&quot;, # Order of the moving-average part.
              },
              &quot;seasonalPeriods&quot;: [ # Seasonal periods. Repeated because multiple periods are supported for one time series.
                &quot;A String&quot;,
              ],
              &quot;timeSeriesId&quot;: &quot;A String&quot;, # The time_series_id value for this time series. It will be one of the unique values from the time_series_id_column specified during ARIMA model training. Only present when time_series_id_column training option was used.
              &quot;timeSeriesIds&quot;: [ # The tuple of time_series_ids identifying this time series. It will be one of the unique tuples of values present in the time_series_id_columns specified during ARIMA model training. Only present when time_series_id_columns training option was used and the order of values here are same as the order of time_series_id_columns.
                &quot;A String&quot;,
              ],
            },
          ],
          &quot;hasDrift&quot;: [ # Whether Arima model fitted with drift or not. It is always false when d is not 1.
            True or False,
          ],
          &quot;nonSeasonalOrder&quot;: [ # Non-seasonal order.
            { # Arima order, can be used for both non-seasonal and seasonal parts.
              &quot;d&quot;: &quot;A String&quot;, # Order of the differencing part.
              &quot;p&quot;: &quot;A String&quot;, # Order of the autoregressive part.
              &quot;q&quot;: &quot;A String&quot;, # Order of the moving-average part.
            },
          ],
          &quot;seasonalPeriods&quot;: [ # Seasonal periods. Repeated because multiple periods are supported for one time series.
            &quot;A String&quot;,
          ],
          &quot;timeSeriesId&quot;: [ # Id to differentiate different time series for the large-scale case.
            &quot;A String&quot;,
          ],
        },
        &quot;binaryClassificationMetrics&quot;: { # Evaluation metrics for binary classification/classifier models. # Populated for binary classification/classifier models.
          &quot;aggregateClassificationMetrics&quot;: { # Aggregate metrics for classification/classifier models. For multi-class models, the metrics are either macro-averaged or micro-averaged. When macro-averaged, the metrics are calculated for each label and then an unweighted average is taken of those values. When micro-averaged, the metric is calculated globally by counting the total number of correctly predicted rows. # Aggregate classification metrics.
            &quot;accuracy&quot;: 3.14, # Accuracy is the fraction of predictions given the correct label. For multiclass this is a micro-averaged metric.
            &quot;f1Score&quot;: 3.14, # The F1 score is an average of recall and precision. For multiclass this is a macro-averaged metric.
            &quot;logLoss&quot;: 3.14, # Logarithmic Loss. For multiclass this is a macro-averaged metric.
            &quot;precision&quot;: 3.14, # Precision is the fraction of actual positive predictions that had positive actual labels. For multiclass this is a macro-averaged metric treating each class as a binary classifier.
            &quot;recall&quot;: 3.14, # Recall is the fraction of actual positive labels that were given a positive prediction. For multiclass this is a macro-averaged metric.
            &quot;rocAuc&quot;: 3.14, # Area Under a ROC Curve. For multiclass this is a macro-averaged metric.
            &quot;threshold&quot;: 3.14, # Threshold at which the metrics are computed. For binary classification models this is the positive class threshold. For multi-class classfication models this is the confidence threshold.
          },
          &quot;binaryConfusionMatrixList&quot;: [ # Binary confusion matrix at multiple thresholds.
            { # Confusion matrix for binary classification models.
              &quot;accuracy&quot;: 3.14, # The fraction of predictions given the correct label.
              &quot;f1Score&quot;: 3.14, # The equally weighted average of recall and precision.
              &quot;falseNegatives&quot;: &quot;A String&quot;, # Number of false samples predicted as false.
              &quot;falsePositives&quot;: &quot;A String&quot;, # Number of false samples predicted as true.
              &quot;positiveClassThreshold&quot;: 3.14, # Threshold value used when computing each of the following metric.
              &quot;precision&quot;: 3.14, # The fraction of actual positive predictions that had positive actual labels.
              &quot;recall&quot;: 3.14, # The fraction of actual positive labels that were given a positive prediction.
              &quot;trueNegatives&quot;: &quot;A String&quot;, # Number of true samples predicted as false.
              &quot;truePositives&quot;: &quot;A String&quot;, # Number of true samples predicted as true.
            },
          ],
          &quot;negativeLabel&quot;: &quot;A String&quot;, # Label representing the negative class.
          &quot;positiveLabel&quot;: &quot;A String&quot;, # Label representing the positive class.
        },
        &quot;clusteringMetrics&quot;: { # Evaluation metrics for clustering models. # Populated for clustering models.
          &quot;clusters&quot;: [ # Information for all clusters.
            { # Message containing the information about one cluster.
              &quot;centroidId&quot;: &quot;A String&quot;, # Centroid id.
              &quot;count&quot;: &quot;A String&quot;, # Count of training data rows that were assigned to this cluster.
              &quot;featureValues&quot;: [ # Values of highly variant features for this cluster.
                { # Representative value of a single feature within the cluster.
                  &quot;categoricalValue&quot;: { # Representative value of a categorical feature. # The categorical feature value.
                    &quot;categoryCounts&quot;: [ # Counts of all categories for the categorical feature. If there are more than ten categories, we return top ten (by count) and return one more CategoryCount with category &quot;_OTHER_&quot; and count as aggregate counts of remaining categories.
                      { # Represents the count of a single category within the cluster.
                        &quot;category&quot;: &quot;A String&quot;, # The name of category.
                        &quot;count&quot;: &quot;A String&quot;, # The count of training samples matching the category within the cluster.
                      },
                    ],
                  },
                  &quot;featureColumn&quot;: &quot;A String&quot;, # The feature column name.
                  &quot;numericalValue&quot;: 3.14, # The numerical feature value. This is the centroid value for this feature.
                },
              ],
            },
          ],
          &quot;daviesBouldinIndex&quot;: 3.14, # Davies-Bouldin index.
          &quot;meanSquaredDistance&quot;: 3.14, # Mean of squared distances between each sample to its cluster centroid.
        },
        &quot;multiClassClassificationMetrics&quot;: { # Evaluation metrics for multi-class classification/classifier models. # Populated for multi-class classification/classifier models.
          &quot;aggregateClassificationMetrics&quot;: { # Aggregate metrics for classification/classifier models. For multi-class models, the metrics are either macro-averaged or micro-averaged. When macro-averaged, the metrics are calculated for each label and then an unweighted average is taken of those values. When micro-averaged, the metric is calculated globally by counting the total number of correctly predicted rows. # Aggregate classification metrics.
            &quot;accuracy&quot;: 3.14, # Accuracy is the fraction of predictions given the correct label. For multiclass this is a micro-averaged metric.
            &quot;f1Score&quot;: 3.14, # The F1 score is an average of recall and precision. For multiclass this is a macro-averaged metric.
            &quot;logLoss&quot;: 3.14, # Logarithmic Loss. For multiclass this is a macro-averaged metric.
            &quot;precision&quot;: 3.14, # Precision is the fraction of actual positive predictions that had positive actual labels. For multiclass this is a macro-averaged metric treating each class as a binary classifier.
            &quot;recall&quot;: 3.14, # Recall is the fraction of actual positive labels that were given a positive prediction. For multiclass this is a macro-averaged metric.
            &quot;rocAuc&quot;: 3.14, # Area Under a ROC Curve. For multiclass this is a macro-averaged metric.
            &quot;threshold&quot;: 3.14, # Threshold at which the metrics are computed. For binary classification models this is the positive class threshold. For multi-class classfication models this is the confidence threshold.
          },
          &quot;confusionMatrixList&quot;: [ # Confusion matrix at different thresholds.
            { # Confusion matrix for multi-class classification models.
              &quot;confidenceThreshold&quot;: 3.14, # Confidence threshold used when computing the entries of the confusion matrix.
              &quot;rows&quot;: [ # One row per actual label.
                { # A single row in the confusion matrix.
                  &quot;actualLabel&quot;: &quot;A String&quot;, # The original label of this row.
                  &quot;entries&quot;: [ # Info describing predicted label distribution.
                    { # A single entry in the confusion matrix.
                      &quot;itemCount&quot;: &quot;A String&quot;, # Number of items being predicted as this label.
                      &quot;predictedLabel&quot;: &quot;A String&quot;, # The predicted label. For confidence_threshold &gt; 0, we will also add an entry indicating the number of items under the confidence threshold.
                    },
                  ],
                },
              ],
            },
          ],
        },
        &quot;rankingMetrics&quot;: { # Evaluation metrics used by weighted-ALS models specified by feedback_type=implicit. # Populated for implicit feedback type matrix factorization models.
          &quot;averageRank&quot;: 3.14, # Determines the goodness of a ranking by computing the percentile rank from the predicted confidence and dividing it by the original rank.
          &quot;meanAveragePrecision&quot;: 3.14, # Calculates a precision per user for all the items by ranking them and then averages all the precisions across all the users.
          &quot;meanSquaredError&quot;: 3.14, # Similar to the mean squared error computed in regression and explicit recommendation models except instead of computing the rating directly, the output from evaluate is computed against a preference which is 1 or 0 depending on if the rating exists or not.
          &quot;normalizedDiscountedCumulativeGain&quot;: 3.14, # A metric to determine the goodness of a ranking calculated from the predicted confidence by comparing it to an ideal rank measured by the original ratings.
        },
        &quot;regressionMetrics&quot;: { # Evaluation metrics for regression and explicit feedback type matrix factorization models. # Populated for regression models and explicit feedback type matrix factorization models.
          &quot;meanAbsoluteError&quot;: 3.14, # Mean absolute error.
          &quot;meanSquaredError&quot;: 3.14, # Mean squared error.
          &quot;meanSquaredLogError&quot;: 3.14, # Mean squared log error.
          &quot;medianAbsoluteError&quot;: 3.14, # Median absolute error.
          &quot;rSquared&quot;: 3.14, # R^2 score. This corresponds to r2_score in ML.EVALUATE.
        },
      },
      &quot;globalExplanations&quot;: [ # Global explanations for important features of the model. For multi-class models, there is one entry for each label class. For other models, there is only one entry in the list.
        { # Global explanations containing the top most important features after training.
          &quot;classLabel&quot;: &quot;A String&quot;, # Class label for this set of global explanations. Will be empty/null for binary logistic and linear regression models. Sorted alphabetically in descending order.
          &quot;explanations&quot;: [ # A list of the top global explanations. Sorted by absolute value of attribution in descending order.
            { # Explanation for a single feature.
              &quot;attribution&quot;: 3.14, # Attribution of feature.
              &quot;featureName&quot;: &quot;A String&quot;, # Full name of the feature. For non-numerical features, will be formatted like .. Overall size of feature name will always be truncated to first 120 characters.
            },
          ],
        },
      ],
      &quot;results&quot;: [ # Output of each iteration run, results.size() &lt;= max_iterations.
        { # Information about a single iteration of the training run.
          &quot;arimaResult&quot;: { # (Auto-)arima fitting result. Wrap everything in ArimaResult for easier refactoring if we want to use model-specific iteration results.
            &quot;arimaModelInfo&quot;: [ # This message is repeated because there are multiple arima models fitted in auto-arima. For non-auto-arima model, its size is one.
              { # Arima model information.
                &quot;arimaCoefficients&quot;: { # Arima coefficients. # Arima coefficients.
                  &quot;autoRegressiveCoefficients&quot;: [ # Auto-regressive coefficients, an array of double.
                    3.14,
                  ],
                  &quot;interceptCoefficient&quot;: 3.14, # Intercept coefficient, just a double not an array.
                  &quot;movingAverageCoefficients&quot;: [ # Moving-average coefficients, an array of double.
                    3.14,
                  ],
                },
                &quot;arimaFittingMetrics&quot;: { # ARIMA model fitting metrics. # Arima fitting metrics.
                  &quot;aic&quot;: 3.14, # AIC.
                  &quot;logLikelihood&quot;: 3.14, # Log-likelihood.
                  &quot;variance&quot;: 3.14, # Variance.
                },
                &quot;hasDrift&quot;: True or False, # Whether Arima model fitted with drift or not. It is always false when d is not 1.
                &quot;hasHolidayEffect&quot;: True or False, # If true, holiday_effect is a part of time series decomposition result.
                &quot;hasSpikesAndDips&quot;: True or False, # If true, spikes_and_dips is a part of time series decomposition result.
                &quot;hasStepChanges&quot;: True or False, # If true, step_changes is a part of time series decomposition result.
                &quot;nonSeasonalOrder&quot;: { # Arima order, can be used for both non-seasonal and seasonal parts. # Non-seasonal order.
                  &quot;d&quot;: &quot;A String&quot;, # Order of the differencing part.
                  &quot;p&quot;: &quot;A String&quot;, # Order of the autoregressive part.
                  &quot;q&quot;: &quot;A String&quot;, # Order of the moving-average part.
                },
                &quot;seasonalPeriods&quot;: [ # Seasonal periods. Repeated because multiple periods are supported for one time series.
                  &quot;A String&quot;,
                ],
                &quot;timeSeriesId&quot;: &quot;A String&quot;, # The time_series_id value for this time series. It will be one of the unique values from the time_series_id_column specified during ARIMA model training. Only present when time_series_id_column training option was used.
                &quot;timeSeriesIds&quot;: [ # The tuple of time_series_ids identifying this time series. It will be one of the unique tuples of values present in the time_series_id_columns specified during ARIMA model training. Only present when time_series_id_columns training option was used and the order of values here are same as the order of time_series_id_columns.
                  &quot;A String&quot;,
                ],
              },
            ],
            &quot;seasonalPeriods&quot;: [ # Seasonal periods. Repeated because multiple periods are supported for one time series.
              &quot;A String&quot;,
            ],
          },
          &quot;clusterInfos&quot;: [ # Information about top clusters for clustering models.
            { # Information about a single cluster for clustering model.
              &quot;centroidId&quot;: &quot;A String&quot;, # Centroid id.
              &quot;clusterRadius&quot;: 3.14, # Cluster radius, the average distance from centroid to each point assigned to the cluster.
              &quot;clusterSize&quot;: &quot;A String&quot;, # Cluster size, the total number of points assigned to the cluster.
            },
          ],
          &quot;durationMs&quot;: &quot;A String&quot;, # Time taken to run the iteration in milliseconds.
          &quot;evalLoss&quot;: 3.14, # Loss computed on the eval data at the end of iteration.
          &quot;index&quot;: 42, # Index of the iteration, 0 based.
          &quot;learnRate&quot;: 3.14, # Learn rate used for this iteration.
          &quot;trainingLoss&quot;: 3.14, # Loss computed on the training data at the end of iteration.
        },
      ],
      &quot;startTime&quot;: &quot;A String&quot;, # The start time of this training run.
      &quot;trainingOptions&quot;: { # Options used in model training. # Options that were used for this training run, includes user specified and default options that were used.
        &quot;adjustStepChanges&quot;: True or False, # If true, detect step changes and make data adjustment in the input time series.
        &quot;autoArima&quot;: True or False, # Whether to enable auto ARIMA or not.
        &quot;autoArimaMaxOrder&quot;: &quot;A String&quot;, # The max value of non-seasonal p and q.
        &quot;batchSize&quot;: &quot;A String&quot;, # Batch size for dnn models.
        &quot;cleanSpikesAndDips&quot;: True or False, # If true, clean spikes and dips in the input time series.
        &quot;dataFrequency&quot;: &quot;A String&quot;, # The data frequency of a time series.
        &quot;dataSplitColumn&quot;: &quot;A String&quot;, # The column to split data with. This column won&#x27;t be used as a feature. 1. When data_split_method is CUSTOM, the corresponding column should be boolean. The rows with true value tag are eval data, and the false are training data. 2. When data_split_method is SEQ, the first DATA_SPLIT_EVAL_FRACTION rows (from smallest to largest) in the corresponding column are used as training data, and the rest are eval data. It respects the order in Orderable data types: https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#data-type-properties
        &quot;dataSplitEvalFraction&quot;: 3.14, # The fraction of evaluation data over the whole input data. The rest of data will be used as training data. The format should be double. Accurate to two decimal places. Default value is 0.2.
        &quot;dataSplitMethod&quot;: &quot;A String&quot;, # The data split type for training and evaluation, e.g. RANDOM.
        &quot;decomposeTimeSeries&quot;: True or False, # If true, perform decompose time series and save the results.
        &quot;distanceType&quot;: &quot;A String&quot;, # Distance type for clustering models.
        &quot;dropout&quot;: 3.14, # Dropout probability for dnn models.
        &quot;earlyStop&quot;: True or False, # Whether to stop early when the loss doesn&#x27;t improve significantly any more (compared to min_relative_progress). Used only for iterative training algorithms.
        &quot;feedbackType&quot;: &quot;A String&quot;, # Feedback type that specifies which algorithm to run for matrix factorization.
        &quot;hiddenUnits&quot;: [ # Hidden units for dnn models.
          &quot;A String&quot;,
        ],
        &quot;holidayRegion&quot;: &quot;A String&quot;, # The geographical region based on which the holidays are considered in time series modeling. If a valid value is specified, then holiday effects modeling is enabled.
        &quot;horizon&quot;: &quot;A String&quot;, # The number of periods ahead that need to be forecasted.
        &quot;includeDrift&quot;: True or False, # Include drift when fitting an ARIMA model.
        &quot;initialLearnRate&quot;: 3.14, # Specifies the initial learning rate for the line search learn rate strategy.
        &quot;inputLabelColumns&quot;: [ # Name of input label columns in training data.
          &quot;A String&quot;,
        ],
        &quot;itemColumn&quot;: &quot;A String&quot;, # Item column specified for matrix factorization models.
        &quot;kmeansInitializationColumn&quot;: &quot;A String&quot;, # The column used to provide the initial centroids for kmeans algorithm when kmeans_initialization_method is CUSTOM.
        &quot;kmeansInitializationMethod&quot;: &quot;A String&quot;, # The method used to initialize the centroids for kmeans algorithm.
        &quot;l1Regularization&quot;: 3.14, # L1 regularization coefficient.
        &quot;l2Regularization&quot;: 3.14, # L2 regularization coefficient.
        &quot;labelClassWeights&quot;: { # Weights associated with each label class, for rebalancing the training data. Only applicable for classification models.
          &quot;a_key&quot;: 3.14,
        },
        &quot;learnRate&quot;: 3.14, # Learning rate in training. Used only for iterative training algorithms.
        &quot;learnRateStrategy&quot;: &quot;A String&quot;, # The strategy to determine learn rate for the current iteration.
        &quot;lossType&quot;: &quot;A String&quot;, # Type of loss function used during training run.
        &quot;maxIterations&quot;: &quot;A String&quot;, # The maximum number of iterations in training. Used only for iterative training algorithms.
        &quot;maxTreeDepth&quot;: &quot;A String&quot;, # Maximum depth of a tree for boosted tree models.
        &quot;minRelativeProgress&quot;: 3.14, # When early_stop is true, stops training when accuracy improvement is less than &#x27;min_relative_progress&#x27;. Used only for iterative training algorithms.
        &quot;minSplitLoss&quot;: 3.14, # Minimum split loss for boosted tree models.
        &quot;modelUri&quot;: &quot;A String&quot;, # Google Cloud Storage URI from which the model was imported. Only applicable for imported models.
        &quot;nonSeasonalOrder&quot;: { # Arima order, can be used for both non-seasonal and seasonal parts. # A specification of the non-seasonal part of the ARIMA model: the three components (p, d, q) are the AR order, the degree of differencing, and the MA order.
          &quot;d&quot;: &quot;A String&quot;, # Order of the differencing part.
          &quot;p&quot;: &quot;A String&quot;, # Order of the autoregressive part.
          &quot;q&quot;: &quot;A String&quot;, # Order of the moving-average part.
        },
        &quot;numClusters&quot;: &quot;A String&quot;, # Number of clusters for clustering models.
        &quot;numFactors&quot;: &quot;A String&quot;, # Num factors specified for matrix factorization models.
        &quot;optimizationStrategy&quot;: &quot;A String&quot;, # Optimization strategy for training linear regression models.
        &quot;preserveInputStructs&quot;: True or False, # Whether to preserve the input structs in output feature names. Suppose there is a struct A with field b. When false (default), the output feature name is A_b. When true, the output feature name is A.b.
        &quot;subsample&quot;: 3.14, # Subsample fraction of the training data to grow tree to prevent overfitting for boosted tree models.
        &quot;timeSeriesDataColumn&quot;: &quot;A String&quot;, # Column to be designated as time series data for ARIMA model.
        &quot;timeSeriesIdColumn&quot;: &quot;A String&quot;, # The time series id column that was used during ARIMA model training.
        &quot;timeSeriesIdColumns&quot;: [ # The time series id columns that were used during ARIMA model training.
          &quot;A String&quot;,
        ],
        &quot;timeSeriesTimestampColumn&quot;: &quot;A String&quot;, # Column to be designated as time series timestamp for ARIMA model.
        &quot;userColumn&quot;: &quot;A String&quot;, # User column specified for matrix factorization models.
        &quot;walsAlpha&quot;: 3.14, # Hyperparameter for matrix factoration when implicit feedback type is specified.
        &quot;warmStart&quot;: True or False, # Whether to train a model from the last checkpoint.
      },
    },
  ],
}</pre>
</div>

</body></html>