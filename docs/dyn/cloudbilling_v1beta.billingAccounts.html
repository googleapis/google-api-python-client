<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="cloudbilling_v1beta.html">Cloud Billing API</a> . <a href="cloudbilling_v1beta.billingAccounts.html">billingAccounts</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#estimateCostScenario">estimateCostScenario(billingAccount, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Use custom pricing in the estimate, using a `CostScenario` with a defined `billingAccount`.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="estimateCostScenario">estimateCostScenario(billingAccount, body=None, x__xgafv=None)</code>
  <pre>Use custom pricing in the estimate, using a `CostScenario` with a defined `billingAccount`.

Args:
  billingAccount: string, Resource name of the billing account for the cost estimate. The resource name has the form `billingAccounts/{billing_acount_id}`. For example, `billingAccounts/012345-567890-ABCDEF` is the resource name for billing account `012345-567890-ABCDEF`. Must be specified. (required)
  body: object, The request body.
    The object takes the form of:

{ # Request for EstimateCostScenarioForBillingAccount.
  &quot;costScenario&quot;: { # Encapsulates all the information needed to perform a cost estimate. It includes a specification of the Google Cloud usage whose costs are estimated, and configuration options. # The scenario to estimate costs for.
    &quot;commitments&quot;: [ # New commitments to estimate the costs for. The cost of the commitments will be included in the estimate result and discounts the commitment entitles will be included in the workload cost estimates. A maximum of 100 workloads can be provided.
      { # Commitments give you the ability to pay a recurring fee in exchange for a benefit, such as a discount for your use. For example, this object might contain details of a [spend-based committed use discount (CUD)](https://cloud.google.com/docs/cuds#spend_based_commitments). Within a CostScenario, adding a commitment includes the cost of the commitment and any discounts.
        &quot;name&quot;: &quot;A String&quot;, # Required. A name for this commitment. All commitments in a CostScenario must have unique names. Each name may be at most 128 characters long.
        &quot;vmResourceBasedCud&quot;: { # Specifies a resource-based committed use discount (CUD). # A resource-based committed use discount (CUD).
          &quot;guestAccelerator&quot;: { # Specification of a set of guest accelerators attached to a machine. # Guest accelerator, known as GPU.
            &quot;acceleratorCount&quot;: &quot;A String&quot;, # The number of the guest accelerator cards exposed to each instance.
            &quot;acceleratorType&quot;: &quot;A String&quot;, # The type of the guest accelerator cards. For example: &quot;nvidia-tesla-t4&quot;.
          },
          &quot;machineSeries&quot;: &quot;A String&quot;, # The machine series for CUD. For example: &quot;n1&quot; for general purpose N1 machine type commitments. &quot;n2&quot; for general purpose N2 machine type commitments. &quot;e2&quot; for general purpose E2 machine type commitments. &quot;n2d&quot; for general purpose N2D machine type commitments. &quot;t2d&quot; for general purpose T2D machine type commitments. &quot;c2&quot;/&quot;c2d&quot; for compute-optimized commitments. &quot;m1&quot;/&quot;m2&quot; for the memory-optimized commitments. &quot;a2&#x27; for the accelerator-optimized commitments.
          &quot;memorySizeGb&quot;: 3.14, # Memory size of the VM in GB (2^30 bytes). Must be an increment of 0.25 (256 MB).
          &quot;plan&quot;: &quot;A String&quot;, # Commitment usage plan.
          &quot;region&quot;: &quot;A String&quot;, # The region where the VM runs. For example: &quot;us-central1&quot;
          &quot;virtualCpuCount&quot;: &quot;A String&quot;, # The number of vCPUs. The number of vCPUs must be an integer of 0 or more and can be even or odd.
        },
      },
    ],
    &quot;scenarioConfig&quot;: { # Configuration for a CostScenario. Specifies how costs are calculated. # Configuration for the scenario.
      &quot;estimateDuration&quot;: &quot;A String&quot;, # Time frame for the estimate. Workloads must specify usage for this duration. Duration must be at least 1 hour (3,600 seconds) and at most 10 years (315,360,000 seconds). The calculations for years and months are based on a 730-hour (2,628,000-second) month. For durations longer than one month (2,628,000 seconds), the duration is rounded up to the next month, so the estimate shows you the costs for full months. For example, a duration of 3,232,800 seconds (roughly 5 weeks) is rounded up to 2 months.
    },
    &quot;workloads&quot;: [ # The Google Cloud usage whose costs are estimated. A maximum of 100 workloads can be provided.
      { # Specifies usage on a single Google Cloud product over a time frame. Each Google Cloud product has its own message, containing specific product configuration parameters of the product usage amounts along each dimension in which the product is billed.
        &quot;cloudCdnEgressWorkload&quot;: { # Specifies usage for Cloud CDN egress. # Usage on Google Cloud CDN Egress.
          &quot;cacheEgressDestination&quot;: &quot;A String&quot;, # The destination for the cache egress charges.
          &quot;cacheEgressRate&quot;: { # An amount of usage over a time frame. # Cache egress usage. The rate of data cache egressed in the destination. For example : units such as &quot;GiBy/s&quot; or &quot;TBy/mo&quot;.
            &quot;usageRateTimeline&quot;: { # A timeline of usage rates. Consists of a series of entries, each of which specifies a constant rate of usage during a time interval. Each entry contains an effective time. The usage rate is in effect from that time until the effective time of the subsequent entry, or, for the last entry, for the remaining portion of estimation time frame. Effective times are specified as an offset into the estimation time frame. Usage is considered to be zero until the `effective_time` of the first entry. All subsequent entries must have an effective time greater than the previous entry and less than the estimate time frame. The effective time on all entries must be an integer number of hours. # A timeline of usage rates over the estimate interval.
              &quot;unit&quot;: &quot;A String&quot;, # The unit for the usage rate in each timeline entry. If you provide an incorrect unit for an instance, the correct unit is provided in the error message. The supported units are a subset of [The Unified Code for Units of Measure](https://ucum.org/ucum.html) standard: * **Time units (TIME-UNIT)** * `s` second * `min` minute * `h` hour * `d` day * `wk` week * `mo` month * `yr` year * `ms` millisecond * `us` microsecond * `ns` nanosecond * **Basic storage units (BASIC-STORAGE-UNIT)** * `bit` bit * `By` byte * **Count units (COUNT-UNIT)** * `count` count * **Prefixes (PREFIX)** * `k` kilo (10^3) * `M` mega (10^6) * `G` giga (10^9) * `T` tera (10^12) * `P` peta (10^15) * `Ki` kibi (2^10) * `Mi` mebi (2^20) * `Gi` gibi (2^30) * `Ti` tebi (2^40) * `Pi` pebi (2^50) **Grammar** The grammar also includes these connectors: * `/` division or ratio (as an infix operator). For example: `kBy/{email}` or `MiBy/10ms`. * `.` multiplication or composition (as an infix operator). For example: `GBy.d` or `k{watt}.h`. The grammar for a unit is as follows: ``` Expression = Component { &quot;.&quot; Component } { &quot;/&quot; Component } ; Component = ( [ PREFIX ] UNIT | &quot;%&quot; ) [ Annotation ] | Annotation | &quot;1&quot; ; UNIT = TIME-UNIT | STORAGE-UNIT | DATA-UNIT | COUNT-UNIT Annotation = &quot;{&quot; NAME &quot;}&quot; ; ``` Examples: * Request per second: `1/s` or `{requests}/s` * GibiBytes: `GiBy` * GibiBytes * seconds: `GiBy.s`
              &quot;usageRateTimelineEntries&quot;: [ # The timeline entries. Each entry has a start time and usage rate. The start time specifies the effective time of the usage rate. The entries must be sorted by start time in an increasing order.
                { # A usage rate timeline entry. Each entry specifies a constant usage rate during a time interval.
                  &quot;effectiveTime&quot;: { # Represents a point in time. # The effective time for this entry. The usage rate is in effect starting at this time until the effective time of the subsequent entry in the timeline. The last entry defines the usage rate until the end of the `Usage` time frame. Must correspond to an integer number of hours.
                    &quot;estimationTimeFrameOffset&quot;: &quot;A String&quot;, # The point in time, relative to the start of the time frame covered by the cost estimate.
                  },
                  &quot;usageRate&quot;: 3.14, # The usage rate.
                },
              ],
            },
          },
        },
        &quot;cloudCdnWorkload&quot;: { # Specifies usage for Cloud CDN resources. # Usage on Google Cloud CDN.
          &quot;cacheFillOriginService&quot;: &quot;A String&quot;, # The source service for the cache fill.
          &quot;cacheFillRate&quot;: { # An amount of usage over a time frame. # Cache fill usage. The rate of data transferred between cache fill regions. For example: units such as &quot;GiBy/s&quot; or &quot;TBy/mo&quot;.
            &quot;usageRateTimeline&quot;: { # A timeline of usage rates. Consists of a series of entries, each of which specifies a constant rate of usage during a time interval. Each entry contains an effective time. The usage rate is in effect from that time until the effective time of the subsequent entry, or, for the last entry, for the remaining portion of estimation time frame. Effective times are specified as an offset into the estimation time frame. Usage is considered to be zero until the `effective_time` of the first entry. All subsequent entries must have an effective time greater than the previous entry and less than the estimate time frame. The effective time on all entries must be an integer number of hours. # A timeline of usage rates over the estimate interval.
              &quot;unit&quot;: &quot;A String&quot;, # The unit for the usage rate in each timeline entry. If you provide an incorrect unit for an instance, the correct unit is provided in the error message. The supported units are a subset of [The Unified Code for Units of Measure](https://ucum.org/ucum.html) standard: * **Time units (TIME-UNIT)** * `s` second * `min` minute * `h` hour * `d` day * `wk` week * `mo` month * `yr` year * `ms` millisecond * `us` microsecond * `ns` nanosecond * **Basic storage units (BASIC-STORAGE-UNIT)** * `bit` bit * `By` byte * **Count units (COUNT-UNIT)** * `count` count * **Prefixes (PREFIX)** * `k` kilo (10^3) * `M` mega (10^6) * `G` giga (10^9) * `T` tera (10^12) * `P` peta (10^15) * `Ki` kibi (2^10) * `Mi` mebi (2^20) * `Gi` gibi (2^30) * `Ti` tebi (2^40) * `Pi` pebi (2^50) **Grammar** The grammar also includes these connectors: * `/` division or ratio (as an infix operator). For example: `kBy/{email}` or `MiBy/10ms`. * `.` multiplication or composition (as an infix operator). For example: `GBy.d` or `k{watt}.h`. The grammar for a unit is as follows: ``` Expression = Component { &quot;.&quot; Component } { &quot;/&quot; Component } ; Component = ( [ PREFIX ] UNIT | &quot;%&quot; ) [ Annotation ] | Annotation | &quot;1&quot; ; UNIT = TIME-UNIT | STORAGE-UNIT | DATA-UNIT | COUNT-UNIT Annotation = &quot;{&quot; NAME &quot;}&quot; ; ``` Examples: * Request per second: `1/s` or `{requests}/s` * GibiBytes: `GiBy` * GibiBytes * seconds: `GiBy.s`
              &quot;usageRateTimelineEntries&quot;: [ # The timeline entries. Each entry has a start time and usage rate. The start time specifies the effective time of the usage rate. The entries must be sorted by start time in an increasing order.
                { # A usage rate timeline entry. Each entry specifies a constant usage rate during a time interval.
                  &quot;effectiveTime&quot;: { # Represents a point in time. # The effective time for this entry. The usage rate is in effect starting at this time until the effective time of the subsequent entry in the timeline. The last entry defines the usage rate until the end of the `Usage` time frame. Must correspond to an integer number of hours.
                    &quot;estimationTimeFrameOffset&quot;: &quot;A String&quot;, # The point in time, relative to the start of the time frame covered by the cost estimate.
                  },
                  &quot;usageRate&quot;: 3.14, # The usage rate.
                },
              ],
            },
          },
          &quot;cacheFillRegions&quot;: { # Specifies the regions for Cache Fill. # The regions where data is transferred from Google data locations into Google global cache servers. The SKU prices for cache fill across services are the same.
            &quot;destinationRegion&quot;: &quot;A String&quot;, # The destination region for cache fill.
            &quot;sourceRegion&quot;: &quot;A String&quot;, # The source region for cache fill.
          },
          &quot;cacheLookUpRate&quot;: { # An amount of usage over a time frame. # Cache look up requests. This is specified to indicate the number of requests. For example: units such as &quot;1/s&quot;.
            &quot;usageRateTimeline&quot;: { # A timeline of usage rates. Consists of a series of entries, each of which specifies a constant rate of usage during a time interval. Each entry contains an effective time. The usage rate is in effect from that time until the effective time of the subsequent entry, or, for the last entry, for the remaining portion of estimation time frame. Effective times are specified as an offset into the estimation time frame. Usage is considered to be zero until the `effective_time` of the first entry. All subsequent entries must have an effective time greater than the previous entry and less than the estimate time frame. The effective time on all entries must be an integer number of hours. # A timeline of usage rates over the estimate interval.
              &quot;unit&quot;: &quot;A String&quot;, # The unit for the usage rate in each timeline entry. If you provide an incorrect unit for an instance, the correct unit is provided in the error message. The supported units are a subset of [The Unified Code for Units of Measure](https://ucum.org/ucum.html) standard: * **Time units (TIME-UNIT)** * `s` second * `min` minute * `h` hour * `d` day * `wk` week * `mo` month * `yr` year * `ms` millisecond * `us` microsecond * `ns` nanosecond * **Basic storage units (BASIC-STORAGE-UNIT)** * `bit` bit * `By` byte * **Count units (COUNT-UNIT)** * `count` count * **Prefixes (PREFIX)** * `k` kilo (10^3) * `M` mega (10^6) * `G` giga (10^9) * `T` tera (10^12) * `P` peta (10^15) * `Ki` kibi (2^10) * `Mi` mebi (2^20) * `Gi` gibi (2^30) * `Ti` tebi (2^40) * `Pi` pebi (2^50) **Grammar** The grammar also includes these connectors: * `/` division or ratio (as an infix operator). For example: `kBy/{email}` or `MiBy/10ms`. * `.` multiplication or composition (as an infix operator). For example: `GBy.d` or `k{watt}.h`. The grammar for a unit is as follows: ``` Expression = Component { &quot;.&quot; Component } { &quot;/&quot; Component } ; Component = ( [ PREFIX ] UNIT | &quot;%&quot; ) [ Annotation ] | Annotation | &quot;1&quot; ; UNIT = TIME-UNIT | STORAGE-UNIT | DATA-UNIT | COUNT-UNIT Annotation = &quot;{&quot; NAME &quot;}&quot; ; ``` Examples: * Request per second: `1/s` or `{requests}/s` * GibiBytes: `GiBy` * GibiBytes * seconds: `GiBy.s`
              &quot;usageRateTimelineEntries&quot;: [ # The timeline entries. Each entry has a start time and usage rate. The start time specifies the effective time of the usage rate. The entries must be sorted by start time in an increasing order.
                { # A usage rate timeline entry. Each entry specifies a constant usage rate during a time interval.
                  &quot;effectiveTime&quot;: { # Represents a point in time. # The effective time for this entry. The usage rate is in effect starting at this time until the effective time of the subsequent entry in the timeline. The last entry defines the usage rate until the end of the `Usage` time frame. Must correspond to an integer number of hours.
                    &quot;estimationTimeFrameOffset&quot;: &quot;A String&quot;, # The point in time, relative to the start of the time frame covered by the cost estimate.
                  },
                  &quot;usageRate&quot;: 3.14, # The usage rate.
                },
              ],
            },
          },
        },
        &quot;cloudInterconnectEgressWorkload&quot;: { # The interconnect egress only includes the Interconnect Egress. Please use the standard egress traffic interface to specify your standard egress usage. # Usage on Google Cloud Interconnect Egress.
          &quot;egressRate&quot;: { # An amount of usage over a time frame. # Data egress usage. This usage applies when you move or copy data from one Google Cloud service to another service. Expected units such as &quot;GiBy/s, By/s, etc.&quot;
            &quot;usageRateTimeline&quot;: { # A timeline of usage rates. Consists of a series of entries, each of which specifies a constant rate of usage during a time interval. Each entry contains an effective time. The usage rate is in effect from that time until the effective time of the subsequent entry, or, for the last entry, for the remaining portion of estimation time frame. Effective times are specified as an offset into the estimation time frame. Usage is considered to be zero until the `effective_time` of the first entry. All subsequent entries must have an effective time greater than the previous entry and less than the estimate time frame. The effective time on all entries must be an integer number of hours. # A timeline of usage rates over the estimate interval.
              &quot;unit&quot;: &quot;A String&quot;, # The unit for the usage rate in each timeline entry. If you provide an incorrect unit for an instance, the correct unit is provided in the error message. The supported units are a subset of [The Unified Code for Units of Measure](https://ucum.org/ucum.html) standard: * **Time units (TIME-UNIT)** * `s` second * `min` minute * `h` hour * `d` day * `wk` week * `mo` month * `yr` year * `ms` millisecond * `us` microsecond * `ns` nanosecond * **Basic storage units (BASIC-STORAGE-UNIT)** * `bit` bit * `By` byte * **Count units (COUNT-UNIT)** * `count` count * **Prefixes (PREFIX)** * `k` kilo (10^3) * `M` mega (10^6) * `G` giga (10^9) * `T` tera (10^12) * `P` peta (10^15) * `Ki` kibi (2^10) * `Mi` mebi (2^20) * `Gi` gibi (2^30) * `Ti` tebi (2^40) * `Pi` pebi (2^50) **Grammar** The grammar also includes these connectors: * `/` division or ratio (as an infix operator). For example: `kBy/{email}` or `MiBy/10ms`. * `.` multiplication or composition (as an infix operator). For example: `GBy.d` or `k{watt}.h`. The grammar for a unit is as follows: ``` Expression = Component { &quot;.&quot; Component } { &quot;/&quot; Component } ; Component = ( [ PREFIX ] UNIT | &quot;%&quot; ) [ Annotation ] | Annotation | &quot;1&quot; ; UNIT = TIME-UNIT | STORAGE-UNIT | DATA-UNIT | COUNT-UNIT Annotation = &quot;{&quot; NAME &quot;}&quot; ; ``` Examples: * Request per second: `1/s` or `{requests}/s` * GibiBytes: `GiBy` * GibiBytes * seconds: `GiBy.s`
              &quot;usageRateTimelineEntries&quot;: [ # The timeline entries. Each entry has a start time and usage rate. The start time specifies the effective time of the usage rate. The entries must be sorted by start time in an increasing order.
                { # A usage rate timeline entry. Each entry specifies a constant usage rate during a time interval.
                  &quot;effectiveTime&quot;: { # Represents a point in time. # The effective time for this entry. The usage rate is in effect starting at this time until the effective time of the subsequent entry in the timeline. The last entry defines the usage rate until the end of the `Usage` time frame. Must correspond to an integer number of hours.
                    &quot;estimationTimeFrameOffset&quot;: &quot;A String&quot;, # The point in time, relative to the start of the time frame covered by the cost estimate.
                  },
                  &quot;usageRate&quot;: 3.14, # The usage rate.
                },
              ],
            },
          },
          &quot;interconnectConnectionLocation&quot;: &quot;A String&quot;, # Locations in the [Interconnect connection location table](https://cloud.google.com/vpc/network-pricing#interconnect-pricing). This is the interconnect egress charges.
        },
        &quot;cloudInterconnectWorkload&quot;: { # Specifies usage for Cloud Interconnect resources. # Usage on Google Cloud Interconnect.
          &quot;interconnectAttachments&quot;: [ # VLAN attachment used for interconnect.
            { # VLAN attachment for cloud interconnect.
              &quot;bandwidth&quot;: &quot;A String&quot;, # Capacities in the [pricing table](https://cloud.google.com/vpc/network-pricing#interconnect-pricing) Examples of capacity are: 50/100/200/300/400/500-Mbps, 1/2/5/10/20/50-Gbps.
              &quot;vlanCount&quot;: { # An amount of usage over a time frame. # VLAN usage. This is specified as a unitless quantity which indicates the number of VLAN attachment used in interconnect.
                &quot;usageRateTimeline&quot;: { # A timeline of usage rates. Consists of a series of entries, each of which specifies a constant rate of usage during a time interval. Each entry contains an effective time. The usage rate is in effect from that time until the effective time of the subsequent entry, or, for the last entry, for the remaining portion of estimation time frame. Effective times are specified as an offset into the estimation time frame. Usage is considered to be zero until the `effective_time` of the first entry. All subsequent entries must have an effective time greater than the previous entry and less than the estimate time frame. The effective time on all entries must be an integer number of hours. # A timeline of usage rates over the estimate interval.
                  &quot;unit&quot;: &quot;A String&quot;, # The unit for the usage rate in each timeline entry. If you provide an incorrect unit for an instance, the correct unit is provided in the error message. The supported units are a subset of [The Unified Code for Units of Measure](https://ucum.org/ucum.html) standard: * **Time units (TIME-UNIT)** * `s` second * `min` minute * `h` hour * `d` day * `wk` week * `mo` month * `yr` year * `ms` millisecond * `us` microsecond * `ns` nanosecond * **Basic storage units (BASIC-STORAGE-UNIT)** * `bit` bit * `By` byte * **Count units (COUNT-UNIT)** * `count` count * **Prefixes (PREFIX)** * `k` kilo (10^3) * `M` mega (10^6) * `G` giga (10^9) * `T` tera (10^12) * `P` peta (10^15) * `Ki` kibi (2^10) * `Mi` mebi (2^20) * `Gi` gibi (2^30) * `Ti` tebi (2^40) * `Pi` pebi (2^50) **Grammar** The grammar also includes these connectors: * `/` division or ratio (as an infix operator). For example: `kBy/{email}` or `MiBy/10ms`. * `.` multiplication or composition (as an infix operator). For example: `GBy.d` or `k{watt}.h`. The grammar for a unit is as follows: ``` Expression = Component { &quot;.&quot; Component } { &quot;/&quot; Component } ; Component = ( [ PREFIX ] UNIT | &quot;%&quot; ) [ Annotation ] | Annotation | &quot;1&quot; ; UNIT = TIME-UNIT | STORAGE-UNIT | DATA-UNIT | COUNT-UNIT Annotation = &quot;{&quot; NAME &quot;}&quot; ; ``` Examples: * Request per second: `1/s` or `{requests}/s` * GibiBytes: `GiBy` * GibiBytes * seconds: `GiBy.s`
                  &quot;usageRateTimelineEntries&quot;: [ # The timeline entries. Each entry has a start time and usage rate. The start time specifies the effective time of the usage rate. The entries must be sorted by start time in an increasing order.
                    { # A usage rate timeline entry. Each entry specifies a constant usage rate during a time interval.
                      &quot;effectiveTime&quot;: { # Represents a point in time. # The effective time for this entry. The usage rate is in effect starting at this time until the effective time of the subsequent entry in the timeline. The last entry defines the usage rate until the end of the `Usage` time frame. Must correspond to an integer number of hours.
                        &quot;estimationTimeFrameOffset&quot;: &quot;A String&quot;, # The point in time, relative to the start of the time frame covered by the cost estimate.
                      },
                      &quot;usageRate&quot;: 3.14, # The usage rate.
                    },
                  ],
                },
              },
            },
          ],
          &quot;interconnectType&quot;: &quot;A String&quot;, # Vlan attachment type.
          &quot;linkType&quot;: &quot;A String&quot;, # Interconnect circuit link type.
          &quot;provisionedLinkCount&quot;: { # An amount of usage over a time frame. # Interconnect usage. This is specified as a unitless quantity which indicates the number of circuit provisioned in interconnect.
            &quot;usageRateTimeline&quot;: { # A timeline of usage rates. Consists of a series of entries, each of which specifies a constant rate of usage during a time interval. Each entry contains an effective time. The usage rate is in effect from that time until the effective time of the subsequent entry, or, for the last entry, for the remaining portion of estimation time frame. Effective times are specified as an offset into the estimation time frame. Usage is considered to be zero until the `effective_time` of the first entry. All subsequent entries must have an effective time greater than the previous entry and less than the estimate time frame. The effective time on all entries must be an integer number of hours. # A timeline of usage rates over the estimate interval.
              &quot;unit&quot;: &quot;A String&quot;, # The unit for the usage rate in each timeline entry. If you provide an incorrect unit for an instance, the correct unit is provided in the error message. The supported units are a subset of [The Unified Code for Units of Measure](https://ucum.org/ucum.html) standard: * **Time units (TIME-UNIT)** * `s` second * `min` minute * `h` hour * `d` day * `wk` week * `mo` month * `yr` year * `ms` millisecond * `us` microsecond * `ns` nanosecond * **Basic storage units (BASIC-STORAGE-UNIT)** * `bit` bit * `By` byte * **Count units (COUNT-UNIT)** * `count` count * **Prefixes (PREFIX)** * `k` kilo (10^3) * `M` mega (10^6) * `G` giga (10^9) * `T` tera (10^12) * `P` peta (10^15) * `Ki` kibi (2^10) * `Mi` mebi (2^20) * `Gi` gibi (2^30) * `Ti` tebi (2^40) * `Pi` pebi (2^50) **Grammar** The grammar also includes these connectors: * `/` division or ratio (as an infix operator). For example: `kBy/{email}` or `MiBy/10ms`. * `.` multiplication or composition (as an infix operator). For example: `GBy.d` or `k{watt}.h`. The grammar for a unit is as follows: ``` Expression = Component { &quot;.&quot; Component } { &quot;/&quot; Component } ; Component = ( [ PREFIX ] UNIT | &quot;%&quot; ) [ Annotation ] | Annotation | &quot;1&quot; ; UNIT = TIME-UNIT | STORAGE-UNIT | DATA-UNIT | COUNT-UNIT Annotation = &quot;{&quot; NAME &quot;}&quot; ; ``` Examples: * Request per second: `1/s` or `{requests}/s` * GibiBytes: `GiBy` * GibiBytes * seconds: `GiBy.s`
              &quot;usageRateTimelineEntries&quot;: [ # The timeline entries. Each entry has a start time and usage rate. The start time specifies the effective time of the usage rate. The entries must be sorted by start time in an increasing order.
                { # A usage rate timeline entry. Each entry specifies a constant usage rate during a time interval.
                  &quot;effectiveTime&quot;: { # Represents a point in time. # The effective time for this entry. The usage rate is in effect starting at this time until the effective time of the subsequent entry in the timeline. The last entry defines the usage rate until the end of the `Usage` time frame. Must correspond to an integer number of hours.
                    &quot;estimationTimeFrameOffset&quot;: &quot;A String&quot;, # The point in time, relative to the start of the time frame covered by the cost estimate.
                  },
                  &quot;usageRate&quot;: 3.14, # The usage rate.
                },
              ],
            },
          },
        },
        &quot;cloudStorageEgressWorkload&quot;: { # Specification of a network type. Network egress within Google Cloud applies when you move or copy data from one Cloud Storage bucket to another or when another Google Cloud service accesses data in your Cloud Storage bucket.This includes the network egress within Google Cloud and the general network usage. # Usage on a cloud storage egress.
          &quot;destinationContinent&quot;: &quot;A String&quot;, # Where the data is sent to.
          &quot;egressRate&quot;: { # An amount of usage over a time frame. # Egress usage rate. This usage applies when you move or copy data from one Cloud Storage bucket to another or when another Google Cloud service accesses data in your Cloud Storage bucket. Expected units such as &quot;GiBy/s, By/s, ...&quot;
            &quot;usageRateTimeline&quot;: { # A timeline of usage rates. Consists of a series of entries, each of which specifies a constant rate of usage during a time interval. Each entry contains an effective time. The usage rate is in effect from that time until the effective time of the subsequent entry, or, for the last entry, for the remaining portion of estimation time frame. Effective times are specified as an offset into the estimation time frame. Usage is considered to be zero until the `effective_time` of the first entry. All subsequent entries must have an effective time greater than the previous entry and less than the estimate time frame. The effective time on all entries must be an integer number of hours. # A timeline of usage rates over the estimate interval.
              &quot;unit&quot;: &quot;A String&quot;, # The unit for the usage rate in each timeline entry. If you provide an incorrect unit for an instance, the correct unit is provided in the error message. The supported units are a subset of [The Unified Code for Units of Measure](https://ucum.org/ucum.html) standard: * **Time units (TIME-UNIT)** * `s` second * `min` minute * `h` hour * `d` day * `wk` week * `mo` month * `yr` year * `ms` millisecond * `us` microsecond * `ns` nanosecond * **Basic storage units (BASIC-STORAGE-UNIT)** * `bit` bit * `By` byte * **Count units (COUNT-UNIT)** * `count` count * **Prefixes (PREFIX)** * `k` kilo (10^3) * `M` mega (10^6) * `G` giga (10^9) * `T` tera (10^12) * `P` peta (10^15) * `Ki` kibi (2^10) * `Mi` mebi (2^20) * `Gi` gibi (2^30) * `Ti` tebi (2^40) * `Pi` pebi (2^50) **Grammar** The grammar also includes these connectors: * `/` division or ratio (as an infix operator). For example: `kBy/{email}` or `MiBy/10ms`. * `.` multiplication or composition (as an infix operator). For example: `GBy.d` or `k{watt}.h`. The grammar for a unit is as follows: ``` Expression = Component { &quot;.&quot; Component } { &quot;/&quot; Component } ; Component = ( [ PREFIX ] UNIT | &quot;%&quot; ) [ Annotation ] | Annotation | &quot;1&quot; ; UNIT = TIME-UNIT | STORAGE-UNIT | DATA-UNIT | COUNT-UNIT Annotation = &quot;{&quot; NAME &quot;}&quot; ; ``` Examples: * Request per second: `1/s` or `{requests}/s` * GibiBytes: `GiBy` * GibiBytes * seconds: `GiBy.s`
              &quot;usageRateTimelineEntries&quot;: [ # The timeline entries. Each entry has a start time and usage rate. The start time specifies the effective time of the usage rate. The entries must be sorted by start time in an increasing order.
                { # A usage rate timeline entry. Each entry specifies a constant usage rate during a time interval.
                  &quot;effectiveTime&quot;: { # Represents a point in time. # The effective time for this entry. The usage rate is in effect starting at this time until the effective time of the subsequent entry in the timeline. The last entry defines the usage rate until the end of the `Usage` time frame. Must correspond to an integer number of hours.
                    &quot;estimationTimeFrameOffset&quot;: &quot;A String&quot;, # The point in time, relative to the start of the time frame covered by the cost estimate.
                  },
                  &quot;usageRate&quot;: 3.14, # The usage rate.
                },
              ],
            },
          },
          &quot;sourceContinent&quot;: &quot;A String&quot;, # Where the data comes from.
        },
        &quot;cloudStorageWorkload&quot;: { # Specifies usage of Cloud Storage resources. # Usage on Google Cloud Storage.
          &quot;dataRetrieval&quot;: { # An amount of usage over a time frame. # Data retrieval usage. A retrieval cost applies when data or metadata is read, copied, or rewritten . For example: units such as &quot;GiBy/s&quot; or &quot;By/s&quot;.
            &quot;usageRateTimeline&quot;: { # A timeline of usage rates. Consists of a series of entries, each of which specifies a constant rate of usage during a time interval. Each entry contains an effective time. The usage rate is in effect from that time until the effective time of the subsequent entry, or, for the last entry, for the remaining portion of estimation time frame. Effective times are specified as an offset into the estimation time frame. Usage is considered to be zero until the `effective_time` of the first entry. All subsequent entries must have an effective time greater than the previous entry and less than the estimate time frame. The effective time on all entries must be an integer number of hours. # A timeline of usage rates over the estimate interval.
              &quot;unit&quot;: &quot;A String&quot;, # The unit for the usage rate in each timeline entry. If you provide an incorrect unit for an instance, the correct unit is provided in the error message. The supported units are a subset of [The Unified Code for Units of Measure](https://ucum.org/ucum.html) standard: * **Time units (TIME-UNIT)** * `s` second * `min` minute * `h` hour * `d` day * `wk` week * `mo` month * `yr` year * `ms` millisecond * `us` microsecond * `ns` nanosecond * **Basic storage units (BASIC-STORAGE-UNIT)** * `bit` bit * `By` byte * **Count units (COUNT-UNIT)** * `count` count * **Prefixes (PREFIX)** * `k` kilo (10^3) * `M` mega (10^6) * `G` giga (10^9) * `T` tera (10^12) * `P` peta (10^15) * `Ki` kibi (2^10) * `Mi` mebi (2^20) * `Gi` gibi (2^30) * `Ti` tebi (2^40) * `Pi` pebi (2^50) **Grammar** The grammar also includes these connectors: * `/` division or ratio (as an infix operator). For example: `kBy/{email}` or `MiBy/10ms`. * `.` multiplication or composition (as an infix operator). For example: `GBy.d` or `k{watt}.h`. The grammar for a unit is as follows: ``` Expression = Component { &quot;.&quot; Component } { &quot;/&quot; Component } ; Component = ( [ PREFIX ] UNIT | &quot;%&quot; ) [ Annotation ] | Annotation | &quot;1&quot; ; UNIT = TIME-UNIT | STORAGE-UNIT | DATA-UNIT | COUNT-UNIT Annotation = &quot;{&quot; NAME &quot;}&quot; ; ``` Examples: * Request per second: `1/s` or `{requests}/s` * GibiBytes: `GiBy` * GibiBytes * seconds: `GiBy.s`
              &quot;usageRateTimelineEntries&quot;: [ # The timeline entries. Each entry has a start time and usage rate. The start time specifies the effective time of the usage rate. The entries must be sorted by start time in an increasing order.
                { # A usage rate timeline entry. Each entry specifies a constant usage rate during a time interval.
                  &quot;effectiveTime&quot;: { # Represents a point in time. # The effective time for this entry. The usage rate is in effect starting at this time until the effective time of the subsequent entry in the timeline. The last entry defines the usage rate until the end of the `Usage` time frame. Must correspond to an integer number of hours.
                    &quot;estimationTimeFrameOffset&quot;: &quot;A String&quot;, # The point in time, relative to the start of the time frame covered by the cost estimate.
                  },
                  &quot;usageRate&quot;: 3.14, # The usage rate.
                },
              ],
            },
          },
          &quot;dataStored&quot;: { # An amount of usage over a time frame. # Data storage usage. The amount of data stored in buckets. For example: units such as &quot;GiBy/s&quot; or &quot;TBy/mo&quot;.
            &quot;usageRateTimeline&quot;: { # A timeline of usage rates. Consists of a series of entries, each of which specifies a constant rate of usage during a time interval. Each entry contains an effective time. The usage rate is in effect from that time until the effective time of the subsequent entry, or, for the last entry, for the remaining portion of estimation time frame. Effective times are specified as an offset into the estimation time frame. Usage is considered to be zero until the `effective_time` of the first entry. All subsequent entries must have an effective time greater than the previous entry and less than the estimate time frame. The effective time on all entries must be an integer number of hours. # A timeline of usage rates over the estimate interval.
              &quot;unit&quot;: &quot;A String&quot;, # The unit for the usage rate in each timeline entry. If you provide an incorrect unit for an instance, the correct unit is provided in the error message. The supported units are a subset of [The Unified Code for Units of Measure](https://ucum.org/ucum.html) standard: * **Time units (TIME-UNIT)** * `s` second * `min` minute * `h` hour * `d` day * `wk` week * `mo` month * `yr` year * `ms` millisecond * `us` microsecond * `ns` nanosecond * **Basic storage units (BASIC-STORAGE-UNIT)** * `bit` bit * `By` byte * **Count units (COUNT-UNIT)** * `count` count * **Prefixes (PREFIX)** * `k` kilo (10^3) * `M` mega (10^6) * `G` giga (10^9) * `T` tera (10^12) * `P` peta (10^15) * `Ki` kibi (2^10) * `Mi` mebi (2^20) * `Gi` gibi (2^30) * `Ti` tebi (2^40) * `Pi` pebi (2^50) **Grammar** The grammar also includes these connectors: * `/` division or ratio (as an infix operator). For example: `kBy/{email}` or `MiBy/10ms`. * `.` multiplication or composition (as an infix operator). For example: `GBy.d` or `k{watt}.h`. The grammar for a unit is as follows: ``` Expression = Component { &quot;.&quot; Component } { &quot;/&quot; Component } ; Component = ( [ PREFIX ] UNIT | &quot;%&quot; ) [ Annotation ] | Annotation | &quot;1&quot; ; UNIT = TIME-UNIT | STORAGE-UNIT | DATA-UNIT | COUNT-UNIT Annotation = &quot;{&quot; NAME &quot;}&quot; ; ``` Examples: * Request per second: `1/s` or `{requests}/s` * GibiBytes: `GiBy` * GibiBytes * seconds: `GiBy.s`
              &quot;usageRateTimelineEntries&quot;: [ # The timeline entries. Each entry has a start time and usage rate. The start time specifies the effective time of the usage rate. The entries must be sorted by start time in an increasing order.
                { # A usage rate timeline entry. Each entry specifies a constant usage rate during a time interval.
                  &quot;effectiveTime&quot;: { # Represents a point in time. # The effective time for this entry. The usage rate is in effect starting at this time until the effective time of the subsequent entry in the timeline. The last entry defines the usage rate until the end of the `Usage` time frame. Must correspond to an integer number of hours.
                    &quot;estimationTimeFrameOffset&quot;: &quot;A String&quot;, # The point in time, relative to the start of the time frame covered by the cost estimate.
                  },
                  &quot;usageRate&quot;: 3.14, # The usage rate.
                },
              ],
            },
          },
          &quot;dualRegion&quot;: { # Area contains dual locations. # Specify dual regions.
            &quot;name&quot;: &quot;A String&quot;, # The [location name](https://cloud.google.com/storage/docs/locations#available-locations) where the data is stored. For example: &quot;asia1&quot; for dual region.
          },
          &quot;multiRegion&quot;: { # Area contains multiple locations. # Specify multi regions.
            &quot;name&quot;: &quot;A String&quot;, # The [location name](https://cloud.google.com/storage/docs/locations#available-locations) where the data is stored. For example: &quot;us&quot; for multi-region.
          },
          &quot;operationA&quot;: { # An amount of usage over a time frame. # Class A operation usage in Cloud Storage, such as listing the objects in buckets. See the [operations pricing](https://cloud.google.com/storage/pricing#operations-pricing) tables for a list of which operations fall into each class. For example: units such as &quot;1/s&quot;.
            &quot;usageRateTimeline&quot;: { # A timeline of usage rates. Consists of a series of entries, each of which specifies a constant rate of usage during a time interval. Each entry contains an effective time. The usage rate is in effect from that time until the effective time of the subsequent entry, or, for the last entry, for the remaining portion of estimation time frame. Effective times are specified as an offset into the estimation time frame. Usage is considered to be zero until the `effective_time` of the first entry. All subsequent entries must have an effective time greater than the previous entry and less than the estimate time frame. The effective time on all entries must be an integer number of hours. # A timeline of usage rates over the estimate interval.
              &quot;unit&quot;: &quot;A String&quot;, # The unit for the usage rate in each timeline entry. If you provide an incorrect unit for an instance, the correct unit is provided in the error message. The supported units are a subset of [The Unified Code for Units of Measure](https://ucum.org/ucum.html) standard: * **Time units (TIME-UNIT)** * `s` second * `min` minute * `h` hour * `d` day * `wk` week * `mo` month * `yr` year * `ms` millisecond * `us` microsecond * `ns` nanosecond * **Basic storage units (BASIC-STORAGE-UNIT)** * `bit` bit * `By` byte * **Count units (COUNT-UNIT)** * `count` count * **Prefixes (PREFIX)** * `k` kilo (10^3) * `M` mega (10^6) * `G` giga (10^9) * `T` tera (10^12) * `P` peta (10^15) * `Ki` kibi (2^10) * `Mi` mebi (2^20) * `Gi` gibi (2^30) * `Ti` tebi (2^40) * `Pi` pebi (2^50) **Grammar** The grammar also includes these connectors: * `/` division or ratio (as an infix operator). For example: `kBy/{email}` or `MiBy/10ms`. * `.` multiplication or composition (as an infix operator). For example: `GBy.d` or `k{watt}.h`. The grammar for a unit is as follows: ``` Expression = Component { &quot;.&quot; Component } { &quot;/&quot; Component } ; Component = ( [ PREFIX ] UNIT | &quot;%&quot; ) [ Annotation ] | Annotation | &quot;1&quot; ; UNIT = TIME-UNIT | STORAGE-UNIT | DATA-UNIT | COUNT-UNIT Annotation = &quot;{&quot; NAME &quot;}&quot; ; ``` Examples: * Request per second: `1/s` or `{requests}/s` * GibiBytes: `GiBy` * GibiBytes * seconds: `GiBy.s`
              &quot;usageRateTimelineEntries&quot;: [ # The timeline entries. Each entry has a start time and usage rate. The start time specifies the effective time of the usage rate. The entries must be sorted by start time in an increasing order.
                { # A usage rate timeline entry. Each entry specifies a constant usage rate during a time interval.
                  &quot;effectiveTime&quot;: { # Represents a point in time. # The effective time for this entry. The usage rate is in effect starting at this time until the effective time of the subsequent entry in the timeline. The last entry defines the usage rate until the end of the `Usage` time frame. Must correspond to an integer number of hours.
                    &quot;estimationTimeFrameOffset&quot;: &quot;A String&quot;, # The point in time, relative to the start of the time frame covered by the cost estimate.
                  },
                  &quot;usageRate&quot;: 3.14, # The usage rate.
                },
              ],
            },
          },
          &quot;operationB&quot;: { # An amount of usage over a time frame. # Class B operation usage in Cloud Storage, such as `getIamPolicy`. See the [operations pricing](https://cloud.google.com/storage/pricing#operations-pricing) tables for a list of which operations fall into each class. For example: units such as &quot;1/s&quot;.
            &quot;usageRateTimeline&quot;: { # A timeline of usage rates. Consists of a series of entries, each of which specifies a constant rate of usage during a time interval. Each entry contains an effective time. The usage rate is in effect from that time until the effective time of the subsequent entry, or, for the last entry, for the remaining portion of estimation time frame. Effective times are specified as an offset into the estimation time frame. Usage is considered to be zero until the `effective_time` of the first entry. All subsequent entries must have an effective time greater than the previous entry and less than the estimate time frame. The effective time on all entries must be an integer number of hours. # A timeline of usage rates over the estimate interval.
              &quot;unit&quot;: &quot;A String&quot;, # The unit for the usage rate in each timeline entry. If you provide an incorrect unit for an instance, the correct unit is provided in the error message. The supported units are a subset of [The Unified Code for Units of Measure](https://ucum.org/ucum.html) standard: * **Time units (TIME-UNIT)** * `s` second * `min` minute * `h` hour * `d` day * `wk` week * `mo` month * `yr` year * `ms` millisecond * `us` microsecond * `ns` nanosecond * **Basic storage units (BASIC-STORAGE-UNIT)** * `bit` bit * `By` byte * **Count units (COUNT-UNIT)** * `count` count * **Prefixes (PREFIX)** * `k` kilo (10^3) * `M` mega (10^6) * `G` giga (10^9) * `T` tera (10^12) * `P` peta (10^15) * `Ki` kibi (2^10) * `Mi` mebi (2^20) * `Gi` gibi (2^30) * `Ti` tebi (2^40) * `Pi` pebi (2^50) **Grammar** The grammar also includes these connectors: * `/` division or ratio (as an infix operator). For example: `kBy/{email}` or `MiBy/10ms`. * `.` multiplication or composition (as an infix operator). For example: `GBy.d` or `k{watt}.h`. The grammar for a unit is as follows: ``` Expression = Component { &quot;.&quot; Component } { &quot;/&quot; Component } ; Component = ( [ PREFIX ] UNIT | &quot;%&quot; ) [ Annotation ] | Annotation | &quot;1&quot; ; UNIT = TIME-UNIT | STORAGE-UNIT | DATA-UNIT | COUNT-UNIT Annotation = &quot;{&quot; NAME &quot;}&quot; ; ``` Examples: * Request per second: `1/s` or `{requests}/s` * GibiBytes: `GiBy` * GibiBytes * seconds: `GiBy.s`
              &quot;usageRateTimelineEntries&quot;: [ # The timeline entries. Each entry has a start time and usage rate. The start time specifies the effective time of the usage rate. The entries must be sorted by start time in an increasing order.
                { # A usage rate timeline entry. Each entry specifies a constant usage rate during a time interval.
                  &quot;effectiveTime&quot;: { # Represents a point in time. # The effective time for this entry. The usage rate is in effect starting at this time until the effective time of the subsequent entry in the timeline. The last entry defines the usage rate until the end of the `Usage` time frame. Must correspond to an integer number of hours.
                    &quot;estimationTimeFrameOffset&quot;: &quot;A String&quot;, # The point in time, relative to the start of the time frame covered by the cost estimate.
                  },
                  &quot;usageRate&quot;: 3.14, # The usage rate.
                },
              ],
            },
          },
          &quot;region&quot;: { # Area contains only one location. # Specify a single region.
            &quot;name&quot;: &quot;A String&quot;, # The [location name](https://cloud.google.com/storage/docs/locations#available-locations). For example: &quot;us-central1&quot; for region.
          },
          &quot;storageClass&quot;: &quot;A String&quot;, # The [storage class](https://cloud.google.com/storage/docs/storage-classes#classes) of the data and operation. For example: &quot;standard&quot; or &quot;nearline&quot;.
        },
        &quot;computeVmWorkload&quot;: { # Specificies usage of a set of identical compute VM instances. # Usage of a Google Compute Engine Virtual Machine.
          &quot;enableConfidentialCompute&quot;: True or False, # Defines whether each instance has confidential compute enabled.
          &quot;guestAccelerator&quot;: { # Specification of a set of guest accelerators attached to a machine. # Guest accelerators attached to each machine.
            &quot;acceleratorCount&quot;: &quot;A String&quot;, # The number of the guest accelerator cards exposed to each instance.
            &quot;acceleratorType&quot;: &quot;A String&quot;, # The type of the guest accelerator cards. For example: &quot;nvidia-tesla-t4&quot;.
          },
          &quot;instancesRunning&quot;: { # An amount of usage over a time frame. # VM usage. This is specified as a unitless quantity which indicates the number of instances running.
            &quot;usageRateTimeline&quot;: { # A timeline of usage rates. Consists of a series of entries, each of which specifies a constant rate of usage during a time interval. Each entry contains an effective time. The usage rate is in effect from that time until the effective time of the subsequent entry, or, for the last entry, for the remaining portion of estimation time frame. Effective times are specified as an offset into the estimation time frame. Usage is considered to be zero until the `effective_time` of the first entry. All subsequent entries must have an effective time greater than the previous entry and less than the estimate time frame. The effective time on all entries must be an integer number of hours. # A timeline of usage rates over the estimate interval.
              &quot;unit&quot;: &quot;A String&quot;, # The unit for the usage rate in each timeline entry. If you provide an incorrect unit for an instance, the correct unit is provided in the error message. The supported units are a subset of [The Unified Code for Units of Measure](https://ucum.org/ucum.html) standard: * **Time units (TIME-UNIT)** * `s` second * `min` minute * `h` hour * `d` day * `wk` week * `mo` month * `yr` year * `ms` millisecond * `us` microsecond * `ns` nanosecond * **Basic storage units (BASIC-STORAGE-UNIT)** * `bit` bit * `By` byte * **Count units (COUNT-UNIT)** * `count` count * **Prefixes (PREFIX)** * `k` kilo (10^3) * `M` mega (10^6) * `G` giga (10^9) * `T` tera (10^12) * `P` peta (10^15) * `Ki` kibi (2^10) * `Mi` mebi (2^20) * `Gi` gibi (2^30) * `Ti` tebi (2^40) * `Pi` pebi (2^50) **Grammar** The grammar also includes these connectors: * `/` division or ratio (as an infix operator). For example: `kBy/{email}` or `MiBy/10ms`. * `.` multiplication or composition (as an infix operator). For example: `GBy.d` or `k{watt}.h`. The grammar for a unit is as follows: ``` Expression = Component { &quot;.&quot; Component } { &quot;/&quot; Component } ; Component = ( [ PREFIX ] UNIT | &quot;%&quot; ) [ Annotation ] | Annotation | &quot;1&quot; ; UNIT = TIME-UNIT | STORAGE-UNIT | DATA-UNIT | COUNT-UNIT Annotation = &quot;{&quot; NAME &quot;}&quot; ; ``` Examples: * Request per second: `1/s` or `{requests}/s` * GibiBytes: `GiBy` * GibiBytes * seconds: `GiBy.s`
              &quot;usageRateTimelineEntries&quot;: [ # The timeline entries. Each entry has a start time and usage rate. The start time specifies the effective time of the usage rate. The entries must be sorted by start time in an increasing order.
                { # A usage rate timeline entry. Each entry specifies a constant usage rate during a time interval.
                  &quot;effectiveTime&quot;: { # Represents a point in time. # The effective time for this entry. The usage rate is in effect starting at this time until the effective time of the subsequent entry in the timeline. The last entry defines the usage rate until the end of the `Usage` time frame. Must correspond to an integer number of hours.
                    &quot;estimationTimeFrameOffset&quot;: &quot;A String&quot;, # The point in time, relative to the start of the time frame covered by the cost estimate.
                  },
                  &quot;usageRate&quot;: 3.14, # The usage rate.
                },
              ],
            },
          },
          &quot;licenses&quot;: [ # Premium image licenses used by each instance.
            &quot;A String&quot;,
          ],
          &quot;machineType&quot;: { # Specification of machine series, memory, and number of vCPUs. # The machine type.
            &quot;customMachineType&quot;: { # Specification of a custom machine type.
              &quot;machineSeries&quot;: &quot;A String&quot;, # Required. The machine series. Only certain [machine series](https://cloud.google.com/compute/docs/general-purpose-machines#custom_machine_types) support custom configurations. For example: &quot;n1&quot;.
              &quot;memorySizeGb&quot;: 3.14, # Required. Memory size of the VM in GB (2^30 bytes). Must be an increment of 0.25 (256 MB). Each [machine series](https://cloud.google.com/compute/docs/machine-types#machine_type_comparison) has limitations on allowed values for the ratio of memory-to-vCPU count.
              &quot;virtualCpuCount&quot;: &quot;A String&quot;, # Required. The number of vCPUs. The allowed values depend on the [machine series](https://cloud.google.com/compute/docs/machine-types#machine_type_comparison).
            },
            &quot;predefinedMachineType&quot;: { # Specification of a predefined machine type.
              &quot;machineType&quot;: &quot;A String&quot;, # The [machine type](https://cloud.google.com/compute/docs/machine-types). For example: &quot;n1-standard1&quot;.
            },
          },
          &quot;persistentDisks&quot;: [ # Persistent disks attached to each instance. Must include a boot disk.
            { # Specification of a persistent disk attached to a VM.
              &quot;diskSize&quot;: { # An amount of usage over a time frame. # Specifies the size of disk. Must be at least 10 GB.
                &quot;usageRateTimeline&quot;: { # A timeline of usage rates. Consists of a series of entries, each of which specifies a constant rate of usage during a time interval. Each entry contains an effective time. The usage rate is in effect from that time until the effective time of the subsequent entry, or, for the last entry, for the remaining portion of estimation time frame. Effective times are specified as an offset into the estimation time frame. Usage is considered to be zero until the `effective_time` of the first entry. All subsequent entries must have an effective time greater than the previous entry and less than the estimate time frame. The effective time on all entries must be an integer number of hours. # A timeline of usage rates over the estimate interval.
                  &quot;unit&quot;: &quot;A String&quot;, # The unit for the usage rate in each timeline entry. If you provide an incorrect unit for an instance, the correct unit is provided in the error message. The supported units are a subset of [The Unified Code for Units of Measure](https://ucum.org/ucum.html) standard: * **Time units (TIME-UNIT)** * `s` second * `min` minute * `h` hour * `d` day * `wk` week * `mo` month * `yr` year * `ms` millisecond * `us` microsecond * `ns` nanosecond * **Basic storage units (BASIC-STORAGE-UNIT)** * `bit` bit * `By` byte * **Count units (COUNT-UNIT)** * `count` count * **Prefixes (PREFIX)** * `k` kilo (10^3) * `M` mega (10^6) * `G` giga (10^9) * `T` tera (10^12) * `P` peta (10^15) * `Ki` kibi (2^10) * `Mi` mebi (2^20) * `Gi` gibi (2^30) * `Ti` tebi (2^40) * `Pi` pebi (2^50) **Grammar** The grammar also includes these connectors: * `/` division or ratio (as an infix operator). For example: `kBy/{email}` or `MiBy/10ms`. * `.` multiplication or composition (as an infix operator). For example: `GBy.d` or `k{watt}.h`. The grammar for a unit is as follows: ``` Expression = Component { &quot;.&quot; Component } { &quot;/&quot; Component } ; Component = ( [ PREFIX ] UNIT | &quot;%&quot; ) [ Annotation ] | Annotation | &quot;1&quot; ; UNIT = TIME-UNIT | STORAGE-UNIT | DATA-UNIT | COUNT-UNIT Annotation = &quot;{&quot; NAME &quot;}&quot; ; ``` Examples: * Request per second: `1/s` or `{requests}/s` * GibiBytes: `GiBy` * GibiBytes * seconds: `GiBy.s`
                  &quot;usageRateTimelineEntries&quot;: [ # The timeline entries. Each entry has a start time and usage rate. The start time specifies the effective time of the usage rate. The entries must be sorted by start time in an increasing order.
                    { # A usage rate timeline entry. Each entry specifies a constant usage rate during a time interval.
                      &quot;effectiveTime&quot;: { # Represents a point in time. # The effective time for this entry. The usage rate is in effect starting at this time until the effective time of the subsequent entry in the timeline. The last entry defines the usage rate until the end of the `Usage` time frame. Must correspond to an integer number of hours.
                        &quot;estimationTimeFrameOffset&quot;: &quot;A String&quot;, # The point in time, relative to the start of the time frame covered by the cost estimate.
                      },
                      &quot;usageRate&quot;: 3.14, # The usage rate.
                    },
                  ],
                },
              },
              &quot;diskType&quot;: &quot;A String&quot;, # The [disk type](https://cloud.google.com/compute/docs/disks#disk-types). For example: &quot;pd-standard&quot;.
              &quot;provisionedIops&quot;: { # An amount of usage over a time frame. # Indicates how many IOPS to provision for the disk for extreme persistent disks. This sets the number of I/O operations per second that the disk can handle. Values must be between 10,000 and 120,000.
                &quot;usageRateTimeline&quot;: { # A timeline of usage rates. Consists of a series of entries, each of which specifies a constant rate of usage during a time interval. Each entry contains an effective time. The usage rate is in effect from that time until the effective time of the subsequent entry, or, for the last entry, for the remaining portion of estimation time frame. Effective times are specified as an offset into the estimation time frame. Usage is considered to be zero until the `effective_time` of the first entry. All subsequent entries must have an effective time greater than the previous entry and less than the estimate time frame. The effective time on all entries must be an integer number of hours. # A timeline of usage rates over the estimate interval.
                  &quot;unit&quot;: &quot;A String&quot;, # The unit for the usage rate in each timeline entry. If you provide an incorrect unit for an instance, the correct unit is provided in the error message. The supported units are a subset of [The Unified Code for Units of Measure](https://ucum.org/ucum.html) standard: * **Time units (TIME-UNIT)** * `s` second * `min` minute * `h` hour * `d` day * `wk` week * `mo` month * `yr` year * `ms` millisecond * `us` microsecond * `ns` nanosecond * **Basic storage units (BASIC-STORAGE-UNIT)** * `bit` bit * `By` byte * **Count units (COUNT-UNIT)** * `count` count * **Prefixes (PREFIX)** * `k` kilo (10^3) * `M` mega (10^6) * `G` giga (10^9) * `T` tera (10^12) * `P` peta (10^15) * `Ki` kibi (2^10) * `Mi` mebi (2^20) * `Gi` gibi (2^30) * `Ti` tebi (2^40) * `Pi` pebi (2^50) **Grammar** The grammar also includes these connectors: * `/` division or ratio (as an infix operator). For example: `kBy/{email}` or `MiBy/10ms`. * `.` multiplication or composition (as an infix operator). For example: `GBy.d` or `k{watt}.h`. The grammar for a unit is as follows: ``` Expression = Component { &quot;.&quot; Component } { &quot;/&quot; Component } ; Component = ( [ PREFIX ] UNIT | &quot;%&quot; ) [ Annotation ] | Annotation | &quot;1&quot; ; UNIT = TIME-UNIT | STORAGE-UNIT | DATA-UNIT | COUNT-UNIT Annotation = &quot;{&quot; NAME &quot;}&quot; ; ``` Examples: * Request per second: `1/s` or `{requests}/s` * GibiBytes: `GiBy` * GibiBytes * seconds: `GiBy.s`
                  &quot;usageRateTimelineEntries&quot;: [ # The timeline entries. Each entry has a start time and usage rate. The start time specifies the effective time of the usage rate. The entries must be sorted by start time in an increasing order.
                    { # A usage rate timeline entry. Each entry specifies a constant usage rate during a time interval.
                      &quot;effectiveTime&quot;: { # Represents a point in time. # The effective time for this entry. The usage rate is in effect starting at this time until the effective time of the subsequent entry in the timeline. The last entry defines the usage rate until the end of the `Usage` time frame. Must correspond to an integer number of hours.
                        &quot;estimationTimeFrameOffset&quot;: &quot;A String&quot;, # The point in time, relative to the start of the time frame covered by the cost estimate.
                      },
                      &quot;usageRate&quot;: 3.14, # The usage rate.
                    },
                  ],
                },
              },
              &quot;scope&quot;: &quot;A String&quot;, # The geographic scope of the disk. Defaults to `SCOPE_ZONAL` if not specified.
            },
          ],
          &quot;preemptible&quot;: True or False, # Defines whether each instance is preemptible.
          &quot;region&quot;: &quot;A String&quot;, # The [region](https://cloud.google.com/compute/docs/regions-zones) where the VMs run. For example: &quot;us-central1&quot;.
        },
        &quot;name&quot;: &quot;A String&quot;, # Required. A name for this workload. All workloads in a `CostScenario` must have a unique `name`. Each `name` may be at most 128 characters long.
        &quot;premiumTierEgressWorkload&quot;: { # Specify Premium Tier Internet egress networking. # Usage on Premium Tier Internet Egress.
          &quot;destinationContinent&quot;: &quot;A String&quot;, # Where the data is sent to.
          &quot;egressRate&quot;: { # An amount of usage over a time frame. # Premium Tier egress usage. Expected units such as &quot;GiBy/s, By/s, etc.&quot;
            &quot;usageRateTimeline&quot;: { # A timeline of usage rates. Consists of a series of entries, each of which specifies a constant rate of usage during a time interval. Each entry contains an effective time. The usage rate is in effect from that time until the effective time of the subsequent entry, or, for the last entry, for the remaining portion of estimation time frame. Effective times are specified as an offset into the estimation time frame. Usage is considered to be zero until the `effective_time` of the first entry. All subsequent entries must have an effective time greater than the previous entry and less than the estimate time frame. The effective time on all entries must be an integer number of hours. # A timeline of usage rates over the estimate interval.
              &quot;unit&quot;: &quot;A String&quot;, # The unit for the usage rate in each timeline entry. If you provide an incorrect unit for an instance, the correct unit is provided in the error message. The supported units are a subset of [The Unified Code for Units of Measure](https://ucum.org/ucum.html) standard: * **Time units (TIME-UNIT)** * `s` second * `min` minute * `h` hour * `d` day * `wk` week * `mo` month * `yr` year * `ms` millisecond * `us` microsecond * `ns` nanosecond * **Basic storage units (BASIC-STORAGE-UNIT)** * `bit` bit * `By` byte * **Count units (COUNT-UNIT)** * `count` count * **Prefixes (PREFIX)** * `k` kilo (10^3) * `M` mega (10^6) * `G` giga (10^9) * `T` tera (10^12) * `P` peta (10^15) * `Ki` kibi (2^10) * `Mi` mebi (2^20) * `Gi` gibi (2^30) * `Ti` tebi (2^40) * `Pi` pebi (2^50) **Grammar** The grammar also includes these connectors: * `/` division or ratio (as an infix operator). For example: `kBy/{email}` or `MiBy/10ms`. * `.` multiplication or composition (as an infix operator). For example: `GBy.d` or `k{watt}.h`. The grammar for a unit is as follows: ``` Expression = Component { &quot;.&quot; Component } { &quot;/&quot; Component } ; Component = ( [ PREFIX ] UNIT | &quot;%&quot; ) [ Annotation ] | Annotation | &quot;1&quot; ; UNIT = TIME-UNIT | STORAGE-UNIT | DATA-UNIT | COUNT-UNIT Annotation = &quot;{&quot; NAME &quot;}&quot; ; ``` Examples: * Request per second: `1/s` or `{requests}/s` * GibiBytes: `GiBy` * GibiBytes * seconds: `GiBy.s`
              &quot;usageRateTimelineEntries&quot;: [ # The timeline entries. Each entry has a start time and usage rate. The start time specifies the effective time of the usage rate. The entries must be sorted by start time in an increasing order.
                { # A usage rate timeline entry. Each entry specifies a constant usage rate during a time interval.
                  &quot;effectiveTime&quot;: { # Represents a point in time. # The effective time for this entry. The usage rate is in effect starting at this time until the effective time of the subsequent entry in the timeline. The last entry defines the usage rate until the end of the `Usage` time frame. Must correspond to an integer number of hours.
                    &quot;estimationTimeFrameOffset&quot;: &quot;A String&quot;, # The point in time, relative to the start of the time frame covered by the cost estimate.
                  },
                  &quot;usageRate&quot;: 3.14, # The usage rate.
                },
              ],
            },
          },
          &quot;sourceRegion&quot;: &quot;A String&quot;, # Which [region](https://cloud.google.com/compute/docs/regions-zones) the egress data comes from.
        },
        &quot;standardTierEgressWorkload&quot;: { # Specify Standard Tier Internet egress networking. # Usage on Standard Tier Internet Egress.
          &quot;egressRate&quot;: { # An amount of usage over a time frame. # Standard tier egress usage. Expected units such as &quot;GiBy/s, By/s, etc.&quot;
            &quot;usageRateTimeline&quot;: { # A timeline of usage rates. Consists of a series of entries, each of which specifies a constant rate of usage during a time interval. Each entry contains an effective time. The usage rate is in effect from that time until the effective time of the subsequent entry, or, for the last entry, for the remaining portion of estimation time frame. Effective times are specified as an offset into the estimation time frame. Usage is considered to be zero until the `effective_time` of the first entry. All subsequent entries must have an effective time greater than the previous entry and less than the estimate time frame. The effective time on all entries must be an integer number of hours. # A timeline of usage rates over the estimate interval.
              &quot;unit&quot;: &quot;A String&quot;, # The unit for the usage rate in each timeline entry. If you provide an incorrect unit for an instance, the correct unit is provided in the error message. The supported units are a subset of [The Unified Code for Units of Measure](https://ucum.org/ucum.html) standard: * **Time units (TIME-UNIT)** * `s` second * `min` minute * `h` hour * `d` day * `wk` week * `mo` month * `yr` year * `ms` millisecond * `us` microsecond * `ns` nanosecond * **Basic storage units (BASIC-STORAGE-UNIT)** * `bit` bit * `By` byte * **Count units (COUNT-UNIT)** * `count` count * **Prefixes (PREFIX)** * `k` kilo (10^3) * `M` mega (10^6) * `G` giga (10^9) * `T` tera (10^12) * `P` peta (10^15) * `Ki` kibi (2^10) * `Mi` mebi (2^20) * `Gi` gibi (2^30) * `Ti` tebi (2^40) * `Pi` pebi (2^50) **Grammar** The grammar also includes these connectors: * `/` division or ratio (as an infix operator). For example: `kBy/{email}` or `MiBy/10ms`. * `.` multiplication or composition (as an infix operator). For example: `GBy.d` or `k{watt}.h`. The grammar for a unit is as follows: ``` Expression = Component { &quot;.&quot; Component } { &quot;/&quot; Component } ; Component = ( [ PREFIX ] UNIT | &quot;%&quot; ) [ Annotation ] | Annotation | &quot;1&quot; ; UNIT = TIME-UNIT | STORAGE-UNIT | DATA-UNIT | COUNT-UNIT Annotation = &quot;{&quot; NAME &quot;}&quot; ; ``` Examples: * Request per second: `1/s` or `{requests}/s` * GibiBytes: `GiBy` * GibiBytes * seconds: `GiBy.s`
              &quot;usageRateTimelineEntries&quot;: [ # The timeline entries. Each entry has a start time and usage rate. The start time specifies the effective time of the usage rate. The entries must be sorted by start time in an increasing order.
                { # A usage rate timeline entry. Each entry specifies a constant usage rate during a time interval.
                  &quot;effectiveTime&quot;: { # Represents a point in time. # The effective time for this entry. The usage rate is in effect starting at this time until the effective time of the subsequent entry in the timeline. The last entry defines the usage rate until the end of the `Usage` time frame. Must correspond to an integer number of hours.
                    &quot;estimationTimeFrameOffset&quot;: &quot;A String&quot;, # The point in time, relative to the start of the time frame covered by the cost estimate.
                  },
                  &quot;usageRate&quot;: 3.14, # The usage rate.
                },
              ],
            },
          },
          &quot;sourceRegion&quot;: &quot;A String&quot;, # Which [region](https://cloud.google.com/compute/docs/regions-zones) the egress data comes from.
        },
        &quot;vmToVmEgressWorkload&quot;: { # Specify VM to VM egress. # Usage on Vm to Vm Egress.
          &quot;interRegionEgress&quot;: { # Egress traffic between two regions.
            &quot;destinationRegion&quot;: &quot;A String&quot;, # Which [region](https://cloud.google.com/compute/docs/regions-zones) the egress data goes to.
            &quot;egressRate&quot;: { # An amount of usage over a time frame. # VM to VM egress usage. Expected units such as &quot;GiBy/s, By/s, etc.&quot;
              &quot;usageRateTimeline&quot;: { # A timeline of usage rates. Consists of a series of entries, each of which specifies a constant rate of usage during a time interval. Each entry contains an effective time. The usage rate is in effect from that time until the effective time of the subsequent entry, or, for the last entry, for the remaining portion of estimation time frame. Effective times are specified as an offset into the estimation time frame. Usage is considered to be zero until the `effective_time` of the first entry. All subsequent entries must have an effective time greater than the previous entry and less than the estimate time frame. The effective time on all entries must be an integer number of hours. # A timeline of usage rates over the estimate interval.
                &quot;unit&quot;: &quot;A String&quot;, # The unit for the usage rate in each timeline entry. If you provide an incorrect unit for an instance, the correct unit is provided in the error message. The supported units are a subset of [The Unified Code for Units of Measure](https://ucum.org/ucum.html) standard: * **Time units (TIME-UNIT)** * `s` second * `min` minute * `h` hour * `d` day * `wk` week * `mo` month * `yr` year * `ms` millisecond * `us` microsecond * `ns` nanosecond * **Basic storage units (BASIC-STORAGE-UNIT)** * `bit` bit * `By` byte * **Count units (COUNT-UNIT)** * `count` count * **Prefixes (PREFIX)** * `k` kilo (10^3) * `M` mega (10^6) * `G` giga (10^9) * `T` tera (10^12) * `P` peta (10^15) * `Ki` kibi (2^10) * `Mi` mebi (2^20) * `Gi` gibi (2^30) * `Ti` tebi (2^40) * `Pi` pebi (2^50) **Grammar** The grammar also includes these connectors: * `/` division or ratio (as an infix operator). For example: `kBy/{email}` or `MiBy/10ms`. * `.` multiplication or composition (as an infix operator). For example: `GBy.d` or `k{watt}.h`. The grammar for a unit is as follows: ``` Expression = Component { &quot;.&quot; Component } { &quot;/&quot; Component } ; Component = ( [ PREFIX ] UNIT | &quot;%&quot; ) [ Annotation ] | Annotation | &quot;1&quot; ; UNIT = TIME-UNIT | STORAGE-UNIT | DATA-UNIT | COUNT-UNIT Annotation = &quot;{&quot; NAME &quot;}&quot; ; ``` Examples: * Request per second: `1/s` or `{requests}/s` * GibiBytes: `GiBy` * GibiBytes * seconds: `GiBy.s`
                &quot;usageRateTimelineEntries&quot;: [ # The timeline entries. Each entry has a start time and usage rate. The start time specifies the effective time of the usage rate. The entries must be sorted by start time in an increasing order.
                  { # A usage rate timeline entry. Each entry specifies a constant usage rate during a time interval.
                    &quot;effectiveTime&quot;: { # Represents a point in time. # The effective time for this entry. The usage rate is in effect starting at this time until the effective time of the subsequent entry in the timeline. The last entry defines the usage rate until the end of the `Usage` time frame. Must correspond to an integer number of hours.
                      &quot;estimationTimeFrameOffset&quot;: &quot;A String&quot;, # The point in time, relative to the start of the time frame covered by the cost estimate.
                    },
                    &quot;usageRate&quot;: 3.14, # The usage rate.
                  },
                ],
              },
            },
            &quot;sourceRegion&quot;: &quot;A String&quot;, # Which [region](https://cloud.google.com/compute/docs/regions-zones) the egress data comes from.
          },
          &quot;intraRegionEgress&quot;: { # Egress traffic within the same region. When source region and destination region are in the same zone, using the internal IP addresses, there isn&#x27;t any egress charge.
            &quot;egressRate&quot;: { # An amount of usage over a time frame. # VM to VM egress usage. Expected units such as &quot;GiBy/s, By/s, etc.&quot;
              &quot;usageRateTimeline&quot;: { # A timeline of usage rates. Consists of a series of entries, each of which specifies a constant rate of usage during a time interval. Each entry contains an effective time. The usage rate is in effect from that time until the effective time of the subsequent entry, or, for the last entry, for the remaining portion of estimation time frame. Effective times are specified as an offset into the estimation time frame. Usage is considered to be zero until the `effective_time` of the first entry. All subsequent entries must have an effective time greater than the previous entry and less than the estimate time frame. The effective time on all entries must be an integer number of hours. # A timeline of usage rates over the estimate interval.
                &quot;unit&quot;: &quot;A String&quot;, # The unit for the usage rate in each timeline entry. If you provide an incorrect unit for an instance, the correct unit is provided in the error message. The supported units are a subset of [The Unified Code for Units of Measure](https://ucum.org/ucum.html) standard: * **Time units (TIME-UNIT)** * `s` second * `min` minute * `h` hour * `d` day * `wk` week * `mo` month * `yr` year * `ms` millisecond * `us` microsecond * `ns` nanosecond * **Basic storage units (BASIC-STORAGE-UNIT)** * `bit` bit * `By` byte * **Count units (COUNT-UNIT)** * `count` count * **Prefixes (PREFIX)** * `k` kilo (10^3) * `M` mega (10^6) * `G` giga (10^9) * `T` tera (10^12) * `P` peta (10^15) * `Ki` kibi (2^10) * `Mi` mebi (2^20) * `Gi` gibi (2^30) * `Ti` tebi (2^40) * `Pi` pebi (2^50) **Grammar** The grammar also includes these connectors: * `/` division or ratio (as an infix operator). For example: `kBy/{email}` or `MiBy/10ms`. * `.` multiplication or composition (as an infix operator). For example: `GBy.d` or `k{watt}.h`. The grammar for a unit is as follows: ``` Expression = Component { &quot;.&quot; Component } { &quot;/&quot; Component } ; Component = ( [ PREFIX ] UNIT | &quot;%&quot; ) [ Annotation ] | Annotation | &quot;1&quot; ; UNIT = TIME-UNIT | STORAGE-UNIT | DATA-UNIT | COUNT-UNIT Annotation = &quot;{&quot; NAME &quot;}&quot; ; ``` Examples: * Request per second: `1/s` or `{requests}/s` * GibiBytes: `GiBy` * GibiBytes * seconds: `GiBy.s`
                &quot;usageRateTimelineEntries&quot;: [ # The timeline entries. Each entry has a start time and usage rate. The start time specifies the effective time of the usage rate. The entries must be sorted by start time in an increasing order.
                  { # A usage rate timeline entry. Each entry specifies a constant usage rate during a time interval.
                    &quot;effectiveTime&quot;: { # Represents a point in time. # The effective time for this entry. The usage rate is in effect starting at this time until the effective time of the subsequent entry in the timeline. The last entry defines the usage rate until the end of the `Usage` time frame. Must correspond to an integer number of hours.
                      &quot;estimationTimeFrameOffset&quot;: &quot;A String&quot;, # The point in time, relative to the start of the time frame covered by the cost estimate.
                    },
                    &quot;usageRate&quot;: 3.14, # The usage rate.
                  },
                ],
              },
            },
          },
        },
      },
    ],
  },
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response for EstimateCostScenarioForBillingAccount
  &quot;costEstimationResult&quot;: { # The result of a estimating the costs of a `CostScenario`. # The result of the cost estimation.
    &quot;currencyCode&quot;: &quot;A String&quot;, # Required. The ISO 4217 currency code for the cost estimate.
    &quot;segmentCostEstimates&quot;: [ # Required. Estimated costs for each idealized month of a `CostScenario`.
      { # Workload cost estimates for a single time segment.
        &quot;commitmentCostEstimates&quot;: [ # Estimated costs for each commitment.
          { # Estimated cost for a commitment.
            &quot;commitmentTotalCostEstimate&quot;: { # An estimated cost. # Total estimated costs for the commitment.
              &quot;creditEstimates&quot;: [ # The estimated credits applied.
                { # An estimated credit applied to the costs on a SKU.
                  &quot;creditAmount&quot;: { # Represents an amount of money with its currency type. # The estimated credit amount.
                    &quot;currencyCode&quot;: &quot;A String&quot;, # The three-letter currency code defined in ISO 4217.
                    &quot;nanos&quot;: 42, # Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
                    &quot;units&quot;: &quot;A String&quot;, # The whole units of the amount. For example if `currencyCode` is `&quot;USD&quot;`, then 1 unit is one US dollar.
                  },
                  &quot;creditDescription&quot;: &quot;A String&quot;, # The credit description.
                  &quot;creditType&quot;: &quot;A String&quot;, # The credit type.
                },
              ],
              &quot;netCostEstimate&quot;: { # Represents an amount of money with its currency type. # The estimated net cost after applying credits.
                &quot;currencyCode&quot;: &quot;A String&quot;, # The three-letter currency code defined in ISO 4217.
                &quot;nanos&quot;: 42, # Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
                &quot;units&quot;: &quot;A String&quot;, # The whole units of the amount. For example if `currencyCode` is `&quot;USD&quot;`, then 1 unit is one US dollar.
              },
              &quot;preCreditCostEstimate&quot;: { # Represents an amount of money with its currency type. # The estimated cost prior to applying credits.
                &quot;currencyCode&quot;: &quot;A String&quot;, # The three-letter currency code defined in ISO 4217.
                &quot;nanos&quot;: 42, # Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
                &quot;units&quot;: &quot;A String&quot;, # The whole units of the amount. For example if `currencyCode` is `&quot;USD&quot;`, then 1 unit is one US dollar.
              },
            },
            &quot;name&quot;: &quot;A String&quot;, # The name of the commitment, as specified in the `CostScenario`.
            &quot;skuCostEstimates&quot;: [ # Estimated costs for each SKU in the commitment.
              { # Estimated cost for usage on a SKU.
                &quot;costEstimate&quot;: { # An estimated cost. # The estimated cost for the usage on this SKU.
                  &quot;creditEstimates&quot;: [ # The estimated credits applied.
                    { # An estimated credit applied to the costs on a SKU.
                      &quot;creditAmount&quot;: { # Represents an amount of money with its currency type. # The estimated credit amount.
                        &quot;currencyCode&quot;: &quot;A String&quot;, # The three-letter currency code defined in ISO 4217.
                        &quot;nanos&quot;: 42, # Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
                        &quot;units&quot;: &quot;A String&quot;, # The whole units of the amount. For example if `currencyCode` is `&quot;USD&quot;`, then 1 unit is one US dollar.
                      },
                      &quot;creditDescription&quot;: &quot;A String&quot;, # The credit description.
                      &quot;creditType&quot;: &quot;A String&quot;, # The credit type.
                    },
                  ],
                  &quot;netCostEstimate&quot;: { # Represents an amount of money with its currency type. # The estimated net cost after applying credits.
                    &quot;currencyCode&quot;: &quot;A String&quot;, # The three-letter currency code defined in ISO 4217.
                    &quot;nanos&quot;: 42, # Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
                    &quot;units&quot;: &quot;A String&quot;, # The whole units of the amount. For example if `currencyCode` is `&quot;USD&quot;`, then 1 unit is one US dollar.
                  },
                  &quot;preCreditCostEstimate&quot;: { # Represents an amount of money with its currency type. # The estimated cost prior to applying credits.
                    &quot;currencyCode&quot;: &quot;A String&quot;, # The three-letter currency code defined in ISO 4217.
                    &quot;nanos&quot;: 42, # Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
                    &quot;units&quot;: &quot;A String&quot;, # The whole units of the amount. For example if `currencyCode` is `&quot;USD&quot;`, then 1 unit is one US dollar.
                  },
                },
                &quot;sku&quot;: &quot;A String&quot;, # The resource name for the SKU. Example: &quot;services/DA34-426B-A397/skus/AA95-CD31-42FE&quot; More information about the SKU can be found in the `skus` field of the `CostEstimationResult`.
                &quot;usageAmount&quot;: 3.14, # The amount of usage on this SKU.
                &quot;usageUnit&quot;: &quot;A String&quot;, # The unit for the usage on this SKU.
              },
            ],
          },
        ],
        &quot;segmentStartTime&quot;: { # Represents a point in time. # Timestamp for the start of the segment.
          &quot;estimationTimeFrameOffset&quot;: &quot;A String&quot;, # The point in time, relative to the start of the time frame covered by the cost estimate.
        },
        &quot;segmentTotalCostEstimate&quot;: { # An estimated cost. # Total estimated costs for the time segment.
          &quot;creditEstimates&quot;: [ # The estimated credits applied.
            { # An estimated credit applied to the costs on a SKU.
              &quot;creditAmount&quot;: { # Represents an amount of money with its currency type. # The estimated credit amount.
                &quot;currencyCode&quot;: &quot;A String&quot;, # The three-letter currency code defined in ISO 4217.
                &quot;nanos&quot;: 42, # Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
                &quot;units&quot;: &quot;A String&quot;, # The whole units of the amount. For example if `currencyCode` is `&quot;USD&quot;`, then 1 unit is one US dollar.
              },
              &quot;creditDescription&quot;: &quot;A String&quot;, # The credit description.
              &quot;creditType&quot;: &quot;A String&quot;, # The credit type.
            },
          ],
          &quot;netCostEstimate&quot;: { # Represents an amount of money with its currency type. # The estimated net cost after applying credits.
            &quot;currencyCode&quot;: &quot;A String&quot;, # The three-letter currency code defined in ISO 4217.
            &quot;nanos&quot;: 42, # Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
            &quot;units&quot;: &quot;A String&quot;, # The whole units of the amount. For example if `currencyCode` is `&quot;USD&quot;`, then 1 unit is one US dollar.
          },
          &quot;preCreditCostEstimate&quot;: { # Represents an amount of money with its currency type. # The estimated cost prior to applying credits.
            &quot;currencyCode&quot;: &quot;A String&quot;, # The three-letter currency code defined in ISO 4217.
            &quot;nanos&quot;: 42, # Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
            &quot;units&quot;: &quot;A String&quot;, # The whole units of the amount. For example if `currencyCode` is `&quot;USD&quot;`, then 1 unit is one US dollar.
          },
        },
        &quot;workloadCostEstimates&quot;: [ # Estimated costs for each workload.
          { # Estimated cost for a workload.
            &quot;name&quot;: &quot;A String&quot;, # The name of the workload, as specified in the `CostScenario`.
            &quot;skuCostEstimates&quot;: [ # Estimated costs for each SKU in the workload.
              { # Estimated cost for usage on a SKU.
                &quot;costEstimate&quot;: { # An estimated cost. # The estimated cost for the usage on this SKU.
                  &quot;creditEstimates&quot;: [ # The estimated credits applied.
                    { # An estimated credit applied to the costs on a SKU.
                      &quot;creditAmount&quot;: { # Represents an amount of money with its currency type. # The estimated credit amount.
                        &quot;currencyCode&quot;: &quot;A String&quot;, # The three-letter currency code defined in ISO 4217.
                        &quot;nanos&quot;: 42, # Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
                        &quot;units&quot;: &quot;A String&quot;, # The whole units of the amount. For example if `currencyCode` is `&quot;USD&quot;`, then 1 unit is one US dollar.
                      },
                      &quot;creditDescription&quot;: &quot;A String&quot;, # The credit description.
                      &quot;creditType&quot;: &quot;A String&quot;, # The credit type.
                    },
                  ],
                  &quot;netCostEstimate&quot;: { # Represents an amount of money with its currency type. # The estimated net cost after applying credits.
                    &quot;currencyCode&quot;: &quot;A String&quot;, # The three-letter currency code defined in ISO 4217.
                    &quot;nanos&quot;: 42, # Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
                    &quot;units&quot;: &quot;A String&quot;, # The whole units of the amount. For example if `currencyCode` is `&quot;USD&quot;`, then 1 unit is one US dollar.
                  },
                  &quot;preCreditCostEstimate&quot;: { # Represents an amount of money with its currency type. # The estimated cost prior to applying credits.
                    &quot;currencyCode&quot;: &quot;A String&quot;, # The three-letter currency code defined in ISO 4217.
                    &quot;nanos&quot;: 42, # Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
                    &quot;units&quot;: &quot;A String&quot;, # The whole units of the amount. For example if `currencyCode` is `&quot;USD&quot;`, then 1 unit is one US dollar.
                  },
                },
                &quot;sku&quot;: &quot;A String&quot;, # The resource name for the SKU. Example: &quot;services/DA34-426B-A397/skus/AA95-CD31-42FE&quot; More information about the SKU can be found in the `skus` field of the `CostEstimationResult`.
                &quot;usageAmount&quot;: 3.14, # The amount of usage on this SKU.
                &quot;usageUnit&quot;: &quot;A String&quot;, # The unit for the usage on this SKU.
              },
            ],
            &quot;workloadTotalCostEstimate&quot;: { # An estimated cost. # Total estimated costs for the workload.
              &quot;creditEstimates&quot;: [ # The estimated credits applied.
                { # An estimated credit applied to the costs on a SKU.
                  &quot;creditAmount&quot;: { # Represents an amount of money with its currency type. # The estimated credit amount.
                    &quot;currencyCode&quot;: &quot;A String&quot;, # The three-letter currency code defined in ISO 4217.
                    &quot;nanos&quot;: 42, # Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
                    &quot;units&quot;: &quot;A String&quot;, # The whole units of the amount. For example if `currencyCode` is `&quot;USD&quot;`, then 1 unit is one US dollar.
                  },
                  &quot;creditDescription&quot;: &quot;A String&quot;, # The credit description.
                  &quot;creditType&quot;: &quot;A String&quot;, # The credit type.
                },
              ],
              &quot;netCostEstimate&quot;: { # Represents an amount of money with its currency type. # The estimated net cost after applying credits.
                &quot;currencyCode&quot;: &quot;A String&quot;, # The three-letter currency code defined in ISO 4217.
                &quot;nanos&quot;: 42, # Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
                &quot;units&quot;: &quot;A String&quot;, # The whole units of the amount. For example if `currencyCode` is `&quot;USD&quot;`, then 1 unit is one US dollar.
              },
              &quot;preCreditCostEstimate&quot;: { # Represents an amount of money with its currency type. # The estimated cost prior to applying credits.
                &quot;currencyCode&quot;: &quot;A String&quot;, # The three-letter currency code defined in ISO 4217.
                &quot;nanos&quot;: 42, # Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
                &quot;units&quot;: &quot;A String&quot;, # The whole units of the amount. For example if `currencyCode` is `&quot;USD&quot;`, then 1 unit is one US dollar.
              },
            },
          },
        ],
      },
    ],
    &quot;skus&quot;: [ # Required. Information about SKUs used in the estimate.
      { # Information about SKUs appearing in the cost estimate.
        &quot;displayName&quot;: &quot;A String&quot;, # The display name for the SKU. Example: A2 Instance Core running in Americas
        &quot;prices&quot;: [ # A timeline of prices for a SKU in chronological order. Note: The API currently only supports using a constant price for the entire estimation time frame so this list will contain a single value.
          { # The price of a SKU at a point int time.
            &quot;effectiveTime&quot;: { # Represents a point in time. # The timestamp within the estimation time frame when the price was set.
              &quot;estimationTimeFrameOffset&quot;: &quot;A String&quot;, # The point in time, relative to the start of the time frame covered by the cost estimate.
            },
            &quot;priceType&quot;: &quot;A String&quot;, # The type of price. Possible values: &quot;RATE&quot;
            &quot;rate&quot;: { # A SKU price consisting of tiered rates. # A set of tiered rates.
              &quot;tiers&quot;: [ # The service tiers.
                { # Pricing details for a service tier.
                  &quot;price&quot;: { # Represents an amount of money with its currency type. # The price for this tier.
                    &quot;currencyCode&quot;: &quot;A String&quot;, # The three-letter currency code defined in ISO 4217.
                    &quot;nanos&quot;: 42, # Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
                    &quot;units&quot;: &quot;A String&quot;, # The whole units of the amount. For example if `currencyCode` is `&quot;USD&quot;`, then 1 unit is one US dollar.
                  },
                  &quot;startAmount&quot;: 3.14, # The magnitude of usage in which the tier interval begins. Example: &quot;From 100 GiBi the price is $1 per byte&quot; implies `start_amount` = 100
                },
              ],
              &quot;unit&quot;: &quot;A String&quot;, # The SKU&#x27;s pricing unit. For example, if the tier price is $1 per 1000000 Bytes, then this field will show &#x27;By&#x27;. The `start_amount` field in each tier will be in this unit.
              &quot;unitCount&quot;: 3.14, # The SKU&#x27;s count for the pricing unit. For example, if the tier price is $1 per 1000000 Bytes, then this column will show 1000000.
            },
          },
        ],
        &quot;sku&quot;: &quot;A String&quot;, # The resource name for the SKU. Example: &quot;services/DA34-426B-A397/skus/AA95-CD31-42FE&quot;
      },
    ],
  },
}</pre>
</div>

</body></html>