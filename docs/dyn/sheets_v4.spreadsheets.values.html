<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="sheets_v4.html">Google Sheets API</a> . <a href="sheets_v4.spreadsheets.html">spreadsheets</a> . <a href="sheets_v4.spreadsheets.values.html">values</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#append">append(spreadsheetId, range, body=None, includeValuesInResponse=None, insertDataOption=None, responseDateTimeRenderOption=None, responseValueRenderOption=None, valueInputOption=None, x__xgafv=None)</a></code></p>
<p class="firstline">Appends values to a spreadsheet. The input range is used to search for existing data and find a "table" within that range. Values will be appended to the next row of the table, starting with the first column of the table. See the [guide](/sheets/api/guides/values#appending_values) and [sample code](/sheets/api/samples/writing#append_values) for specific details of how tables are detected and data is appended. The caller must specify the spreadsheet ID, range, and a valueInputOption. The `valueInputOption` only controls how the input data will be added to the sheet (column-wise or row-wise), it does not influence what cell the data starts being written to.</p>
<p class="toc_element">
  <code><a href="#batchClear">batchClear(spreadsheetId, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Clears one or more ranges of values from a spreadsheet. The caller must specify the spreadsheet ID and one or more ranges. Only values are cleared -- all other properties of the cell (such as formatting, data validation, etc..) are kept.</p>
<p class="toc_element">
  <code><a href="#batchClearByDataFilter">batchClearByDataFilter(spreadsheetId, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Clears one or more ranges of values from a spreadsheet. The caller must specify the spreadsheet ID and one or more DataFilters. Ranges matching any of the specified data filters will be cleared. Only values are cleared -- all other properties of the cell (such as formatting, data validation, etc..) are kept.</p>
<p class="toc_element">
  <code><a href="#batchGet">batchGet(spreadsheetId, dateTimeRenderOption=None, majorDimension=None, ranges=None, valueRenderOption=None, x__xgafv=None)</a></code></p>
<p class="firstline">Returns one or more ranges of values from a spreadsheet. The caller must specify the spreadsheet ID and one or more ranges.</p>
<p class="toc_element">
  <code><a href="#batchGetByDataFilter">batchGetByDataFilter(spreadsheetId, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Returns one or more ranges of values that match the specified data filters. The caller must specify the spreadsheet ID and one or more DataFilters. Ranges that match any of the data filters in the request will be returned.</p>
<p class="toc_element">
  <code><a href="#batchUpdate">batchUpdate(spreadsheetId, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Sets values in one or more ranges of a spreadsheet. The caller must specify the spreadsheet ID, a valueInputOption, and one or more ValueRanges.</p>
<p class="toc_element">
  <code><a href="#batchUpdateByDataFilter">batchUpdateByDataFilter(spreadsheetId, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Sets values in one or more ranges of a spreadsheet. The caller must specify the spreadsheet ID, a valueInputOption, and one or more DataFilterValueRanges.</p>
<p class="toc_element">
  <code><a href="#clear">clear(spreadsheetId, range, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Clears values from a spreadsheet. The caller must specify the spreadsheet ID and range. Only values are cleared -- all other properties of the cell (such as formatting, data validation, etc..) are kept.</p>
<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#get">get(spreadsheetId, range, dateTimeRenderOption=None, majorDimension=None, valueRenderOption=None, x__xgafv=None)</a></code></p>
<p class="firstline">Returns a range of values from a spreadsheet. The caller must specify the spreadsheet ID and a range.</p>
<p class="toc_element">
  <code><a href="#update">update(spreadsheetId, range, body=None, includeValuesInResponse=None, responseDateTimeRenderOption=None, responseValueRenderOption=None, valueInputOption=None, x__xgafv=None)</a></code></p>
<p class="firstline">Sets values in a range of a spreadsheet. The caller must specify the spreadsheet ID, range, and a valueInputOption.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="append">append(spreadsheetId, range, body=None, includeValuesInResponse=None, insertDataOption=None, responseDateTimeRenderOption=None, responseValueRenderOption=None, valueInputOption=None, x__xgafv=None)</code>
  <pre>Appends values to a spreadsheet. The input range is used to search for existing data and find a &quot;table&quot; within that range. Values will be appended to the next row of the table, starting with the first column of the table. See the [guide](/sheets/api/guides/values#appending_values) and [sample code](/sheets/api/samples/writing#append_values) for specific details of how tables are detected and data is appended. The caller must specify the spreadsheet ID, range, and a valueInputOption. The `valueInputOption` only controls how the input data will be added to the sheet (column-wise or row-wise), it does not influence what cell the data starts being written to.

Args:
  spreadsheetId: string, The ID of the spreadsheet to update. (required)
  range: string, The A1 notation of a range to search for a logical table of data. Values are appended after the last row of the table. (required)
  body: object, The request body.
    The object takes the form of:

{ # Data within a range of the spreadsheet.
  &quot;majorDimension&quot;: &quot;A String&quot;, # The major dimension of the values. For output, if the spreadsheet data is: `A1=1,B1=2,A2=3,B2=4`, then requesting `range=A1:B2,majorDimension=ROWS` will return `[[1,2],[3,4]]`, whereas requesting `range=A1:B2,majorDimension=COLUMNS` will return `[[1,3],[2,4]]`. For input, with `range=A1:B2,majorDimension=ROWS` then `[[1,2],[3,4]]` will set `A1=1,B1=2,A2=3,B2=4`. With `range=A1:B2,majorDimension=COLUMNS` then `[[1,2],[3,4]]` will set `A1=1,B1=3,A2=2,B2=4`. When writing, if this field is not set, it defaults to ROWS.
  &quot;range&quot;: &quot;A String&quot;, # The range the values cover, in A1 notation. For output, this range indicates the entire requested range, even though the values will exclude trailing rows and columns. When appending values, this field represents the range to search for a table, after which values will be appended.
  &quot;values&quot;: [ # The data that was read or to be written. This is an array of arrays, the outer array representing all the data and each inner array representing a major dimension. Each item in the inner array corresponds with one cell. For output, empty trailing rows and columns will not be included. For input, supported value types are: bool, string, and double. Null values will be skipped. To set a cell to an empty value, set the string value to an empty string.
    [
      &quot;&quot;,
    ],
  ],
}

  includeValuesInResponse: boolean, Determines if the update response should include the values of the cells that were appended. By default, responses do not include the updated values.
  insertDataOption: string, How the input data should be inserted.
    Allowed values
      OVERWRITE - The new data overwrites existing data in the areas it is written. (Note: adding data to the end of the sheet will still insert new rows or columns so the data can be written.)
      INSERT_ROWS - Rows are inserted for the new data.
  responseDateTimeRenderOption: string, Determines how dates, times, and durations in the response should be rendered. This is ignored if response_value_render_option is FORMATTED_VALUE. The default dateTime render option is [DateTimeRenderOption.SERIAL_NUMBER].
    Allowed values
      SERIAL_NUMBER - Instructs date, time, datetime, and duration fields to be output as doubles in &quot;serial number&quot; format, as popularized by Lotus 1-2-3. The whole number portion of the value (left of the decimal) counts the days since December 30th 1899. The fractional portion (right of the decimal) counts the time as a fraction of the day. For example, January 1st 1900 at noon would be 2.5, 2 because it&#x27;s 2 days after December 30st 1899, and .5 because noon is half a day. February 1st 1900 at 3pm would be 33.625. This correctly treats the year 1900 as not a leap year.
      FORMATTED_STRING - Instructs date, time, datetime, and duration fields to be output as strings in their given number format (which is dependent on the spreadsheet locale).
  responseValueRenderOption: string, Determines how values in the response should be rendered. The default render option is ValueRenderOption.FORMATTED_VALUE.
    Allowed values
      FORMATTED_VALUE - Values will be calculated &amp; formatted in the reply according to the cell&#x27;s formatting. Formatting is based on the spreadsheet&#x27;s locale, not the requesting user&#x27;s locale. For example, if `A1` is `1.23` and `A2` is `=A1` and formatted as currency, then `A2` would return `&quot;$1.23&quot;`.
      UNFORMATTED_VALUE - Values will be calculated, but not formatted in the reply. For example, if `A1` is `1.23` and `A2` is `=A1` and formatted as currency, then `A2` would return the number `1.23`.
      FORMULA - Values will not be calculated. The reply will include the formulas. For example, if `A1` is `1.23` and `A2` is `=A1` and formatted as currency, then A2 would return `&quot;=A1&quot;`.
  valueInputOption: string, How the input data should be interpreted.
    Allowed values
      INPUT_VALUE_OPTION_UNSPECIFIED - Default input value. This value must not be used.
      RAW - The values the user has entered will not be parsed and will be stored as-is.
      USER_ENTERED - The values will be parsed as if the user typed them into the UI. Numbers will stay as numbers, but strings may be converted to numbers, dates, etc. following the same rules that are applied when entering text into a cell via the Google Sheets UI.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The response when updating a range of values in a spreadsheet.
  &quot;spreadsheetId&quot;: &quot;A String&quot;, # The spreadsheet the updates were applied to.
  &quot;tableRange&quot;: &quot;A String&quot;, # The range (in A1 notation) of the table that values are being appended to (before the values were appended). Empty if no table was found.
  &quot;updates&quot;: { # The response when updating a range of values in a spreadsheet. # Information about the updates that were applied.
    &quot;spreadsheetId&quot;: &quot;A String&quot;, # The spreadsheet the updates were applied to.
    &quot;updatedCells&quot;: 42, # The number of cells updated.
    &quot;updatedColumns&quot;: 42, # The number of columns where at least one cell in the column was updated.
    &quot;updatedData&quot;: { # Data within a range of the spreadsheet. # The values of the cells after updates were applied. This is only included if the request&#x27;s `includeValuesInResponse` field was `true`.
      &quot;majorDimension&quot;: &quot;A String&quot;, # The major dimension of the values. For output, if the spreadsheet data is: `A1=1,B1=2,A2=3,B2=4`, then requesting `range=A1:B2,majorDimension=ROWS` will return `[[1,2],[3,4]]`, whereas requesting `range=A1:B2,majorDimension=COLUMNS` will return `[[1,3],[2,4]]`. For input, with `range=A1:B2,majorDimension=ROWS` then `[[1,2],[3,4]]` will set `A1=1,B1=2,A2=3,B2=4`. With `range=A1:B2,majorDimension=COLUMNS` then `[[1,2],[3,4]]` will set `A1=1,B1=3,A2=2,B2=4`. When writing, if this field is not set, it defaults to ROWS.
      &quot;range&quot;: &quot;A String&quot;, # The range the values cover, in A1 notation. For output, this range indicates the entire requested range, even though the values will exclude trailing rows and columns. When appending values, this field represents the range to search for a table, after which values will be appended.
      &quot;values&quot;: [ # The data that was read or to be written. This is an array of arrays, the outer array representing all the data and each inner array representing a major dimension. Each item in the inner array corresponds with one cell. For output, empty trailing rows and columns will not be included. For input, supported value types are: bool, string, and double. Null values will be skipped. To set a cell to an empty value, set the string value to an empty string.
        [
          &quot;&quot;,
        ],
      ],
    },
    &quot;updatedRange&quot;: &quot;A String&quot;, # The range (in A1 notation) that updates were applied to.
    &quot;updatedRows&quot;: 42, # The number of rows where at least one cell in the row was updated.
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="batchClear">batchClear(spreadsheetId, body=None, x__xgafv=None)</code>
  <pre>Clears one or more ranges of values from a spreadsheet. The caller must specify the spreadsheet ID and one or more ranges. Only values are cleared -- all other properties of the cell (such as formatting, data validation, etc..) are kept.

Args:
  spreadsheetId: string, The ID of the spreadsheet to update. (required)
  body: object, The request body.
    The object takes the form of:

{ # The request for clearing more than one range of values in a spreadsheet.
  &quot;ranges&quot;: [ # The ranges to clear, in A1 or R1C1 notation.
    &quot;A String&quot;,
  ],
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The response when clearing a range of values in a spreadsheet.
  &quot;clearedRanges&quot;: [ # The ranges that were cleared, in A1 notation. If the requests are for an unbounded range or a ranger larger than the bounds of the sheet, this is the actual ranges that were cleared, bounded to the sheet&#x27;s limits.
    &quot;A String&quot;,
  ],
  &quot;spreadsheetId&quot;: &quot;A String&quot;, # The spreadsheet the updates were applied to.
}</pre>
</div>

<div class="method">
    <code class="details" id="batchClearByDataFilter">batchClearByDataFilter(spreadsheetId, body=None, x__xgafv=None)</code>
  <pre>Clears one or more ranges of values from a spreadsheet. The caller must specify the spreadsheet ID and one or more DataFilters. Ranges matching any of the specified data filters will be cleared. Only values are cleared -- all other properties of the cell (such as formatting, data validation, etc..) are kept.

Args:
  spreadsheetId: string, The ID of the spreadsheet to update. (required)
  body: object, The request body.
    The object takes the form of:

{ # The request for clearing more than one range selected by a DataFilter in a spreadsheet.
  &quot;dataFilters&quot;: [ # The DataFilters used to determine which ranges to clear.
    { # Filter that describes what data should be selected or returned from a request.
      &quot;a1Range&quot;: &quot;A String&quot;, # Selects data that matches the specified A1 range.
      &quot;developerMetadataLookup&quot;: { # Selects DeveloperMetadata that matches all of the specified fields. For example, if only a metadata ID is specified this considers the DeveloperMetadata with that particular unique ID. If a metadata key is specified, this considers all developer metadata with that key. If a key, visibility, and location type are all specified, this considers all developer metadata with that key and visibility that are associated with a location of that type. In general, this selects all DeveloperMetadata that matches the intersection of all the specified fields; any field or combination of fields may be specified. # Selects data associated with the developer metadata matching the criteria described by this DeveloperMetadataLookup.
        &quot;locationMatchingStrategy&quot;: &quot;A String&quot;, # Determines how this lookup matches the location. If this field is specified as EXACT, only developer metadata associated on the exact location specified is matched. If this field is specified to INTERSECTING, developer metadata associated on intersecting locations is also matched. If left unspecified, this field assumes a default value of INTERSECTING. If this field is specified, a metadataLocation must also be specified.
        &quot;locationType&quot;: &quot;A String&quot;, # Limits the selected developer metadata to those entries which are associated with locations of the specified type. For example, when this field is specified as ROW this lookup only considers developer metadata associated on rows. If the field is left unspecified, all location types are considered. This field cannot be specified as SPREADSHEET when the locationMatchingStrategy is specified as INTERSECTING or when the metadataLocation is specified as a non-spreadsheet location: spreadsheet metadata cannot intersect any other developer metadata location. This field also must be left unspecified when the locationMatchingStrategy is specified as EXACT.
        &quot;metadataId&quot;: 42, # Limits the selected developer metadata to that which has a matching DeveloperMetadata.metadata_id.
        &quot;metadataKey&quot;: &quot;A String&quot;, # Limits the selected developer metadata to that which has a matching DeveloperMetadata.metadata_key.
        &quot;metadataLocation&quot;: { # A location where metadata may be associated in a spreadsheet. # Limits the selected developer metadata to those entries associated with the specified location. This field either matches exact locations or all intersecting locations according the specified locationMatchingStrategy.
          &quot;dimensionRange&quot;: { # A range along a single dimension on a sheet. All indexes are zero-based. Indexes are half open: the start index is inclusive and the end index is exclusive. Missing indexes indicate the range is unbounded on that side. # Represents the row or column when metadata is associated with a dimension. The specified DimensionRange must represent a single row or column; it cannot be unbounded or span multiple rows or columns.
            &quot;dimension&quot;: &quot;A String&quot;, # The dimension of the span.
            &quot;endIndex&quot;: 42, # The end (exclusive) of the span, or not set if unbounded.
            &quot;sheetId&quot;: 42, # The sheet this span is on.
            &quot;startIndex&quot;: 42, # The start (inclusive) of the span, or not set if unbounded.
          },
          &quot;locationType&quot;: &quot;A String&quot;, # The type of location this object represents. This field is read-only.
          &quot;sheetId&quot;: 42, # The ID of the sheet when metadata is associated with an entire sheet.
          &quot;spreadsheet&quot;: True or False, # True when metadata is associated with an entire spreadsheet.
        },
        &quot;metadataValue&quot;: &quot;A String&quot;, # Limits the selected developer metadata to that which has a matching DeveloperMetadata.metadata_value.
        &quot;visibility&quot;: &quot;A String&quot;, # Limits the selected developer metadata to that which has a matching DeveloperMetadata.visibility. If left unspecified, all developer metadata visibile to the requesting project is considered.
      },
      &quot;gridRange&quot;: { # A range on a sheet. All indexes are zero-based. Indexes are half open, i.e. the start index is inclusive and the end index is exclusive -- [start_index, end_index). Missing indexes indicate the range is unbounded on that side. For example, if `&quot;Sheet1&quot;` is sheet ID 0, then: `Sheet1!A1:A1 == sheet_id: 0, start_row_index: 0, end_row_index: 1, start_column_index: 0, end_column_index: 1` `Sheet1!A3:B4 == sheet_id: 0, start_row_index: 2, end_row_index: 4, start_column_index: 0, end_column_index: 2` `Sheet1!A:B == sheet_id: 0, start_column_index: 0, end_column_index: 2` `Sheet1!A5:B == sheet_id: 0, start_row_index: 4, start_column_index: 0, end_column_index: 2` `Sheet1 == sheet_id:0` The start index must always be less than or equal to the end index. If the start index equals the end index, then the range is empty. Empty ranges are typically not meaningful and are usually rendered in the UI as `#REF!`. # Selects data that matches the range described by the GridRange.
        &quot;endColumnIndex&quot;: 42, # The end column (exclusive) of the range, or not set if unbounded.
        &quot;endRowIndex&quot;: 42, # The end row (exclusive) of the range, or not set if unbounded.
        &quot;sheetId&quot;: 42, # The sheet this range is on.
        &quot;startColumnIndex&quot;: 42, # The start column (inclusive) of the range, or not set if unbounded.
        &quot;startRowIndex&quot;: 42, # The start row (inclusive) of the range, or not set if unbounded.
      },
    },
  ],
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The response when clearing a range of values selected with DataFilters in a spreadsheet.
  &quot;clearedRanges&quot;: [ # The ranges that were cleared, in A1 notation. If the requests are for an unbounded range or a ranger larger than the bounds of the sheet, this is the actual ranges that were cleared, bounded to the sheet&#x27;s limits.
    &quot;A String&quot;,
  ],
  &quot;spreadsheetId&quot;: &quot;A String&quot;, # The spreadsheet the updates were applied to.
}</pre>
</div>

<div class="method">
    <code class="details" id="batchGet">batchGet(spreadsheetId, dateTimeRenderOption=None, majorDimension=None, ranges=None, valueRenderOption=None, x__xgafv=None)</code>
  <pre>Returns one or more ranges of values from a spreadsheet. The caller must specify the spreadsheet ID and one or more ranges.

Args:
  spreadsheetId: string, The ID of the spreadsheet to retrieve data from. (required)
  dateTimeRenderOption: string, How dates, times, and durations should be represented in the output. This is ignored if value_render_option is FORMATTED_VALUE. The default dateTime render option is [DateTimeRenderOption.SERIAL_NUMBER].
    Allowed values
      SERIAL_NUMBER - Instructs date, time, datetime, and duration fields to be output as doubles in &quot;serial number&quot; format, as popularized by Lotus 1-2-3. The whole number portion of the value (left of the decimal) counts the days since December 30th 1899. The fractional portion (right of the decimal) counts the time as a fraction of the day. For example, January 1st 1900 at noon would be 2.5, 2 because it&#x27;s 2 days after December 30st 1899, and .5 because noon is half a day. February 1st 1900 at 3pm would be 33.625. This correctly treats the year 1900 as not a leap year.
      FORMATTED_STRING - Instructs date, time, datetime, and duration fields to be output as strings in their given number format (which is dependent on the spreadsheet locale).
  majorDimension: string, The major dimension that results should use. For example, if the spreadsheet data is: `A1=1,B1=2,A2=3,B2=4`, then requesting `range=A1:B2,majorDimension=ROWS` returns `[[1,2],[3,4]]`, whereas requesting `range=A1:B2,majorDimension=COLUMNS` returns `[[1,3],[2,4]]`.
    Allowed values
      DIMENSION_UNSPECIFIED - The default value, do not use.
      ROWS - Operates on the rows of a sheet.
      COLUMNS - Operates on the columns of a sheet.
  ranges: string, The A1 notation or R1C1 notation of the range to retrieve values from. (repeated)
  valueRenderOption: string, How values should be represented in the output. The default render option is ValueRenderOption.FORMATTED_VALUE.
    Allowed values
      FORMATTED_VALUE - Values will be calculated &amp; formatted in the reply according to the cell&#x27;s formatting. Formatting is based on the spreadsheet&#x27;s locale, not the requesting user&#x27;s locale. For example, if `A1` is `1.23` and `A2` is `=A1` and formatted as currency, then `A2` would return `&quot;$1.23&quot;`.
      UNFORMATTED_VALUE - Values will be calculated, but not formatted in the reply. For example, if `A1` is `1.23` and `A2` is `=A1` and formatted as currency, then `A2` would return the number `1.23`.
      FORMULA - Values will not be calculated. The reply will include the formulas. For example, if `A1` is `1.23` and `A2` is `=A1` and formatted as currency, then A2 would return `&quot;=A1&quot;`.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The response when retrieving more than one range of values in a spreadsheet.
  &quot;spreadsheetId&quot;: &quot;A String&quot;, # The ID of the spreadsheet the data was retrieved from.
  &quot;valueRanges&quot;: [ # The requested values. The order of the ValueRanges is the same as the order of the requested ranges.
    { # Data within a range of the spreadsheet.
      &quot;majorDimension&quot;: &quot;A String&quot;, # The major dimension of the values. For output, if the spreadsheet data is: `A1=1,B1=2,A2=3,B2=4`, then requesting `range=A1:B2,majorDimension=ROWS` will return `[[1,2],[3,4]]`, whereas requesting `range=A1:B2,majorDimension=COLUMNS` will return `[[1,3],[2,4]]`. For input, with `range=A1:B2,majorDimension=ROWS` then `[[1,2],[3,4]]` will set `A1=1,B1=2,A2=3,B2=4`. With `range=A1:B2,majorDimension=COLUMNS` then `[[1,2],[3,4]]` will set `A1=1,B1=3,A2=2,B2=4`. When writing, if this field is not set, it defaults to ROWS.
      &quot;range&quot;: &quot;A String&quot;, # The range the values cover, in A1 notation. For output, this range indicates the entire requested range, even though the values will exclude trailing rows and columns. When appending values, this field represents the range to search for a table, after which values will be appended.
      &quot;values&quot;: [ # The data that was read or to be written. This is an array of arrays, the outer array representing all the data and each inner array representing a major dimension. Each item in the inner array corresponds with one cell. For output, empty trailing rows and columns will not be included. For input, supported value types are: bool, string, and double. Null values will be skipped. To set a cell to an empty value, set the string value to an empty string.
        [
          &quot;&quot;,
        ],
      ],
    },
  ],
}</pre>
</div>

<div class="method">
    <code class="details" id="batchGetByDataFilter">batchGetByDataFilter(spreadsheetId, body=None, x__xgafv=None)</code>
  <pre>Returns one or more ranges of values that match the specified data filters. The caller must specify the spreadsheet ID and one or more DataFilters. Ranges that match any of the data filters in the request will be returned.

Args:
  spreadsheetId: string, The ID of the spreadsheet to retrieve data from. (required)
  body: object, The request body.
    The object takes the form of:

{ # The request for retrieving a range of values in a spreadsheet selected by a set of DataFilters.
  &quot;dataFilters&quot;: [ # The data filters used to match the ranges of values to retrieve. Ranges that match any of the specified data filters are included in the response.
    { # Filter that describes what data should be selected or returned from a request.
      &quot;a1Range&quot;: &quot;A String&quot;, # Selects data that matches the specified A1 range.
      &quot;developerMetadataLookup&quot;: { # Selects DeveloperMetadata that matches all of the specified fields. For example, if only a metadata ID is specified this considers the DeveloperMetadata with that particular unique ID. If a metadata key is specified, this considers all developer metadata with that key. If a key, visibility, and location type are all specified, this considers all developer metadata with that key and visibility that are associated with a location of that type. In general, this selects all DeveloperMetadata that matches the intersection of all the specified fields; any field or combination of fields may be specified. # Selects data associated with the developer metadata matching the criteria described by this DeveloperMetadataLookup.
        &quot;locationMatchingStrategy&quot;: &quot;A String&quot;, # Determines how this lookup matches the location. If this field is specified as EXACT, only developer metadata associated on the exact location specified is matched. If this field is specified to INTERSECTING, developer metadata associated on intersecting locations is also matched. If left unspecified, this field assumes a default value of INTERSECTING. If this field is specified, a metadataLocation must also be specified.
        &quot;locationType&quot;: &quot;A String&quot;, # Limits the selected developer metadata to those entries which are associated with locations of the specified type. For example, when this field is specified as ROW this lookup only considers developer metadata associated on rows. If the field is left unspecified, all location types are considered. This field cannot be specified as SPREADSHEET when the locationMatchingStrategy is specified as INTERSECTING or when the metadataLocation is specified as a non-spreadsheet location: spreadsheet metadata cannot intersect any other developer metadata location. This field also must be left unspecified when the locationMatchingStrategy is specified as EXACT.
        &quot;metadataId&quot;: 42, # Limits the selected developer metadata to that which has a matching DeveloperMetadata.metadata_id.
        &quot;metadataKey&quot;: &quot;A String&quot;, # Limits the selected developer metadata to that which has a matching DeveloperMetadata.metadata_key.
        &quot;metadataLocation&quot;: { # A location where metadata may be associated in a spreadsheet. # Limits the selected developer metadata to those entries associated with the specified location. This field either matches exact locations or all intersecting locations according the specified locationMatchingStrategy.
          &quot;dimensionRange&quot;: { # A range along a single dimension on a sheet. All indexes are zero-based. Indexes are half open: the start index is inclusive and the end index is exclusive. Missing indexes indicate the range is unbounded on that side. # Represents the row or column when metadata is associated with a dimension. The specified DimensionRange must represent a single row or column; it cannot be unbounded or span multiple rows or columns.
            &quot;dimension&quot;: &quot;A String&quot;, # The dimension of the span.
            &quot;endIndex&quot;: 42, # The end (exclusive) of the span, or not set if unbounded.
            &quot;sheetId&quot;: 42, # The sheet this span is on.
            &quot;startIndex&quot;: 42, # The start (inclusive) of the span, or not set if unbounded.
          },
          &quot;locationType&quot;: &quot;A String&quot;, # The type of location this object represents. This field is read-only.
          &quot;sheetId&quot;: 42, # The ID of the sheet when metadata is associated with an entire sheet.
          &quot;spreadsheet&quot;: True or False, # True when metadata is associated with an entire spreadsheet.
        },
        &quot;metadataValue&quot;: &quot;A String&quot;, # Limits the selected developer metadata to that which has a matching DeveloperMetadata.metadata_value.
        &quot;visibility&quot;: &quot;A String&quot;, # Limits the selected developer metadata to that which has a matching DeveloperMetadata.visibility. If left unspecified, all developer metadata visibile to the requesting project is considered.
      },
      &quot;gridRange&quot;: { # A range on a sheet. All indexes are zero-based. Indexes are half open, i.e. the start index is inclusive and the end index is exclusive -- [start_index, end_index). Missing indexes indicate the range is unbounded on that side. For example, if `&quot;Sheet1&quot;` is sheet ID 0, then: `Sheet1!A1:A1 == sheet_id: 0, start_row_index: 0, end_row_index: 1, start_column_index: 0, end_column_index: 1` `Sheet1!A3:B4 == sheet_id: 0, start_row_index: 2, end_row_index: 4, start_column_index: 0, end_column_index: 2` `Sheet1!A:B == sheet_id: 0, start_column_index: 0, end_column_index: 2` `Sheet1!A5:B == sheet_id: 0, start_row_index: 4, start_column_index: 0, end_column_index: 2` `Sheet1 == sheet_id:0` The start index must always be less than or equal to the end index. If the start index equals the end index, then the range is empty. Empty ranges are typically not meaningful and are usually rendered in the UI as `#REF!`. # Selects data that matches the range described by the GridRange.
        &quot;endColumnIndex&quot;: 42, # The end column (exclusive) of the range, or not set if unbounded.
        &quot;endRowIndex&quot;: 42, # The end row (exclusive) of the range, or not set if unbounded.
        &quot;sheetId&quot;: 42, # The sheet this range is on.
        &quot;startColumnIndex&quot;: 42, # The start column (inclusive) of the range, or not set if unbounded.
        &quot;startRowIndex&quot;: 42, # The start row (inclusive) of the range, or not set if unbounded.
      },
    },
  ],
  &quot;dateTimeRenderOption&quot;: &quot;A String&quot;, # How dates, times, and durations should be represented in the output. This is ignored if value_render_option is FORMATTED_VALUE. The default dateTime render option is [DateTimeRenderOption.SERIAL_NUMBER].
  &quot;majorDimension&quot;: &quot;A String&quot;, # The major dimension that results should use. For example, if the spreadsheet data is: `A1=1,B1=2,A2=3,B2=4`, then a request that selects that range and sets `majorDimension=ROWS` returns `[[1,2],[3,4]]`, whereas a request that sets `majorDimension=COLUMNS` returns `[[1,3],[2,4]]`.
  &quot;valueRenderOption&quot;: &quot;A String&quot;, # How values should be represented in the output. The default render option is ValueRenderOption.FORMATTED_VALUE.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The response when retrieving more than one range of values in a spreadsheet selected by DataFilters.
  &quot;spreadsheetId&quot;: &quot;A String&quot;, # The ID of the spreadsheet the data was retrieved from.
  &quot;valueRanges&quot;: [ # The requested values with the list of data filters that matched them.
    { # A value range that was matched by one or more data filers.
      &quot;dataFilters&quot;: [ # The DataFilters from the request that matched the range of values.
        { # Filter that describes what data should be selected or returned from a request.
          &quot;a1Range&quot;: &quot;A String&quot;, # Selects data that matches the specified A1 range.
          &quot;developerMetadataLookup&quot;: { # Selects DeveloperMetadata that matches all of the specified fields. For example, if only a metadata ID is specified this considers the DeveloperMetadata with that particular unique ID. If a metadata key is specified, this considers all developer metadata with that key. If a key, visibility, and location type are all specified, this considers all developer metadata with that key and visibility that are associated with a location of that type. In general, this selects all DeveloperMetadata that matches the intersection of all the specified fields; any field or combination of fields may be specified. # Selects data associated with the developer metadata matching the criteria described by this DeveloperMetadataLookup.
            &quot;locationMatchingStrategy&quot;: &quot;A String&quot;, # Determines how this lookup matches the location. If this field is specified as EXACT, only developer metadata associated on the exact location specified is matched. If this field is specified to INTERSECTING, developer metadata associated on intersecting locations is also matched. If left unspecified, this field assumes a default value of INTERSECTING. If this field is specified, a metadataLocation must also be specified.
            &quot;locationType&quot;: &quot;A String&quot;, # Limits the selected developer metadata to those entries which are associated with locations of the specified type. For example, when this field is specified as ROW this lookup only considers developer metadata associated on rows. If the field is left unspecified, all location types are considered. This field cannot be specified as SPREADSHEET when the locationMatchingStrategy is specified as INTERSECTING or when the metadataLocation is specified as a non-spreadsheet location: spreadsheet metadata cannot intersect any other developer metadata location. This field also must be left unspecified when the locationMatchingStrategy is specified as EXACT.
            &quot;metadataId&quot;: 42, # Limits the selected developer metadata to that which has a matching DeveloperMetadata.metadata_id.
            &quot;metadataKey&quot;: &quot;A String&quot;, # Limits the selected developer metadata to that which has a matching DeveloperMetadata.metadata_key.
            &quot;metadataLocation&quot;: { # A location where metadata may be associated in a spreadsheet. # Limits the selected developer metadata to those entries associated with the specified location. This field either matches exact locations or all intersecting locations according the specified locationMatchingStrategy.
              &quot;dimensionRange&quot;: { # A range along a single dimension on a sheet. All indexes are zero-based. Indexes are half open: the start index is inclusive and the end index is exclusive. Missing indexes indicate the range is unbounded on that side. # Represents the row or column when metadata is associated with a dimension. The specified DimensionRange must represent a single row or column; it cannot be unbounded or span multiple rows or columns.
                &quot;dimension&quot;: &quot;A String&quot;, # The dimension of the span.
                &quot;endIndex&quot;: 42, # The end (exclusive) of the span, or not set if unbounded.
                &quot;sheetId&quot;: 42, # The sheet this span is on.
                &quot;startIndex&quot;: 42, # The start (inclusive) of the span, or not set if unbounded.
              },
              &quot;locationType&quot;: &quot;A String&quot;, # The type of location this object represents. This field is read-only.
              &quot;sheetId&quot;: 42, # The ID of the sheet when metadata is associated with an entire sheet.
              &quot;spreadsheet&quot;: True or False, # True when metadata is associated with an entire spreadsheet.
            },
            &quot;metadataValue&quot;: &quot;A String&quot;, # Limits the selected developer metadata to that which has a matching DeveloperMetadata.metadata_value.
            &quot;visibility&quot;: &quot;A String&quot;, # Limits the selected developer metadata to that which has a matching DeveloperMetadata.visibility. If left unspecified, all developer metadata visibile to the requesting project is considered.
          },
          &quot;gridRange&quot;: { # A range on a sheet. All indexes are zero-based. Indexes are half open, i.e. the start index is inclusive and the end index is exclusive -- [start_index, end_index). Missing indexes indicate the range is unbounded on that side. For example, if `&quot;Sheet1&quot;` is sheet ID 0, then: `Sheet1!A1:A1 == sheet_id: 0, start_row_index: 0, end_row_index: 1, start_column_index: 0, end_column_index: 1` `Sheet1!A3:B4 == sheet_id: 0, start_row_index: 2, end_row_index: 4, start_column_index: 0, end_column_index: 2` `Sheet1!A:B == sheet_id: 0, start_column_index: 0, end_column_index: 2` `Sheet1!A5:B == sheet_id: 0, start_row_index: 4, start_column_index: 0, end_column_index: 2` `Sheet1 == sheet_id:0` The start index must always be less than or equal to the end index. If the start index equals the end index, then the range is empty. Empty ranges are typically not meaningful and are usually rendered in the UI as `#REF!`. # Selects data that matches the range described by the GridRange.
            &quot;endColumnIndex&quot;: 42, # The end column (exclusive) of the range, or not set if unbounded.
            &quot;endRowIndex&quot;: 42, # The end row (exclusive) of the range, or not set if unbounded.
            &quot;sheetId&quot;: 42, # The sheet this range is on.
            &quot;startColumnIndex&quot;: 42, # The start column (inclusive) of the range, or not set if unbounded.
            &quot;startRowIndex&quot;: 42, # The start row (inclusive) of the range, or not set if unbounded.
          },
        },
      ],
      &quot;valueRange&quot;: { # Data within a range of the spreadsheet. # The values matched by the DataFilter.
        &quot;majorDimension&quot;: &quot;A String&quot;, # The major dimension of the values. For output, if the spreadsheet data is: `A1=1,B1=2,A2=3,B2=4`, then requesting `range=A1:B2,majorDimension=ROWS` will return `[[1,2],[3,4]]`, whereas requesting `range=A1:B2,majorDimension=COLUMNS` will return `[[1,3],[2,4]]`. For input, with `range=A1:B2,majorDimension=ROWS` then `[[1,2],[3,4]]` will set `A1=1,B1=2,A2=3,B2=4`. With `range=A1:B2,majorDimension=COLUMNS` then `[[1,2],[3,4]]` will set `A1=1,B1=3,A2=2,B2=4`. When writing, if this field is not set, it defaults to ROWS.
        &quot;range&quot;: &quot;A String&quot;, # The range the values cover, in A1 notation. For output, this range indicates the entire requested range, even though the values will exclude trailing rows and columns. When appending values, this field represents the range to search for a table, after which values will be appended.
        &quot;values&quot;: [ # The data that was read or to be written. This is an array of arrays, the outer array representing all the data and each inner array representing a major dimension. Each item in the inner array corresponds with one cell. For output, empty trailing rows and columns will not be included. For input, supported value types are: bool, string, and double. Null values will be skipped. To set a cell to an empty value, set the string value to an empty string.
          [
            &quot;&quot;,
          ],
        ],
      },
    },
  ],
}</pre>
</div>

<div class="method">
    <code class="details" id="batchUpdate">batchUpdate(spreadsheetId, body=None, x__xgafv=None)</code>
  <pre>Sets values in one or more ranges of a spreadsheet. The caller must specify the spreadsheet ID, a valueInputOption, and one or more ValueRanges.

Args:
  spreadsheetId: string, The ID of the spreadsheet to update. (required)
  body: object, The request body.
    The object takes the form of:

{ # The request for updating more than one range of values in a spreadsheet.
  &quot;data&quot;: [ # The new values to apply to the spreadsheet.
    { # Data within a range of the spreadsheet.
      &quot;majorDimension&quot;: &quot;A String&quot;, # The major dimension of the values. For output, if the spreadsheet data is: `A1=1,B1=2,A2=3,B2=4`, then requesting `range=A1:B2,majorDimension=ROWS` will return `[[1,2],[3,4]]`, whereas requesting `range=A1:B2,majorDimension=COLUMNS` will return `[[1,3],[2,4]]`. For input, with `range=A1:B2,majorDimension=ROWS` then `[[1,2],[3,4]]` will set `A1=1,B1=2,A2=3,B2=4`. With `range=A1:B2,majorDimension=COLUMNS` then `[[1,2],[3,4]]` will set `A1=1,B1=3,A2=2,B2=4`. When writing, if this field is not set, it defaults to ROWS.
      &quot;range&quot;: &quot;A String&quot;, # The range the values cover, in A1 notation. For output, this range indicates the entire requested range, even though the values will exclude trailing rows and columns. When appending values, this field represents the range to search for a table, after which values will be appended.
      &quot;values&quot;: [ # The data that was read or to be written. This is an array of arrays, the outer array representing all the data and each inner array representing a major dimension. Each item in the inner array corresponds with one cell. For output, empty trailing rows and columns will not be included. For input, supported value types are: bool, string, and double. Null values will be skipped. To set a cell to an empty value, set the string value to an empty string.
        [
          &quot;&quot;,
        ],
      ],
    },
  ],
  &quot;includeValuesInResponse&quot;: True or False, # Determines if the update response should include the values of the cells that were updated. By default, responses do not include the updated values. The `updatedData` field within each of the BatchUpdateValuesResponse.responses contains the updated values. If the range to write was larger than the range actually written, the response includes all values in the requested range (excluding trailing empty rows and columns).
  &quot;responseDateTimeRenderOption&quot;: &quot;A String&quot;, # Determines how dates, times, and durations in the response should be rendered. This is ignored if response_value_render_option is FORMATTED_VALUE. The default dateTime render option is DateTimeRenderOption.SERIAL_NUMBER.
  &quot;responseValueRenderOption&quot;: &quot;A String&quot;, # Determines how values in the response should be rendered. The default render option is ValueRenderOption.FORMATTED_VALUE.
  &quot;valueInputOption&quot;: &quot;A String&quot;, # How the input data should be interpreted.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The response when updating a range of values in a spreadsheet.
  &quot;responses&quot;: [ # One UpdateValuesResponse per requested range, in the same order as the requests appeared.
    { # The response when updating a range of values in a spreadsheet.
      &quot;spreadsheetId&quot;: &quot;A String&quot;, # The spreadsheet the updates were applied to.
      &quot;updatedCells&quot;: 42, # The number of cells updated.
      &quot;updatedColumns&quot;: 42, # The number of columns where at least one cell in the column was updated.
      &quot;updatedData&quot;: { # Data within a range of the spreadsheet. # The values of the cells after updates were applied. This is only included if the request&#x27;s `includeValuesInResponse` field was `true`.
        &quot;majorDimension&quot;: &quot;A String&quot;, # The major dimension of the values. For output, if the spreadsheet data is: `A1=1,B1=2,A2=3,B2=4`, then requesting `range=A1:B2,majorDimension=ROWS` will return `[[1,2],[3,4]]`, whereas requesting `range=A1:B2,majorDimension=COLUMNS` will return `[[1,3],[2,4]]`. For input, with `range=A1:B2,majorDimension=ROWS` then `[[1,2],[3,4]]` will set `A1=1,B1=2,A2=3,B2=4`. With `range=A1:B2,majorDimension=COLUMNS` then `[[1,2],[3,4]]` will set `A1=1,B1=3,A2=2,B2=4`. When writing, if this field is not set, it defaults to ROWS.
        &quot;range&quot;: &quot;A String&quot;, # The range the values cover, in A1 notation. For output, this range indicates the entire requested range, even though the values will exclude trailing rows and columns. When appending values, this field represents the range to search for a table, after which values will be appended.
        &quot;values&quot;: [ # The data that was read or to be written. This is an array of arrays, the outer array representing all the data and each inner array representing a major dimension. Each item in the inner array corresponds with one cell. For output, empty trailing rows and columns will not be included. For input, supported value types are: bool, string, and double. Null values will be skipped. To set a cell to an empty value, set the string value to an empty string.
          [
            &quot;&quot;,
          ],
        ],
      },
      &quot;updatedRange&quot;: &quot;A String&quot;, # The range (in A1 notation) that updates were applied to.
      &quot;updatedRows&quot;: 42, # The number of rows where at least one cell in the row was updated.
    },
  ],
  &quot;spreadsheetId&quot;: &quot;A String&quot;, # The spreadsheet the updates were applied to.
  &quot;totalUpdatedCells&quot;: 42, # The total number of cells updated.
  &quot;totalUpdatedColumns&quot;: 42, # The total number of columns where at least one cell in the column was updated.
  &quot;totalUpdatedRows&quot;: 42, # The total number of rows where at least one cell in the row was updated.
  &quot;totalUpdatedSheets&quot;: 42, # The total number of sheets where at least one cell in the sheet was updated.
}</pre>
</div>

<div class="method">
    <code class="details" id="batchUpdateByDataFilter">batchUpdateByDataFilter(spreadsheetId, body=None, x__xgafv=None)</code>
  <pre>Sets values in one or more ranges of a spreadsheet. The caller must specify the spreadsheet ID, a valueInputOption, and one or more DataFilterValueRanges.

Args:
  spreadsheetId: string, The ID of the spreadsheet to update. (required)
  body: object, The request body.
    The object takes the form of:

{ # The request for updating more than one range of values in a spreadsheet.
  &quot;data&quot;: [ # The new values to apply to the spreadsheet. If more than one range is matched by the specified DataFilter the specified values are applied to all of those ranges.
    { # A range of values whose location is specified by a DataFilter.
      &quot;dataFilter&quot;: { # Filter that describes what data should be selected or returned from a request. # The data filter describing the location of the values in the spreadsheet.
        &quot;a1Range&quot;: &quot;A String&quot;, # Selects data that matches the specified A1 range.
        &quot;developerMetadataLookup&quot;: { # Selects DeveloperMetadata that matches all of the specified fields. For example, if only a metadata ID is specified this considers the DeveloperMetadata with that particular unique ID. If a metadata key is specified, this considers all developer metadata with that key. If a key, visibility, and location type are all specified, this considers all developer metadata with that key and visibility that are associated with a location of that type. In general, this selects all DeveloperMetadata that matches the intersection of all the specified fields; any field or combination of fields may be specified. # Selects data associated with the developer metadata matching the criteria described by this DeveloperMetadataLookup.
          &quot;locationMatchingStrategy&quot;: &quot;A String&quot;, # Determines how this lookup matches the location. If this field is specified as EXACT, only developer metadata associated on the exact location specified is matched. If this field is specified to INTERSECTING, developer metadata associated on intersecting locations is also matched. If left unspecified, this field assumes a default value of INTERSECTING. If this field is specified, a metadataLocation must also be specified.
          &quot;locationType&quot;: &quot;A String&quot;, # Limits the selected developer metadata to those entries which are associated with locations of the specified type. For example, when this field is specified as ROW this lookup only considers developer metadata associated on rows. If the field is left unspecified, all location types are considered. This field cannot be specified as SPREADSHEET when the locationMatchingStrategy is specified as INTERSECTING or when the metadataLocation is specified as a non-spreadsheet location: spreadsheet metadata cannot intersect any other developer metadata location. This field also must be left unspecified when the locationMatchingStrategy is specified as EXACT.
          &quot;metadataId&quot;: 42, # Limits the selected developer metadata to that which has a matching DeveloperMetadata.metadata_id.
          &quot;metadataKey&quot;: &quot;A String&quot;, # Limits the selected developer metadata to that which has a matching DeveloperMetadata.metadata_key.
          &quot;metadataLocation&quot;: { # A location where metadata may be associated in a spreadsheet. # Limits the selected developer metadata to those entries associated with the specified location. This field either matches exact locations or all intersecting locations according the specified locationMatchingStrategy.
            &quot;dimensionRange&quot;: { # A range along a single dimension on a sheet. All indexes are zero-based. Indexes are half open: the start index is inclusive and the end index is exclusive. Missing indexes indicate the range is unbounded on that side. # Represents the row or column when metadata is associated with a dimension. The specified DimensionRange must represent a single row or column; it cannot be unbounded or span multiple rows or columns.
              &quot;dimension&quot;: &quot;A String&quot;, # The dimension of the span.
              &quot;endIndex&quot;: 42, # The end (exclusive) of the span, or not set if unbounded.
              &quot;sheetId&quot;: 42, # The sheet this span is on.
              &quot;startIndex&quot;: 42, # The start (inclusive) of the span, or not set if unbounded.
            },
            &quot;locationType&quot;: &quot;A String&quot;, # The type of location this object represents. This field is read-only.
            &quot;sheetId&quot;: 42, # The ID of the sheet when metadata is associated with an entire sheet.
            &quot;spreadsheet&quot;: True or False, # True when metadata is associated with an entire spreadsheet.
          },
          &quot;metadataValue&quot;: &quot;A String&quot;, # Limits the selected developer metadata to that which has a matching DeveloperMetadata.metadata_value.
          &quot;visibility&quot;: &quot;A String&quot;, # Limits the selected developer metadata to that which has a matching DeveloperMetadata.visibility. If left unspecified, all developer metadata visibile to the requesting project is considered.
        },
        &quot;gridRange&quot;: { # A range on a sheet. All indexes are zero-based. Indexes are half open, i.e. the start index is inclusive and the end index is exclusive -- [start_index, end_index). Missing indexes indicate the range is unbounded on that side. For example, if `&quot;Sheet1&quot;` is sheet ID 0, then: `Sheet1!A1:A1 == sheet_id: 0, start_row_index: 0, end_row_index: 1, start_column_index: 0, end_column_index: 1` `Sheet1!A3:B4 == sheet_id: 0, start_row_index: 2, end_row_index: 4, start_column_index: 0, end_column_index: 2` `Sheet1!A:B == sheet_id: 0, start_column_index: 0, end_column_index: 2` `Sheet1!A5:B == sheet_id: 0, start_row_index: 4, start_column_index: 0, end_column_index: 2` `Sheet1 == sheet_id:0` The start index must always be less than or equal to the end index. If the start index equals the end index, then the range is empty. Empty ranges are typically not meaningful and are usually rendered in the UI as `#REF!`. # Selects data that matches the range described by the GridRange.
          &quot;endColumnIndex&quot;: 42, # The end column (exclusive) of the range, or not set if unbounded.
          &quot;endRowIndex&quot;: 42, # The end row (exclusive) of the range, or not set if unbounded.
          &quot;sheetId&quot;: 42, # The sheet this range is on.
          &quot;startColumnIndex&quot;: 42, # The start column (inclusive) of the range, or not set if unbounded.
          &quot;startRowIndex&quot;: 42, # The start row (inclusive) of the range, or not set if unbounded.
        },
      },
      &quot;majorDimension&quot;: &quot;A String&quot;, # The major dimension of the values.
      &quot;values&quot;: [ # The data to be written. If the provided values exceed any of the ranges matched by the data filter then the request fails. If the provided values are less than the matched ranges only the specified values are written, existing values in the matched ranges remain unaffected.
        [
          &quot;&quot;,
        ],
      ],
    },
  ],
  &quot;includeValuesInResponse&quot;: True or False, # Determines if the update response should include the values of the cells that were updated. By default, responses do not include the updated values. The `updatedData` field within each of the BatchUpdateValuesResponse.responses contains the updated values. If the range to write was larger than the range actually written, the response includes all values in the requested range (excluding trailing empty rows and columns).
  &quot;responseDateTimeRenderOption&quot;: &quot;A String&quot;, # Determines how dates, times, and durations in the response should be rendered. This is ignored if response_value_render_option is FORMATTED_VALUE. The default dateTime render option is DateTimeRenderOption.SERIAL_NUMBER.
  &quot;responseValueRenderOption&quot;: &quot;A String&quot;, # Determines how values in the response should be rendered. The default render option is ValueRenderOption.FORMATTED_VALUE.
  &quot;valueInputOption&quot;: &quot;A String&quot;, # How the input data should be interpreted.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The response when updating a range of values in a spreadsheet.
  &quot;responses&quot;: [ # The response for each range updated.
    { # The response when updating a range of values by a data filter in a spreadsheet.
      &quot;dataFilter&quot;: { # Filter that describes what data should be selected or returned from a request. # The data filter that selected the range that was updated.
        &quot;a1Range&quot;: &quot;A String&quot;, # Selects data that matches the specified A1 range.
        &quot;developerMetadataLookup&quot;: { # Selects DeveloperMetadata that matches all of the specified fields. For example, if only a metadata ID is specified this considers the DeveloperMetadata with that particular unique ID. If a metadata key is specified, this considers all developer metadata with that key. If a key, visibility, and location type are all specified, this considers all developer metadata with that key and visibility that are associated with a location of that type. In general, this selects all DeveloperMetadata that matches the intersection of all the specified fields; any field or combination of fields may be specified. # Selects data associated with the developer metadata matching the criteria described by this DeveloperMetadataLookup.
          &quot;locationMatchingStrategy&quot;: &quot;A String&quot;, # Determines how this lookup matches the location. If this field is specified as EXACT, only developer metadata associated on the exact location specified is matched. If this field is specified to INTERSECTING, developer metadata associated on intersecting locations is also matched. If left unspecified, this field assumes a default value of INTERSECTING. If this field is specified, a metadataLocation must also be specified.
          &quot;locationType&quot;: &quot;A String&quot;, # Limits the selected developer metadata to those entries which are associated with locations of the specified type. For example, when this field is specified as ROW this lookup only considers developer metadata associated on rows. If the field is left unspecified, all location types are considered. This field cannot be specified as SPREADSHEET when the locationMatchingStrategy is specified as INTERSECTING or when the metadataLocation is specified as a non-spreadsheet location: spreadsheet metadata cannot intersect any other developer metadata location. This field also must be left unspecified when the locationMatchingStrategy is specified as EXACT.
          &quot;metadataId&quot;: 42, # Limits the selected developer metadata to that which has a matching DeveloperMetadata.metadata_id.
          &quot;metadataKey&quot;: &quot;A String&quot;, # Limits the selected developer metadata to that which has a matching DeveloperMetadata.metadata_key.
          &quot;metadataLocation&quot;: { # A location where metadata may be associated in a spreadsheet. # Limits the selected developer metadata to those entries associated with the specified location. This field either matches exact locations or all intersecting locations according the specified locationMatchingStrategy.
            &quot;dimensionRange&quot;: { # A range along a single dimension on a sheet. All indexes are zero-based. Indexes are half open: the start index is inclusive and the end index is exclusive. Missing indexes indicate the range is unbounded on that side. # Represents the row or column when metadata is associated with a dimension. The specified DimensionRange must represent a single row or column; it cannot be unbounded or span multiple rows or columns.
              &quot;dimension&quot;: &quot;A String&quot;, # The dimension of the span.
              &quot;endIndex&quot;: 42, # The end (exclusive) of the span, or not set if unbounded.
              &quot;sheetId&quot;: 42, # The sheet this span is on.
              &quot;startIndex&quot;: 42, # The start (inclusive) of the span, or not set if unbounded.
            },
            &quot;locationType&quot;: &quot;A String&quot;, # The type of location this object represents. This field is read-only.
            &quot;sheetId&quot;: 42, # The ID of the sheet when metadata is associated with an entire sheet.
            &quot;spreadsheet&quot;: True or False, # True when metadata is associated with an entire spreadsheet.
          },
          &quot;metadataValue&quot;: &quot;A String&quot;, # Limits the selected developer metadata to that which has a matching DeveloperMetadata.metadata_value.
          &quot;visibility&quot;: &quot;A String&quot;, # Limits the selected developer metadata to that which has a matching DeveloperMetadata.visibility. If left unspecified, all developer metadata visibile to the requesting project is considered.
        },
        &quot;gridRange&quot;: { # A range on a sheet. All indexes are zero-based. Indexes are half open, i.e. the start index is inclusive and the end index is exclusive -- [start_index, end_index). Missing indexes indicate the range is unbounded on that side. For example, if `&quot;Sheet1&quot;` is sheet ID 0, then: `Sheet1!A1:A1 == sheet_id: 0, start_row_index: 0, end_row_index: 1, start_column_index: 0, end_column_index: 1` `Sheet1!A3:B4 == sheet_id: 0, start_row_index: 2, end_row_index: 4, start_column_index: 0, end_column_index: 2` `Sheet1!A:B == sheet_id: 0, start_column_index: 0, end_column_index: 2` `Sheet1!A5:B == sheet_id: 0, start_row_index: 4, start_column_index: 0, end_column_index: 2` `Sheet1 == sheet_id:0` The start index must always be less than or equal to the end index. If the start index equals the end index, then the range is empty. Empty ranges are typically not meaningful and are usually rendered in the UI as `#REF!`. # Selects data that matches the range described by the GridRange.
          &quot;endColumnIndex&quot;: 42, # The end column (exclusive) of the range, or not set if unbounded.
          &quot;endRowIndex&quot;: 42, # The end row (exclusive) of the range, or not set if unbounded.
          &quot;sheetId&quot;: 42, # The sheet this range is on.
          &quot;startColumnIndex&quot;: 42, # The start column (inclusive) of the range, or not set if unbounded.
          &quot;startRowIndex&quot;: 42, # The start row (inclusive) of the range, or not set if unbounded.
        },
      },
      &quot;updatedCells&quot;: 42, # The number of cells updated.
      &quot;updatedColumns&quot;: 42, # The number of columns where at least one cell in the column was updated.
      &quot;updatedData&quot;: { # Data within a range of the spreadsheet. # The values of the cells in the range matched by the dataFilter after all updates were applied. This is only included if the request&#x27;s `includeValuesInResponse` field was `true`.
        &quot;majorDimension&quot;: &quot;A String&quot;, # The major dimension of the values. For output, if the spreadsheet data is: `A1=1,B1=2,A2=3,B2=4`, then requesting `range=A1:B2,majorDimension=ROWS` will return `[[1,2],[3,4]]`, whereas requesting `range=A1:B2,majorDimension=COLUMNS` will return `[[1,3],[2,4]]`. For input, with `range=A1:B2,majorDimension=ROWS` then `[[1,2],[3,4]]` will set `A1=1,B1=2,A2=3,B2=4`. With `range=A1:B2,majorDimension=COLUMNS` then `[[1,2],[3,4]]` will set `A1=1,B1=3,A2=2,B2=4`. When writing, if this field is not set, it defaults to ROWS.
        &quot;range&quot;: &quot;A String&quot;, # The range the values cover, in A1 notation. For output, this range indicates the entire requested range, even though the values will exclude trailing rows and columns. When appending values, this field represents the range to search for a table, after which values will be appended.
        &quot;values&quot;: [ # The data that was read or to be written. This is an array of arrays, the outer array representing all the data and each inner array representing a major dimension. Each item in the inner array corresponds with one cell. For output, empty trailing rows and columns will not be included. For input, supported value types are: bool, string, and double. Null values will be skipped. To set a cell to an empty value, set the string value to an empty string.
          [
            &quot;&quot;,
          ],
        ],
      },
      &quot;updatedRange&quot;: &quot;A String&quot;, # The range (in A1 notation) that updates were applied to.
      &quot;updatedRows&quot;: 42, # The number of rows where at least one cell in the row was updated.
    },
  ],
  &quot;spreadsheetId&quot;: &quot;A String&quot;, # The spreadsheet the updates were applied to.
  &quot;totalUpdatedCells&quot;: 42, # The total number of cells updated.
  &quot;totalUpdatedColumns&quot;: 42, # The total number of columns where at least one cell in the column was updated.
  &quot;totalUpdatedRows&quot;: 42, # The total number of rows where at least one cell in the row was updated.
  &quot;totalUpdatedSheets&quot;: 42, # The total number of sheets where at least one cell in the sheet was updated.
}</pre>
</div>

<div class="method">
    <code class="details" id="clear">clear(spreadsheetId, range, body=None, x__xgafv=None)</code>
  <pre>Clears values from a spreadsheet. The caller must specify the spreadsheet ID and range. Only values are cleared -- all other properties of the cell (such as formatting, data validation, etc..) are kept.

Args:
  spreadsheetId: string, The ID of the spreadsheet to update. (required)
  range: string, The A1 notation or R1C1 notation of the values to clear. (required)
  body: object, The request body.
    The object takes the form of:

{ # The request for clearing a range of values in a spreadsheet.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The response when clearing a range of values in a spreadsheet.
  &quot;clearedRange&quot;: &quot;A String&quot;, # The range (in A1 notation) that was cleared. (If the request was for an unbounded range or a ranger larger than the bounds of the sheet, this will be the actual range that was cleared, bounded to the sheet&#x27;s limits.)
  &quot;spreadsheetId&quot;: &quot;A String&quot;, # The spreadsheet the updates were applied to.
}</pre>
</div>

<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="get">get(spreadsheetId, range, dateTimeRenderOption=None, majorDimension=None, valueRenderOption=None, x__xgafv=None)</code>
  <pre>Returns a range of values from a spreadsheet. The caller must specify the spreadsheet ID and a range.

Args:
  spreadsheetId: string, The ID of the spreadsheet to retrieve data from. (required)
  range: string, The A1 notation or R1C1 notation of the range to retrieve values from. (required)
  dateTimeRenderOption: string, How dates, times, and durations should be represented in the output. This is ignored if value_render_option is FORMATTED_VALUE. The default dateTime render option is [DateTimeRenderOption.SERIAL_NUMBER].
    Allowed values
      SERIAL_NUMBER - Instructs date, time, datetime, and duration fields to be output as doubles in &quot;serial number&quot; format, as popularized by Lotus 1-2-3. The whole number portion of the value (left of the decimal) counts the days since December 30th 1899. The fractional portion (right of the decimal) counts the time as a fraction of the day. For example, January 1st 1900 at noon would be 2.5, 2 because it&#x27;s 2 days after December 30st 1899, and .5 because noon is half a day. February 1st 1900 at 3pm would be 33.625. This correctly treats the year 1900 as not a leap year.
      FORMATTED_STRING - Instructs date, time, datetime, and duration fields to be output as strings in their given number format (which is dependent on the spreadsheet locale).
  majorDimension: string, The major dimension that results should use. For example, if the spreadsheet data is: `A1=1,B1=2,A2=3,B2=4`, then requesting `range=A1:B2,majorDimension=ROWS` returns `[[1,2],[3,4]]`, whereas requesting `range=A1:B2,majorDimension=COLUMNS` returns `[[1,3],[2,4]]`.
    Allowed values
      DIMENSION_UNSPECIFIED - The default value, do not use.
      ROWS - Operates on the rows of a sheet.
      COLUMNS - Operates on the columns of a sheet.
  valueRenderOption: string, How values should be represented in the output. The default render option is ValueRenderOption.FORMATTED_VALUE.
    Allowed values
      FORMATTED_VALUE - Values will be calculated &amp; formatted in the reply according to the cell&#x27;s formatting. Formatting is based on the spreadsheet&#x27;s locale, not the requesting user&#x27;s locale. For example, if `A1` is `1.23` and `A2` is `=A1` and formatted as currency, then `A2` would return `&quot;$1.23&quot;`.
      UNFORMATTED_VALUE - Values will be calculated, but not formatted in the reply. For example, if `A1` is `1.23` and `A2` is `=A1` and formatted as currency, then `A2` would return the number `1.23`.
      FORMULA - Values will not be calculated. The reply will include the formulas. For example, if `A1` is `1.23` and `A2` is `=A1` and formatted as currency, then A2 would return `&quot;=A1&quot;`.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Data within a range of the spreadsheet.
  &quot;majorDimension&quot;: &quot;A String&quot;, # The major dimension of the values. For output, if the spreadsheet data is: `A1=1,B1=2,A2=3,B2=4`, then requesting `range=A1:B2,majorDimension=ROWS` will return `[[1,2],[3,4]]`, whereas requesting `range=A1:B2,majorDimension=COLUMNS` will return `[[1,3],[2,4]]`. For input, with `range=A1:B2,majorDimension=ROWS` then `[[1,2],[3,4]]` will set `A1=1,B1=2,A2=3,B2=4`. With `range=A1:B2,majorDimension=COLUMNS` then `[[1,2],[3,4]]` will set `A1=1,B1=3,A2=2,B2=4`. When writing, if this field is not set, it defaults to ROWS.
  &quot;range&quot;: &quot;A String&quot;, # The range the values cover, in A1 notation. For output, this range indicates the entire requested range, even though the values will exclude trailing rows and columns. When appending values, this field represents the range to search for a table, after which values will be appended.
  &quot;values&quot;: [ # The data that was read or to be written. This is an array of arrays, the outer array representing all the data and each inner array representing a major dimension. Each item in the inner array corresponds with one cell. For output, empty trailing rows and columns will not be included. For input, supported value types are: bool, string, and double. Null values will be skipped. To set a cell to an empty value, set the string value to an empty string.
    [
      &quot;&quot;,
    ],
  ],
}</pre>
</div>

<div class="method">
    <code class="details" id="update">update(spreadsheetId, range, body=None, includeValuesInResponse=None, responseDateTimeRenderOption=None, responseValueRenderOption=None, valueInputOption=None, x__xgafv=None)</code>
  <pre>Sets values in a range of a spreadsheet. The caller must specify the spreadsheet ID, range, and a valueInputOption.

Args:
  spreadsheetId: string, The ID of the spreadsheet to update. (required)
  range: string, The A1 notation of the values to update. (required)
  body: object, The request body.
    The object takes the form of:

{ # Data within a range of the spreadsheet.
  &quot;majorDimension&quot;: &quot;A String&quot;, # The major dimension of the values. For output, if the spreadsheet data is: `A1=1,B1=2,A2=3,B2=4`, then requesting `range=A1:B2,majorDimension=ROWS` will return `[[1,2],[3,4]]`, whereas requesting `range=A1:B2,majorDimension=COLUMNS` will return `[[1,3],[2,4]]`. For input, with `range=A1:B2,majorDimension=ROWS` then `[[1,2],[3,4]]` will set `A1=1,B1=2,A2=3,B2=4`. With `range=A1:B2,majorDimension=COLUMNS` then `[[1,2],[3,4]]` will set `A1=1,B1=3,A2=2,B2=4`. When writing, if this field is not set, it defaults to ROWS.
  &quot;range&quot;: &quot;A String&quot;, # The range the values cover, in A1 notation. For output, this range indicates the entire requested range, even though the values will exclude trailing rows and columns. When appending values, this field represents the range to search for a table, after which values will be appended.
  &quot;values&quot;: [ # The data that was read or to be written. This is an array of arrays, the outer array representing all the data and each inner array representing a major dimension. Each item in the inner array corresponds with one cell. For output, empty trailing rows and columns will not be included. For input, supported value types are: bool, string, and double. Null values will be skipped. To set a cell to an empty value, set the string value to an empty string.
    [
      &quot;&quot;,
    ],
  ],
}

  includeValuesInResponse: boolean, Determines if the update response should include the values of the cells that were updated. By default, responses do not include the updated values. If the range to write was larger than the range actually written, the response includes all values in the requested range (excluding trailing empty rows and columns).
  responseDateTimeRenderOption: string, Determines how dates, times, and durations in the response should be rendered. This is ignored if response_value_render_option is FORMATTED_VALUE. The default dateTime render option is DateTimeRenderOption.SERIAL_NUMBER.
    Allowed values
      SERIAL_NUMBER - Instructs date, time, datetime, and duration fields to be output as doubles in &quot;serial number&quot; format, as popularized by Lotus 1-2-3. The whole number portion of the value (left of the decimal) counts the days since December 30th 1899. The fractional portion (right of the decimal) counts the time as a fraction of the day. For example, January 1st 1900 at noon would be 2.5, 2 because it&#x27;s 2 days after December 30st 1899, and .5 because noon is half a day. February 1st 1900 at 3pm would be 33.625. This correctly treats the year 1900 as not a leap year.
      FORMATTED_STRING - Instructs date, time, datetime, and duration fields to be output as strings in their given number format (which is dependent on the spreadsheet locale).
  responseValueRenderOption: string, Determines how values in the response should be rendered. The default render option is ValueRenderOption.FORMATTED_VALUE.
    Allowed values
      FORMATTED_VALUE - Values will be calculated &amp; formatted in the reply according to the cell&#x27;s formatting. Formatting is based on the spreadsheet&#x27;s locale, not the requesting user&#x27;s locale. For example, if `A1` is `1.23` and `A2` is `=A1` and formatted as currency, then `A2` would return `&quot;$1.23&quot;`.
      UNFORMATTED_VALUE - Values will be calculated, but not formatted in the reply. For example, if `A1` is `1.23` and `A2` is `=A1` and formatted as currency, then `A2` would return the number `1.23`.
      FORMULA - Values will not be calculated. The reply will include the formulas. For example, if `A1` is `1.23` and `A2` is `=A1` and formatted as currency, then A2 would return `&quot;=A1&quot;`.
  valueInputOption: string, How the input data should be interpreted.
    Allowed values
      INPUT_VALUE_OPTION_UNSPECIFIED - Default input value. This value must not be used.
      RAW - The values the user has entered will not be parsed and will be stored as-is.
      USER_ENTERED - The values will be parsed as if the user typed them into the UI. Numbers will stay as numbers, but strings may be converted to numbers, dates, etc. following the same rules that are applied when entering text into a cell via the Google Sheets UI.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The response when updating a range of values in a spreadsheet.
  &quot;spreadsheetId&quot;: &quot;A String&quot;, # The spreadsheet the updates were applied to.
  &quot;updatedCells&quot;: 42, # The number of cells updated.
  &quot;updatedColumns&quot;: 42, # The number of columns where at least one cell in the column was updated.
  &quot;updatedData&quot;: { # Data within a range of the spreadsheet. # The values of the cells after updates were applied. This is only included if the request&#x27;s `includeValuesInResponse` field was `true`.
    &quot;majorDimension&quot;: &quot;A String&quot;, # The major dimension of the values. For output, if the spreadsheet data is: `A1=1,B1=2,A2=3,B2=4`, then requesting `range=A1:B2,majorDimension=ROWS` will return `[[1,2],[3,4]]`, whereas requesting `range=A1:B2,majorDimension=COLUMNS` will return `[[1,3],[2,4]]`. For input, with `range=A1:B2,majorDimension=ROWS` then `[[1,2],[3,4]]` will set `A1=1,B1=2,A2=3,B2=4`. With `range=A1:B2,majorDimension=COLUMNS` then `[[1,2],[3,4]]` will set `A1=1,B1=3,A2=2,B2=4`. When writing, if this field is not set, it defaults to ROWS.
    &quot;range&quot;: &quot;A String&quot;, # The range the values cover, in A1 notation. For output, this range indicates the entire requested range, even though the values will exclude trailing rows and columns. When appending values, this field represents the range to search for a table, after which values will be appended.
    &quot;values&quot;: [ # The data that was read or to be written. This is an array of arrays, the outer array representing all the data and each inner array representing a major dimension. Each item in the inner array corresponds with one cell. For output, empty trailing rows and columns will not be included. For input, supported value types are: bool, string, and double. Null values will be skipped. To set a cell to an empty value, set the string value to an empty string.
      [
        &quot;&quot;,
      ],
    ],
  },
  &quot;updatedRange&quot;: &quot;A String&quot;, # The range (in A1 notation) that updates were applied to.
  &quot;updatedRows&quot;: 42, # The number of rows where at least one cell in the row was updated.
}</pre>
</div>

</body></html>