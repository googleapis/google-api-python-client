<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="bigquery_v2.html">BigQuery API</a> . <a href="bigquery_v2.routines.html">routines</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#delete">delete(projectId, datasetId, routineId)</a></code></p>
<p class="firstline">Deletes the routine specified by routineId from the dataset.</p>
<p class="toc_element">
  <code><a href="#get">get(projectId, datasetId, routineId, readMask=None)</a></code></p>
<p class="firstline">Gets the specified routine resource by routine ID.</p>
<p class="toc_element">
  <code><a href="#insert">insert(projectId, datasetId, body=None)</a></code></p>
<p class="firstline">Creates a new routine in the dataset.</p>
<p class="toc_element">
  <code><a href="#list">list(projectId, datasetId, filter=None, maxResults=None, pageToken=None, readMask=None)</a></code></p>
<p class="firstline">Lists all routines in the specified dataset. Requires the READER dataset role.</p>
<p class="toc_element">
  <code><a href="#list_next">list_next(previous_request, previous_response)</a></code></p>
<p class="firstline">Retrieves the next page of results.</p>
<p class="toc_element">
  <code><a href="#update">update(projectId, datasetId, routineId, body=None)</a></code></p>
<p class="firstline">Updates information in an existing routine. The update method replaces the entire Routine resource.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="delete">delete(projectId, datasetId, routineId)</code>
  <pre>Deletes the routine specified by routineId from the dataset.

Args:
  projectId: string, Required. Project ID of the routine to delete (required)
  datasetId: string, Required. Dataset ID of the routine to delete (required)
  routineId: string, Required. Routine ID of the routine to delete (required)
</pre>
</div>

<div class="method">
    <code class="details" id="get">get(projectId, datasetId, routineId, readMask=None)</code>
  <pre>Gets the specified routine resource by routine ID.

Args:
  projectId: string, Required. Project ID of the requested routine (required)
  datasetId: string, Required. Dataset ID of the requested routine (required)
  routineId: string, Required. Routine ID of the requested routine (required)
  readMask: string, If set, only the Routine fields in the field mask are returned in the response. If unset, all Routine fields are returned.

Returns:
  An object of the form:

    { # A user-defined function or a stored procedure.
  &quot;arguments&quot;: [ # Optional.
    { # Input/output argument of a function or a stored procedure.
      &quot;argumentKind&quot;: &quot;A String&quot;, # Optional. Defaults to FIXED_TYPE.
      &quot;dataType&quot;: { # The type of a variable, e.g., a function argument. Examples: INT64: {type_kind=&quot;INT64&quot;} ARRAY: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;} STRUCT&gt;: {type_kind=&quot;STRUCT&quot;, struct_type={fields=[ {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}}, {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}} ]}} # Required unless argument_kind = ANY_TYPE.
        &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
        &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
          &quot;fields&quot;: [
            # Object with schema name: StandardSqlField
          ],
        },
        &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field. Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
      },
      &quot;mode&quot;: &quot;A String&quot;, # Optional. Specifies whether the argument is input or output. Can be set for procedures only.
      &quot;name&quot;: &quot;A String&quot;, # Optional. The name of this argument. Can be absent for function return argument.
    },
  ],
  &quot;creationTime&quot;: &quot;A String&quot;, # Output only. The time when this routine was created, in milliseconds since the epoch.
  &quot;definitionBody&quot;: &quot;A String&quot;, # Required. The body of the routine. For functions, this is the expression in the AS clause. If language=SQL, it is the substring inside (but excluding) the parentheses. For example, for the function created with the following statement: `CREATE FUNCTION JoinLines(x string, y string) as (concat(x, &quot;\n&quot;, y))` The definition_body is `concat(x, &quot;\n&quot;, y)` (\n is not replaced with linebreak). If language=JAVASCRIPT, it is the evaluated string in the AS clause. For example, for the function created with the following statement: `CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS &#x27;return &quot;\n&quot;;\n&#x27;` The definition_body is `return &quot;\n&quot;;\n` Note that both \n are replaced with linebreaks.
  &quot;description&quot;: &quot;A String&quot;, # Optional. [Experimental] The description of the routine if defined.
  &quot;determinismLevel&quot;: &quot;A String&quot;, # Optional. [Experimental] The determinism level of the JavaScript UDF if defined.
  &quot;etag&quot;: &quot;A String&quot;, # Output only. A hash of this resource.
  &quot;importedLibraries&quot;: [ # Optional. If language = &quot;JAVASCRIPT&quot;, this field stores the path of the imported JAVASCRIPT libraries.
    &quot;A String&quot;,
  ],
  &quot;language&quot;: &quot;A String&quot;, # Optional. Defaults to &quot;SQL&quot;.
  &quot;lastModifiedTime&quot;: &quot;A String&quot;, # Output only. The time when this routine was last modified, in milliseconds since the epoch.
  &quot;returnTableType&quot;: { # A table type # Optional. Set only if Routine is a &quot;TABLE_VALUED_FUNCTION&quot;.
    &quot;columns&quot;: [ # The columns in this table type
      { # A field or a column.
        &quot;name&quot;: &quot;A String&quot;, # Optional. The name of this field. Can be absent for struct fields.
        &quot;type&quot;: { # The type of a variable, e.g., a function argument. Examples: INT64: {type_kind=&quot;INT64&quot;} ARRAY: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;} STRUCT&gt;: {type_kind=&quot;STRUCT&quot;, struct_type={fields=[ {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}}, {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}} ]}} # Optional. The type of this parameter. Absent if not explicitly specified (e.g., CREATE FUNCTION statement can omit the return type; in this case the output parameter does not have this &quot;type&quot; field).
          &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
          &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
            &quot;fields&quot;: [
              # Object with schema name: StandardSqlField
            ],
          },
          &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field. Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
        },
      },
    ],
  },
  &quot;returnType&quot;: { # The type of a variable, e.g., a function argument. Examples: INT64: {type_kind=&quot;INT64&quot;} ARRAY: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;} STRUCT&gt;: {type_kind=&quot;STRUCT&quot;, struct_type={fields=[ {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}}, {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}} ]}} # Optional if language = &quot;SQL&quot;; required otherwise. If absent, the return type is inferred from definition_body at query time in each query that references this routine. If present, then the evaluated result will be cast to the specified returned type at query time. For example, for the functions created with the following statements: * `CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);` * `CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));` * `CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));` The return_type is `{type_kind: &quot;FLOAT64&quot;}` for `Add` and `Decrement`, and is absent for `Increment` (inferred as FLOAT64 at query time). Suppose the function `Add` is replaced by `CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);` Then the inferred return type of `Increment` is automatically changed to INT64 at query time, while the return type of `Decrement` remains FLOAT64.
    &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
    &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
      &quot;fields&quot;: [
        # Object with schema name: StandardSqlField
      ],
    },
    &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field. Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
  },
  &quot;routineReference&quot;: { # Required. Reference describing the ID of this routine.
    &quot;datasetId&quot;: &quot;A String&quot;, # [Required] The ID of the dataset containing this routine.
    &quot;projectId&quot;: &quot;A String&quot;, # [Required] The ID of the project containing this routine.
    &quot;routineId&quot;: &quot;A String&quot;, # [Required] The ID of the routine. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 256 characters.
  },
  &quot;routineType&quot;: &quot;A String&quot;, # Required. The type of routine.
}</pre>
</div>

<div class="method">
    <code class="details" id="insert">insert(projectId, datasetId, body=None)</code>
  <pre>Creates a new routine in the dataset.

Args:
  projectId: string, Required. Project ID of the new routine (required)
  datasetId: string, Required. Dataset ID of the new routine (required)
  body: object, The request body.
    The object takes the form of:

{ # A user-defined function or a stored procedure.
  &quot;arguments&quot;: [ # Optional.
    { # Input/output argument of a function or a stored procedure.
      &quot;argumentKind&quot;: &quot;A String&quot;, # Optional. Defaults to FIXED_TYPE.
      &quot;dataType&quot;: { # The type of a variable, e.g., a function argument. Examples: INT64: {type_kind=&quot;INT64&quot;} ARRAY: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;} STRUCT&gt;: {type_kind=&quot;STRUCT&quot;, struct_type={fields=[ {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}}, {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}} ]}} # Required unless argument_kind = ANY_TYPE.
        &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
        &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
          &quot;fields&quot;: [
            # Object with schema name: StandardSqlField
          ],
        },
        &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field. Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
      },
      &quot;mode&quot;: &quot;A String&quot;, # Optional. Specifies whether the argument is input or output. Can be set for procedures only.
      &quot;name&quot;: &quot;A String&quot;, # Optional. The name of this argument. Can be absent for function return argument.
    },
  ],
  &quot;creationTime&quot;: &quot;A String&quot;, # Output only. The time when this routine was created, in milliseconds since the epoch.
  &quot;definitionBody&quot;: &quot;A String&quot;, # Required. The body of the routine. For functions, this is the expression in the AS clause. If language=SQL, it is the substring inside (but excluding) the parentheses. For example, for the function created with the following statement: `CREATE FUNCTION JoinLines(x string, y string) as (concat(x, &quot;\n&quot;, y))` The definition_body is `concat(x, &quot;\n&quot;, y)` (\n is not replaced with linebreak). If language=JAVASCRIPT, it is the evaluated string in the AS clause. For example, for the function created with the following statement: `CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS &#x27;return &quot;\n&quot;;\n&#x27;` The definition_body is `return &quot;\n&quot;;\n` Note that both \n are replaced with linebreaks.
  &quot;description&quot;: &quot;A String&quot;, # Optional. [Experimental] The description of the routine if defined.
  &quot;determinismLevel&quot;: &quot;A String&quot;, # Optional. [Experimental] The determinism level of the JavaScript UDF if defined.
  &quot;etag&quot;: &quot;A String&quot;, # Output only. A hash of this resource.
  &quot;importedLibraries&quot;: [ # Optional. If language = &quot;JAVASCRIPT&quot;, this field stores the path of the imported JAVASCRIPT libraries.
    &quot;A String&quot;,
  ],
  &quot;language&quot;: &quot;A String&quot;, # Optional. Defaults to &quot;SQL&quot;.
  &quot;lastModifiedTime&quot;: &quot;A String&quot;, # Output only. The time when this routine was last modified, in milliseconds since the epoch.
  &quot;returnTableType&quot;: { # A table type # Optional. Set only if Routine is a &quot;TABLE_VALUED_FUNCTION&quot;.
    &quot;columns&quot;: [ # The columns in this table type
      { # A field or a column.
        &quot;name&quot;: &quot;A String&quot;, # Optional. The name of this field. Can be absent for struct fields.
        &quot;type&quot;: { # The type of a variable, e.g., a function argument. Examples: INT64: {type_kind=&quot;INT64&quot;} ARRAY: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;} STRUCT&gt;: {type_kind=&quot;STRUCT&quot;, struct_type={fields=[ {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}}, {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}} ]}} # Optional. The type of this parameter. Absent if not explicitly specified (e.g., CREATE FUNCTION statement can omit the return type; in this case the output parameter does not have this &quot;type&quot; field).
          &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
          &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
            &quot;fields&quot;: [
              # Object with schema name: StandardSqlField
            ],
          },
          &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field. Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
        },
      },
    ],
  },
  &quot;returnType&quot;: { # The type of a variable, e.g., a function argument. Examples: INT64: {type_kind=&quot;INT64&quot;} ARRAY: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;} STRUCT&gt;: {type_kind=&quot;STRUCT&quot;, struct_type={fields=[ {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}}, {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}} ]}} # Optional if language = &quot;SQL&quot;; required otherwise. If absent, the return type is inferred from definition_body at query time in each query that references this routine. If present, then the evaluated result will be cast to the specified returned type at query time. For example, for the functions created with the following statements: * `CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);` * `CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));` * `CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));` The return_type is `{type_kind: &quot;FLOAT64&quot;}` for `Add` and `Decrement`, and is absent for `Increment` (inferred as FLOAT64 at query time). Suppose the function `Add` is replaced by `CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);` Then the inferred return type of `Increment` is automatically changed to INT64 at query time, while the return type of `Decrement` remains FLOAT64.
    &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
    &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
      &quot;fields&quot;: [
        # Object with schema name: StandardSqlField
      ],
    },
    &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field. Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
  },
  &quot;routineReference&quot;: { # Required. Reference describing the ID of this routine.
    &quot;datasetId&quot;: &quot;A String&quot;, # [Required] The ID of the dataset containing this routine.
    &quot;projectId&quot;: &quot;A String&quot;, # [Required] The ID of the project containing this routine.
    &quot;routineId&quot;: &quot;A String&quot;, # [Required] The ID of the routine. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 256 characters.
  },
  &quot;routineType&quot;: &quot;A String&quot;, # Required. The type of routine.
}


Returns:
  An object of the form:

    { # A user-defined function or a stored procedure.
  &quot;arguments&quot;: [ # Optional.
    { # Input/output argument of a function or a stored procedure.
      &quot;argumentKind&quot;: &quot;A String&quot;, # Optional. Defaults to FIXED_TYPE.
      &quot;dataType&quot;: { # The type of a variable, e.g., a function argument. Examples: INT64: {type_kind=&quot;INT64&quot;} ARRAY: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;} STRUCT&gt;: {type_kind=&quot;STRUCT&quot;, struct_type={fields=[ {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}}, {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}} ]}} # Required unless argument_kind = ANY_TYPE.
        &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
        &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
          &quot;fields&quot;: [
            # Object with schema name: StandardSqlField
          ],
        },
        &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field. Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
      },
      &quot;mode&quot;: &quot;A String&quot;, # Optional. Specifies whether the argument is input or output. Can be set for procedures only.
      &quot;name&quot;: &quot;A String&quot;, # Optional. The name of this argument. Can be absent for function return argument.
    },
  ],
  &quot;creationTime&quot;: &quot;A String&quot;, # Output only. The time when this routine was created, in milliseconds since the epoch.
  &quot;definitionBody&quot;: &quot;A String&quot;, # Required. The body of the routine. For functions, this is the expression in the AS clause. If language=SQL, it is the substring inside (but excluding) the parentheses. For example, for the function created with the following statement: `CREATE FUNCTION JoinLines(x string, y string) as (concat(x, &quot;\n&quot;, y))` The definition_body is `concat(x, &quot;\n&quot;, y)` (\n is not replaced with linebreak). If language=JAVASCRIPT, it is the evaluated string in the AS clause. For example, for the function created with the following statement: `CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS &#x27;return &quot;\n&quot;;\n&#x27;` The definition_body is `return &quot;\n&quot;;\n` Note that both \n are replaced with linebreaks.
  &quot;description&quot;: &quot;A String&quot;, # Optional. [Experimental] The description of the routine if defined.
  &quot;determinismLevel&quot;: &quot;A String&quot;, # Optional. [Experimental] The determinism level of the JavaScript UDF if defined.
  &quot;etag&quot;: &quot;A String&quot;, # Output only. A hash of this resource.
  &quot;importedLibraries&quot;: [ # Optional. If language = &quot;JAVASCRIPT&quot;, this field stores the path of the imported JAVASCRIPT libraries.
    &quot;A String&quot;,
  ],
  &quot;language&quot;: &quot;A String&quot;, # Optional. Defaults to &quot;SQL&quot;.
  &quot;lastModifiedTime&quot;: &quot;A String&quot;, # Output only. The time when this routine was last modified, in milliseconds since the epoch.
  &quot;returnTableType&quot;: { # A table type # Optional. Set only if Routine is a &quot;TABLE_VALUED_FUNCTION&quot;.
    &quot;columns&quot;: [ # The columns in this table type
      { # A field or a column.
        &quot;name&quot;: &quot;A String&quot;, # Optional. The name of this field. Can be absent for struct fields.
        &quot;type&quot;: { # The type of a variable, e.g., a function argument. Examples: INT64: {type_kind=&quot;INT64&quot;} ARRAY: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;} STRUCT&gt;: {type_kind=&quot;STRUCT&quot;, struct_type={fields=[ {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}}, {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}} ]}} # Optional. The type of this parameter. Absent if not explicitly specified (e.g., CREATE FUNCTION statement can omit the return type; in this case the output parameter does not have this &quot;type&quot; field).
          &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
          &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
            &quot;fields&quot;: [
              # Object with schema name: StandardSqlField
            ],
          },
          &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field. Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
        },
      },
    ],
  },
  &quot;returnType&quot;: { # The type of a variable, e.g., a function argument. Examples: INT64: {type_kind=&quot;INT64&quot;} ARRAY: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;} STRUCT&gt;: {type_kind=&quot;STRUCT&quot;, struct_type={fields=[ {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}}, {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}} ]}} # Optional if language = &quot;SQL&quot;; required otherwise. If absent, the return type is inferred from definition_body at query time in each query that references this routine. If present, then the evaluated result will be cast to the specified returned type at query time. For example, for the functions created with the following statements: * `CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);` * `CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));` * `CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));` The return_type is `{type_kind: &quot;FLOAT64&quot;}` for `Add` and `Decrement`, and is absent for `Increment` (inferred as FLOAT64 at query time). Suppose the function `Add` is replaced by `CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);` Then the inferred return type of `Increment` is automatically changed to INT64 at query time, while the return type of `Decrement` remains FLOAT64.
    &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
    &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
      &quot;fields&quot;: [
        # Object with schema name: StandardSqlField
      ],
    },
    &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field. Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
  },
  &quot;routineReference&quot;: { # Required. Reference describing the ID of this routine.
    &quot;datasetId&quot;: &quot;A String&quot;, # [Required] The ID of the dataset containing this routine.
    &quot;projectId&quot;: &quot;A String&quot;, # [Required] The ID of the project containing this routine.
    &quot;routineId&quot;: &quot;A String&quot;, # [Required] The ID of the routine. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 256 characters.
  },
  &quot;routineType&quot;: &quot;A String&quot;, # Required. The type of routine.
}</pre>
</div>

<div class="method">
    <code class="details" id="list">list(projectId, datasetId, filter=None, maxResults=None, pageToken=None, readMask=None)</code>
  <pre>Lists all routines in the specified dataset. Requires the READER dataset role.

Args:
  projectId: string, Required. Project ID of the routines to list (required)
  datasetId: string, Required. Dataset ID of the routines to list (required)
  filter: string, If set, then only the Routines matching this filter are returned. The current supported form is either &quot;routine_type:&quot; or &quot;routineType:&quot;, where is a RoutineType enum. Example: &quot;routineType:SCALAR_FUNCTION&quot;.
  maxResults: integer, The maximum number of results to return in a single response page. Leverage the page tokens to iterate through the entire collection.
  pageToken: string, Page token, returned by a previous call, to request the next page of results
  readMask: string, If set, then only the Routine fields in the field mask, as well as project_id, dataset_id and routine_id, are returned in the response. If unset, then the following Routine fields are returned: etag, project_id, dataset_id, routine_id, routine_type, creation_time, last_modified_time, and language.

Returns:
  An object of the form:

    {
  &quot;nextPageToken&quot;: &quot;A String&quot;, # A token to request the next page of results.
  &quot;routines&quot;: [ # Routines in the requested dataset. Unless read_mask is set in the request, only the following fields are populated: etag, project_id, dataset_id, routine_id, routine_type, creation_time, last_modified_time, and language.
    { # A user-defined function or a stored procedure.
      &quot;arguments&quot;: [ # Optional.
        { # Input/output argument of a function or a stored procedure.
          &quot;argumentKind&quot;: &quot;A String&quot;, # Optional. Defaults to FIXED_TYPE.
          &quot;dataType&quot;: { # The type of a variable, e.g., a function argument. Examples: INT64: {type_kind=&quot;INT64&quot;} ARRAY: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;} STRUCT&gt;: {type_kind=&quot;STRUCT&quot;, struct_type={fields=[ {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}}, {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}} ]}} # Required unless argument_kind = ANY_TYPE.
            &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
            &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
              &quot;fields&quot;: [
                # Object with schema name: StandardSqlField
              ],
            },
            &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field. Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
          },
          &quot;mode&quot;: &quot;A String&quot;, # Optional. Specifies whether the argument is input or output. Can be set for procedures only.
          &quot;name&quot;: &quot;A String&quot;, # Optional. The name of this argument. Can be absent for function return argument.
        },
      ],
      &quot;creationTime&quot;: &quot;A String&quot;, # Output only. The time when this routine was created, in milliseconds since the epoch.
      &quot;definitionBody&quot;: &quot;A String&quot;, # Required. The body of the routine. For functions, this is the expression in the AS clause. If language=SQL, it is the substring inside (but excluding) the parentheses. For example, for the function created with the following statement: `CREATE FUNCTION JoinLines(x string, y string) as (concat(x, &quot;\n&quot;, y))` The definition_body is `concat(x, &quot;\n&quot;, y)` (\n is not replaced with linebreak). If language=JAVASCRIPT, it is the evaluated string in the AS clause. For example, for the function created with the following statement: `CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS &#x27;return &quot;\n&quot;;\n&#x27;` The definition_body is `return &quot;\n&quot;;\n` Note that both \n are replaced with linebreaks.
      &quot;description&quot;: &quot;A String&quot;, # Optional. [Experimental] The description of the routine if defined.
      &quot;determinismLevel&quot;: &quot;A String&quot;, # Optional. [Experimental] The determinism level of the JavaScript UDF if defined.
      &quot;etag&quot;: &quot;A String&quot;, # Output only. A hash of this resource.
      &quot;importedLibraries&quot;: [ # Optional. If language = &quot;JAVASCRIPT&quot;, this field stores the path of the imported JAVASCRIPT libraries.
        &quot;A String&quot;,
      ],
      &quot;language&quot;: &quot;A String&quot;, # Optional. Defaults to &quot;SQL&quot;.
      &quot;lastModifiedTime&quot;: &quot;A String&quot;, # Output only. The time when this routine was last modified, in milliseconds since the epoch.
      &quot;returnTableType&quot;: { # A table type # Optional. Set only if Routine is a &quot;TABLE_VALUED_FUNCTION&quot;.
        &quot;columns&quot;: [ # The columns in this table type
          { # A field or a column.
            &quot;name&quot;: &quot;A String&quot;, # Optional. The name of this field. Can be absent for struct fields.
            &quot;type&quot;: { # The type of a variable, e.g., a function argument. Examples: INT64: {type_kind=&quot;INT64&quot;} ARRAY: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;} STRUCT&gt;: {type_kind=&quot;STRUCT&quot;, struct_type={fields=[ {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}}, {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}} ]}} # Optional. The type of this parameter. Absent if not explicitly specified (e.g., CREATE FUNCTION statement can omit the return type; in this case the output parameter does not have this &quot;type&quot; field).
              &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
              &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
                &quot;fields&quot;: [
                  # Object with schema name: StandardSqlField
                ],
              },
              &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field. Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
            },
          },
        ],
      },
      &quot;returnType&quot;: { # The type of a variable, e.g., a function argument. Examples: INT64: {type_kind=&quot;INT64&quot;} ARRAY: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;} STRUCT&gt;: {type_kind=&quot;STRUCT&quot;, struct_type={fields=[ {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}}, {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}} ]}} # Optional if language = &quot;SQL&quot;; required otherwise. If absent, the return type is inferred from definition_body at query time in each query that references this routine. If present, then the evaluated result will be cast to the specified returned type at query time. For example, for the functions created with the following statements: * `CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);` * `CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));` * `CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));` The return_type is `{type_kind: &quot;FLOAT64&quot;}` for `Add` and `Decrement`, and is absent for `Increment` (inferred as FLOAT64 at query time). Suppose the function `Add` is replaced by `CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);` Then the inferred return type of `Increment` is automatically changed to INT64 at query time, while the return type of `Decrement` remains FLOAT64.
        &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
        &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
          &quot;fields&quot;: [
            # Object with schema name: StandardSqlField
          ],
        },
        &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field. Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
      },
      &quot;routineReference&quot;: { # Required. Reference describing the ID of this routine.
        &quot;datasetId&quot;: &quot;A String&quot;, # [Required] The ID of the dataset containing this routine.
        &quot;projectId&quot;: &quot;A String&quot;, # [Required] The ID of the project containing this routine.
        &quot;routineId&quot;: &quot;A String&quot;, # [Required] The ID of the routine. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 256 characters.
      },
      &quot;routineType&quot;: &quot;A String&quot;, # Required. The type of routine.
    },
  ],
}</pre>
</div>

<div class="method">
    <code class="details" id="list_next">list_next(previous_request, previous_response)</code>
  <pre>Retrieves the next page of results.

Args:
  previous_request: The request for the previous page. (required)
  previous_response: The response from the request for the previous page. (required)

Returns:
  A request object that you can call &#x27;execute()&#x27; on to request the next
  page. Returns None if there are no more items in the collection.
    </pre>
</div>

<div class="method">
    <code class="details" id="update">update(projectId, datasetId, routineId, body=None)</code>
  <pre>Updates information in an existing routine. The update method replaces the entire Routine resource.

Args:
  projectId: string, Required. Project ID of the routine to update (required)
  datasetId: string, Required. Dataset ID of the routine to update (required)
  routineId: string, Required. Routine ID of the routine to update (required)
  body: object, The request body.
    The object takes the form of:

{ # A user-defined function or a stored procedure.
  &quot;arguments&quot;: [ # Optional.
    { # Input/output argument of a function or a stored procedure.
      &quot;argumentKind&quot;: &quot;A String&quot;, # Optional. Defaults to FIXED_TYPE.
      &quot;dataType&quot;: { # The type of a variable, e.g., a function argument. Examples: INT64: {type_kind=&quot;INT64&quot;} ARRAY: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;} STRUCT&gt;: {type_kind=&quot;STRUCT&quot;, struct_type={fields=[ {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}}, {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}} ]}} # Required unless argument_kind = ANY_TYPE.
        &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
        &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
          &quot;fields&quot;: [
            # Object with schema name: StandardSqlField
          ],
        },
        &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field. Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
      },
      &quot;mode&quot;: &quot;A String&quot;, # Optional. Specifies whether the argument is input or output. Can be set for procedures only.
      &quot;name&quot;: &quot;A String&quot;, # Optional. The name of this argument. Can be absent for function return argument.
    },
  ],
  &quot;creationTime&quot;: &quot;A String&quot;, # Output only. The time when this routine was created, in milliseconds since the epoch.
  &quot;definitionBody&quot;: &quot;A String&quot;, # Required. The body of the routine. For functions, this is the expression in the AS clause. If language=SQL, it is the substring inside (but excluding) the parentheses. For example, for the function created with the following statement: `CREATE FUNCTION JoinLines(x string, y string) as (concat(x, &quot;\n&quot;, y))` The definition_body is `concat(x, &quot;\n&quot;, y)` (\n is not replaced with linebreak). If language=JAVASCRIPT, it is the evaluated string in the AS clause. For example, for the function created with the following statement: `CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS &#x27;return &quot;\n&quot;;\n&#x27;` The definition_body is `return &quot;\n&quot;;\n` Note that both \n are replaced with linebreaks.
  &quot;description&quot;: &quot;A String&quot;, # Optional. [Experimental] The description of the routine if defined.
  &quot;determinismLevel&quot;: &quot;A String&quot;, # Optional. [Experimental] The determinism level of the JavaScript UDF if defined.
  &quot;etag&quot;: &quot;A String&quot;, # Output only. A hash of this resource.
  &quot;importedLibraries&quot;: [ # Optional. If language = &quot;JAVASCRIPT&quot;, this field stores the path of the imported JAVASCRIPT libraries.
    &quot;A String&quot;,
  ],
  &quot;language&quot;: &quot;A String&quot;, # Optional. Defaults to &quot;SQL&quot;.
  &quot;lastModifiedTime&quot;: &quot;A String&quot;, # Output only. The time when this routine was last modified, in milliseconds since the epoch.
  &quot;returnTableType&quot;: { # A table type # Optional. Set only if Routine is a &quot;TABLE_VALUED_FUNCTION&quot;.
    &quot;columns&quot;: [ # The columns in this table type
      { # A field or a column.
        &quot;name&quot;: &quot;A String&quot;, # Optional. The name of this field. Can be absent for struct fields.
        &quot;type&quot;: { # The type of a variable, e.g., a function argument. Examples: INT64: {type_kind=&quot;INT64&quot;} ARRAY: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;} STRUCT&gt;: {type_kind=&quot;STRUCT&quot;, struct_type={fields=[ {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}}, {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}} ]}} # Optional. The type of this parameter. Absent if not explicitly specified (e.g., CREATE FUNCTION statement can omit the return type; in this case the output parameter does not have this &quot;type&quot; field).
          &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
          &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
            &quot;fields&quot;: [
              # Object with schema name: StandardSqlField
            ],
          },
          &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field. Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
        },
      },
    ],
  },
  &quot;returnType&quot;: { # The type of a variable, e.g., a function argument. Examples: INT64: {type_kind=&quot;INT64&quot;} ARRAY: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;} STRUCT&gt;: {type_kind=&quot;STRUCT&quot;, struct_type={fields=[ {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}}, {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}} ]}} # Optional if language = &quot;SQL&quot;; required otherwise. If absent, the return type is inferred from definition_body at query time in each query that references this routine. If present, then the evaluated result will be cast to the specified returned type at query time. For example, for the functions created with the following statements: * `CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);` * `CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));` * `CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));` The return_type is `{type_kind: &quot;FLOAT64&quot;}` for `Add` and `Decrement`, and is absent for `Increment` (inferred as FLOAT64 at query time). Suppose the function `Add` is replaced by `CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);` Then the inferred return type of `Increment` is automatically changed to INT64 at query time, while the return type of `Decrement` remains FLOAT64.
    &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
    &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
      &quot;fields&quot;: [
        # Object with schema name: StandardSqlField
      ],
    },
    &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field. Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
  },
  &quot;routineReference&quot;: { # Required. Reference describing the ID of this routine.
    &quot;datasetId&quot;: &quot;A String&quot;, # [Required] The ID of the dataset containing this routine.
    &quot;projectId&quot;: &quot;A String&quot;, # [Required] The ID of the project containing this routine.
    &quot;routineId&quot;: &quot;A String&quot;, # [Required] The ID of the routine. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 256 characters.
  },
  &quot;routineType&quot;: &quot;A String&quot;, # Required. The type of routine.
}


Returns:
  An object of the form:

    { # A user-defined function or a stored procedure.
  &quot;arguments&quot;: [ # Optional.
    { # Input/output argument of a function or a stored procedure.
      &quot;argumentKind&quot;: &quot;A String&quot;, # Optional. Defaults to FIXED_TYPE.
      &quot;dataType&quot;: { # The type of a variable, e.g., a function argument. Examples: INT64: {type_kind=&quot;INT64&quot;} ARRAY: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;} STRUCT&gt;: {type_kind=&quot;STRUCT&quot;, struct_type={fields=[ {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}}, {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}} ]}} # Required unless argument_kind = ANY_TYPE.
        &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
        &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
          &quot;fields&quot;: [
            # Object with schema name: StandardSqlField
          ],
        },
        &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field. Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
      },
      &quot;mode&quot;: &quot;A String&quot;, # Optional. Specifies whether the argument is input or output. Can be set for procedures only.
      &quot;name&quot;: &quot;A String&quot;, # Optional. The name of this argument. Can be absent for function return argument.
    },
  ],
  &quot;creationTime&quot;: &quot;A String&quot;, # Output only. The time when this routine was created, in milliseconds since the epoch.
  &quot;definitionBody&quot;: &quot;A String&quot;, # Required. The body of the routine. For functions, this is the expression in the AS clause. If language=SQL, it is the substring inside (but excluding) the parentheses. For example, for the function created with the following statement: `CREATE FUNCTION JoinLines(x string, y string) as (concat(x, &quot;\n&quot;, y))` The definition_body is `concat(x, &quot;\n&quot;, y)` (\n is not replaced with linebreak). If language=JAVASCRIPT, it is the evaluated string in the AS clause. For example, for the function created with the following statement: `CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS &#x27;return &quot;\n&quot;;\n&#x27;` The definition_body is `return &quot;\n&quot;;\n` Note that both \n are replaced with linebreaks.
  &quot;description&quot;: &quot;A String&quot;, # Optional. [Experimental] The description of the routine if defined.
  &quot;determinismLevel&quot;: &quot;A String&quot;, # Optional. [Experimental] The determinism level of the JavaScript UDF if defined.
  &quot;etag&quot;: &quot;A String&quot;, # Output only. A hash of this resource.
  &quot;importedLibraries&quot;: [ # Optional. If language = &quot;JAVASCRIPT&quot;, this field stores the path of the imported JAVASCRIPT libraries.
    &quot;A String&quot;,
  ],
  &quot;language&quot;: &quot;A String&quot;, # Optional. Defaults to &quot;SQL&quot;.
  &quot;lastModifiedTime&quot;: &quot;A String&quot;, # Output only. The time when this routine was last modified, in milliseconds since the epoch.
  &quot;returnTableType&quot;: { # A table type # Optional. Set only if Routine is a &quot;TABLE_VALUED_FUNCTION&quot;.
    &quot;columns&quot;: [ # The columns in this table type
      { # A field or a column.
        &quot;name&quot;: &quot;A String&quot;, # Optional. The name of this field. Can be absent for struct fields.
        &quot;type&quot;: { # The type of a variable, e.g., a function argument. Examples: INT64: {type_kind=&quot;INT64&quot;} ARRAY: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;} STRUCT&gt;: {type_kind=&quot;STRUCT&quot;, struct_type={fields=[ {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}}, {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}} ]}} # Optional. The type of this parameter. Absent if not explicitly specified (e.g., CREATE FUNCTION statement can omit the return type; in this case the output parameter does not have this &quot;type&quot; field).
          &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
          &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
            &quot;fields&quot;: [
              # Object with schema name: StandardSqlField
            ],
          },
          &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field. Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
        },
      },
    ],
  },
  &quot;returnType&quot;: { # The type of a variable, e.g., a function argument. Examples: INT64: {type_kind=&quot;INT64&quot;} ARRAY: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;} STRUCT&gt;: {type_kind=&quot;STRUCT&quot;, struct_type={fields=[ {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}}, {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}} ]}} # Optional if language = &quot;SQL&quot;; required otherwise. If absent, the return type is inferred from definition_body at query time in each query that references this routine. If present, then the evaluated result will be cast to the specified returned type at query time. For example, for the functions created with the following statements: * `CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);` * `CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));` * `CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));` The return_type is `{type_kind: &quot;FLOAT64&quot;}` for `Add` and `Decrement`, and is absent for `Increment` (inferred as FLOAT64 at query time). Suppose the function `Add` is replaced by `CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);` Then the inferred return type of `Increment` is automatically changed to INT64 at query time, while the return type of `Decrement` remains FLOAT64.
    &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
    &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
      &quot;fields&quot;: [
        # Object with schema name: StandardSqlField
      ],
    },
    &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field. Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
  },
  &quot;routineReference&quot;: { # Required. Reference describing the ID of this routine.
    &quot;datasetId&quot;: &quot;A String&quot;, # [Required] The ID of the dataset containing this routine.
    &quot;projectId&quot;: &quot;A String&quot;, # [Required] The ID of the project containing this routine.
    &quot;routineId&quot;: &quot;A String&quot;, # [Required] The ID of the routine. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 256 characters.
  },
  &quot;routineType&quot;: &quot;A String&quot;, # Required. The type of routine.
}</pre>
</div>

</body></html>