<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="bigquery_v2.html">BigQuery API</a> . <a href="bigquery_v2.routines.html">routines</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#delete">delete(projectId, datasetId, routineId)</a></code></p>
<p class="firstline">Deletes the routine specified by routineId from the dataset.</p>
<p class="toc_element">
  <code><a href="#get">get(projectId, datasetId, routineId, readMask=None)</a></code></p>
<p class="firstline">Gets the specified routine resource by routine ID.</p>
<p class="toc_element">
  <code><a href="#insert">insert(projectId, datasetId, body=None)</a></code></p>
<p class="firstline">Creates a new routine in the dataset.</p>
<p class="toc_element">
  <code><a href="#list">list(projectId, datasetId, pageToken=None, maxResults=None, readMask=None, filter=None)</a></code></p>
<p class="firstline">Lists all routines in the specified dataset. Requires the READER dataset</p>
<p class="toc_element">
  <code><a href="#list_next">list_next(previous_request, previous_response)</a></code></p>
<p class="firstline">Retrieves the next page of results.</p>
<p class="toc_element">
  <code><a href="#update">update(projectId, datasetId, routineId, body=None)</a></code></p>
<p class="firstline">Updates information in an existing routine. The update method replaces the</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="delete">delete(projectId, datasetId, routineId)</code>
  <pre>Deletes the routine specified by routineId from the dataset.

Args:
  projectId: string, Required. Project ID of the routine to delete (required)
  datasetId: string, Required. Dataset ID of the routine to delete (required)
  routineId: string, Required. Routine ID of the routine to delete (required)
</pre>
</div>

<div class="method">
    <code class="details" id="get">get(projectId, datasetId, routineId, readMask=None)</code>
  <pre>Gets the specified routine resource by routine ID.

Args:
  projectId: string, Required. Project ID of the requested routine (required)
  datasetId: string, Required. Dataset ID of the requested routine (required)
  routineId: string, Required. Routine ID of the requested routine (required)
  readMask: string, If set, only the Routine fields in the field mask are returned in the
response. If unset, all Routine fields are returned.

Returns:
  An object of the form:

    { # A user-defined function or a stored procedure.
      &quot;arguments&quot;: [ # Optional.
        { # Input/output argument of a function or a stored procedure.
          &quot;name&quot;: &quot;A String&quot;, # Optional. The name of this argument. Can be absent for function return argument.
          &quot;argumentKind&quot;: &quot;A String&quot;, # Optional. Defaults to FIXED_TYPE.
          &quot;mode&quot;: &quot;A String&quot;, # Optional. Specifies whether the argument is input or output.
              # Can be set for procedures only.
          &quot;dataType&quot;: { # The type of a variable, e.g., a function argument. # Required unless argument_kind = ANY_TYPE.
              # Examples:
              # INT64: {type_kind=&quot;INT64&quot;}
              # ARRAY&lt;STRING&gt;: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;}
              # STRUCT&lt;x STRING, y ARRAY&lt;DATE&gt;&gt;:
              #   {type_kind=&quot;STRUCT&quot;,
              #    struct_type={fields=[
              #      {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}},
              #      {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}}
              #    ]}}
            &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
            &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field.
                # Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
            &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
              &quot;fields&quot;: [
                # Object with schema name: StandardSqlField
              ],
            },
          },
        },
      ],
      &quot;importedLibraries&quot;: [ # Optional. If language = &quot;JAVASCRIPT&quot;, this field stores the path of the
          # imported JAVASCRIPT libraries.
        &quot;A String&quot;,
      ],
      &quot;returnType&quot;: { # The type of a variable, e.g., a function argument. # Optional if language = &quot;SQL&quot;; required otherwise.
          #
          # If absent, the return type is inferred from definition_body at query time
          # in each query that references this routine. If present, then the evaluated
          # result will be cast to the specified returned type at query time.
          #
          # For example, for the functions created with the following statements:
          #
          # * `CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);`
          #
          # * `CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));`
          #
          # * `CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));`
          #
          # The return_type is `{type_kind: &quot;FLOAT64&quot;}` for `Add` and `Decrement`, and
          # is absent for `Increment` (inferred as FLOAT64 at query time).
          #
          # Suppose the function `Add` is replaced by
          #   `CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);`
          #
          # Then the inferred return type of `Increment` is automatically changed to
          # INT64 at query time, while the return type of `Decrement` remains FLOAT64.
          # Examples:
          # INT64: {type_kind=&quot;INT64&quot;}
          # ARRAY&lt;STRING&gt;: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;}
          # STRUCT&lt;x STRING, y ARRAY&lt;DATE&gt;&gt;:
          #   {type_kind=&quot;STRUCT&quot;,
          #    struct_type={fields=[
          #      {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}},
          #      {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}}
          #    ]}}
        &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
        &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field.
            # Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
        &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
          &quot;fields&quot;: [
            # Object with schema name: StandardSqlField
          ],
        },
      },
      &quot;language&quot;: &quot;A String&quot;, # Optional. Defaults to &quot;SQL&quot;.
      &quot;lastModifiedTime&quot;: &quot;A String&quot;, # Output only. The time when this routine was last modified, in milliseconds
          # since the epoch.
      &quot;description&quot;: &quot;A String&quot;, # Optional. [Experimental] The description of the routine if defined.
      &quot;etag&quot;: &quot;A String&quot;, # Output only. A hash of this resource.
      &quot;definitionBody&quot;: &quot;A String&quot;, # Required. The body of the routine.
          #
          # For functions, this is the expression in the AS clause.
          #
          # If language=SQL, it is the substring inside (but excluding) the
          # parentheses. For example, for the function created with the following
          # statement:
          #
          # `CREATE FUNCTION JoinLines(x string, y string) as (concat(x, &quot;\n&quot;, y))`
          #
          # The definition_body is `concat(x, &quot;\n&quot;, y)` (\n is not replaced with
          # linebreak).
          #
          # If language=JAVASCRIPT, it is the evaluated string in the AS clause.
          # For example, for the function created with the following statement:
          #
          # `CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS &#x27;return &quot;\n&quot;;\n&#x27;`
          #
          # The definition_body is
          #
          # `return &quot;\n&quot;;\n`
          #
          # Note that both \n are replaced with linebreaks.
      &quot;creationTime&quot;: &quot;A String&quot;, # Output only. The time when this routine was created, in milliseconds since
          # the epoch.
      &quot;routineType&quot;: &quot;A String&quot;, # Required. The type of routine.
      &quot;routineReference&quot;: { # Required. Reference describing the ID of this routine.
        &quot;projectId&quot;: &quot;A String&quot;, # [Required] The ID of the project containing this routine.
        &quot;datasetId&quot;: &quot;A String&quot;, # [Required] The ID of the dataset containing this routine.
        &quot;routineId&quot;: &quot;A String&quot;, # [Required] The ID of the routine. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 256 characters.
      },
    }</pre>
</div>

<div class="method">
    <code class="details" id="insert">insert(projectId, datasetId, body=None)</code>
  <pre>Creates a new routine in the dataset.

Args:
  projectId: string, Required. Project ID of the new routine (required)
  datasetId: string, Required. Dataset ID of the new routine (required)
  body: object, The request body.
    The object takes the form of:

{ # A user-defined function or a stored procedure.
    &quot;arguments&quot;: [ # Optional.
      { # Input/output argument of a function or a stored procedure.
        &quot;name&quot;: &quot;A String&quot;, # Optional. The name of this argument. Can be absent for function return argument.
        &quot;argumentKind&quot;: &quot;A String&quot;, # Optional. Defaults to FIXED_TYPE.
        &quot;mode&quot;: &quot;A String&quot;, # Optional. Specifies whether the argument is input or output.
            # Can be set for procedures only.
        &quot;dataType&quot;: { # The type of a variable, e.g., a function argument. # Required unless argument_kind = ANY_TYPE.
            # Examples:
            # INT64: {type_kind=&quot;INT64&quot;}
            # ARRAY&lt;STRING&gt;: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;}
            # STRUCT&lt;x STRING, y ARRAY&lt;DATE&gt;&gt;:
            #   {type_kind=&quot;STRUCT&quot;,
            #    struct_type={fields=[
            #      {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}},
            #      {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}}
            #    ]}}
          &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
          &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field.
              # Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
          &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
            &quot;fields&quot;: [
              # Object with schema name: StandardSqlField
            ],
          },
        },
      },
    ],
    &quot;importedLibraries&quot;: [ # Optional. If language = &quot;JAVASCRIPT&quot;, this field stores the path of the
        # imported JAVASCRIPT libraries.
      &quot;A String&quot;,
    ],
    &quot;returnType&quot;: { # The type of a variable, e.g., a function argument. # Optional if language = &quot;SQL&quot;; required otherwise.
        # 
        # If absent, the return type is inferred from definition_body at query time
        # in each query that references this routine. If present, then the evaluated
        # result will be cast to the specified returned type at query time.
        # 
        # For example, for the functions created with the following statements:
        # 
        # * `CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);`
        # 
        # * `CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));`
        # 
        # * `CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));`
        # 
        # The return_type is `{type_kind: &quot;FLOAT64&quot;}` for `Add` and `Decrement`, and
        # is absent for `Increment` (inferred as FLOAT64 at query time).
        # 
        # Suppose the function `Add` is replaced by
        #   `CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);`
        # 
        # Then the inferred return type of `Increment` is automatically changed to
        # INT64 at query time, while the return type of `Decrement` remains FLOAT64.
        # Examples:
        # INT64: {type_kind=&quot;INT64&quot;}
        # ARRAY&lt;STRING&gt;: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;}
        # STRUCT&lt;x STRING, y ARRAY&lt;DATE&gt;&gt;:
        #   {type_kind=&quot;STRUCT&quot;,
        #    struct_type={fields=[
        #      {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}},
        #      {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}}
        #    ]}}
      &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
      &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field.
          # Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
      &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
        &quot;fields&quot;: [
          # Object with schema name: StandardSqlField
        ],
      },
    },
    &quot;language&quot;: &quot;A String&quot;, # Optional. Defaults to &quot;SQL&quot;.
    &quot;lastModifiedTime&quot;: &quot;A String&quot;, # Output only. The time when this routine was last modified, in milliseconds
        # since the epoch.
    &quot;description&quot;: &quot;A String&quot;, # Optional. [Experimental] The description of the routine if defined.
    &quot;etag&quot;: &quot;A String&quot;, # Output only. A hash of this resource.
    &quot;definitionBody&quot;: &quot;A String&quot;, # Required. The body of the routine.
        # 
        # For functions, this is the expression in the AS clause.
        # 
        # If language=SQL, it is the substring inside (but excluding) the
        # parentheses. For example, for the function created with the following
        # statement:
        # 
        # `CREATE FUNCTION JoinLines(x string, y string) as (concat(x, &quot;\n&quot;, y))`
        # 
        # The definition_body is `concat(x, &quot;\n&quot;, y)` (\n is not replaced with
        # linebreak).
        # 
        # If language=JAVASCRIPT, it is the evaluated string in the AS clause.
        # For example, for the function created with the following statement:
        # 
        # `CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS &#x27;return &quot;\n&quot;;\n&#x27;`
        # 
        # The definition_body is
        # 
        # `return &quot;\n&quot;;\n`
        # 
        # Note that both \n are replaced with linebreaks.
    &quot;creationTime&quot;: &quot;A String&quot;, # Output only. The time when this routine was created, in milliseconds since
        # the epoch.
    &quot;routineType&quot;: &quot;A String&quot;, # Required. The type of routine.
    &quot;routineReference&quot;: { # Required. Reference describing the ID of this routine.
      &quot;projectId&quot;: &quot;A String&quot;, # [Required] The ID of the project containing this routine.
      &quot;datasetId&quot;: &quot;A String&quot;, # [Required] The ID of the dataset containing this routine.
      &quot;routineId&quot;: &quot;A String&quot;, # [Required] The ID of the routine. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 256 characters.
    },
  }


Returns:
  An object of the form:

    { # A user-defined function or a stored procedure.
      &quot;arguments&quot;: [ # Optional.
        { # Input/output argument of a function or a stored procedure.
          &quot;name&quot;: &quot;A String&quot;, # Optional. The name of this argument. Can be absent for function return argument.
          &quot;argumentKind&quot;: &quot;A String&quot;, # Optional. Defaults to FIXED_TYPE.
          &quot;mode&quot;: &quot;A String&quot;, # Optional. Specifies whether the argument is input or output.
              # Can be set for procedures only.
          &quot;dataType&quot;: { # The type of a variable, e.g., a function argument. # Required unless argument_kind = ANY_TYPE.
              # Examples:
              # INT64: {type_kind=&quot;INT64&quot;}
              # ARRAY&lt;STRING&gt;: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;}
              # STRUCT&lt;x STRING, y ARRAY&lt;DATE&gt;&gt;:
              #   {type_kind=&quot;STRUCT&quot;,
              #    struct_type={fields=[
              #      {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}},
              #      {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}}
              #    ]}}
            &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
            &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field.
                # Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
            &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
              &quot;fields&quot;: [
                # Object with schema name: StandardSqlField
              ],
            },
          },
        },
      ],
      &quot;importedLibraries&quot;: [ # Optional. If language = &quot;JAVASCRIPT&quot;, this field stores the path of the
          # imported JAVASCRIPT libraries.
        &quot;A String&quot;,
      ],
      &quot;returnType&quot;: { # The type of a variable, e.g., a function argument. # Optional if language = &quot;SQL&quot;; required otherwise.
          #
          # If absent, the return type is inferred from definition_body at query time
          # in each query that references this routine. If present, then the evaluated
          # result will be cast to the specified returned type at query time.
          #
          # For example, for the functions created with the following statements:
          #
          # * `CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);`
          #
          # * `CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));`
          #
          # * `CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));`
          #
          # The return_type is `{type_kind: &quot;FLOAT64&quot;}` for `Add` and `Decrement`, and
          # is absent for `Increment` (inferred as FLOAT64 at query time).
          #
          # Suppose the function `Add` is replaced by
          #   `CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);`
          #
          # Then the inferred return type of `Increment` is automatically changed to
          # INT64 at query time, while the return type of `Decrement` remains FLOAT64.
          # Examples:
          # INT64: {type_kind=&quot;INT64&quot;}
          # ARRAY&lt;STRING&gt;: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;}
          # STRUCT&lt;x STRING, y ARRAY&lt;DATE&gt;&gt;:
          #   {type_kind=&quot;STRUCT&quot;,
          #    struct_type={fields=[
          #      {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}},
          #      {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}}
          #    ]}}
        &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
        &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field.
            # Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
        &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
          &quot;fields&quot;: [
            # Object with schema name: StandardSqlField
          ],
        },
      },
      &quot;language&quot;: &quot;A String&quot;, # Optional. Defaults to &quot;SQL&quot;.
      &quot;lastModifiedTime&quot;: &quot;A String&quot;, # Output only. The time when this routine was last modified, in milliseconds
          # since the epoch.
      &quot;description&quot;: &quot;A String&quot;, # Optional. [Experimental] The description of the routine if defined.
      &quot;etag&quot;: &quot;A String&quot;, # Output only. A hash of this resource.
      &quot;definitionBody&quot;: &quot;A String&quot;, # Required. The body of the routine.
          #
          # For functions, this is the expression in the AS clause.
          #
          # If language=SQL, it is the substring inside (but excluding) the
          # parentheses. For example, for the function created with the following
          # statement:
          #
          # `CREATE FUNCTION JoinLines(x string, y string) as (concat(x, &quot;\n&quot;, y))`
          #
          # The definition_body is `concat(x, &quot;\n&quot;, y)` (\n is not replaced with
          # linebreak).
          #
          # If language=JAVASCRIPT, it is the evaluated string in the AS clause.
          # For example, for the function created with the following statement:
          #
          # `CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS &#x27;return &quot;\n&quot;;\n&#x27;`
          #
          # The definition_body is
          #
          # `return &quot;\n&quot;;\n`
          #
          # Note that both \n are replaced with linebreaks.
      &quot;creationTime&quot;: &quot;A String&quot;, # Output only. The time when this routine was created, in milliseconds since
          # the epoch.
      &quot;routineType&quot;: &quot;A String&quot;, # Required. The type of routine.
      &quot;routineReference&quot;: { # Required. Reference describing the ID of this routine.
        &quot;projectId&quot;: &quot;A String&quot;, # [Required] The ID of the project containing this routine.
        &quot;datasetId&quot;: &quot;A String&quot;, # [Required] The ID of the dataset containing this routine.
        &quot;routineId&quot;: &quot;A String&quot;, # [Required] The ID of the routine. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 256 characters.
      },
    }</pre>
</div>

<div class="method">
    <code class="details" id="list">list(projectId, datasetId, pageToken=None, maxResults=None, readMask=None, filter=None)</code>
  <pre>Lists all routines in the specified dataset. Requires the READER dataset
role.

Args:
  projectId: string, Required. Project ID of the routines to list (required)
  datasetId: string, Required. Dataset ID of the routines to list (required)
  pageToken: string, Page token, returned by a previous call, to request the next page of
results
  maxResults: integer, The maximum number of results to return in a single response page.
Leverage the page tokens to iterate through the entire collection.
  readMask: string, If set, then only the Routine fields in the field mask, as well as
project_id, dataset_id and routine_id, are returned in the response.
If unset, then the following Routine fields are returned:
etag, project_id, dataset_id, routine_id, routine_type, creation_time,
last_modified_time, and language.
  filter: string, If set, then only the Routines matching this filter are returned.
The current supported form is either &quot;routine_type:&lt;RoutineType&gt;&quot; or
&quot;routineType:&lt;RoutineType&gt;&quot;, where &lt;RoutineType&gt; is a RoutineType enum.
Example: &quot;routineType:SCALAR_FUNCTION&quot;.

Returns:
  An object of the form:

    {
    &quot;routines&quot;: [ # Routines in the requested dataset. Unless read_mask is set in the request,
        # only the following fields are populated:
        # etag, project_id, dataset_id, routine_id, routine_type, creation_time,
        # last_modified_time, and language.
      { # A user-defined function or a stored procedure.
          &quot;arguments&quot;: [ # Optional.
            { # Input/output argument of a function or a stored procedure.
              &quot;name&quot;: &quot;A String&quot;, # Optional. The name of this argument. Can be absent for function return argument.
              &quot;argumentKind&quot;: &quot;A String&quot;, # Optional. Defaults to FIXED_TYPE.
              &quot;mode&quot;: &quot;A String&quot;, # Optional. Specifies whether the argument is input or output.
                  # Can be set for procedures only.
              &quot;dataType&quot;: { # The type of a variable, e.g., a function argument. # Required unless argument_kind = ANY_TYPE.
                  # Examples:
                  # INT64: {type_kind=&quot;INT64&quot;}
                  # ARRAY&lt;STRING&gt;: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;}
                  # STRUCT&lt;x STRING, y ARRAY&lt;DATE&gt;&gt;:
                  #   {type_kind=&quot;STRUCT&quot;,
                  #    struct_type={fields=[
                  #      {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}},
                  #      {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}}
                  #    ]}}
                &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
                &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field.
                    # Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
                &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
                  &quot;fields&quot;: [
                    # Object with schema name: StandardSqlField
                  ],
                },
              },
            },
          ],
          &quot;importedLibraries&quot;: [ # Optional. If language = &quot;JAVASCRIPT&quot;, this field stores the path of the
              # imported JAVASCRIPT libraries.
            &quot;A String&quot;,
          ],
          &quot;returnType&quot;: { # The type of a variable, e.g., a function argument. # Optional if language = &quot;SQL&quot;; required otherwise.
              #
              # If absent, the return type is inferred from definition_body at query time
              # in each query that references this routine. If present, then the evaluated
              # result will be cast to the specified returned type at query time.
              #
              # For example, for the functions created with the following statements:
              #
              # * `CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);`
              #
              # * `CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));`
              #
              # * `CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));`
              #
              # The return_type is `{type_kind: &quot;FLOAT64&quot;}` for `Add` and `Decrement`, and
              # is absent for `Increment` (inferred as FLOAT64 at query time).
              #
              # Suppose the function `Add` is replaced by
              #   `CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);`
              #
              # Then the inferred return type of `Increment` is automatically changed to
              # INT64 at query time, while the return type of `Decrement` remains FLOAT64.
              # Examples:
              # INT64: {type_kind=&quot;INT64&quot;}
              # ARRAY&lt;STRING&gt;: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;}
              # STRUCT&lt;x STRING, y ARRAY&lt;DATE&gt;&gt;:
              #   {type_kind=&quot;STRUCT&quot;,
              #    struct_type={fields=[
              #      {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}},
              #      {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}}
              #    ]}}
            &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
            &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field.
                # Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
            &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
              &quot;fields&quot;: [
                # Object with schema name: StandardSqlField
              ],
            },
          },
          &quot;language&quot;: &quot;A String&quot;, # Optional. Defaults to &quot;SQL&quot;.
          &quot;lastModifiedTime&quot;: &quot;A String&quot;, # Output only. The time when this routine was last modified, in milliseconds
              # since the epoch.
          &quot;description&quot;: &quot;A String&quot;, # Optional. [Experimental] The description of the routine if defined.
          &quot;etag&quot;: &quot;A String&quot;, # Output only. A hash of this resource.
          &quot;definitionBody&quot;: &quot;A String&quot;, # Required. The body of the routine.
              #
              # For functions, this is the expression in the AS clause.
              #
              # If language=SQL, it is the substring inside (but excluding) the
              # parentheses. For example, for the function created with the following
              # statement:
              #
              # `CREATE FUNCTION JoinLines(x string, y string) as (concat(x, &quot;\n&quot;, y))`
              #
              # The definition_body is `concat(x, &quot;\n&quot;, y)` (\n is not replaced with
              # linebreak).
              #
              # If language=JAVASCRIPT, it is the evaluated string in the AS clause.
              # For example, for the function created with the following statement:
              #
              # `CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS &#x27;return &quot;\n&quot;;\n&#x27;`
              #
              # The definition_body is
              #
              # `return &quot;\n&quot;;\n`
              #
              # Note that both \n are replaced with linebreaks.
          &quot;creationTime&quot;: &quot;A String&quot;, # Output only. The time when this routine was created, in milliseconds since
              # the epoch.
          &quot;routineType&quot;: &quot;A String&quot;, # Required. The type of routine.
          &quot;routineReference&quot;: { # Required. Reference describing the ID of this routine.
            &quot;projectId&quot;: &quot;A String&quot;, # [Required] The ID of the project containing this routine.
            &quot;datasetId&quot;: &quot;A String&quot;, # [Required] The ID of the dataset containing this routine.
            &quot;routineId&quot;: &quot;A String&quot;, # [Required] The ID of the routine. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 256 characters.
          },
        },
    ],
    &quot;nextPageToken&quot;: &quot;A String&quot;, # A token to request the next page of results.
  }</pre>
</div>

<div class="method">
    <code class="details" id="list_next">list_next(previous_request, previous_response)</code>
  <pre>Retrieves the next page of results.

Args:
  previous_request: The request for the previous page. (required)
  previous_response: The response from the request for the previous page. (required)

Returns:
  A request object that you can call &#x27;execute()&#x27; on to request the next
  page. Returns None if there are no more items in the collection.
    </pre>
</div>

<div class="method">
    <code class="details" id="update">update(projectId, datasetId, routineId, body=None)</code>
  <pre>Updates information in an existing routine. The update method replaces the
entire Routine resource.

Args:
  projectId: string, Required. Project ID of the routine to update (required)
  datasetId: string, Required. Dataset ID of the routine to update (required)
  routineId: string, Required. Routine ID of the routine to update (required)
  body: object, The request body.
    The object takes the form of:

{ # A user-defined function or a stored procedure.
    &quot;arguments&quot;: [ # Optional.
      { # Input/output argument of a function or a stored procedure.
        &quot;name&quot;: &quot;A String&quot;, # Optional. The name of this argument. Can be absent for function return argument.
        &quot;argumentKind&quot;: &quot;A String&quot;, # Optional. Defaults to FIXED_TYPE.
        &quot;mode&quot;: &quot;A String&quot;, # Optional. Specifies whether the argument is input or output.
            # Can be set for procedures only.
        &quot;dataType&quot;: { # The type of a variable, e.g., a function argument. # Required unless argument_kind = ANY_TYPE.
            # Examples:
            # INT64: {type_kind=&quot;INT64&quot;}
            # ARRAY&lt;STRING&gt;: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;}
            # STRUCT&lt;x STRING, y ARRAY&lt;DATE&gt;&gt;:
            #   {type_kind=&quot;STRUCT&quot;,
            #    struct_type={fields=[
            #      {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}},
            #      {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}}
            #    ]}}
          &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
          &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field.
              # Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
          &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
            &quot;fields&quot;: [
              # Object with schema name: StandardSqlField
            ],
          },
        },
      },
    ],
    &quot;importedLibraries&quot;: [ # Optional. If language = &quot;JAVASCRIPT&quot;, this field stores the path of the
        # imported JAVASCRIPT libraries.
      &quot;A String&quot;,
    ],
    &quot;returnType&quot;: { # The type of a variable, e.g., a function argument. # Optional if language = &quot;SQL&quot;; required otherwise.
        # 
        # If absent, the return type is inferred from definition_body at query time
        # in each query that references this routine. If present, then the evaluated
        # result will be cast to the specified returned type at query time.
        # 
        # For example, for the functions created with the following statements:
        # 
        # * `CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);`
        # 
        # * `CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));`
        # 
        # * `CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));`
        # 
        # The return_type is `{type_kind: &quot;FLOAT64&quot;}` for `Add` and `Decrement`, and
        # is absent for `Increment` (inferred as FLOAT64 at query time).
        # 
        # Suppose the function `Add` is replaced by
        #   `CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);`
        # 
        # Then the inferred return type of `Increment` is automatically changed to
        # INT64 at query time, while the return type of `Decrement` remains FLOAT64.
        # Examples:
        # INT64: {type_kind=&quot;INT64&quot;}
        # ARRAY&lt;STRING&gt;: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;}
        # STRUCT&lt;x STRING, y ARRAY&lt;DATE&gt;&gt;:
        #   {type_kind=&quot;STRUCT&quot;,
        #    struct_type={fields=[
        #      {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}},
        #      {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}}
        #    ]}}
      &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
      &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field.
          # Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
      &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
        &quot;fields&quot;: [
          # Object with schema name: StandardSqlField
        ],
      },
    },
    &quot;language&quot;: &quot;A String&quot;, # Optional. Defaults to &quot;SQL&quot;.
    &quot;lastModifiedTime&quot;: &quot;A String&quot;, # Output only. The time when this routine was last modified, in milliseconds
        # since the epoch.
    &quot;description&quot;: &quot;A String&quot;, # Optional. [Experimental] The description of the routine if defined.
    &quot;etag&quot;: &quot;A String&quot;, # Output only. A hash of this resource.
    &quot;definitionBody&quot;: &quot;A String&quot;, # Required. The body of the routine.
        # 
        # For functions, this is the expression in the AS clause.
        # 
        # If language=SQL, it is the substring inside (but excluding) the
        # parentheses. For example, for the function created with the following
        # statement:
        # 
        # `CREATE FUNCTION JoinLines(x string, y string) as (concat(x, &quot;\n&quot;, y))`
        # 
        # The definition_body is `concat(x, &quot;\n&quot;, y)` (\n is not replaced with
        # linebreak).
        # 
        # If language=JAVASCRIPT, it is the evaluated string in the AS clause.
        # For example, for the function created with the following statement:
        # 
        # `CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS &#x27;return &quot;\n&quot;;\n&#x27;`
        # 
        # The definition_body is
        # 
        # `return &quot;\n&quot;;\n`
        # 
        # Note that both \n are replaced with linebreaks.
    &quot;creationTime&quot;: &quot;A String&quot;, # Output only. The time when this routine was created, in milliseconds since
        # the epoch.
    &quot;routineType&quot;: &quot;A String&quot;, # Required. The type of routine.
    &quot;routineReference&quot;: { # Required. Reference describing the ID of this routine.
      &quot;projectId&quot;: &quot;A String&quot;, # [Required] The ID of the project containing this routine.
      &quot;datasetId&quot;: &quot;A String&quot;, # [Required] The ID of the dataset containing this routine.
      &quot;routineId&quot;: &quot;A String&quot;, # [Required] The ID of the routine. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 256 characters.
    },
  }


Returns:
  An object of the form:

    { # A user-defined function or a stored procedure.
      &quot;arguments&quot;: [ # Optional.
        { # Input/output argument of a function or a stored procedure.
          &quot;name&quot;: &quot;A String&quot;, # Optional. The name of this argument. Can be absent for function return argument.
          &quot;argumentKind&quot;: &quot;A String&quot;, # Optional. Defaults to FIXED_TYPE.
          &quot;mode&quot;: &quot;A String&quot;, # Optional. Specifies whether the argument is input or output.
              # Can be set for procedures only.
          &quot;dataType&quot;: { # The type of a variable, e.g., a function argument. # Required unless argument_kind = ANY_TYPE.
              # Examples:
              # INT64: {type_kind=&quot;INT64&quot;}
              # ARRAY&lt;STRING&gt;: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;}
              # STRUCT&lt;x STRING, y ARRAY&lt;DATE&gt;&gt;:
              #   {type_kind=&quot;STRUCT&quot;,
              #    struct_type={fields=[
              #      {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}},
              #      {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}}
              #    ]}}
            &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
            &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field.
                # Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
            &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
              &quot;fields&quot;: [
                # Object with schema name: StandardSqlField
              ],
            },
          },
        },
      ],
      &quot;importedLibraries&quot;: [ # Optional. If language = &quot;JAVASCRIPT&quot;, this field stores the path of the
          # imported JAVASCRIPT libraries.
        &quot;A String&quot;,
      ],
      &quot;returnType&quot;: { # The type of a variable, e.g., a function argument. # Optional if language = &quot;SQL&quot;; required otherwise.
          #
          # If absent, the return type is inferred from definition_body at query time
          # in each query that references this routine. If present, then the evaluated
          # result will be cast to the specified returned type at query time.
          #
          # For example, for the functions created with the following statements:
          #
          # * `CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);`
          #
          # * `CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));`
          #
          # * `CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));`
          #
          # The return_type is `{type_kind: &quot;FLOAT64&quot;}` for `Add` and `Decrement`, and
          # is absent for `Increment` (inferred as FLOAT64 at query time).
          #
          # Suppose the function `Add` is replaced by
          #   `CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);`
          #
          # Then the inferred return type of `Increment` is automatically changed to
          # INT64 at query time, while the return type of `Decrement` remains FLOAT64.
          # Examples:
          # INT64: {type_kind=&quot;INT64&quot;}
          # ARRAY&lt;STRING&gt;: {type_kind=&quot;ARRAY&quot;, array_element_type=&quot;STRING&quot;}
          # STRUCT&lt;x STRING, y ARRAY&lt;DATE&gt;&gt;:
          #   {type_kind=&quot;STRUCT&quot;,
          #    struct_type={fields=[
          #      {name=&quot;x&quot;, type={type_kind=&quot;STRING&quot;}},
          #      {name=&quot;y&quot;, type={type_kind=&quot;ARRAY&quot;, array_element_type=&quot;DATE&quot;}}
          #    ]}}
        &quot;arrayElementType&quot;: # Object with schema name: StandardSqlDataType # The type of the array&#x27;s elements, if type_kind = &quot;ARRAY&quot;.
        &quot;typeKind&quot;: &quot;A String&quot;, # Required. The top level type of this field.
            # Can be any standard SQL data type (e.g., &quot;INT64&quot;, &quot;DATE&quot;, &quot;ARRAY&quot;).
        &quot;structType&quot;: { # The fields of this struct, in order, if type_kind = &quot;STRUCT&quot;.
          &quot;fields&quot;: [
            # Object with schema name: StandardSqlField
          ],
        },
      },
      &quot;language&quot;: &quot;A String&quot;, # Optional. Defaults to &quot;SQL&quot;.
      &quot;lastModifiedTime&quot;: &quot;A String&quot;, # Output only. The time when this routine was last modified, in milliseconds
          # since the epoch.
      &quot;description&quot;: &quot;A String&quot;, # Optional. [Experimental] The description of the routine if defined.
      &quot;etag&quot;: &quot;A String&quot;, # Output only. A hash of this resource.
      &quot;definitionBody&quot;: &quot;A String&quot;, # Required. The body of the routine.
          #
          # For functions, this is the expression in the AS clause.
          #
          # If language=SQL, it is the substring inside (but excluding) the
          # parentheses. For example, for the function created with the following
          # statement:
          #
          # `CREATE FUNCTION JoinLines(x string, y string) as (concat(x, &quot;\n&quot;, y))`
          #
          # The definition_body is `concat(x, &quot;\n&quot;, y)` (\n is not replaced with
          # linebreak).
          #
          # If language=JAVASCRIPT, it is the evaluated string in the AS clause.
          # For example, for the function created with the following statement:
          #
          # `CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS &#x27;return &quot;\n&quot;;\n&#x27;`
          #
          # The definition_body is
          #
          # `return &quot;\n&quot;;\n`
          #
          # Note that both \n are replaced with linebreaks.
      &quot;creationTime&quot;: &quot;A String&quot;, # Output only. The time when this routine was created, in milliseconds since
          # the epoch.
      &quot;routineType&quot;: &quot;A String&quot;, # Required. The type of routine.
      &quot;routineReference&quot;: { # Required. Reference describing the ID of this routine.
        &quot;projectId&quot;: &quot;A String&quot;, # [Required] The ID of the project containing this routine.
        &quot;datasetId&quot;: &quot;A String&quot;, # [Required] The ID of the dataset containing this routine.
        &quot;routineId&quot;: &quot;A String&quot;, # [Required] The ID of the routine. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 256 characters.
      },
    }</pre>
</div>

</body></html>