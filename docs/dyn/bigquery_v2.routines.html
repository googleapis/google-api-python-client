<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="bigquery_v2.html">BigQuery API</a> . <a href="bigquery_v2.routines.html">routines</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#delete">delete(projectId, datasetId, routineId)</a></code></p>
<p class="firstline">Deletes the routine specified by routineId from the dataset.</p>
<p class="toc_element">
  <code><a href="#get">get(projectId, datasetId, routineId, fieldMask=None)</a></code></p>
<p class="firstline">Gets the specified routine resource by routine ID.</p>
<p class="toc_element">
  <code><a href="#insert">insert(projectId, datasetId, body)</a></code></p>
<p class="firstline">Creates a new routine in the dataset.</p>
<p class="toc_element">
  <code><a href="#list">list(projectId, datasetId, pageToken=None, maxResults=None)</a></code></p>
<p class="firstline">Lists all routines in the specified dataset. Requires the READER dataset</p>
<p class="toc_element">
  <code><a href="#list_next">list_next(previous_request, previous_response)</a></code></p>
<p class="firstline">Retrieves the next page of results.</p>
<p class="toc_element">
  <code><a href="#update">update(projectId, datasetId, routineId, body)</a></code></p>
<p class="firstline">Updates information in an existing routine. The update method replaces the</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="delete">delete(projectId, datasetId, routineId)</code>
  <pre>Deletes the routine specified by routineId from the dataset.

Args:
  projectId: string, Project ID of the routine to delete (required)
  datasetId: string, Dataset ID of the routine to delete (required)
  routineId: string, Routine ID of the routine to delete (required)
</pre>
</div>

<div class="method">
    <code class="details" id="get">get(projectId, datasetId, routineId, fieldMask=None)</code>
  <pre>Gets the specified routine resource by routine ID.

Args:
  projectId: string, Project ID of the requested routine (required)
  datasetId: string, Dataset ID of the requested routine (required)
  routineId: string, Routine ID of the requested routine (required)
  fieldMask: string, If set, only the Routine fields in the field mask are returned in the
response. If unset, all Routine fields are returned.

Returns:
  An object of the form:

    { # A user-defined function or a stored procedure.
      "routineType": "A String", # Required.
      "language": "A String", # Optional. Defaults to "SQL".
      "creationTime": "A String", # Output only. The time when this routine was created, in milliseconds since
          # the epoch.
      "importedLibraries": [ # Optional. If language = "JAVASCRIPT", this field stores the path of the
          # imported JAVASCRIPT libraries.
        "A String",
      ],
      "routineReference": { # Required. Reference describing the ID of this routine.
        "projectId": "A String", # [Required] The ID of the project containing this routine.
        "routineId": "A String", # [Required] The ID of the routine. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 256 characters.
        "datasetId": "A String", # [Required] The ID of the dataset containing this routine.
      },
      "etag": "A String", # Output only. A hash of this resource.
      "arguments": [ # Optional.
        { # Input/output argument of a function or a stored procedure.
          "dataType": { # The type of a variable, e.g., a function argument. # Required unless argument_kind = ANY_TYPE.
              # Examples:
              # INT64: {type_kind="INT64"}
              # ARRAY<STRING>: {type_kind="ARRAY", array_element_type="STRING"}
              # STRUCT<x STRING, y ARRAY<DATE>>:
              #   {type_kind="STRUCT",
              #    struct_type={fields=[
              #      {name="x", type={type_kind="STRING"}},
              #      {name="y", type={type_kind="ARRAY", array_element_type="DATE"}}
              #    ]}}
            "structType": { # The fields of this struct, in order, if type_kind = "STRUCT".
              "fields": [
                # Object with schema name: StandardSqlField
              ],
            },
            "arrayElementType": # Object with schema name: StandardSqlDataType # The type of the array's elements, if type_kind = "ARRAY".
            "typeKind": "A String", # Required. The top level type of this field.
                # Can be any standard SQL data type (e.g., "INT64", "DATE", "ARRAY").
          },
          "argumentKind": "A String", # Optional. Defaults to FIXED_TYPE.
          "mode": "A String", # Optional. Specifies whether the argument is input or output.
              # Can be set for procedures only.
          "name": "A String", # Optional. The name of this argument. Can be absent for function return
              # argument.
        },
      ],
      "returnType": { # The type of a variable, e.g., a function argument. # Optional if language = "SQL"; required otherwise.
          # If absent, the return type is inferred from definition_body at query time
          # in each query that references this routine. If present, then the evaluated
          # result will be cast to the specified returned type at query time.
          #
          # For example, for the functions created with the following statements
          #   CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);
          #   CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));
          #   CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));
          # The return_type is {type_kind: "FLOAT64"} for Add and Decrement, and
          # is absent for Increment (inferred as FLOAT64 at query time).
          # Suppose the function Add is replaced by
          #   CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);
          # Then the inferred return type of Increment is automatically changed to
          # INT64 at query time, while the return type of Decrement remains FLOAT64.
          # Examples:
          # INT64: {type_kind="INT64"}
          # ARRAY<STRING>: {type_kind="ARRAY", array_element_type="STRING"}
          # STRUCT<x STRING, y ARRAY<DATE>>:
          #   {type_kind="STRUCT",
          #    struct_type={fields=[
          #      {name="x", type={type_kind="STRING"}},
          #      {name="y", type={type_kind="ARRAY", array_element_type="DATE"}}
          #    ]}}
        "structType": { # The fields of this struct, in order, if type_kind = "STRUCT".
          "fields": [
            # Object with schema name: StandardSqlField
          ],
        },
        "arrayElementType": # Object with schema name: StandardSqlDataType # The type of the array's elements, if type_kind = "ARRAY".
        "typeKind": "A String", # Required. The top level type of this field.
            # Can be any standard SQL data type (e.g., "INT64", "DATE", "ARRAY").
      },
      "lastModifiedTime": "A String", # Output only. The time when this routine was last modified, in milliseconds
          # since the epoch.
      "definitionBody": "A String", # Required. The body of the routine.
          # For functions, this is the expression in the AS clause.
          # If language=SQL, it is the substring inside (but excluding) the
          # parentheses. For example, for the function created with the following
          # statement
          #   create function JoinLines(x string, y string) as (concat(x, "\n", y))
          # definition_body = r'concat(x, "\n", y)' (\n is not replaced with
          # linebreak).
          # If language=JAVASCRIPT, it is the evaluated string in the AS clause.
          # For example, for the function created with the following statement
          #   CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS 'return "\n";\n'
          # definition_body = 'return "\n";\n' (both \n are replaced with
          # linebreaks).
    }</pre>
</div>

<div class="method">
    <code class="details" id="insert">insert(projectId, datasetId, body)</code>
  <pre>Creates a new routine in the dataset.

Args:
  projectId: string, Project ID of the new routine (required)
  datasetId: string, Dataset ID of the new routine (required)
  body: object, The request body. (required)
    The object takes the form of:

{ # A user-defined function or a stored procedure.
    "routineType": "A String", # Required.
    "language": "A String", # Optional. Defaults to "SQL".
    "creationTime": "A String", # Output only. The time when this routine was created, in milliseconds since
        # the epoch.
    "importedLibraries": [ # Optional. If language = "JAVASCRIPT", this field stores the path of the
        # imported JAVASCRIPT libraries.
      "A String",
    ],
    "routineReference": { # Required. Reference describing the ID of this routine.
      "projectId": "A String", # [Required] The ID of the project containing this routine.
      "routineId": "A String", # [Required] The ID of the routine. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 256 characters.
      "datasetId": "A String", # [Required] The ID of the dataset containing this routine.
    },
    "etag": "A String", # Output only. A hash of this resource.
    "arguments": [ # Optional.
      { # Input/output argument of a function or a stored procedure.
        "dataType": { # The type of a variable, e.g., a function argument. # Required unless argument_kind = ANY_TYPE.
            # Examples:
            # INT64: {type_kind="INT64"}
            # ARRAY<STRING>: {type_kind="ARRAY", array_element_type="STRING"}
            # STRUCT<x STRING, y ARRAY<DATE>>:
            #   {type_kind="STRUCT",
            #    struct_type={fields=[
            #      {name="x", type={type_kind="STRING"}},
            #      {name="y", type={type_kind="ARRAY", array_element_type="DATE"}}
            #    ]}}
          "structType": { # The fields of this struct, in order, if type_kind = "STRUCT".
            "fields": [
              # Object with schema name: StandardSqlField
            ],
          },
          "arrayElementType": # Object with schema name: StandardSqlDataType # The type of the array's elements, if type_kind = "ARRAY".
          "typeKind": "A String", # Required. The top level type of this field.
              # Can be any standard SQL data type (e.g., "INT64", "DATE", "ARRAY").
        },
        "argumentKind": "A String", # Optional. Defaults to FIXED_TYPE.
        "mode": "A String", # Optional. Specifies whether the argument is input or output.
            # Can be set for procedures only.
        "name": "A String", # Optional. The name of this argument. Can be absent for function return
            # argument.
      },
    ],
    "returnType": { # The type of a variable, e.g., a function argument. # Optional if language = "SQL"; required otherwise.
        # If absent, the return type is inferred from definition_body at query time
        # in each query that references this routine. If present, then the evaluated
        # result will be cast to the specified returned type at query time.
        # 
        # For example, for the functions created with the following statements
        #   CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);
        #   CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));
        #   CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));
        # The return_type is {type_kind: "FLOAT64"} for Add and Decrement, and
        # is absent for Increment (inferred as FLOAT64 at query time).
        # Suppose the function Add is replaced by
        #   CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);
        # Then the inferred return type of Increment is automatically changed to
        # INT64 at query time, while the return type of Decrement remains FLOAT64.
        # Examples:
        # INT64: {type_kind="INT64"}
        # ARRAY<STRING>: {type_kind="ARRAY", array_element_type="STRING"}
        # STRUCT<x STRING, y ARRAY<DATE>>:
        #   {type_kind="STRUCT",
        #    struct_type={fields=[
        #      {name="x", type={type_kind="STRING"}},
        #      {name="y", type={type_kind="ARRAY", array_element_type="DATE"}}
        #    ]}}
      "structType": { # The fields of this struct, in order, if type_kind = "STRUCT".
        "fields": [
          # Object with schema name: StandardSqlField
        ],
      },
      "arrayElementType": # Object with schema name: StandardSqlDataType # The type of the array's elements, if type_kind = "ARRAY".
      "typeKind": "A String", # Required. The top level type of this field.
          # Can be any standard SQL data type (e.g., "INT64", "DATE", "ARRAY").
    },
    "lastModifiedTime": "A String", # Output only. The time when this routine was last modified, in milliseconds
        # since the epoch.
    "definitionBody": "A String", # Required. The body of the routine.
        # For functions, this is the expression in the AS clause.
        # If language=SQL, it is the substring inside (but excluding) the
        # parentheses. For example, for the function created with the following
        # statement
        #   create function JoinLines(x string, y string) as (concat(x, "\n", y))
        # definition_body = r'concat(x, "\n", y)' (\n is not replaced with
        # linebreak).
        # If language=JAVASCRIPT, it is the evaluated string in the AS clause.
        # For example, for the function created with the following statement
        #   CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS 'return "\n";\n'
        # definition_body = 'return "\n";\n' (both \n are replaced with
        # linebreaks).
  }


Returns:
  An object of the form:

    { # A user-defined function or a stored procedure.
      "routineType": "A String", # Required.
      "language": "A String", # Optional. Defaults to "SQL".
      "creationTime": "A String", # Output only. The time when this routine was created, in milliseconds since
          # the epoch.
      "importedLibraries": [ # Optional. If language = "JAVASCRIPT", this field stores the path of the
          # imported JAVASCRIPT libraries.
        "A String",
      ],
      "routineReference": { # Required. Reference describing the ID of this routine.
        "projectId": "A String", # [Required] The ID of the project containing this routine.
        "routineId": "A String", # [Required] The ID of the routine. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 256 characters.
        "datasetId": "A String", # [Required] The ID of the dataset containing this routine.
      },
      "etag": "A String", # Output only. A hash of this resource.
      "arguments": [ # Optional.
        { # Input/output argument of a function or a stored procedure.
          "dataType": { # The type of a variable, e.g., a function argument. # Required unless argument_kind = ANY_TYPE.
              # Examples:
              # INT64: {type_kind="INT64"}
              # ARRAY<STRING>: {type_kind="ARRAY", array_element_type="STRING"}
              # STRUCT<x STRING, y ARRAY<DATE>>:
              #   {type_kind="STRUCT",
              #    struct_type={fields=[
              #      {name="x", type={type_kind="STRING"}},
              #      {name="y", type={type_kind="ARRAY", array_element_type="DATE"}}
              #    ]}}
            "structType": { # The fields of this struct, in order, if type_kind = "STRUCT".
              "fields": [
                # Object with schema name: StandardSqlField
              ],
            },
            "arrayElementType": # Object with schema name: StandardSqlDataType # The type of the array's elements, if type_kind = "ARRAY".
            "typeKind": "A String", # Required. The top level type of this field.
                # Can be any standard SQL data type (e.g., "INT64", "DATE", "ARRAY").
          },
          "argumentKind": "A String", # Optional. Defaults to FIXED_TYPE.
          "mode": "A String", # Optional. Specifies whether the argument is input or output.
              # Can be set for procedures only.
          "name": "A String", # Optional. The name of this argument. Can be absent for function return
              # argument.
        },
      ],
      "returnType": { # The type of a variable, e.g., a function argument. # Optional if language = "SQL"; required otherwise.
          # If absent, the return type is inferred from definition_body at query time
          # in each query that references this routine. If present, then the evaluated
          # result will be cast to the specified returned type at query time.
          #
          # For example, for the functions created with the following statements
          #   CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);
          #   CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));
          #   CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));
          # The return_type is {type_kind: "FLOAT64"} for Add and Decrement, and
          # is absent for Increment (inferred as FLOAT64 at query time).
          # Suppose the function Add is replaced by
          #   CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);
          # Then the inferred return type of Increment is automatically changed to
          # INT64 at query time, while the return type of Decrement remains FLOAT64.
          # Examples:
          # INT64: {type_kind="INT64"}
          # ARRAY<STRING>: {type_kind="ARRAY", array_element_type="STRING"}
          # STRUCT<x STRING, y ARRAY<DATE>>:
          #   {type_kind="STRUCT",
          #    struct_type={fields=[
          #      {name="x", type={type_kind="STRING"}},
          #      {name="y", type={type_kind="ARRAY", array_element_type="DATE"}}
          #    ]}}
        "structType": { # The fields of this struct, in order, if type_kind = "STRUCT".
          "fields": [
            # Object with schema name: StandardSqlField
          ],
        },
        "arrayElementType": # Object with schema name: StandardSqlDataType # The type of the array's elements, if type_kind = "ARRAY".
        "typeKind": "A String", # Required. The top level type of this field.
            # Can be any standard SQL data type (e.g., "INT64", "DATE", "ARRAY").
      },
      "lastModifiedTime": "A String", # Output only. The time when this routine was last modified, in milliseconds
          # since the epoch.
      "definitionBody": "A String", # Required. The body of the routine.
          # For functions, this is the expression in the AS clause.
          # If language=SQL, it is the substring inside (but excluding) the
          # parentheses. For example, for the function created with the following
          # statement
          #   create function JoinLines(x string, y string) as (concat(x, "\n", y))
          # definition_body = r'concat(x, "\n", y)' (\n is not replaced with
          # linebreak).
          # If language=JAVASCRIPT, it is the evaluated string in the AS clause.
          # For example, for the function created with the following statement
          #   CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS 'return "\n";\n'
          # definition_body = 'return "\n";\n' (both \n are replaced with
          # linebreaks).
    }</pre>
</div>

<div class="method">
    <code class="details" id="list">list(projectId, datasetId, pageToken=None, maxResults=None)</code>
  <pre>Lists all routines in the specified dataset. Requires the READER dataset
role.

Args:
  projectId: string, Project ID of the routines to list (required)
  datasetId: string, Dataset ID of the routines to list (required)
  pageToken: string, Page token, returned by a previous call, to request the next page of
results
  maxResults: integer, The maximum number of results per page.

Returns:
  An object of the form:

    {
    "nextPageToken": "A String", # A token to request the next page of results.
    "routines": [ # Routines in the requested dataset. Only the following fields are populated:
        # etag, project_id, dataset_id, routine_id, routine_type, creation_time,
        # last_modified_time, language.
      { # A user-defined function or a stored procedure.
          "routineType": "A String", # Required.
          "language": "A String", # Optional. Defaults to "SQL".
          "creationTime": "A String", # Output only. The time when this routine was created, in milliseconds since
              # the epoch.
          "importedLibraries": [ # Optional. If language = "JAVASCRIPT", this field stores the path of the
              # imported JAVASCRIPT libraries.
            "A String",
          ],
          "routineReference": { # Required. Reference describing the ID of this routine.
            "projectId": "A String", # [Required] The ID of the project containing this routine.
            "routineId": "A String", # [Required] The ID of the routine. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 256 characters.
            "datasetId": "A String", # [Required] The ID of the dataset containing this routine.
          },
          "etag": "A String", # Output only. A hash of this resource.
          "arguments": [ # Optional.
            { # Input/output argument of a function or a stored procedure.
              "dataType": { # The type of a variable, e.g., a function argument. # Required unless argument_kind = ANY_TYPE.
                  # Examples:
                  # INT64: {type_kind="INT64"}
                  # ARRAY<STRING>: {type_kind="ARRAY", array_element_type="STRING"}
                  # STRUCT<x STRING, y ARRAY<DATE>>:
                  #   {type_kind="STRUCT",
                  #    struct_type={fields=[
                  #      {name="x", type={type_kind="STRING"}},
                  #      {name="y", type={type_kind="ARRAY", array_element_type="DATE"}}
                  #    ]}}
                "structType": { # The fields of this struct, in order, if type_kind = "STRUCT".
                  "fields": [
                    # Object with schema name: StandardSqlField
                  ],
                },
                "arrayElementType": # Object with schema name: StandardSqlDataType # The type of the array's elements, if type_kind = "ARRAY".
                "typeKind": "A String", # Required. The top level type of this field.
                    # Can be any standard SQL data type (e.g., "INT64", "DATE", "ARRAY").
              },
              "argumentKind": "A String", # Optional. Defaults to FIXED_TYPE.
              "mode": "A String", # Optional. Specifies whether the argument is input or output.
                  # Can be set for procedures only.
              "name": "A String", # Optional. The name of this argument. Can be absent for function return
                  # argument.
            },
          ],
          "returnType": { # The type of a variable, e.g., a function argument. # Optional if language = "SQL"; required otherwise.
              # If absent, the return type is inferred from definition_body at query time
              # in each query that references this routine. If present, then the evaluated
              # result will be cast to the specified returned type at query time.
              #
              # For example, for the functions created with the following statements
              #   CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);
              #   CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));
              #   CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));
              # The return_type is {type_kind: "FLOAT64"} for Add and Decrement, and
              # is absent for Increment (inferred as FLOAT64 at query time).
              # Suppose the function Add is replaced by
              #   CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);
              # Then the inferred return type of Increment is automatically changed to
              # INT64 at query time, while the return type of Decrement remains FLOAT64.
              # Examples:
              # INT64: {type_kind="INT64"}
              # ARRAY<STRING>: {type_kind="ARRAY", array_element_type="STRING"}
              # STRUCT<x STRING, y ARRAY<DATE>>:
              #   {type_kind="STRUCT",
              #    struct_type={fields=[
              #      {name="x", type={type_kind="STRING"}},
              #      {name="y", type={type_kind="ARRAY", array_element_type="DATE"}}
              #    ]}}
            "structType": { # The fields of this struct, in order, if type_kind = "STRUCT".
              "fields": [
                # Object with schema name: StandardSqlField
              ],
            },
            "arrayElementType": # Object with schema name: StandardSqlDataType # The type of the array's elements, if type_kind = "ARRAY".
            "typeKind": "A String", # Required. The top level type of this field.
                # Can be any standard SQL data type (e.g., "INT64", "DATE", "ARRAY").
          },
          "lastModifiedTime": "A String", # Output only. The time when this routine was last modified, in milliseconds
              # since the epoch.
          "definitionBody": "A String", # Required. The body of the routine.
              # For functions, this is the expression in the AS clause.
              # If language=SQL, it is the substring inside (but excluding) the
              # parentheses. For example, for the function created with the following
              # statement
              #   create function JoinLines(x string, y string) as (concat(x, "\n", y))
              # definition_body = r'concat(x, "\n", y)' (\n is not replaced with
              # linebreak).
              # If language=JAVASCRIPT, it is the evaluated string in the AS clause.
              # For example, for the function created with the following statement
              #   CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS 'return "\n";\n'
              # definition_body = 'return "\n";\n' (both \n are replaced with
              # linebreaks).
        },
    ],
  }</pre>
</div>

<div class="method">
    <code class="details" id="list_next">list_next(previous_request, previous_response)</code>
  <pre>Retrieves the next page of results.

Args:
  previous_request: The request for the previous page. (required)
  previous_response: The response from the request for the previous page. (required)

Returns:
  A request object that you can call 'execute()' on to request the next
  page. Returns None if there are no more items in the collection.
    </pre>
</div>

<div class="method">
    <code class="details" id="update">update(projectId, datasetId, routineId, body)</code>
  <pre>Updates information in an existing routine. The update method replaces the
entire Routine resource.

Args:
  projectId: string, Project ID of the routine to update (required)
  datasetId: string, Dataset ID of the routine to update (required)
  routineId: string, Routine ID of the routine to update (required)
  body: object, The request body. (required)
    The object takes the form of:

{ # A user-defined function or a stored procedure.
    "routineType": "A String", # Required.
    "language": "A String", # Optional. Defaults to "SQL".
    "creationTime": "A String", # Output only. The time when this routine was created, in milliseconds since
        # the epoch.
    "importedLibraries": [ # Optional. If language = "JAVASCRIPT", this field stores the path of the
        # imported JAVASCRIPT libraries.
      "A String",
    ],
    "routineReference": { # Required. Reference describing the ID of this routine.
      "projectId": "A String", # [Required] The ID of the project containing this routine.
      "routineId": "A String", # [Required] The ID of the routine. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 256 characters.
      "datasetId": "A String", # [Required] The ID of the dataset containing this routine.
    },
    "etag": "A String", # Output only. A hash of this resource.
    "arguments": [ # Optional.
      { # Input/output argument of a function or a stored procedure.
        "dataType": { # The type of a variable, e.g., a function argument. # Required unless argument_kind = ANY_TYPE.
            # Examples:
            # INT64: {type_kind="INT64"}
            # ARRAY<STRING>: {type_kind="ARRAY", array_element_type="STRING"}
            # STRUCT<x STRING, y ARRAY<DATE>>:
            #   {type_kind="STRUCT",
            #    struct_type={fields=[
            #      {name="x", type={type_kind="STRING"}},
            #      {name="y", type={type_kind="ARRAY", array_element_type="DATE"}}
            #    ]}}
          "structType": { # The fields of this struct, in order, if type_kind = "STRUCT".
            "fields": [
              # Object with schema name: StandardSqlField
            ],
          },
          "arrayElementType": # Object with schema name: StandardSqlDataType # The type of the array's elements, if type_kind = "ARRAY".
          "typeKind": "A String", # Required. The top level type of this field.
              # Can be any standard SQL data type (e.g., "INT64", "DATE", "ARRAY").
        },
        "argumentKind": "A String", # Optional. Defaults to FIXED_TYPE.
        "mode": "A String", # Optional. Specifies whether the argument is input or output.
            # Can be set for procedures only.
        "name": "A String", # Optional. The name of this argument. Can be absent for function return
            # argument.
      },
    ],
    "returnType": { # The type of a variable, e.g., a function argument. # Optional if language = "SQL"; required otherwise.
        # If absent, the return type is inferred from definition_body at query time
        # in each query that references this routine. If present, then the evaluated
        # result will be cast to the specified returned type at query time.
        # 
        # For example, for the functions created with the following statements
        #   CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);
        #   CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));
        #   CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));
        # The return_type is {type_kind: "FLOAT64"} for Add and Decrement, and
        # is absent for Increment (inferred as FLOAT64 at query time).
        # Suppose the function Add is replaced by
        #   CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);
        # Then the inferred return type of Increment is automatically changed to
        # INT64 at query time, while the return type of Decrement remains FLOAT64.
        # Examples:
        # INT64: {type_kind="INT64"}
        # ARRAY<STRING>: {type_kind="ARRAY", array_element_type="STRING"}
        # STRUCT<x STRING, y ARRAY<DATE>>:
        #   {type_kind="STRUCT",
        #    struct_type={fields=[
        #      {name="x", type={type_kind="STRING"}},
        #      {name="y", type={type_kind="ARRAY", array_element_type="DATE"}}
        #    ]}}
      "structType": { # The fields of this struct, in order, if type_kind = "STRUCT".
        "fields": [
          # Object with schema name: StandardSqlField
        ],
      },
      "arrayElementType": # Object with schema name: StandardSqlDataType # The type of the array's elements, if type_kind = "ARRAY".
      "typeKind": "A String", # Required. The top level type of this field.
          # Can be any standard SQL data type (e.g., "INT64", "DATE", "ARRAY").
    },
    "lastModifiedTime": "A String", # Output only. The time when this routine was last modified, in milliseconds
        # since the epoch.
    "definitionBody": "A String", # Required. The body of the routine.
        # For functions, this is the expression in the AS clause.
        # If language=SQL, it is the substring inside (but excluding) the
        # parentheses. For example, for the function created with the following
        # statement
        #   create function JoinLines(x string, y string) as (concat(x, "\n", y))
        # definition_body = r'concat(x, "\n", y)' (\n is not replaced with
        # linebreak).
        # If language=JAVASCRIPT, it is the evaluated string in the AS clause.
        # For example, for the function created with the following statement
        #   CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS 'return "\n";\n'
        # definition_body = 'return "\n";\n' (both \n are replaced with
        # linebreaks).
  }


Returns:
  An object of the form:

    { # A user-defined function or a stored procedure.
      "routineType": "A String", # Required.
      "language": "A String", # Optional. Defaults to "SQL".
      "creationTime": "A String", # Output only. The time when this routine was created, in milliseconds since
          # the epoch.
      "importedLibraries": [ # Optional. If language = "JAVASCRIPT", this field stores the path of the
          # imported JAVASCRIPT libraries.
        "A String",
      ],
      "routineReference": { # Required. Reference describing the ID of this routine.
        "projectId": "A String", # [Required] The ID of the project containing this routine.
        "routineId": "A String", # [Required] The ID of the routine. The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum length is 256 characters.
        "datasetId": "A String", # [Required] The ID of the dataset containing this routine.
      },
      "etag": "A String", # Output only. A hash of this resource.
      "arguments": [ # Optional.
        { # Input/output argument of a function or a stored procedure.
          "dataType": { # The type of a variable, e.g., a function argument. # Required unless argument_kind = ANY_TYPE.
              # Examples:
              # INT64: {type_kind="INT64"}
              # ARRAY<STRING>: {type_kind="ARRAY", array_element_type="STRING"}
              # STRUCT<x STRING, y ARRAY<DATE>>:
              #   {type_kind="STRUCT",
              #    struct_type={fields=[
              #      {name="x", type={type_kind="STRING"}},
              #      {name="y", type={type_kind="ARRAY", array_element_type="DATE"}}
              #    ]}}
            "structType": { # The fields of this struct, in order, if type_kind = "STRUCT".
              "fields": [
                # Object with schema name: StandardSqlField
              ],
            },
            "arrayElementType": # Object with schema name: StandardSqlDataType # The type of the array's elements, if type_kind = "ARRAY".
            "typeKind": "A String", # Required. The top level type of this field.
                # Can be any standard SQL data type (e.g., "INT64", "DATE", "ARRAY").
          },
          "argumentKind": "A String", # Optional. Defaults to FIXED_TYPE.
          "mode": "A String", # Optional. Specifies whether the argument is input or output.
              # Can be set for procedures only.
          "name": "A String", # Optional. The name of this argument. Can be absent for function return
              # argument.
        },
      ],
      "returnType": { # The type of a variable, e.g., a function argument. # Optional if language = "SQL"; required otherwise.
          # If absent, the return type is inferred from definition_body at query time
          # in each query that references this routine. If present, then the evaluated
          # result will be cast to the specified returned type at query time.
          #
          # For example, for the functions created with the following statements
          #   CREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);
          #   CREATE FUNCTION Increment(x FLOAT64) AS (Add(x, 1));
          #   CREATE FUNCTION Decrement(x FLOAT64) RETURNS FLOAT64 AS (Add(x, -1));
          # The return_type is {type_kind: "FLOAT64"} for Add and Decrement, and
          # is absent for Increment (inferred as FLOAT64 at query time).
          # Suppose the function Add is replaced by
          #   CREATE OR REPLACE FUNCTION Add(x INT64, y INT64) AS (x + y);
          # Then the inferred return type of Increment is automatically changed to
          # INT64 at query time, while the return type of Decrement remains FLOAT64.
          # Examples:
          # INT64: {type_kind="INT64"}
          # ARRAY<STRING>: {type_kind="ARRAY", array_element_type="STRING"}
          # STRUCT<x STRING, y ARRAY<DATE>>:
          #   {type_kind="STRUCT",
          #    struct_type={fields=[
          #      {name="x", type={type_kind="STRING"}},
          #      {name="y", type={type_kind="ARRAY", array_element_type="DATE"}}
          #    ]}}
        "structType": { # The fields of this struct, in order, if type_kind = "STRUCT".
          "fields": [
            # Object with schema name: StandardSqlField
          ],
        },
        "arrayElementType": # Object with schema name: StandardSqlDataType # The type of the array's elements, if type_kind = "ARRAY".
        "typeKind": "A String", # Required. The top level type of this field.
            # Can be any standard SQL data type (e.g., "INT64", "DATE", "ARRAY").
      },
      "lastModifiedTime": "A String", # Output only. The time when this routine was last modified, in milliseconds
          # since the epoch.
      "definitionBody": "A String", # Required. The body of the routine.
          # For functions, this is the expression in the AS clause.
          # If language=SQL, it is the substring inside (but excluding) the
          # parentheses. For example, for the function created with the following
          # statement
          #   create function JoinLines(x string, y string) as (concat(x, "\n", y))
          # definition_body = r'concat(x, "\n", y)' (\n is not replaced with
          # linebreak).
          # If language=JAVASCRIPT, it is the evaluated string in the AS clause.
          # For example, for the function created with the following statement
          #   CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS 'return "\n";\n'
          # definition_body = 'return "\n";\n' (both \n are replaced with
          # linebreaks).
    }</pre>
</div>

</body></html>