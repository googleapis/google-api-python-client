<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="containeranalysis_v1beta1.html">Container Analysis API</a> . <a href="containeranalysis_v1beta1.projects.html">projects</a> . <a href="containeranalysis_v1beta1.projects.notes.html">notes</a> . <a href="containeranalysis_v1beta1.projects.notes.occurrences.html">occurrences</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#list">list(name, pageToken=None, x__xgafv=None, pageSize=None, filter=None)</a></code></p>
<p class="firstline">Lists occurrences referencing the specified note. Provider projects can use</p>
<p class="toc_element">
  <code><a href="#list_next">list_next(previous_request, previous_response)</a></code></p>
<p class="firstline">Retrieves the next page of results.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="list">list(name, pageToken=None, x__xgafv=None, pageSize=None, filter=None)</code>
  <pre>Lists occurrences referencing the specified note. Provider projects can use
this method to get all occurrences across consumer projects referencing the
specified note.

Args:
  name: string, The name of the note to list occurrences for in the form of
`projects/[PROVIDER_ID]/notes/[NOTE_ID]`. (required)
  pageToken: string, Token to provide to skip to a particular spot in the list.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format
  pageSize: integer, Number of occurrences to return in the list.
  filter: string, The filter expression.

Returns:
  An object of the form:

    { # Response for listing occurrences for a note.
    "nextPageToken": "A String", # Token to provide to skip to a particular spot in the list.
    "occurrences": [ # The occurrences attached to the specified note.
      { # An instance of an analysis type that has been found on a resource.
        "kind": "A String", # Output only. This explicitly denotes which of the occurrence details are
            # specified. This field can be used as a filter in list requests.
        "resource": { # An entity that can have metadata. For example, a Docker image. # Required. Immutable. The resource for which the occurrence applies.
          "contentHash": { # Container message for hash values. # Deprecated, do not use. Use uri instead.
              #
              # The hash of the resource content. For example, the Docker digest.
            "type": "A String", # Required. The type of hash that was performed.
            "value": "A String", # Required. The hash value.
          },
          "uri": "A String", # Required. The unique URI of the resource. For example,
              # `https://gcr.io/project/image@sha256:foo` for a Docker image.
          "name": "A String", # Deprecated, do not use. Use uri instead.
              #
              # The name of the resource. For example, the name of a Docker image -
              # "Debian".
        },
        "name": "A String", # Output only. The name of the occurrence in the form of
            # `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
        "vulnerability": { # Details of a vulnerability Occurrence. # Describes a security vulnerability.
          "cvssScore": 3.14, # Output only. The CVSS score of this vulnerability. CVSS score is on a
              # scale of 0-10 where 0 indicates low severity and 10 indicates high
              # severity.
          "severity": "A String", # Output only. The note provider assigned Severity of the vulnerability.
          "type": "A String", # The type of package; whether native or non native(ruby gems, node.js
              # packages etc)
          "effectiveSeverity": "A String", # The distro assigned severity for this vulnerability when it is
              # available, and note provider assigned severity when distro has not yet
              # assigned a severity for this vulnerability.
          "relatedUrls": [ # Output only. URLs related to this vulnerability.
            { # Metadata for any related URL information.
              "url": "A String", # Specific URL associated with the resource.
              "label": "A String", # Label to describe usage of the URL.
            },
          ],
          "packageIssue": [ # Required. The set of affected locations and their fixes (if available)
              # within the associated resource.
            { # This message wraps a location affected by a vulnerability and its
                # associated fix (if one is available).
              "severityName": "A String", # Deprecated, use Details.effective_severity instead
                  # The severity (e.g., distro assigned severity) for this vulnerability.
              "affectedLocation": { # The location of the vulnerability. # Required. The location of the vulnerability.
                "cpeUri": "A String", # Required. The CPE URI in [cpe format](https://cpe.mitre.org/specification/)
                    # format. Examples include distro or storage location for vulnerable jar.
                "version": { # Version contains structured information about the version of a package. # Required. The version of the package being described.
                  "epoch": 42, # Used to correct mistakes in the version numbering scheme.
                  "kind": "A String", # Required. Distinguishes between sentinel MIN/MAX versions and normal
                      # versions.
                  "name": "A String", # Required only when version kind is NORMAL. The main part of the version
                      # name.
                  "revision": "A String", # The iteration of the package build from the above version.
                },
                "package": "A String", # Required. The package being described.
              },
              "fixedLocation": { # The location of the vulnerability. # The location of the available fix for vulnerability.
                "cpeUri": "A String", # Required. The CPE URI in [cpe format](https://cpe.mitre.org/specification/)
                    # format. Examples include distro or storage location for vulnerable jar.
                "version": { # Version contains structured information about the version of a package. # Required. The version of the package being described.
                  "epoch": 42, # Used to correct mistakes in the version numbering scheme.
                  "kind": "A String", # Required. Distinguishes between sentinel MIN/MAX versions and normal
                      # versions.
                  "name": "A String", # Required only when version kind is NORMAL. The main part of the version
                      # name.
                  "revision": "A String", # The iteration of the package build from the above version.
                },
                "package": "A String", # Required. The package being described.
              },
            },
          ],
          "longDescription": "A String", # Output only. A detailed description of this vulnerability.
          "shortDescription": "A String", # Output only. A one sentence description of this vulnerability.
        },
        "updateTime": "A String", # Output only. The time this occurrence was last updated.
        "discovered": { # Details of a discovery occurrence. # Describes when a resource was discovered.
          "discovered": { # Provides information about the analysis status of a discovered resource. # Required. Analysis status for the discovered resource.
            "lastAnalysisTime": "A String", # The last time continuous analysis was done for this resource.
                # Deprecated, do not use.
            "analysisStatus": "A String", # The status of discovery for the resource.
            "continuousAnalysis": "A String", # Whether the resource is continuously analyzed.
            "analysisStatusError": { # The `Status` type defines a logical error model that is suitable for # When an error is encountered this will contain a LocalizedMessage under
                # details to show to the user. The LocalizedMessage is output only and
                # populated by the API.
                # different programming environments, including REST APIs and RPC APIs. It is
                # used by [gRPC](https://github.com/grpc). Each `Status` message contains
                # three pieces of data: error code, error message, and error details.
                #
                # You can find out more about this error model and how to work with it in the
                # [API Design Guide](https://cloud.google.com/apis/design/errors).
              "message": "A String", # A developer-facing error message, which should be in English. Any
                  # user-facing error message should be localized and sent in the
                  # google.rpc.Status.details field, or localized by the client.
              "code": 42, # The status code, which should be an enum value of google.rpc.Code.
              "details": [ # A list of messages that carry the error details.  There is a common set of
                  # message types for APIs to use.
                {
                  "a_key": "", # Properties of the object. Contains field @type with type URL.
                },
              ],
            },
          },
        },
        "attestation": { # Details of an attestation occurrence. # Describes an attestation of an artifact.
          "attestation": { # Occurrence that represents a single "attestation". The authenticity of an # Required. Attestation for the resource.
              # attestation can be verified using the attached signature. If the verifier
              # trusts the public key of the signer, then verifying the signature is
              # sufficient to establish trust. In this circumstance, the authority to which
              # this attestation is attached is primarily useful for look-up (how to find
              # this attestation if you already know the authority and artifact to be
              # verified) and intent (which authority was this attestation intended to sign
              # for).
            "pgpSignedAttestation": { # An attestation wrapper with a PGP-compatible signature. This message only # A PGP signed attestation.
                # supports `ATTACHED` signatures, where the payload that is signed is included
                # alongside the signature itself in the same file.
              "pgpKeyId": "A String", # The cryptographic fingerprint of the key used to generate the signature,
                  # as output by, e.g. `gpg --list-keys`. This should be the version 4, full
                  # 160-bit fingerprint, expressed as a 40 character hexidecimal string. See
                  # https://tools.ietf.org/html/rfc4880#section-12.2 for details.
                  # Implementations may choose to acknowledge "LONG", "SHORT", or other
                  # abbreviated key IDs, but only the full fingerprint is guaranteed to work.
                  # In gpg, the full fingerprint can be retrieved from the `fpr` field
                  # returned when calling --list-keys with --with-colons.  For example:
                  # ```
                  # gpg --with-colons --with-fingerprint --force-v4-certs \
                  #     --list-keys attester@example.com
                  # tru::1:1513631572:0:3:1:5
                  # pub:...<SNIP>...
                  # fpr:::::::::24FF6481B76AC91E66A00AC657A93A81EF3AE6FB:
                  # ```
                  # Above, the fingerprint is `24FF6481B76AC91E66A00AC657A93A81EF3AE6FB`.
              "contentType": "A String", # Type (for example schema) of the attestation payload that was signed.
                  # The verifier must ensure that the provided type is one that the verifier
                  # supports, and that the attestation payload is a valid instantiation of that
                  # type (for example by validating a JSON schema).
              "signature": "A String", # Required. The raw content of the signature, as output by GNU Privacy Guard
                  # (GPG) or equivalent. Since this message only supports attached signatures,
                  # the payload that was signed must be attached. While the signature format
                  # supported is dependent on the verification implementation, currently only
                  # ASCII-armored (`--armor` to gpg), non-clearsigned (`--sign` rather than
                  # `--clearsign` to gpg) are supported. Concretely, `gpg --sign --armor
                  # --output=signature.gpg payload.json` will create the signature content
                  # expected in this field in `signature.gpg` for the `payload.json`
                  # attestation payload.
            },
            "genericSignedAttestation": { # An attestation wrapper that uses the Grafeas `Signature` message.
                # This attestation must define the `serialized_payload` that the `signatures`
                # verify and any metadata necessary to interpret that plaintext.  The
                # signatures should always be over the `serialized_payload` bytestring.
              "signatures": [ # One or more signatures over `serialized_payload`.  Verifier implementations
                  # should consider this attestation message verified if at least one
                  # `signature` verifies `serialized_payload`.  See `Signature` in common.proto
                  # for more details on signature structure and verification.
                { # Verifiers (e.g. Kritis implementations) MUST verify signatures
                    # with respect to the trust anchors defined in policy (e.g. a Kritis policy).
                    # Typically this means that the verifier has been configured with a map from
                    # `public_key_id` to public key material (and any required parameters, e.g.
                    # signing algorithm).
                    #
                    # In particular, verification implementations MUST NOT treat the signature
                    # `public_key_id` as anything more than a key lookup hint. The `public_key_id`
                    # DOES NOT validate or authenticate a public key; it only provides a mechanism
                    # for quickly selecting a public key ALREADY CONFIGURED on the verifier through
                    # a trusted channel. Verification implementations MUST reject signatures in any
                    # of the following circumstances:
                    #   * The `public_key_id` is not recognized by the verifier.
                    #   * The public key that `public_key_id` refers to does not verify the
                    #     signature with respect to the payload.
                    #
                    # The `signature` contents SHOULD NOT be "attached" (where the payload is
                    # included with the serialized `signature` bytes). Verifiers MUST ignore any
                    # "attached" payload and only verify signatures with respect to explicitly
                    # provided payload (e.g. a `payload` field on the proto message that holds
                    # this Signature, or the canonical serialization of the proto message that
                    # holds this signature).
                  "publicKeyId": "A String", # The identifier for the public key that verifies this signature.
                      #   * The `public_key_id` is required.
                      #   * The `public_key_id` MUST be an RFC3986 conformant URI.
                      #   * When possible, the `public_key_id` SHOULD be an immutable reference,
                      #     such as a cryptographic digest.
                      #
                      # Examples of valid `public_key_id`s:
                      #
                      # OpenPGP V4 public key fingerprint:
                      #   * "openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA"
                      # See https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr for more
                      # details on this scheme.
                      #
                      # RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER
                      # serialization):
                      #   * "ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU"
                      #   * "nih:///sha-256;703f68f42aba2c6de30f488a5ea122fef76324679c9bf89791ba95a1271589a5"
                  "signature": "A String", # The content of the signature, an opaque bytestring.
                      # The payload that this signature verifies MUST be unambiguously provided
                      # with the Signature during verification. A wrapper message might provide
                      # the payload explicitly. Alternatively, a message might have a canonical
                      # serialization that can always be unambiguously computed to derive the
                      # payload.
                },
              ],
              "contentType": "A String", # Type (for example schema) of the attestation payload that was signed.
                  # The verifier must ensure that the provided type is one that the verifier
                  # supports, and that the attestation payload is a valid instantiation of that
                  # type (for example by validating a JSON schema).
              "serializedPayload": "A String", # The serialized payload that is verified by one or more `signatures`.
                  # The encoding and semantic meaning of this payload must match what is set in
                  # `content_type`.
            },
          },
        },
        "build": { # Details of a build occurrence. # Describes a verifiable build.
          "provenance": { # Provenance of a build. Contains all information needed to verify the full # Required. The actual provenance for the build.
              # details about the build from source to completion.
            "commands": [ # Commands requested by the build.
              { # Command describes a step performed as part of the build pipeline.
                "waitFor": [ # The ID(s) of the command(s) that this command depends on.
                  "A String",
                ],
                "name": "A String", # Required. Name of the command, as presented on the command line, or if the
                    # command is packaged as a Docker container, as presented to `docker pull`.
                "args": [ # Command-line arguments used when executing this command.
                  "A String",
                ],
                "env": [ # Environment variables set before running this command.
                  "A String",
                ],
                "id": "A String", # Optional unique identifier for this command, used in wait_for to reference
                    # this command as a dependency.
                "dir": "A String", # Working directory (relative to project source root) used when running this
                    # command.
              },
            ],
            "sourceProvenance": { # Source describes the location of the source used for the build. # Details of the Source input to the build.
              "fileHashes": { # Hash(es) of the build source, which can be used to verify that the original
                  # source integrity was maintained in the build.
                  #
                  # The keys to this map are file paths used as build source and the values
                  # contain the hash values for those files.
                  #
                  # If the build source came in a single package such as a gzipped tarfile
                  # (.tar.gz), the FileHash will be for the single path to that file.
                "a_key": { # Container message for hashes of byte content of files, used in source
                    # messages to verify integrity of source input to the build.
                  "fileHash": [ # Required. Collection of file hashes.
                    { # Container message for hash values.
                      "type": "A String", # Required. The type of hash that was performed.
                      "value": "A String", # Required. The hash value.
                    },
                  ],
                },
              },
              "artifactStorageSourceUri": "A String", # If provided, the input binary artifacts for the build came from this
                  # location.
              "additionalContexts": [ # If provided, some of the source code used for the build may be found in
                  # these locations, in the case where the source repository had multiple
                  # remotes or submodules. This list will not include the context specified in
                  # the context field.
                { # A SourceContext is a reference to a tree of files. A SourceContext together
                    # with a path point to a unique revision of a single file or directory.
                  "git": { # A GitSourceContext denotes a particular revision in a third party Git # A SourceContext referring to any third party Git repo (e.g., GitHub).
                      # repository (e.g., GitHub).
                    "url": "A String", # Git repository URL.
                    "revisionId": "A String", # Git commit hash.
                  },
                  "cloudRepo": { # A CloudRepoSourceContext denotes a particular revision in a Google Cloud # A SourceContext referring to a revision in a Google Cloud Source Repo.
                      # Source Repo.
                    "aliasContext": { # An alias to a repo revision. # An alias, which may be a branch or tag.
                      "kind": "A String", # The alias kind.
                      "name": "A String", # The alias name.
                    },
                    "revisionId": "A String", # A revision ID.
                    "repoId": { # A unique identifier for a Cloud Repo. # The ID of the repo.
                      "uid": "A String", # A server-assigned, globally unique identifier.
                      "projectRepoId": { # Selects a repo using a Google Cloud Platform project ID (e.g., # A combination of a project ID and a repo name.
                          # winged-cargo-31) and a repo name within that project.
                        "projectId": "A String", # The ID of the project.
                        "repoName": "A String", # The name of the repo. Leave empty for the default repo.
                      },
                    },
                  },
                  "labels": { # Labels with user defined metadata.
                    "a_key": "A String",
                  },
                  "gerrit": { # A SourceContext referring to a Gerrit project. # A SourceContext referring to a Gerrit project.
                    "aliasContext": { # An alias to a repo revision. # An alias, which may be a branch or tag.
                      "kind": "A String", # The alias kind.
                      "name": "A String", # The alias name.
                    },
                    "revisionId": "A String", # A revision (commit) ID.
                    "hostUri": "A String", # The URI of a running Gerrit instance.
                    "gerritProject": "A String", # The full project name within the host. Projects may be nested, so
                        # "project/subproject" is a valid project name. The "repo name" is the
                        # hostURI/project.
                  },
                },
              ],
              "context": { # A SourceContext is a reference to a tree of files. A SourceContext together # If provided, the source code used for the build came from this location.
                  # with a path point to a unique revision of a single file or directory.
                "git": { # A GitSourceContext denotes a particular revision in a third party Git # A SourceContext referring to any third party Git repo (e.g., GitHub).
                    # repository (e.g., GitHub).
                  "url": "A String", # Git repository URL.
                  "revisionId": "A String", # Git commit hash.
                },
                "cloudRepo": { # A CloudRepoSourceContext denotes a particular revision in a Google Cloud # A SourceContext referring to a revision in a Google Cloud Source Repo.
                    # Source Repo.
                  "aliasContext": { # An alias to a repo revision. # An alias, which may be a branch or tag.
                    "kind": "A String", # The alias kind.
                    "name": "A String", # The alias name.
                  },
                  "revisionId": "A String", # A revision ID.
                  "repoId": { # A unique identifier for a Cloud Repo. # The ID of the repo.
                    "uid": "A String", # A server-assigned, globally unique identifier.
                    "projectRepoId": { # Selects a repo using a Google Cloud Platform project ID (e.g., # A combination of a project ID and a repo name.
                        # winged-cargo-31) and a repo name within that project.
                      "projectId": "A String", # The ID of the project.
                      "repoName": "A String", # The name of the repo. Leave empty for the default repo.
                    },
                  },
                },
                "labels": { # Labels with user defined metadata.
                  "a_key": "A String",
                },
                "gerrit": { # A SourceContext referring to a Gerrit project. # A SourceContext referring to a Gerrit project.
                  "aliasContext": { # An alias to a repo revision. # An alias, which may be a branch or tag.
                    "kind": "A String", # The alias kind.
                    "name": "A String", # The alias name.
                  },
                  "revisionId": "A String", # A revision (commit) ID.
                  "hostUri": "A String", # The URI of a running Gerrit instance.
                  "gerritProject": "A String", # The full project name within the host. Projects may be nested, so
                      # "project/subproject" is a valid project name. The "repo name" is the
                      # hostURI/project.
                },
              },
            },
            "buildOptions": { # Special options applied to this build. This is a catch-all field where
                # build providers can enter any desired additional details.
              "a_key": "A String",
            },
            "creator": "A String", # E-mail address of the user who initiated this build. Note that this was the
                # user's e-mail address at the time the build was initiated; this address may
                # not represent the same end-user for all time.
            "projectId": "A String", # ID of the project.
            "builderVersion": "A String", # Version string of the builder at the time this build was executed.
            "createTime": "A String", # Time at which the build was created.
            "builtArtifacts": [ # Output of the build.
              { # Artifact describes a build product.
                "checksum": "A String", # Hash or checksum value of a binary, or Docker Registry 2.0 digest of a
                    # container.
                "id": "A String", # Artifact ID, if any; for container images, this will be a URL by digest
                    # like `gcr.io/projectID/imagename@sha256:123456`.
                "names": [ # Related artifact names. This may be the path to a binary or jar file, or in
                    # the case of a container build, the name used to push the container image to
                    # Google Container Registry, as presented to `docker push`. Note that a
                    # single Artifact ID can have multiple names, for example if two tags are
                    # applied to one image.
                  "A String",
                ],
              },
            ],
            "triggerId": "A String", # Trigger identifier if the build was triggered automatically; empty if not.
            "startTime": "A String", # Time at which execution of the build was started.
            "endTime": "A String", # Time at which execution of the build was finished.
            "id": "A String", # Required. Unique identifier of the build.
            "logsUri": "A String", # URI where any logs for this provenance were written.
          },
          "provenanceBytes": "A String", # Serialized JSON representation of the provenance, used in generating the
              # build signature in the corresponding build note. After verifying the
              # signature, `provenance_bytes` can be unmarshalled and compared to the
              # provenance to confirm that it is unchanged. A base64-encoded string
              # representation of the provenance bytes is used for the signature in order
              # to interoperate with openssl which expects this format for signature
              # verification.
              #
              # The serialized form is captured both to avoid ambiguity in how the
              # provenance is marshalled to json as well to prevent incompatibilities with
              # future changes.
        },
        "deployment": { # Details of a deployment occurrence. # Describes the deployment of an artifact on a runtime.
          "deployment": { # The period during which some deployable was active in a runtime. # Required. Deployment history for the resource.
            "resourceUri": [ # Output only. Resource URI for the artifact being deployed taken from
                # the deployable field with the same name.
              "A String",
            ],
            "userEmail": "A String", # Identity of the user that triggered this deployment.
            "address": "A String", # Address of the runtime element hosting this deployment.
            "platform": "A String", # Platform hosting this deployment.
            "deployTime": "A String", # Required. Beginning of the lifetime of this deployment.
            "undeployTime": "A String", # End of the lifetime of this deployment.
            "config": "A String", # Configuration used to create this deployment.
          },
        },
        "remediation": "A String", # A description of actions that can be taken to remedy the note.
        "installation": { # Details of a package occurrence. # Describes the installation of a package on the linked resource.
          "installation": { # This represents how a particular software package may be installed on a # Required. Where the package was installed.
              # system.
            "location": [ # Required. All of the places within the filesystem versions of this package
                # have been found.
              { # An occurrence of a particular package installation found within a system's
                  # filesystem. E.g., glibc was found in `/var/lib/dpkg/status`.
                "path": "A String", # The path from which we gathered that this package/version is installed.
                "cpeUri": "A String", # Required. The CPE URI in [CPE format](https://cpe.mitre.org/specification/)
                    # denoting the package manager version distributing a package.
                "version": { # Version contains structured information about the version of a package. # The version installed at this location.
                  "epoch": 42, # Used to correct mistakes in the version numbering scheme.
                  "kind": "A String", # Required. Distinguishes between sentinel MIN/MAX versions and normal
                      # versions.
                  "name": "A String", # Required only when version kind is NORMAL. The main part of the version
                      # name.
                  "revision": "A String", # The iteration of the package build from the above version.
                },
              },
            ],
            "name": "A String", # Output only. The name of the installed package.
          },
        },
        "createTime": "A String", # Output only. The time this occurrence was created.
        "derivedImage": { # Details of an image occurrence. # Describes how this resource derives from the basis in the associated
            # note.
          "derivedImage": { # Derived describes the derived image portion (Occurrence) of the DockerImage # Required. Immutable. The child image derived from the base image.
              # relationship. This image would be produced from a Dockerfile with FROM
              # <DockerImage.Basis in attached Note>.
            "distance": 42, # Output only. The number of layers by which this image differs from the
                # associated image basis.
            "baseResourceUrl": "A String", # Output only. This contains the base image URL for the derived image
                # occurrence.
            "layerInfo": [ # This contains layer-specific metadata, if populated it has length
                # "distance" and is ordered with [distance] being the layer immediately
                # following the base image and [1] being the final layer.
              { # Layer holds metadata specific to a layer of a Docker image.
                "arguments": "A String", # The recovered arguments to the Dockerfile directive.
                "directive": "A String", # Required. The recovered Dockerfile directive used to construct this layer.
              },
            ],
            "fingerprint": { # A set of properties that uniquely identify a given Docker image. # Required. The fingerprint of the derived image.
              "v1Name": "A String", # Required. The layer ID of the final layer in the Docker image's v1
                  # representation.
              "v2Name": "A String", # Output only. The name of the image's v2 blobs computed via:
                  #   [bottom] := v2_blobbottom := sha256(v2_blob[N] + " " + v2_name[N+1])
                  # Only the name of the final blob is kept.
              "v2Blob": [ # Required. The ordered list of v2 blobs that represent a given image.
                "A String",
              ],
            },
          },
        },
        "noteName": "A String", # Required. Immutable. The analysis note associated with this occurrence, in
            # the form of `projects/[PROVIDER_ID]/notes/[NOTE_ID]`. This field can be
            # used as a filter in list requests.
      },
    ],
  }</pre>
</div>

<div class="method">
    <code class="details" id="list_next">list_next(previous_request, previous_response)</code>
  <pre>Retrieves the next page of results.

Args:
  previous_request: The request for the previous page. (required)
  previous_response: The response from the request for the previous page. (required)

Returns:
  A request object that you can call 'execute()' on to request the next
  page. Returns None if there are no more items in the collection.
    </pre>
</div>

</body></html>