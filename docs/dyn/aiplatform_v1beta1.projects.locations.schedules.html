<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="aiplatform_v1beta1.html">Vertex AI API</a> . <a href="aiplatform_v1beta1.projects.html">projects</a> . <a href="aiplatform_v1beta1.projects.locations.html">locations</a> . <a href="aiplatform_v1beta1.projects.locations.schedules.html">schedules</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="aiplatform_v1beta1.projects.locations.schedules.operations.html">operations()</a></code>
</p>
<p class="firstline">Returns the operations Resource.</p>

<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#create">create(parent, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Creates a Schedule.</p>
<p class="toc_element">
  <code><a href="#delete">delete(name, x__xgafv=None)</a></code></p>
<p class="firstline">Deletes a Schedule.</p>
<p class="toc_element">
  <code><a href="#get">get(name, x__xgafv=None)</a></code></p>
<p class="firstline">Gets a Schedule.</p>
<p class="toc_element">
  <code><a href="#list">list(parent, filter=None, orderBy=None, pageSize=None, pageToken=None, x__xgafv=None)</a></code></p>
<p class="firstline">Lists Schedules in a Location.</p>
<p class="toc_element">
  <code><a href="#list_next">list_next()</a></code></p>
<p class="firstline">Retrieves the next page of results.</p>
<p class="toc_element">
  <code><a href="#patch">patch(name, body=None, updateMask=None, x__xgafv=None)</a></code></p>
<p class="firstline">Updates an active or paused Schedule. When the Schedule is updated, new runs will be scheduled starting from the updated next execution time after the update time based on the time_specification in the updated Schedule. All unstarted runs before the update time will be skipped while already created runs will NOT be paused or canceled.</p>
<p class="toc_element">
  <code><a href="#pause">pause(name, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Pauses a Schedule. Will mark Schedule.state to 'PAUSED'. If the schedule is paused, no new runs will be created. Already created runs will NOT be paused or canceled.</p>
<p class="toc_element">
  <code><a href="#resume">resume(name, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Resumes a paused Schedule to start scheduling new runs. Will mark Schedule.state to 'ACTIVE'. Only paused Schedule can be resumed. When the Schedule is resumed, new runs will be scheduled starting from the next execution time after the current time based on the time_specification in the Schedule. If Schedule.catchUp is set up true, all missed runs will be scheduled for backfill first.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="create">create(parent, body=None, x__xgafv=None)</code>
  <pre>Creates a Schedule.

Args:
  parent: string, Required. The resource name of the Location to create the Schedule in. Format: `projects/{project}/locations/{location}` (required)
  body: object, The request body.
    The object takes the form of:

{ # An instance of a Schedule periodically schedules runs to make API calls based on user specified time specification and API request type.
  &quot;allowQueueing&quot;: True or False, # Optional. Whether new scheduled runs can be queued when max_concurrent_runs limit is reached. If set to true, new runs will be queued instead of skipped. Default to false.
  &quot;catchUp&quot;: True or False, # Output only. Whether to backfill missed runs when the schedule is resumed from PAUSED state. If set to true, all missed runs will be scheduled. New runs will be scheduled after the backfill is complete. Default to false.
  &quot;createModelMonitoringJobRequest&quot;: { # Request message for ModelMonitoringService.CreateModelMonitoringJob. # Request for ModelMonitoringService.CreateModelMonitoringJob.
    &quot;modelMonitoringJob&quot;: { # Represents a model monitoring job that analyze dataset using different monitoring algorithm. # Required. The ModelMonitoringJob to create
      &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelMonitoringJob was created.
      &quot;displayName&quot;: &quot;A String&quot;, # The display name of the ModelMonitoringJob. The name can be up to 128 characters long and can consist of any UTF-8.
      &quot;jobExecutionDetail&quot;: { # Represent the execution details of the job. # Output only. Execution results for all the monitoring objectives.
        &quot;baselineDatasets&quot;: [ # Processed baseline datasets.
          { # Processed dataset information.
            &quot;location&quot;: &quot;A String&quot;, # Actual data location of the processed dataset.
            &quot;timeRange&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Dataset time range information if any.
              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end.
              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start.
            },
          },
        ],
        &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Additional job error status.
          &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
          &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
            {
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
            },
          ],
          &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
        },
        &quot;objectiveStatus&quot;: { # Status of data processing for each monitoring objective. Key is the objective.
          &quot;a_key&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
            &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
            &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
              {
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
              },
            ],
            &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
          },
        },
        &quot;targetDatasets&quot;: [ # Processed target datasets.
          { # Processed dataset information.
            &quot;location&quot;: &quot;A String&quot;, # Actual data location of the processed dataset.
            &quot;timeRange&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Dataset time range information if any.
              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end.
              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start.
            },
          },
        ],
      },
      &quot;modelMonitoringSpec&quot;: { # Monitoring monitoring job spec. It outlines the specifications for monitoring objectives, notifications, and result exports. # Monitoring monitoring job spec. It outlines the specifications for monitoring objectives, notifications, and result exports. If left blank, the default monitoring specifications from the top-level resource &#x27;ModelMonitor&#x27; will be applied. If provided, we will use the specification defined here rather than the default one.
        &quot;notificationSpec&quot;: { # Notification spec(email, notification channel) for model monitoring statistics/alerts. # The model monitoring notification spec.
          &quot;emailConfig&quot;: { # The config for email alerts. # Email alert config.
            &quot;userEmails&quot;: [ # The email addresses to send the alerts.
              &quot;A String&quot;,
            ],
          },
          &quot;enableCloudLogging&quot;: True or False, # Dump the anomalies to Cloud Logging. The anomalies will be put to json payload encoded from proto google.cloud.aiplatform.logging.ModelMonitoringAnomaliesLogEntry. This can be further sinked to Pub/Sub or any other services supported by Cloud Logging.
          &quot;notificationChannelConfigs&quot;: [ # Notification channel config.
            { # Google Cloud Notification Channel config.
              &quot;notificationChannel&quot;: &quot;A String&quot;, # Resource names of the NotificationChannels. Must be of the format `projects//notificationChannels/`
            },
          ],
        },
        &quot;objectiveSpec&quot;: { # Monitoring objectives spec. # The monitoring objective spec.
          &quot;baselineDataset&quot;: { # Model monitoring data input spec. # Baseline dataset. It could be the training dataset or production serving dataset from a previous period.
            &quot;batchPredictionOutput&quot;: { # Data from Vertex AI Batch prediction job output. # Vertex AI Batch prediction Job.
              &quot;batchPredictionJob&quot;: &quot;A String&quot;, # Vertex AI Batch prediction job resource name. The job must match the model version specified in [ModelMonitor].[model_monitoring_target].
            },
            &quot;columnizedDataset&quot;: { # Input dataset spec. # Columnized dataset.
              &quot;bigquerySource&quot;: { # Dataset spec for data sotred in BigQuery. # BigQuery data source.
                &quot;query&quot;: &quot;A String&quot;, # Standard SQL to be used instead of the `table_uri`.
                &quot;tableUri&quot;: &quot;A String&quot;, # BigQuery URI to a table, up to 2000 characters long. All the columns in the table will be selected. Accepted forms: * BigQuery path. For example: `bq://projectId.bqDatasetId.bqTableId`.
              },
              &quot;gcsSource&quot;: { # Dataset spec for data stored in Google Cloud Storage. # Google Cloud Storage data source.
                &quot;format&quot;: &quot;A String&quot;, # Data format of the dataset.
                &quot;gcsUri&quot;: &quot;A String&quot;, # Google Cloud Storage URI to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
              },
              &quot;timestampField&quot;: &quot;A String&quot;, # The timestamp field. Usually for serving data.
              &quot;vertexDataset&quot;: &quot;A String&quot;, # Resource name of the Vertex AI managed dataset.
            },
            &quot;timeInterval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # The time interval (pair of start_time and end_time) for which results should be returned.
              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end.
              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start.
            },
            &quot;timeOffset&quot;: { # Time offset setting. # The time offset setting for which results should be returned.
              &quot;offset&quot;: &quot;A String&quot;, # [offset] is the time difference from the cut-off time. For scheduled jobs, the cut-off time is the scheduled time. For non-scheduled jobs, it&#x27;s the time when the job was created. Currently we support the following format: &#x27;w|W&#x27;: Week, &#x27;d|D&#x27;: Day, &#x27;h|H&#x27;: Hour E.g. &#x27;1h&#x27; stands for 1 hour, &#x27;2d&#x27; stands for 2 days.
              &quot;window&quot;: &quot;A String&quot;, # [window] refers to the scope of data selected for analysis. It allows you to specify the quantity of data you wish to examine. Currently we support the following format: &#x27;w|W&#x27;: Week, &#x27;d|D&#x27;: Day, &#x27;h|H&#x27;: Hour E.g. &#x27;1h&#x27; stands for 1 hour, &#x27;2d&#x27; stands for 2 days.
            },
            &quot;vertexEndpointLogs&quot;: { # Data from Vertex AI Endpoint request response logging. # Vertex AI Endpoint request &amp; response logging.
              &quot;endpoints&quot;: [ # List of endpoint resource names. The endpoints must enable the logging with the [Endpoint].[request_response_logging_config], and must contain the deployed model corresponding to the model version specified in [ModelMonitor].[model_monitoring_target].
                &quot;A String&quot;,
              ],
            },
          },
          &quot;explanationSpec&quot;: { # Specification of Model explanation. # The explanation spec. This spec is required when the objectives spec includes feature attribution objectives.
            &quot;metadata&quot;: { # Metadata describing the Model&#x27;s input and output for explanation. # Optional. Metadata describing the Model&#x27;s input and output for explanation.
              &quot;featureAttributionsSchemaUri&quot;: &quot;A String&quot;, # Points to a YAML file stored on Google Cloud Storage describing the format of the feature attributions. The schema is defined as an OpenAPI 3.0.2 [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject). AutoML tabular Models always have this field populated by Vertex AI. Note: The URI given on output may be different, including the URI scheme, than the one given on input. The output URI will point to a location where the user only has a read access.
              &quot;inputs&quot;: { # Required. Map from feature names to feature input metadata. Keys are the name of the features. Values are the specification of the feature. An empty InputMetadata is valid. It describes a text feature which has the name specified as the key in ExplanationMetadata.inputs. The baseline of the empty feature is chosen by Vertex AI. For Vertex AI-provided Tensorflow images, the key can be any friendly name of the feature. Once specified, featureAttributions are keyed by this key (if not grouped with another feature). For custom images, the key must match with the key in instance.
                &quot;a_key&quot;: { # Metadata of the input of a feature. Fields other than InputMetadata.input_baselines are applicable only for Models that are using Vertex AI-provided images for Tensorflow.
                  &quot;denseShapeTensorName&quot;: &quot;A String&quot;, # Specifies the shape of the values of the input if the input is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
                  &quot;encodedBaselines&quot;: [ # A list of baselines for the encoded tensor. The shape of each baseline should match the shape of the encoded tensor. If a scalar is provided, Vertex AI broadcasts to the same shape as the encoded tensor.
                    &quot;&quot;,
                  ],
                  &quot;encodedTensorName&quot;: &quot;A String&quot;, # Encoded tensor is a transformation of the input tensor. Must be provided if choosing Integrated Gradients attribution or XRAI attribution and the input tensor is not differentiable. An encoded tensor is generated if the input tensor is encoded by a lookup table.
                  &quot;encoding&quot;: &quot;A String&quot;, # Defines how the feature is encoded into the input tensor. Defaults to IDENTITY.
                  &quot;featureValueDomain&quot;: { # Domain details of the input feature value. Provides numeric information about the feature, such as its range (min, max). If the feature has been pre-processed, for example with z-scoring, then it provides information about how to recover the original feature. For example, if the input feature is an image and it has been pre-processed to obtain 0-mean and stddev = 1 values, then original_mean, and original_stddev refer to the mean and stddev of the original feature (e.g. image tensor) from which input feature (with mean = 0 and stddev = 1) was obtained. # The domain details of the input feature value. Like min/max, original mean or standard deviation if normalized.
                    &quot;maxValue&quot;: 3.14, # The maximum permissible value for this feature.
                    &quot;minValue&quot;: 3.14, # The minimum permissible value for this feature.
                    &quot;originalMean&quot;: 3.14, # If this input feature has been normalized to a mean value of 0, the original_mean specifies the mean value of the domain prior to normalization.
                    &quot;originalStddev&quot;: 3.14, # If this input feature has been normalized to a standard deviation of 1.0, the original_stddev specifies the standard deviation of the domain prior to normalization.
                  },
                  &quot;groupName&quot;: &quot;A String&quot;, # Name of the group that the input belongs to. Features with the same group name will be treated as one feature when computing attributions. Features grouped together can have different shapes in value. If provided, there will be one single attribution generated in Attribution.feature_attributions, keyed by the group name.
                  &quot;indexFeatureMapping&quot;: [ # A list of feature names for each index in the input tensor. Required when the input InputMetadata.encoding is BAG_OF_FEATURES, BAG_OF_FEATURES_SPARSE, INDICATOR.
                    &quot;A String&quot;,
                  ],
                  &quot;indicesTensorName&quot;: &quot;A String&quot;, # Specifies the index of the values of the input tensor. Required when the input tensor is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
                  &quot;inputBaselines&quot;: [ # Baseline inputs for this feature. If no baseline is specified, Vertex AI chooses the baseline for this feature. If multiple baselines are specified, Vertex AI returns the average attributions across them in Attribution.feature_attributions. For Vertex AI-provided Tensorflow images (both 1.x and 2.x), the shape of each baseline must match the shape of the input tensor. If a scalar is provided, we broadcast to the same shape as the input tensor. For custom images, the element of the baselines must be in the same format as the feature&#x27;s input in the instance[]. The schema of any single instance may be specified via Endpoint&#x27;s DeployedModels&#x27; Model&#x27;s PredictSchemata&#x27;s instance_schema_uri.
                    &quot;&quot;,
                  ],
                  &quot;inputTensorName&quot;: &quot;A String&quot;, # Name of the input tensor for this feature. Required and is only applicable to Vertex AI-provided images for Tensorflow.
                  &quot;modality&quot;: &quot;A String&quot;, # Modality of the feature. Valid values are: numeric, image. Defaults to numeric.
                  &quot;visualization&quot;: { # Visualization configurations for image explanation. # Visualization configurations for image explanation.
                    &quot;clipPercentLowerbound&quot;: 3.14, # Excludes attributions below the specified percentile, from the highlighted areas. Defaults to 62.
                    &quot;clipPercentUpperbound&quot;: 3.14, # Excludes attributions above the specified percentile from the highlighted areas. Using the clip_percent_upperbound and clip_percent_lowerbound together can be useful for filtering out noise and making it easier to see areas of strong attribution. Defaults to 99.9.
                    &quot;colorMap&quot;: &quot;A String&quot;, # The color scheme used for the highlighted areas. Defaults to PINK_GREEN for Integrated Gradients attribution, which shows positive attributions in green and negative in pink. Defaults to VIRIDIS for XRAI attribution, which highlights the most influential regions in yellow and the least influential in blue.
                    &quot;overlayType&quot;: &quot;A String&quot;, # How the original image is displayed in the visualization. Adjusting the overlay can help increase visual clarity if the original image makes it difficult to view the visualization. Defaults to NONE.
                    &quot;polarity&quot;: &quot;A String&quot;, # Whether to only highlight pixels with positive contributions, negative or both. Defaults to POSITIVE.
                    &quot;type&quot;: &quot;A String&quot;, # Type of the image visualization. Only applicable to Integrated Gradients attribution. OUTLINES shows regions of attribution, while PIXELS shows per-pixel attribution. Defaults to OUTLINES.
                  },
                },
              },
              &quot;latentSpaceSource&quot;: &quot;A String&quot;, # Name of the source to generate embeddings for example based explanations.
              &quot;outputs&quot;: { # Required. Map from output names to output metadata. For Vertex AI-provided Tensorflow images, keys can be any user defined string that consists of any UTF-8 characters. For custom images, keys are the name of the output field in the prediction to be explained. Currently only one key is allowed.
                &quot;a_key&quot;: { # Metadata of the prediction output to be explained.
                  &quot;displayNameMappingKey&quot;: &quot;A String&quot;, # Specify a field name in the prediction to look for the display name. Use this if the prediction contains the display names for the outputs. The display names in the prediction must have the same shape of the outputs, so that it can be located by Attribution.output_index for a specific output.
                  &quot;indexDisplayNameMapping&quot;: &quot;&quot;, # Static mapping between the index and display name. Use this if the outputs are a deterministic n-dimensional array, e.g. a list of scores of all the classes in a pre-defined order for a multi-classification Model. It&#x27;s not feasible if the outputs are non-deterministic, e.g. the Model produces top-k classes or sort the outputs by their values. The shape of the value must be an n-dimensional array of strings. The number of dimensions must match that of the outputs to be explained. The Attribution.output_display_name is populated by locating in the mapping with Attribution.output_index.
                  &quot;outputTensorName&quot;: &quot;A String&quot;, # Name of the output tensor. Required and is only applicable to Vertex AI provided images for Tensorflow.
                },
              },
            },
            &quot;parameters&quot;: { # Parameters to configure explaining for Model&#x27;s predictions. # Required. Parameters that configure explaining of the Model&#x27;s predictions.
              &quot;examples&quot;: { # Example-based explainability that returns the nearest neighbors from the provided dataset. # Example-based explanations that returns the nearest neighbors from the provided dataset.
                &quot;exampleGcsSource&quot;: { # The Cloud Storage input instances. # The Cloud Storage input instances.
                  &quot;dataFormat&quot;: &quot;A String&quot;, # The format in which instances are given, if not specified, assume it&#x27;s JSONL format. Currently only JSONL format is supported.
                  &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage location for the input instances.
                    &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                      &quot;A String&quot;,
                    ],
                  },
                },
                &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage locations that contain the instances to be indexed for approximate nearest neighbor search.
                  &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                    &quot;A String&quot;,
                  ],
                },
                &quot;nearestNeighborSearchConfig&quot;: &quot;&quot;, # The full configuration for the generated index, the semantics are the same as metadata and should match [NearestNeighborSearchConfig](https://cloud.google.com/vertex-ai/docs/explainable-ai/configuring-explanations-example-based#nearest-neighbor-search-config).
                &quot;neighborCount&quot;: 42, # The number of neighbors to return when querying for examples.
                &quot;presets&quot;: { # Preset configuration for example-based explanations # Simplified preset configuration, which automatically sets configuration values based on the desired query speed-precision trade-off and modality.
                  &quot;modality&quot;: &quot;A String&quot;, # The modality of the uploaded model, which automatically configures the distance measurement and feature normalization for the underlying example index and queries. If your model does not precisely fit one of these types, it is okay to choose the closest type.
                  &quot;query&quot;: &quot;A String&quot;, # Preset option controlling parameters for speed-precision trade-off when querying for examples. If omitted, defaults to `PRECISE`.
                },
              },
              &quot;integratedGradientsAttribution&quot;: { # An attribution method that computes the Aumann-Shapley value taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365 # An attribution method that computes Aumann-Shapley values taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365
                &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for IG with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
                  &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
                },
                &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
                  &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
                    &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
                      { # Noise sigma for a single feature.
                        &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                        &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
                      },
                    ],
                  },
                  &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
                  &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
                },
                &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is within the desired error range. Valid range of its value is [1, 100], inclusively.
              },
              &quot;outputIndices&quot;: [ # If populated, only returns attributions that have output_index contained in output_indices. It must be an ndarray of integers, with the same shape of the output it&#x27;s explaining. If not populated, returns attributions for top_k indices of outputs. If neither top_k nor output_indices is populated, returns the argmax index of the outputs. Only applicable to Models that predict multiple outputs (e,g, multi-class Models that predict multiple classes).
                &quot;&quot;,
              ],
              &quot;sampledShapleyAttribution&quot;: { # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. Refer to this paper for model details: https://arxiv.org/abs/1306.4265.
                &quot;pathCount&quot;: 42, # Required. The number of feature permutations to consider when approximating the Shapley values. Valid range of its value is [1, 50], inclusively.
              },
              &quot;topK&quot;: 42, # If populated, returns attributions for top K indices of outputs (defaults to 1). Only applies to Models that predicts more than one outputs (e,g, multi-class Models). When set to -1, returns explanations for all outputs.
              &quot;xraiAttribution&quot;: { # An explanation method that redistributes Integrated Gradients attributions to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 Supported only by image Models. # An attribution method that redistributes Integrated Gradients attribution to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 XRAI currently performs better on natural images, like a picture of a house or an animal. If the images are taken in artificial environments, like a lab or manufacturing line, or from diagnostic equipment, like x-rays or quality-control cameras, use Integrated Gradients instead.
                &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for XRAI with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
                  &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
                },
                &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
                  &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
                    &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
                      { # Noise sigma for a single feature.
                        &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                        &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
                      },
                    ],
                  },
                  &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
                  &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
                },
                &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is met within the desired error range. Valid range of its value is [1, 100], inclusively.
              },
            },
          },
          &quot;tabularObjective&quot;: { # Tabular monitoring objective. # Tabular monitoring objective.
            &quot;featureAttributionSpec&quot;: { # Feature attribution monitoring spec. # Feature attribution monitoring spec.
              &quot;batchExplanationDedicatedResources&quot;: { # A description of resources that are used for performing batch operations, are dedicated to a Model, and need manual configuration. # The config of resources used by the Model Monitoring during the batch explanation for non-AutoML models. If not set, `n1-standard-2` machine type will be used by default.
                &quot;machineSpec&quot;: { # Specification of a single machine. # Required. Immutable. The specification of a single machine.
                  &quot;acceleratorCount&quot;: 42, # The number of accelerators to attach to the machine.
                  &quot;acceleratorType&quot;: &quot;A String&quot;, # Immutable. The type of accelerator(s) that may be attached to the machine as per accelerator_count.
                  &quot;machineType&quot;: &quot;A String&quot;, # Immutable. The type of the machine. See the [list of machine types supported for prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types) See the [list of machine types supported for custom training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types). For DeployedModel this field is optional, and the default value is `n1-standard-2`. For BatchPredictionJob or as part of WorkerPoolSpec this field is required.
                  &quot;reservationAffinity&quot;: { # A ReservationAffinity can be used to configure a Vertex AI resource (e.g., a DeployedModel) to draw its Compute Engine resources from a Shared Reservation, or exclusively from on-demand capacity. # Optional. Immutable. Configuration controlling how this resource pool consumes reservation.
                    &quot;key&quot;: &quot;A String&quot;, # Optional. Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, use `compute.googleapis.com/reservation-name` as the key and specify the name of your reservation as its value.
                    &quot;reservationAffinityType&quot;: &quot;A String&quot;, # Required. Specifies the reservation affinity type.
                    &quot;values&quot;: [ # Optional. Corresponds to the label values of a reservation resource. This must be the full resource name of the reservation.
                      &quot;A String&quot;,
                    ],
                  },
                  &quot;tpuTopology&quot;: &quot;A String&quot;, # Immutable. The topology of the TPUs. Corresponds to the TPU topologies available from GKE. (Example: tpu_topology: &quot;2x2x1&quot;).
                },
                &quot;maxReplicaCount&quot;: 42, # Immutable. The maximum number of machine replicas the batch operation may be scaled to. The default value is 10.
                &quot;startingReplicaCount&quot;: 42, # Immutable. The number of machine replicas used at the start of the batch operation. If not set, Vertex AI decides starting number, not greater than max_replica_count
              },
              &quot;defaultAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the features.
                &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
              },
              &quot;featureAlertConditions&quot;: { # Per feature alert condition will override default alert condition.
                &quot;a_key&quot;: { # Monitoring alert triggered condition.
                  &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
                },
              },
              &quot;features&quot;: [ # Feature names interested in monitoring. These should be a subset of the input feature names specified in the monitoring schema. If the field is not specified all features outlied in the monitoring schema will be used.
                &quot;A String&quot;,
              ],
            },
            &quot;featureDriftSpec&quot;: { # Data drift monitoring spec. Data drift measures the distribution distance between the current dataset and a baseline dataset. A typical use case is to detect data drift between the recent production serving dataset and the training dataset, or to compare the recent production dataset with a dataset from a previous period. # Input feature distribution drift monitoring spec.
              &quot;categoricalMetricType&quot;: &quot;A String&quot;, # Supported metrics type: * l_infinity * jensen_shannon_divergence
              &quot;defaultCategoricalAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the categorical features.
                &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
              },
              &quot;defaultNumericAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the numeric features.
                &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
              },
              &quot;featureAlertConditions&quot;: { # Per feature alert condition will override default alert condition.
                &quot;a_key&quot;: { # Monitoring alert triggered condition.
                  &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
                },
              },
              &quot;features&quot;: [ # Feature names / Prediction output names interested in monitoring. These should be a subset of the input feature names or prediction output names specified in the monitoring schema. If the field is not specified all features / prediction outputs outlied in the monitoring schema will be used.
                &quot;A String&quot;,
              ],
              &quot;numericMetricType&quot;: &quot;A String&quot;, # Supported metrics type: * jensen_shannon_divergence
            },
            &quot;predictionOutputDriftSpec&quot;: { # Data drift monitoring spec. Data drift measures the distribution distance between the current dataset and a baseline dataset. A typical use case is to detect data drift between the recent production serving dataset and the training dataset, or to compare the recent production dataset with a dataset from a previous period. # Prediction output distribution drift monitoring spec.
              &quot;categoricalMetricType&quot;: &quot;A String&quot;, # Supported metrics type: * l_infinity * jensen_shannon_divergence
              &quot;defaultCategoricalAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the categorical features.
                &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
              },
              &quot;defaultNumericAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the numeric features.
                &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
              },
              &quot;featureAlertConditions&quot;: { # Per feature alert condition will override default alert condition.
                &quot;a_key&quot;: { # Monitoring alert triggered condition.
                  &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
                },
              },
              &quot;features&quot;: [ # Feature names / Prediction output names interested in monitoring. These should be a subset of the input feature names or prediction output names specified in the monitoring schema. If the field is not specified all features / prediction outputs outlied in the monitoring schema will be used.
                &quot;A String&quot;,
              ],
              &quot;numericMetricType&quot;: &quot;A String&quot;, # Supported metrics type: * jensen_shannon_divergence
            },
          },
          &quot;targetDataset&quot;: { # Model monitoring data input spec. # Target dataset.
            &quot;batchPredictionOutput&quot;: { # Data from Vertex AI Batch prediction job output. # Vertex AI Batch prediction Job.
              &quot;batchPredictionJob&quot;: &quot;A String&quot;, # Vertex AI Batch prediction job resource name. The job must match the model version specified in [ModelMonitor].[model_monitoring_target].
            },
            &quot;columnizedDataset&quot;: { # Input dataset spec. # Columnized dataset.
              &quot;bigquerySource&quot;: { # Dataset spec for data sotred in BigQuery. # BigQuery data source.
                &quot;query&quot;: &quot;A String&quot;, # Standard SQL to be used instead of the `table_uri`.
                &quot;tableUri&quot;: &quot;A String&quot;, # BigQuery URI to a table, up to 2000 characters long. All the columns in the table will be selected. Accepted forms: * BigQuery path. For example: `bq://projectId.bqDatasetId.bqTableId`.
              },
              &quot;gcsSource&quot;: { # Dataset spec for data stored in Google Cloud Storage. # Google Cloud Storage data source.
                &quot;format&quot;: &quot;A String&quot;, # Data format of the dataset.
                &quot;gcsUri&quot;: &quot;A String&quot;, # Google Cloud Storage URI to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
              },
              &quot;timestampField&quot;: &quot;A String&quot;, # The timestamp field. Usually for serving data.
              &quot;vertexDataset&quot;: &quot;A String&quot;, # Resource name of the Vertex AI managed dataset.
            },
            &quot;timeInterval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # The time interval (pair of start_time and end_time) for which results should be returned.
              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end.
              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start.
            },
            &quot;timeOffset&quot;: { # Time offset setting. # The time offset setting for which results should be returned.
              &quot;offset&quot;: &quot;A String&quot;, # [offset] is the time difference from the cut-off time. For scheduled jobs, the cut-off time is the scheduled time. For non-scheduled jobs, it&#x27;s the time when the job was created. Currently we support the following format: &#x27;w|W&#x27;: Week, &#x27;d|D&#x27;: Day, &#x27;h|H&#x27;: Hour E.g. &#x27;1h&#x27; stands for 1 hour, &#x27;2d&#x27; stands for 2 days.
              &quot;window&quot;: &quot;A String&quot;, # [window] refers to the scope of data selected for analysis. It allows you to specify the quantity of data you wish to examine. Currently we support the following format: &#x27;w|W&#x27;: Week, &#x27;d|D&#x27;: Day, &#x27;h|H&#x27;: Hour E.g. &#x27;1h&#x27; stands for 1 hour, &#x27;2d&#x27; stands for 2 days.
            },
            &quot;vertexEndpointLogs&quot;: { # Data from Vertex AI Endpoint request response logging. # Vertex AI Endpoint request &amp; response logging.
              &quot;endpoints&quot;: [ # List of endpoint resource names. The endpoints must enable the logging with the [Endpoint].[request_response_logging_config], and must contain the deployed model corresponding to the model version specified in [ModelMonitor].[model_monitoring_target].
                &quot;A String&quot;,
              ],
            },
          },
        },
        &quot;outputSpec&quot;: { # Specification for the export destination of monitoring results, including metrics, logs, etc. # The Output destination spec for metrics, error logs, etc.
          &quot;gcsBaseDirectory&quot;: { # The Google Cloud Storage location where the output is to be written to. # Google Cloud Storage base folder path for metrics, error logs, etc.
            &quot;outputUriPrefix&quot;: &quot;A String&quot;, # Required. Google Cloud Storage URI to output directory. If the uri doesn&#x27;t end with &#x27;/&#x27;, a &#x27;/&#x27; will be automatically appended. The directory is created if it doesn&#x27;t exist.
          },
        },
      },
      &quot;name&quot;: &quot;A String&quot;, # Output only. Resource name of a ModelMonitoringJob. Format: `projects/{project_id}/locations/{location_id}/modelMonitors/{model_monitor_id}/modelMonitoringJobs/{model_monitoring_job_id}`
      &quot;schedule&quot;: &quot;A String&quot;, # Output only. Schedule resource name. It will only appear when this job is triggered by a schedule.
      &quot;scheduleTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelMonitoringJob was scheduled. It will only appear when this job is triggered by a schedule.
      &quot;state&quot;: &quot;A String&quot;, # Output only. The state of the monitoring job. * When the job is still creating, the state will be &#x27;JOB_STATE_PENDING&#x27;. * Once the job is successfully created, the state will be &#x27;JOB_STATE_RUNNING&#x27;. * Once the job is finished, the state will be one of &#x27;JOB_STATE_FAILED&#x27;, &#x27;JOB_STATE_SUCCEEDED&#x27;, &#x27;JOB_STATE_PARTIALLY_SUCCEEDED&#x27;.
      &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelMonitoringJob was updated most recently.
    },
    &quot;modelMonitoringJobId&quot;: &quot;A String&quot;, # Optional. The ID to use for the Model Monitoring Job, which will become the final component of the model monitoring job resource name. The maximum length is 63 characters, and valid characters are `/^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$/`.
    &quot;parent&quot;: &quot;A String&quot;, # Required. The parent of the ModelMonitoringJob. Format: `projects/{project}/locations/{location}/modelMoniitors/{model_monitor}`
  },
  &quot;createNotebookExecutionJobRequest&quot;: { # Request message for [NotebookService.CreateNotebookExecutionJob] # Request for NotebookService.CreateNotebookExecutionJob.
    &quot;notebookExecutionJob&quot;: { # NotebookExecutionJob represents an instance of a notebook execution. # Required. The NotebookExecutionJob to create.
      &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this NotebookExecutionJob was created.
      &quot;dataformRepositorySource&quot;: { # The Dataform Repository containing the input notebook. # The Dataform Repository pointing to a single file notebook repository.
        &quot;commitSha&quot;: &quot;A String&quot;, # The commit SHA to read repository with. If unset, the file will be read at HEAD.
        &quot;dataformRepositoryResourceName&quot;: &quot;A String&quot;, # The resource name of the Dataform Repository. Format: `projects/{project_id}/locations/{location}/repositories/{repository_id}`
      },
      &quot;directNotebookSource&quot;: { # The content of the input notebook in ipynb format. # The contents of an input notebook file.
        &quot;content&quot;: &quot;A String&quot;, # The base64-encoded contents of the input notebook file.
      },
      &quot;displayName&quot;: &quot;A String&quot;, # The display name of the NotebookExecutionJob. The name can be up to 128 characters long and can consist of any UTF-8 characters.
      &quot;encryptionSpec&quot;: { # Represents a customer-managed encryption key spec that can be applied to a top-level resource. # Customer-managed encryption key spec for the notebook execution job. This field is auto-populated if the NotebookRuntimeTemplate has an encryption spec.
        &quot;kmsKeyName&quot;: &quot;A String&quot;, # Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
      },
      &quot;executionTimeout&quot;: &quot;A String&quot;, # Max running time of the execution job in seconds (default 86400s / 24 hrs).
      &quot;executionUser&quot;: &quot;A String&quot;, # The user email to run the execution as. Only supported by Colab runtimes.
      &quot;gcsNotebookSource&quot;: { # The Cloud Storage uri for the input notebook. # The Cloud Storage url pointing to the ipynb file. Format: `gs://bucket/notebook_file.ipynb`
        &quot;generation&quot;: &quot;A String&quot;, # The version of the Cloud Storage object to read. If unset, the current version of the object is read. See https://cloud.google.com/storage/docs/metadata#generation-number.
        &quot;uri&quot;: &quot;A String&quot;, # The Cloud Storage uri pointing to the ipynb file. Format: `gs://bucket/notebook_file.ipynb`
      },
      &quot;gcsOutputUri&quot;: &quot;A String&quot;, # The Cloud Storage location to upload the result to. Format: `gs://bucket-name`
      &quot;jobState&quot;: &quot;A String&quot;, # Output only. The state of the NotebookExecutionJob.
      &quot;labels&quot;: { # The labels with user-defined metadata to organize NotebookExecutionJobs. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels. System reserved label keys are prefixed with &quot;aiplatform.googleapis.com/&quot; and are immutable.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
      &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of this NotebookExecutionJob. Format: `projects/{project_id}/locations/{location}/notebookExecutionJobs/{job_id}`
      &quot;notebookRuntimeTemplateResourceName&quot;: &quot;A String&quot;, # The NotebookRuntimeTemplate to source compute configuration from.
      &quot;scheduleResourceName&quot;: &quot;A String&quot;, # Output only. The Schedule resource name if this job is triggered by one. Format: `projects/{project_id}/locations/{location}/schedules/{schedule_id}`
      &quot;serviceAccount&quot;: &quot;A String&quot;, # The service account to run the execution as.
      &quot;status&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. Populated when the NotebookExecutionJob is completed. When there is an error during notebook execution, the error details are populated.
        &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
        &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
          {
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
          },
        ],
        &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
      },
      &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this NotebookExecutionJob was most recently updated.
    },
    &quot;notebookExecutionJobId&quot;: &quot;A String&quot;, # Optional. User specified ID for the NotebookExecutionJob.
    &quot;parent&quot;: &quot;A String&quot;, # Required. The resource name of the Location to create the NotebookExecutionJob. Format: `projects/{project}/locations/{location}`
  },
  &quot;createPipelineJobRequest&quot;: { # Request message for PipelineService.CreatePipelineJob. # Request for PipelineService.CreatePipelineJob. CreatePipelineJobRequest.parent field is required (format: projects/{project}/locations/{location}).
    &quot;parent&quot;: &quot;A String&quot;, # Required. The resource name of the Location to create the PipelineJob in. Format: `projects/{project}/locations/{location}`
    &quot;pipelineJob&quot;: { # An instance of a machine learning PipelineJob. # Required. The PipelineJob to create.
      &quot;createTime&quot;: &quot;A String&quot;, # Output only. Pipeline creation time.
      &quot;displayName&quot;: &quot;A String&quot;, # The display name of the Pipeline. The name can be up to 128 characters long and can consist of any UTF-8 characters.
      &quot;encryptionSpec&quot;: { # Represents a customer-managed encryption key spec that can be applied to a top-level resource. # Customer-managed encryption key spec for a pipelineJob. If set, this PipelineJob and all of its sub-resources will be secured by this key.
        &quot;kmsKeyName&quot;: &quot;A String&quot;, # Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
      },
      &quot;endTime&quot;: &quot;A String&quot;, # Output only. Pipeline end time.
      &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. The error that occurred during pipeline execution. Only populated when the pipeline&#x27;s state is FAILED or CANCELLED.
        &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
        &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
          {
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
          },
        ],
        &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
      },
      &quot;jobDetail&quot;: { # The runtime detail of PipelineJob. # Output only. The details of pipeline run. Not available in the list view.
        &quot;pipelineContext&quot;: { # Instance of a general context. # Output only. The context of the pipeline.
          &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Context was created.
          &quot;description&quot;: &quot;A String&quot;, # Description of the Context
          &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Context. May be up to 128 Unicode characters.
          &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
          &quot;labels&quot;: { # The labels with user-defined metadata to organize your Contexts. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Context (System labels are excluded).
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;metadata&quot;: { # Properties of the Context. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;name&quot;: &quot;A String&quot;, # Immutable. The resource name of the Context.
          &quot;parentContexts&quot;: [ # Output only. A list of resource names of Contexts that are parents of this Context. A Context may have at most 10 parent_contexts.
            &quot;A String&quot;,
          ],
          &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
          &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in schema_name to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
          &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Context was last updated.
        },
        &quot;pipelineRunContext&quot;: { # Instance of a general context. # Output only. The context of the current pipeline run.
          &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Context was created.
          &quot;description&quot;: &quot;A String&quot;, # Description of the Context
          &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Context. May be up to 128 Unicode characters.
          &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
          &quot;labels&quot;: { # The labels with user-defined metadata to organize your Contexts. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Context (System labels are excluded).
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;metadata&quot;: { # Properties of the Context. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;name&quot;: &quot;A String&quot;, # Immutable. The resource name of the Context.
          &quot;parentContexts&quot;: [ # Output only. A list of resource names of Contexts that are parents of this Context. A Context may have at most 10 parent_contexts.
            &quot;A String&quot;,
          ],
          &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
          &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in schema_name to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
          &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Context was last updated.
        },
        &quot;taskDetails&quot;: [ # Output only. The runtime details of the tasks under the pipeline.
          { # The runtime detail of a task execution.
            &quot;createTime&quot;: &quot;A String&quot;, # Output only. Task create time.
            &quot;endTime&quot;: &quot;A String&quot;, # Output only. Task end time.
            &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. The error that occurred during task execution. Only populated when the task&#x27;s state is FAILED or CANCELLED.
              &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
              &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
                {
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
                },
              ],
              &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
            },
            &quot;execution&quot;: { # Instance of a general execution. # Output only. The execution metadata of the task.
              &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Execution was created.
              &quot;description&quot;: &quot;A String&quot;, # Description of the Execution
              &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Execution. May be up to 128 Unicode characters.
              &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
              &quot;labels&quot;: { # The labels with user-defined metadata to organize your Executions. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Execution (System labels are excluded).
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;metadata&quot;: { # Properties of the Execution. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the Execution.
              &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
              &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in `schema_title` to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
              &quot;state&quot;: &quot;A String&quot;, # The state of this Execution. This is a property of the Execution, and does not imply or capture any ongoing process. This property is managed by clients (such as Vertex AI Pipelines) and the system does not prescribe or check the validity of state transitions.
              &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Execution was last updated.
            },
            &quot;executorDetail&quot;: { # The runtime detail of a pipeline executor. # Output only. The detailed execution info.
              &quot;containerDetail&quot;: { # The detail of a container execution. It contains the job names of the lifecycle of a container execution. # Output only. The detailed info for a container executor.
                &quot;failedMainJobs&quot;: [ # Output only. The names of the previously failed CustomJob for the main container executions. The list includes the all attempts in chronological order.
                  &quot;A String&quot;,
                ],
                &quot;failedPreCachingCheckJobs&quot;: [ # Output only. The names of the previously failed CustomJob for the pre-caching-check container executions. This job will be available if the PipelineJob.pipeline_spec specifies the `pre_caching_check` hook in the lifecycle events. The list includes the all attempts in chronological order.
                  &quot;A String&quot;,
                ],
                &quot;mainJob&quot;: &quot;A String&quot;, # Output only. The name of the CustomJob for the main container execution.
                &quot;preCachingCheckJob&quot;: &quot;A String&quot;, # Output only. The name of the CustomJob for the pre-caching-check container execution. This job will be available if the PipelineJob.pipeline_spec specifies the `pre_caching_check` hook in the lifecycle events.
              },
              &quot;customJobDetail&quot;: { # The detailed info for a custom job executor. # Output only. The detailed info for a custom job executor.
                &quot;failedJobs&quot;: [ # Output only. The names of the previously failed CustomJob. The list includes the all attempts in chronological order.
                  &quot;A String&quot;,
                ],
                &quot;job&quot;: &quot;A String&quot;, # Output only. The name of the CustomJob.
              },
            },
            &quot;inputs&quot;: { # Output only. The runtime input artifacts of the task.
              &quot;a_key&quot;: { # A list of artifact metadata.
                &quot;artifacts&quot;: [ # Output only. A list of artifact metadata.
                  { # Instance of a general artifact.
                    &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Artifact was created.
                    &quot;description&quot;: &quot;A String&quot;, # Description of the Artifact
                    &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Artifact. May be up to 128 Unicode characters.
                    &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
                    &quot;labels&quot;: { # The labels with user-defined metadata to organize your Artifacts. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Artifact (System labels are excluded).
                      &quot;a_key&quot;: &quot;A String&quot;,
                    },
                    &quot;metadata&quot;: { # Properties of the Artifact. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the Artifact.
                    &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
                    &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in schema_name to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
                    &quot;state&quot;: &quot;A String&quot;, # The state of this Artifact. This is a property of the Artifact, and does not imply or capture any ongoing process. This property is managed by clients (such as Vertex AI Pipelines), and the system does not prescribe or check the validity of state transitions.
                    &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Artifact was last updated.
                    &quot;uri&quot;: &quot;A String&quot;, # The uniform resource identifier of the artifact file. May be empty if there is no actual artifact file.
                  },
                ],
              },
            },
            &quot;outputs&quot;: { # Output only. The runtime output artifacts of the task.
              &quot;a_key&quot;: { # A list of artifact metadata.
                &quot;artifacts&quot;: [ # Output only. A list of artifact metadata.
                  { # Instance of a general artifact.
                    &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Artifact was created.
                    &quot;description&quot;: &quot;A String&quot;, # Description of the Artifact
                    &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Artifact. May be up to 128 Unicode characters.
                    &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
                    &quot;labels&quot;: { # The labels with user-defined metadata to organize your Artifacts. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Artifact (System labels are excluded).
                      &quot;a_key&quot;: &quot;A String&quot;,
                    },
                    &quot;metadata&quot;: { # Properties of the Artifact. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the Artifact.
                    &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
                    &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in schema_name to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
                    &quot;state&quot;: &quot;A String&quot;, # The state of this Artifact. This is a property of the Artifact, and does not imply or capture any ongoing process. This property is managed by clients (such as Vertex AI Pipelines), and the system does not prescribe or check the validity of state transitions.
                    &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Artifact was last updated.
                    &quot;uri&quot;: &quot;A String&quot;, # The uniform resource identifier of the artifact file. May be empty if there is no actual artifact file.
                  },
                ],
              },
            },
            &quot;parentTaskId&quot;: &quot;A String&quot;, # Output only. The id of the parent task if the task is within a component scope. Empty if the task is at the root level.
            &quot;pipelineTaskStatus&quot;: [ # Output only. A list of task status. This field keeps a record of task status evolving over time.
              { # A single record of the task status.
                &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. The error that occurred during the state. May be set when the state is any of the non-final state (PENDING/RUNNING/CANCELLING) or FAILED state. If the state is FAILED, the error here is final and not going to be retried. If the state is a non-final state, the error indicates a system-error being retried.
                  &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
                  &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
                    {
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
                    },
                  ],
                  &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
                },
                &quot;state&quot;: &quot;A String&quot;, # Output only. The state of the task.
                &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Update time of this status.
              },
            ],
            &quot;startTime&quot;: &quot;A String&quot;, # Output only. Task start time.
            &quot;state&quot;: &quot;A String&quot;, # Output only. State of the task.
            &quot;taskId&quot;: &quot;A String&quot;, # Output only. The system generated ID of the task.
            &quot;taskName&quot;: &quot;A String&quot;, # Output only. The user specified name of the task that is defined in pipeline_spec.
          },
        ],
      },
      &quot;labels&quot;: { # The labels with user-defined metadata to organize PipelineJob. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels. Note there is some reserved label key for Vertex AI Pipelines. - `vertex-ai-pipelines-run-billing-id`, user set value will get overrided.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
      &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the PipelineJob.
      &quot;network&quot;: &quot;A String&quot;, # The full name of the Compute Engine [network](/compute/docs/networks-and-firewalls#networks) to which the Pipeline Job&#x27;s workload should be peered. For example, `projects/12345/global/networks/myVPC`. [Format](/compute/docs/reference/rest/v1/networks/insert) is of the form `projects/{project}/global/networks/{network}`. Where {project} is a project number, as in `12345`, and {network} is a network name. Private services access must already be configured for the network. Pipeline job will apply the network configuration to the Google Cloud resources being launched, if applied, such as Vertex AI Training or Dataflow job. If left unspecified, the workload is not peered with any network.
      &quot;pipelineSpec&quot;: { # The spec of the pipeline.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;preflightValidations&quot;: True or False, # Optional. Whether to do component level validations before job creation.
      &quot;reservedIpRanges&quot;: [ # A list of names for the reserved ip ranges under the VPC network that can be used for this Pipeline Job&#x27;s workload. If set, we will deploy the Pipeline Job&#x27;s workload within the provided ip ranges. Otherwise, the job will be deployed to any ip ranges under the provided VPC network. Example: [&#x27;vertex-ai-ip-range&#x27;].
        &quot;A String&quot;,
      ],
      &quot;runtimeConfig&quot;: { # The runtime config of a PipelineJob. # Runtime config of the pipeline.
        &quot;failurePolicy&quot;: &quot;A String&quot;, # Represents the failure policy of a pipeline. Currently, the default of a pipeline is that the pipeline will continue to run until no more tasks can be executed, also known as PIPELINE_FAILURE_POLICY_FAIL_SLOW. However, if a pipeline is set to PIPELINE_FAILURE_POLICY_FAIL_FAST, it will stop scheduling any new tasks when a task has failed. Any scheduled tasks will continue to completion.
        &quot;gcsOutputDirectory&quot;: &quot;A String&quot;, # Required. A path in a Cloud Storage bucket, which will be treated as the root output directory of the pipeline. It is used by the system to generate the paths of output artifacts. The artifact paths are generated with a sub-path pattern `{job_id}/{task_id}/{output_key}` under the specified output directory. The service account specified in this pipeline must have the `storage.objects.get` and `storage.objects.create` permissions for this bucket.
        &quot;inputArtifacts&quot;: { # The runtime artifacts of the PipelineJob. The key will be the input artifact name and the value would be one of the InputArtifact.
          &quot;a_key&quot;: { # The type of an input artifact.
            &quot;artifactId&quot;: &quot;A String&quot;, # Artifact resource id from MLMD. Which is the last portion of an artifact resource name: `projects/{project}/locations/{location}/metadataStores/default/artifacts/{artifact_id}`. The artifact must stay within the same project, location and default metadatastore as the pipeline.
          },
        },
        &quot;parameterValues&quot;: { # The runtime parameters of the PipelineJob. The parameters will be passed into PipelineJob.pipeline_spec to replace the placeholders at runtime. This field is used by pipelines built using `PipelineJob.pipeline_spec.schema_version` 2.1.0, such as pipelines built using Kubeflow Pipelines SDK 1.9 or higher and the v2 DSL.
          &quot;a_key&quot;: &quot;&quot;,
        },
        &quot;parameters&quot;: { # Deprecated. Use RuntimeConfig.parameter_values instead. The runtime parameters of the PipelineJob. The parameters will be passed into PipelineJob.pipeline_spec to replace the placeholders at runtime. This field is used by pipelines built using `PipelineJob.pipeline_spec.schema_version` 2.0.0 or lower, such as pipelines built using Kubeflow Pipelines SDK 1.8 or lower.
          &quot;a_key&quot;: { # Value is the value of the field.
            &quot;doubleValue&quot;: 3.14, # A double value.
            &quot;intValue&quot;: &quot;A String&quot;, # An integer value.
            &quot;stringValue&quot;: &quot;A String&quot;, # A string value.
          },
        },
      },
      &quot;satisfiesPzi&quot;: True or False, # Output only. Reserved for future use.
      &quot;satisfiesPzs&quot;: True or False, # Output only. Reserved for future use.
      &quot;scheduleName&quot;: &quot;A String&quot;, # Output only. The schedule resource name. Only returned if the Pipeline is created by Schedule API.
      &quot;serviceAccount&quot;: &quot;A String&quot;, # The service account that the pipeline workload runs as. If not specified, the Compute Engine default service account in the project will be used. See https://cloud.google.com/compute/docs/access/service-accounts#default_service_account Users starting the pipeline must have the `iam.serviceAccounts.actAs` permission on this service account.
      &quot;startTime&quot;: &quot;A String&quot;, # Output only. Pipeline start time.
      &quot;state&quot;: &quot;A String&quot;, # Output only. The detailed state of the job.
      &quot;templateMetadata&quot;: { # Pipeline template metadata if PipelineJob.template_uri is from supported template registry. Currently, the only supported registry is Artifact Registry. # Output only. Pipeline template metadata. Will fill up fields if PipelineJob.template_uri is from supported template registry.
        &quot;version&quot;: &quot;A String&quot;, # The version_name in artifact registry. Will always be presented in output if the PipelineJob.template_uri is from supported template registry. Format is &quot;sha256:abcdef123456...&quot;.
      },
      &quot;templateUri&quot;: &quot;A String&quot;, # A template uri from where the PipelineJob.pipeline_spec, if empty, will be downloaded. Currently, only uri from Vertex Template Registry &amp; Gallery is supported. Reference to https://cloud.google.com/vertex-ai/docs/pipelines/create-pipeline-template.
      &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this PipelineJob was most recently updated.
    },
    &quot;pipelineJobId&quot;: &quot;A String&quot;, # The ID to use for the PipelineJob, which will become the final component of the PipelineJob name. If not provided, an ID will be automatically generated. This value should be less than 128 characters, and valid characters are `/a-z-/`.
  },
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule was created.
  &quot;cron&quot;: &quot;A String&quot;, # Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: &quot;CRON_TZ=${IANA_TIME_ZONE}&quot; or &quot;TZ=${IANA_TIME_ZONE}&quot;. The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, &quot;CRON_TZ=America/New_York 1 * * * *&quot;, or &quot;TZ=America/New_York 1 * * * *&quot;.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. User provided name of the Schedule. The name can be up to 128 characters long and can consist of any UTF-8 characters.
  &quot;endTime&quot;: &quot;A String&quot;, # Optional. Timestamp after which no new runs can be scheduled. If specified, The schedule will be completed when either end_time is reached or when scheduled_run_count &gt;= max_run_count. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
  &quot;lastPauseTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule was last paused. Unset if never paused.
  &quot;lastResumeTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule was last resumed. Unset if never resumed from pause.
  &quot;lastScheduledRunResponse&quot;: { # Status of a scheduled run. # Output only. Response of the last scheduled run. This is the response for starting the scheduled requests and not the execution of the operations/jobs created by the requests (if applicable). Unset if no run has been scheduled yet.
    &quot;runResponse&quot;: &quot;A String&quot;, # The response of the scheduled run.
    &quot;scheduledRunTime&quot;: &quot;A String&quot;, # The scheduled run time based on the user-specified schedule.
  },
  &quot;maxConcurrentRunCount&quot;: &quot;A String&quot;, # Required. Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the operations/jobs created by the requests (if applicable).
  &quot;maxRunCount&quot;: &quot;A String&quot;, # Optional. Maximum run count of the schedule. If specified, The schedule will be completed when either started_run_count &gt;= max_run_count or when end_time is reached. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
  &quot;name&quot;: &quot;A String&quot;, # Immutable. The resource name of the Schedule.
  &quot;nextRunTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule should schedule the next run. Having a next_run_time in the past means the runs are being started behind schedule.
  &quot;startTime&quot;: &quot;A String&quot;, # Optional. Timestamp after which the first run can be scheduled. Default to Schedule create time if not specified.
  &quot;startedRunCount&quot;: &quot;A String&quot;, # Output only. The number of runs started by this schedule.
  &quot;state&quot;: &quot;A String&quot;, # Output only. The state of this Schedule.
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule was updated.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # An instance of a Schedule periodically schedules runs to make API calls based on user specified time specification and API request type.
  &quot;allowQueueing&quot;: True or False, # Optional. Whether new scheduled runs can be queued when max_concurrent_runs limit is reached. If set to true, new runs will be queued instead of skipped. Default to false.
  &quot;catchUp&quot;: True or False, # Output only. Whether to backfill missed runs when the schedule is resumed from PAUSED state. If set to true, all missed runs will be scheduled. New runs will be scheduled after the backfill is complete. Default to false.
  &quot;createModelMonitoringJobRequest&quot;: { # Request message for ModelMonitoringService.CreateModelMonitoringJob. # Request for ModelMonitoringService.CreateModelMonitoringJob.
    &quot;modelMonitoringJob&quot;: { # Represents a model monitoring job that analyze dataset using different monitoring algorithm. # Required. The ModelMonitoringJob to create
      &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelMonitoringJob was created.
      &quot;displayName&quot;: &quot;A String&quot;, # The display name of the ModelMonitoringJob. The name can be up to 128 characters long and can consist of any UTF-8.
      &quot;jobExecutionDetail&quot;: { # Represent the execution details of the job. # Output only. Execution results for all the monitoring objectives.
        &quot;baselineDatasets&quot;: [ # Processed baseline datasets.
          { # Processed dataset information.
            &quot;location&quot;: &quot;A String&quot;, # Actual data location of the processed dataset.
            &quot;timeRange&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Dataset time range information if any.
              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end.
              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start.
            },
          },
        ],
        &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Additional job error status.
          &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
          &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
            {
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
            },
          ],
          &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
        },
        &quot;objectiveStatus&quot;: { # Status of data processing for each monitoring objective. Key is the objective.
          &quot;a_key&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
            &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
            &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
              {
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
              },
            ],
            &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
          },
        },
        &quot;targetDatasets&quot;: [ # Processed target datasets.
          { # Processed dataset information.
            &quot;location&quot;: &quot;A String&quot;, # Actual data location of the processed dataset.
            &quot;timeRange&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Dataset time range information if any.
              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end.
              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start.
            },
          },
        ],
      },
      &quot;modelMonitoringSpec&quot;: { # Monitoring monitoring job spec. It outlines the specifications for monitoring objectives, notifications, and result exports. # Monitoring monitoring job spec. It outlines the specifications for monitoring objectives, notifications, and result exports. If left blank, the default monitoring specifications from the top-level resource &#x27;ModelMonitor&#x27; will be applied. If provided, we will use the specification defined here rather than the default one.
        &quot;notificationSpec&quot;: { # Notification spec(email, notification channel) for model monitoring statistics/alerts. # The model monitoring notification spec.
          &quot;emailConfig&quot;: { # The config for email alerts. # Email alert config.
            &quot;userEmails&quot;: [ # The email addresses to send the alerts.
              &quot;A String&quot;,
            ],
          },
          &quot;enableCloudLogging&quot;: True or False, # Dump the anomalies to Cloud Logging. The anomalies will be put to json payload encoded from proto google.cloud.aiplatform.logging.ModelMonitoringAnomaliesLogEntry. This can be further sinked to Pub/Sub or any other services supported by Cloud Logging.
          &quot;notificationChannelConfigs&quot;: [ # Notification channel config.
            { # Google Cloud Notification Channel config.
              &quot;notificationChannel&quot;: &quot;A String&quot;, # Resource names of the NotificationChannels. Must be of the format `projects//notificationChannels/`
            },
          ],
        },
        &quot;objectiveSpec&quot;: { # Monitoring objectives spec. # The monitoring objective spec.
          &quot;baselineDataset&quot;: { # Model monitoring data input spec. # Baseline dataset. It could be the training dataset or production serving dataset from a previous period.
            &quot;batchPredictionOutput&quot;: { # Data from Vertex AI Batch prediction job output. # Vertex AI Batch prediction Job.
              &quot;batchPredictionJob&quot;: &quot;A String&quot;, # Vertex AI Batch prediction job resource name. The job must match the model version specified in [ModelMonitor].[model_monitoring_target].
            },
            &quot;columnizedDataset&quot;: { # Input dataset spec. # Columnized dataset.
              &quot;bigquerySource&quot;: { # Dataset spec for data sotred in BigQuery. # BigQuery data source.
                &quot;query&quot;: &quot;A String&quot;, # Standard SQL to be used instead of the `table_uri`.
                &quot;tableUri&quot;: &quot;A String&quot;, # BigQuery URI to a table, up to 2000 characters long. All the columns in the table will be selected. Accepted forms: * BigQuery path. For example: `bq://projectId.bqDatasetId.bqTableId`.
              },
              &quot;gcsSource&quot;: { # Dataset spec for data stored in Google Cloud Storage. # Google Cloud Storage data source.
                &quot;format&quot;: &quot;A String&quot;, # Data format of the dataset.
                &quot;gcsUri&quot;: &quot;A String&quot;, # Google Cloud Storage URI to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
              },
              &quot;timestampField&quot;: &quot;A String&quot;, # The timestamp field. Usually for serving data.
              &quot;vertexDataset&quot;: &quot;A String&quot;, # Resource name of the Vertex AI managed dataset.
            },
            &quot;timeInterval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # The time interval (pair of start_time and end_time) for which results should be returned.
              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end.
              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start.
            },
            &quot;timeOffset&quot;: { # Time offset setting. # The time offset setting for which results should be returned.
              &quot;offset&quot;: &quot;A String&quot;, # [offset] is the time difference from the cut-off time. For scheduled jobs, the cut-off time is the scheduled time. For non-scheduled jobs, it&#x27;s the time when the job was created. Currently we support the following format: &#x27;w|W&#x27;: Week, &#x27;d|D&#x27;: Day, &#x27;h|H&#x27;: Hour E.g. &#x27;1h&#x27; stands for 1 hour, &#x27;2d&#x27; stands for 2 days.
              &quot;window&quot;: &quot;A String&quot;, # [window] refers to the scope of data selected for analysis. It allows you to specify the quantity of data you wish to examine. Currently we support the following format: &#x27;w|W&#x27;: Week, &#x27;d|D&#x27;: Day, &#x27;h|H&#x27;: Hour E.g. &#x27;1h&#x27; stands for 1 hour, &#x27;2d&#x27; stands for 2 days.
            },
            &quot;vertexEndpointLogs&quot;: { # Data from Vertex AI Endpoint request response logging. # Vertex AI Endpoint request &amp; response logging.
              &quot;endpoints&quot;: [ # List of endpoint resource names. The endpoints must enable the logging with the [Endpoint].[request_response_logging_config], and must contain the deployed model corresponding to the model version specified in [ModelMonitor].[model_monitoring_target].
                &quot;A String&quot;,
              ],
            },
          },
          &quot;explanationSpec&quot;: { # Specification of Model explanation. # The explanation spec. This spec is required when the objectives spec includes feature attribution objectives.
            &quot;metadata&quot;: { # Metadata describing the Model&#x27;s input and output for explanation. # Optional. Metadata describing the Model&#x27;s input and output for explanation.
              &quot;featureAttributionsSchemaUri&quot;: &quot;A String&quot;, # Points to a YAML file stored on Google Cloud Storage describing the format of the feature attributions. The schema is defined as an OpenAPI 3.0.2 [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject). AutoML tabular Models always have this field populated by Vertex AI. Note: The URI given on output may be different, including the URI scheme, than the one given on input. The output URI will point to a location where the user only has a read access.
              &quot;inputs&quot;: { # Required. Map from feature names to feature input metadata. Keys are the name of the features. Values are the specification of the feature. An empty InputMetadata is valid. It describes a text feature which has the name specified as the key in ExplanationMetadata.inputs. The baseline of the empty feature is chosen by Vertex AI. For Vertex AI-provided Tensorflow images, the key can be any friendly name of the feature. Once specified, featureAttributions are keyed by this key (if not grouped with another feature). For custom images, the key must match with the key in instance.
                &quot;a_key&quot;: { # Metadata of the input of a feature. Fields other than InputMetadata.input_baselines are applicable only for Models that are using Vertex AI-provided images for Tensorflow.
                  &quot;denseShapeTensorName&quot;: &quot;A String&quot;, # Specifies the shape of the values of the input if the input is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
                  &quot;encodedBaselines&quot;: [ # A list of baselines for the encoded tensor. The shape of each baseline should match the shape of the encoded tensor. If a scalar is provided, Vertex AI broadcasts to the same shape as the encoded tensor.
                    &quot;&quot;,
                  ],
                  &quot;encodedTensorName&quot;: &quot;A String&quot;, # Encoded tensor is a transformation of the input tensor. Must be provided if choosing Integrated Gradients attribution or XRAI attribution and the input tensor is not differentiable. An encoded tensor is generated if the input tensor is encoded by a lookup table.
                  &quot;encoding&quot;: &quot;A String&quot;, # Defines how the feature is encoded into the input tensor. Defaults to IDENTITY.
                  &quot;featureValueDomain&quot;: { # Domain details of the input feature value. Provides numeric information about the feature, such as its range (min, max). If the feature has been pre-processed, for example with z-scoring, then it provides information about how to recover the original feature. For example, if the input feature is an image and it has been pre-processed to obtain 0-mean and stddev = 1 values, then original_mean, and original_stddev refer to the mean and stddev of the original feature (e.g. image tensor) from which input feature (with mean = 0 and stddev = 1) was obtained. # The domain details of the input feature value. Like min/max, original mean or standard deviation if normalized.
                    &quot;maxValue&quot;: 3.14, # The maximum permissible value for this feature.
                    &quot;minValue&quot;: 3.14, # The minimum permissible value for this feature.
                    &quot;originalMean&quot;: 3.14, # If this input feature has been normalized to a mean value of 0, the original_mean specifies the mean value of the domain prior to normalization.
                    &quot;originalStddev&quot;: 3.14, # If this input feature has been normalized to a standard deviation of 1.0, the original_stddev specifies the standard deviation of the domain prior to normalization.
                  },
                  &quot;groupName&quot;: &quot;A String&quot;, # Name of the group that the input belongs to. Features with the same group name will be treated as one feature when computing attributions. Features grouped together can have different shapes in value. If provided, there will be one single attribution generated in Attribution.feature_attributions, keyed by the group name.
                  &quot;indexFeatureMapping&quot;: [ # A list of feature names for each index in the input tensor. Required when the input InputMetadata.encoding is BAG_OF_FEATURES, BAG_OF_FEATURES_SPARSE, INDICATOR.
                    &quot;A String&quot;,
                  ],
                  &quot;indicesTensorName&quot;: &quot;A String&quot;, # Specifies the index of the values of the input tensor. Required when the input tensor is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
                  &quot;inputBaselines&quot;: [ # Baseline inputs for this feature. If no baseline is specified, Vertex AI chooses the baseline for this feature. If multiple baselines are specified, Vertex AI returns the average attributions across them in Attribution.feature_attributions. For Vertex AI-provided Tensorflow images (both 1.x and 2.x), the shape of each baseline must match the shape of the input tensor. If a scalar is provided, we broadcast to the same shape as the input tensor. For custom images, the element of the baselines must be in the same format as the feature&#x27;s input in the instance[]. The schema of any single instance may be specified via Endpoint&#x27;s DeployedModels&#x27; Model&#x27;s PredictSchemata&#x27;s instance_schema_uri.
                    &quot;&quot;,
                  ],
                  &quot;inputTensorName&quot;: &quot;A String&quot;, # Name of the input tensor for this feature. Required and is only applicable to Vertex AI-provided images for Tensorflow.
                  &quot;modality&quot;: &quot;A String&quot;, # Modality of the feature. Valid values are: numeric, image. Defaults to numeric.
                  &quot;visualization&quot;: { # Visualization configurations for image explanation. # Visualization configurations for image explanation.
                    &quot;clipPercentLowerbound&quot;: 3.14, # Excludes attributions below the specified percentile, from the highlighted areas. Defaults to 62.
                    &quot;clipPercentUpperbound&quot;: 3.14, # Excludes attributions above the specified percentile from the highlighted areas. Using the clip_percent_upperbound and clip_percent_lowerbound together can be useful for filtering out noise and making it easier to see areas of strong attribution. Defaults to 99.9.
                    &quot;colorMap&quot;: &quot;A String&quot;, # The color scheme used for the highlighted areas. Defaults to PINK_GREEN for Integrated Gradients attribution, which shows positive attributions in green and negative in pink. Defaults to VIRIDIS for XRAI attribution, which highlights the most influential regions in yellow and the least influential in blue.
                    &quot;overlayType&quot;: &quot;A String&quot;, # How the original image is displayed in the visualization. Adjusting the overlay can help increase visual clarity if the original image makes it difficult to view the visualization. Defaults to NONE.
                    &quot;polarity&quot;: &quot;A String&quot;, # Whether to only highlight pixels with positive contributions, negative or both. Defaults to POSITIVE.
                    &quot;type&quot;: &quot;A String&quot;, # Type of the image visualization. Only applicable to Integrated Gradients attribution. OUTLINES shows regions of attribution, while PIXELS shows per-pixel attribution. Defaults to OUTLINES.
                  },
                },
              },
              &quot;latentSpaceSource&quot;: &quot;A String&quot;, # Name of the source to generate embeddings for example based explanations.
              &quot;outputs&quot;: { # Required. Map from output names to output metadata. For Vertex AI-provided Tensorflow images, keys can be any user defined string that consists of any UTF-8 characters. For custom images, keys are the name of the output field in the prediction to be explained. Currently only one key is allowed.
                &quot;a_key&quot;: { # Metadata of the prediction output to be explained.
                  &quot;displayNameMappingKey&quot;: &quot;A String&quot;, # Specify a field name in the prediction to look for the display name. Use this if the prediction contains the display names for the outputs. The display names in the prediction must have the same shape of the outputs, so that it can be located by Attribution.output_index for a specific output.
                  &quot;indexDisplayNameMapping&quot;: &quot;&quot;, # Static mapping between the index and display name. Use this if the outputs are a deterministic n-dimensional array, e.g. a list of scores of all the classes in a pre-defined order for a multi-classification Model. It&#x27;s not feasible if the outputs are non-deterministic, e.g. the Model produces top-k classes or sort the outputs by their values. The shape of the value must be an n-dimensional array of strings. The number of dimensions must match that of the outputs to be explained. The Attribution.output_display_name is populated by locating in the mapping with Attribution.output_index.
                  &quot;outputTensorName&quot;: &quot;A String&quot;, # Name of the output tensor. Required and is only applicable to Vertex AI provided images for Tensorflow.
                },
              },
            },
            &quot;parameters&quot;: { # Parameters to configure explaining for Model&#x27;s predictions. # Required. Parameters that configure explaining of the Model&#x27;s predictions.
              &quot;examples&quot;: { # Example-based explainability that returns the nearest neighbors from the provided dataset. # Example-based explanations that returns the nearest neighbors from the provided dataset.
                &quot;exampleGcsSource&quot;: { # The Cloud Storage input instances. # The Cloud Storage input instances.
                  &quot;dataFormat&quot;: &quot;A String&quot;, # The format in which instances are given, if not specified, assume it&#x27;s JSONL format. Currently only JSONL format is supported.
                  &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage location for the input instances.
                    &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                      &quot;A String&quot;,
                    ],
                  },
                },
                &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage locations that contain the instances to be indexed for approximate nearest neighbor search.
                  &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                    &quot;A String&quot;,
                  ],
                },
                &quot;nearestNeighborSearchConfig&quot;: &quot;&quot;, # The full configuration for the generated index, the semantics are the same as metadata and should match [NearestNeighborSearchConfig](https://cloud.google.com/vertex-ai/docs/explainable-ai/configuring-explanations-example-based#nearest-neighbor-search-config).
                &quot;neighborCount&quot;: 42, # The number of neighbors to return when querying for examples.
                &quot;presets&quot;: { # Preset configuration for example-based explanations # Simplified preset configuration, which automatically sets configuration values based on the desired query speed-precision trade-off and modality.
                  &quot;modality&quot;: &quot;A String&quot;, # The modality of the uploaded model, which automatically configures the distance measurement and feature normalization for the underlying example index and queries. If your model does not precisely fit one of these types, it is okay to choose the closest type.
                  &quot;query&quot;: &quot;A String&quot;, # Preset option controlling parameters for speed-precision trade-off when querying for examples. If omitted, defaults to `PRECISE`.
                },
              },
              &quot;integratedGradientsAttribution&quot;: { # An attribution method that computes the Aumann-Shapley value taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365 # An attribution method that computes Aumann-Shapley values taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365
                &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for IG with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
                  &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
                },
                &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
                  &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
                    &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
                      { # Noise sigma for a single feature.
                        &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                        &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
                      },
                    ],
                  },
                  &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
                  &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
                },
                &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is within the desired error range. Valid range of its value is [1, 100], inclusively.
              },
              &quot;outputIndices&quot;: [ # If populated, only returns attributions that have output_index contained in output_indices. It must be an ndarray of integers, with the same shape of the output it&#x27;s explaining. If not populated, returns attributions for top_k indices of outputs. If neither top_k nor output_indices is populated, returns the argmax index of the outputs. Only applicable to Models that predict multiple outputs (e,g, multi-class Models that predict multiple classes).
                &quot;&quot;,
              ],
              &quot;sampledShapleyAttribution&quot;: { # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. Refer to this paper for model details: https://arxiv.org/abs/1306.4265.
                &quot;pathCount&quot;: 42, # Required. The number of feature permutations to consider when approximating the Shapley values. Valid range of its value is [1, 50], inclusively.
              },
              &quot;topK&quot;: 42, # If populated, returns attributions for top K indices of outputs (defaults to 1). Only applies to Models that predicts more than one outputs (e,g, multi-class Models). When set to -1, returns explanations for all outputs.
              &quot;xraiAttribution&quot;: { # An explanation method that redistributes Integrated Gradients attributions to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 Supported only by image Models. # An attribution method that redistributes Integrated Gradients attribution to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 XRAI currently performs better on natural images, like a picture of a house or an animal. If the images are taken in artificial environments, like a lab or manufacturing line, or from diagnostic equipment, like x-rays or quality-control cameras, use Integrated Gradients instead.
                &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for XRAI with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
                  &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
                },
                &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
                  &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
                    &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
                      { # Noise sigma for a single feature.
                        &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                        &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
                      },
                    ],
                  },
                  &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
                  &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
                },
                &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is met within the desired error range. Valid range of its value is [1, 100], inclusively.
              },
            },
          },
          &quot;tabularObjective&quot;: { # Tabular monitoring objective. # Tabular monitoring objective.
            &quot;featureAttributionSpec&quot;: { # Feature attribution monitoring spec. # Feature attribution monitoring spec.
              &quot;batchExplanationDedicatedResources&quot;: { # A description of resources that are used for performing batch operations, are dedicated to a Model, and need manual configuration. # The config of resources used by the Model Monitoring during the batch explanation for non-AutoML models. If not set, `n1-standard-2` machine type will be used by default.
                &quot;machineSpec&quot;: { # Specification of a single machine. # Required. Immutable. The specification of a single machine.
                  &quot;acceleratorCount&quot;: 42, # The number of accelerators to attach to the machine.
                  &quot;acceleratorType&quot;: &quot;A String&quot;, # Immutable. The type of accelerator(s) that may be attached to the machine as per accelerator_count.
                  &quot;machineType&quot;: &quot;A String&quot;, # Immutable. The type of the machine. See the [list of machine types supported for prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types) See the [list of machine types supported for custom training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types). For DeployedModel this field is optional, and the default value is `n1-standard-2`. For BatchPredictionJob or as part of WorkerPoolSpec this field is required.
                  &quot;reservationAffinity&quot;: { # A ReservationAffinity can be used to configure a Vertex AI resource (e.g., a DeployedModel) to draw its Compute Engine resources from a Shared Reservation, or exclusively from on-demand capacity. # Optional. Immutable. Configuration controlling how this resource pool consumes reservation.
                    &quot;key&quot;: &quot;A String&quot;, # Optional. Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, use `compute.googleapis.com/reservation-name` as the key and specify the name of your reservation as its value.
                    &quot;reservationAffinityType&quot;: &quot;A String&quot;, # Required. Specifies the reservation affinity type.
                    &quot;values&quot;: [ # Optional. Corresponds to the label values of a reservation resource. This must be the full resource name of the reservation.
                      &quot;A String&quot;,
                    ],
                  },
                  &quot;tpuTopology&quot;: &quot;A String&quot;, # Immutable. The topology of the TPUs. Corresponds to the TPU topologies available from GKE. (Example: tpu_topology: &quot;2x2x1&quot;).
                },
                &quot;maxReplicaCount&quot;: 42, # Immutable. The maximum number of machine replicas the batch operation may be scaled to. The default value is 10.
                &quot;startingReplicaCount&quot;: 42, # Immutable. The number of machine replicas used at the start of the batch operation. If not set, Vertex AI decides starting number, not greater than max_replica_count
              },
              &quot;defaultAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the features.
                &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
              },
              &quot;featureAlertConditions&quot;: { # Per feature alert condition will override default alert condition.
                &quot;a_key&quot;: { # Monitoring alert triggered condition.
                  &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
                },
              },
              &quot;features&quot;: [ # Feature names interested in monitoring. These should be a subset of the input feature names specified in the monitoring schema. If the field is not specified all features outlied in the monitoring schema will be used.
                &quot;A String&quot;,
              ],
            },
            &quot;featureDriftSpec&quot;: { # Data drift monitoring spec. Data drift measures the distribution distance between the current dataset and a baseline dataset. A typical use case is to detect data drift between the recent production serving dataset and the training dataset, or to compare the recent production dataset with a dataset from a previous period. # Input feature distribution drift monitoring spec.
              &quot;categoricalMetricType&quot;: &quot;A String&quot;, # Supported metrics type: * l_infinity * jensen_shannon_divergence
              &quot;defaultCategoricalAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the categorical features.
                &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
              },
              &quot;defaultNumericAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the numeric features.
                &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
              },
              &quot;featureAlertConditions&quot;: { # Per feature alert condition will override default alert condition.
                &quot;a_key&quot;: { # Monitoring alert triggered condition.
                  &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
                },
              },
              &quot;features&quot;: [ # Feature names / Prediction output names interested in monitoring. These should be a subset of the input feature names or prediction output names specified in the monitoring schema. If the field is not specified all features / prediction outputs outlied in the monitoring schema will be used.
                &quot;A String&quot;,
              ],
              &quot;numericMetricType&quot;: &quot;A String&quot;, # Supported metrics type: * jensen_shannon_divergence
            },
            &quot;predictionOutputDriftSpec&quot;: { # Data drift monitoring spec. Data drift measures the distribution distance between the current dataset and a baseline dataset. A typical use case is to detect data drift between the recent production serving dataset and the training dataset, or to compare the recent production dataset with a dataset from a previous period. # Prediction output distribution drift monitoring spec.
              &quot;categoricalMetricType&quot;: &quot;A String&quot;, # Supported metrics type: * l_infinity * jensen_shannon_divergence
              &quot;defaultCategoricalAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the categorical features.
                &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
              },
              &quot;defaultNumericAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the numeric features.
                &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
              },
              &quot;featureAlertConditions&quot;: { # Per feature alert condition will override default alert condition.
                &quot;a_key&quot;: { # Monitoring alert triggered condition.
                  &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
                },
              },
              &quot;features&quot;: [ # Feature names / Prediction output names interested in monitoring. These should be a subset of the input feature names or prediction output names specified in the monitoring schema. If the field is not specified all features / prediction outputs outlied in the monitoring schema will be used.
                &quot;A String&quot;,
              ],
              &quot;numericMetricType&quot;: &quot;A String&quot;, # Supported metrics type: * jensen_shannon_divergence
            },
          },
          &quot;targetDataset&quot;: { # Model monitoring data input spec. # Target dataset.
            &quot;batchPredictionOutput&quot;: { # Data from Vertex AI Batch prediction job output. # Vertex AI Batch prediction Job.
              &quot;batchPredictionJob&quot;: &quot;A String&quot;, # Vertex AI Batch prediction job resource name. The job must match the model version specified in [ModelMonitor].[model_monitoring_target].
            },
            &quot;columnizedDataset&quot;: { # Input dataset spec. # Columnized dataset.
              &quot;bigquerySource&quot;: { # Dataset spec for data sotred in BigQuery. # BigQuery data source.
                &quot;query&quot;: &quot;A String&quot;, # Standard SQL to be used instead of the `table_uri`.
                &quot;tableUri&quot;: &quot;A String&quot;, # BigQuery URI to a table, up to 2000 characters long. All the columns in the table will be selected. Accepted forms: * BigQuery path. For example: `bq://projectId.bqDatasetId.bqTableId`.
              },
              &quot;gcsSource&quot;: { # Dataset spec for data stored in Google Cloud Storage. # Google Cloud Storage data source.
                &quot;format&quot;: &quot;A String&quot;, # Data format of the dataset.
                &quot;gcsUri&quot;: &quot;A String&quot;, # Google Cloud Storage URI to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
              },
              &quot;timestampField&quot;: &quot;A String&quot;, # The timestamp field. Usually for serving data.
              &quot;vertexDataset&quot;: &quot;A String&quot;, # Resource name of the Vertex AI managed dataset.
            },
            &quot;timeInterval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # The time interval (pair of start_time and end_time) for which results should be returned.
              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end.
              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start.
            },
            &quot;timeOffset&quot;: { # Time offset setting. # The time offset setting for which results should be returned.
              &quot;offset&quot;: &quot;A String&quot;, # [offset] is the time difference from the cut-off time. For scheduled jobs, the cut-off time is the scheduled time. For non-scheduled jobs, it&#x27;s the time when the job was created. Currently we support the following format: &#x27;w|W&#x27;: Week, &#x27;d|D&#x27;: Day, &#x27;h|H&#x27;: Hour E.g. &#x27;1h&#x27; stands for 1 hour, &#x27;2d&#x27; stands for 2 days.
              &quot;window&quot;: &quot;A String&quot;, # [window] refers to the scope of data selected for analysis. It allows you to specify the quantity of data you wish to examine. Currently we support the following format: &#x27;w|W&#x27;: Week, &#x27;d|D&#x27;: Day, &#x27;h|H&#x27;: Hour E.g. &#x27;1h&#x27; stands for 1 hour, &#x27;2d&#x27; stands for 2 days.
            },
            &quot;vertexEndpointLogs&quot;: { # Data from Vertex AI Endpoint request response logging. # Vertex AI Endpoint request &amp; response logging.
              &quot;endpoints&quot;: [ # List of endpoint resource names. The endpoints must enable the logging with the [Endpoint].[request_response_logging_config], and must contain the deployed model corresponding to the model version specified in [ModelMonitor].[model_monitoring_target].
                &quot;A String&quot;,
              ],
            },
          },
        },
        &quot;outputSpec&quot;: { # Specification for the export destination of monitoring results, including metrics, logs, etc. # The Output destination spec for metrics, error logs, etc.
          &quot;gcsBaseDirectory&quot;: { # The Google Cloud Storage location where the output is to be written to. # Google Cloud Storage base folder path for metrics, error logs, etc.
            &quot;outputUriPrefix&quot;: &quot;A String&quot;, # Required. Google Cloud Storage URI to output directory. If the uri doesn&#x27;t end with &#x27;/&#x27;, a &#x27;/&#x27; will be automatically appended. The directory is created if it doesn&#x27;t exist.
          },
        },
      },
      &quot;name&quot;: &quot;A String&quot;, # Output only. Resource name of a ModelMonitoringJob. Format: `projects/{project_id}/locations/{location_id}/modelMonitors/{model_monitor_id}/modelMonitoringJobs/{model_monitoring_job_id}`
      &quot;schedule&quot;: &quot;A String&quot;, # Output only. Schedule resource name. It will only appear when this job is triggered by a schedule.
      &quot;scheduleTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelMonitoringJob was scheduled. It will only appear when this job is triggered by a schedule.
      &quot;state&quot;: &quot;A String&quot;, # Output only. The state of the monitoring job. * When the job is still creating, the state will be &#x27;JOB_STATE_PENDING&#x27;. * Once the job is successfully created, the state will be &#x27;JOB_STATE_RUNNING&#x27;. * Once the job is finished, the state will be one of &#x27;JOB_STATE_FAILED&#x27;, &#x27;JOB_STATE_SUCCEEDED&#x27;, &#x27;JOB_STATE_PARTIALLY_SUCCEEDED&#x27;.
      &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelMonitoringJob was updated most recently.
    },
    &quot;modelMonitoringJobId&quot;: &quot;A String&quot;, # Optional. The ID to use for the Model Monitoring Job, which will become the final component of the model monitoring job resource name. The maximum length is 63 characters, and valid characters are `/^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$/`.
    &quot;parent&quot;: &quot;A String&quot;, # Required. The parent of the ModelMonitoringJob. Format: `projects/{project}/locations/{location}/modelMoniitors/{model_monitor}`
  },
  &quot;createNotebookExecutionJobRequest&quot;: { # Request message for [NotebookService.CreateNotebookExecutionJob] # Request for NotebookService.CreateNotebookExecutionJob.
    &quot;notebookExecutionJob&quot;: { # NotebookExecutionJob represents an instance of a notebook execution. # Required. The NotebookExecutionJob to create.
      &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this NotebookExecutionJob was created.
      &quot;dataformRepositorySource&quot;: { # The Dataform Repository containing the input notebook. # The Dataform Repository pointing to a single file notebook repository.
        &quot;commitSha&quot;: &quot;A String&quot;, # The commit SHA to read repository with. If unset, the file will be read at HEAD.
        &quot;dataformRepositoryResourceName&quot;: &quot;A String&quot;, # The resource name of the Dataform Repository. Format: `projects/{project_id}/locations/{location}/repositories/{repository_id}`
      },
      &quot;directNotebookSource&quot;: { # The content of the input notebook in ipynb format. # The contents of an input notebook file.
        &quot;content&quot;: &quot;A String&quot;, # The base64-encoded contents of the input notebook file.
      },
      &quot;displayName&quot;: &quot;A String&quot;, # The display name of the NotebookExecutionJob. The name can be up to 128 characters long and can consist of any UTF-8 characters.
      &quot;encryptionSpec&quot;: { # Represents a customer-managed encryption key spec that can be applied to a top-level resource. # Customer-managed encryption key spec for the notebook execution job. This field is auto-populated if the NotebookRuntimeTemplate has an encryption spec.
        &quot;kmsKeyName&quot;: &quot;A String&quot;, # Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
      },
      &quot;executionTimeout&quot;: &quot;A String&quot;, # Max running time of the execution job in seconds (default 86400s / 24 hrs).
      &quot;executionUser&quot;: &quot;A String&quot;, # The user email to run the execution as. Only supported by Colab runtimes.
      &quot;gcsNotebookSource&quot;: { # The Cloud Storage uri for the input notebook. # The Cloud Storage url pointing to the ipynb file. Format: `gs://bucket/notebook_file.ipynb`
        &quot;generation&quot;: &quot;A String&quot;, # The version of the Cloud Storage object to read. If unset, the current version of the object is read. See https://cloud.google.com/storage/docs/metadata#generation-number.
        &quot;uri&quot;: &quot;A String&quot;, # The Cloud Storage uri pointing to the ipynb file. Format: `gs://bucket/notebook_file.ipynb`
      },
      &quot;gcsOutputUri&quot;: &quot;A String&quot;, # The Cloud Storage location to upload the result to. Format: `gs://bucket-name`
      &quot;jobState&quot;: &quot;A String&quot;, # Output only. The state of the NotebookExecutionJob.
      &quot;labels&quot;: { # The labels with user-defined metadata to organize NotebookExecutionJobs. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels. System reserved label keys are prefixed with &quot;aiplatform.googleapis.com/&quot; and are immutable.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
      &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of this NotebookExecutionJob. Format: `projects/{project_id}/locations/{location}/notebookExecutionJobs/{job_id}`
      &quot;notebookRuntimeTemplateResourceName&quot;: &quot;A String&quot;, # The NotebookRuntimeTemplate to source compute configuration from.
      &quot;scheduleResourceName&quot;: &quot;A String&quot;, # Output only. The Schedule resource name if this job is triggered by one. Format: `projects/{project_id}/locations/{location}/schedules/{schedule_id}`
      &quot;serviceAccount&quot;: &quot;A String&quot;, # The service account to run the execution as.
      &quot;status&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. Populated when the NotebookExecutionJob is completed. When there is an error during notebook execution, the error details are populated.
        &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
        &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
          {
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
          },
        ],
        &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
      },
      &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this NotebookExecutionJob was most recently updated.
    },
    &quot;notebookExecutionJobId&quot;: &quot;A String&quot;, # Optional. User specified ID for the NotebookExecutionJob.
    &quot;parent&quot;: &quot;A String&quot;, # Required. The resource name of the Location to create the NotebookExecutionJob. Format: `projects/{project}/locations/{location}`
  },
  &quot;createPipelineJobRequest&quot;: { # Request message for PipelineService.CreatePipelineJob. # Request for PipelineService.CreatePipelineJob. CreatePipelineJobRequest.parent field is required (format: projects/{project}/locations/{location}).
    &quot;parent&quot;: &quot;A String&quot;, # Required. The resource name of the Location to create the PipelineJob in. Format: `projects/{project}/locations/{location}`
    &quot;pipelineJob&quot;: { # An instance of a machine learning PipelineJob. # Required. The PipelineJob to create.
      &quot;createTime&quot;: &quot;A String&quot;, # Output only. Pipeline creation time.
      &quot;displayName&quot;: &quot;A String&quot;, # The display name of the Pipeline. The name can be up to 128 characters long and can consist of any UTF-8 characters.
      &quot;encryptionSpec&quot;: { # Represents a customer-managed encryption key spec that can be applied to a top-level resource. # Customer-managed encryption key spec for a pipelineJob. If set, this PipelineJob and all of its sub-resources will be secured by this key.
        &quot;kmsKeyName&quot;: &quot;A String&quot;, # Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
      },
      &quot;endTime&quot;: &quot;A String&quot;, # Output only. Pipeline end time.
      &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. The error that occurred during pipeline execution. Only populated when the pipeline&#x27;s state is FAILED or CANCELLED.
        &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
        &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
          {
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
          },
        ],
        &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
      },
      &quot;jobDetail&quot;: { # The runtime detail of PipelineJob. # Output only. The details of pipeline run. Not available in the list view.
        &quot;pipelineContext&quot;: { # Instance of a general context. # Output only. The context of the pipeline.
          &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Context was created.
          &quot;description&quot;: &quot;A String&quot;, # Description of the Context
          &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Context. May be up to 128 Unicode characters.
          &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
          &quot;labels&quot;: { # The labels with user-defined metadata to organize your Contexts. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Context (System labels are excluded).
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;metadata&quot;: { # Properties of the Context. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;name&quot;: &quot;A String&quot;, # Immutable. The resource name of the Context.
          &quot;parentContexts&quot;: [ # Output only. A list of resource names of Contexts that are parents of this Context. A Context may have at most 10 parent_contexts.
            &quot;A String&quot;,
          ],
          &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
          &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in schema_name to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
          &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Context was last updated.
        },
        &quot;pipelineRunContext&quot;: { # Instance of a general context. # Output only. The context of the current pipeline run.
          &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Context was created.
          &quot;description&quot;: &quot;A String&quot;, # Description of the Context
          &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Context. May be up to 128 Unicode characters.
          &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
          &quot;labels&quot;: { # The labels with user-defined metadata to organize your Contexts. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Context (System labels are excluded).
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;metadata&quot;: { # Properties of the Context. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;name&quot;: &quot;A String&quot;, # Immutable. The resource name of the Context.
          &quot;parentContexts&quot;: [ # Output only. A list of resource names of Contexts that are parents of this Context. A Context may have at most 10 parent_contexts.
            &quot;A String&quot;,
          ],
          &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
          &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in schema_name to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
          &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Context was last updated.
        },
        &quot;taskDetails&quot;: [ # Output only. The runtime details of the tasks under the pipeline.
          { # The runtime detail of a task execution.
            &quot;createTime&quot;: &quot;A String&quot;, # Output only. Task create time.
            &quot;endTime&quot;: &quot;A String&quot;, # Output only. Task end time.
            &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. The error that occurred during task execution. Only populated when the task&#x27;s state is FAILED or CANCELLED.
              &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
              &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
                {
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
                },
              ],
              &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
            },
            &quot;execution&quot;: { # Instance of a general execution. # Output only. The execution metadata of the task.
              &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Execution was created.
              &quot;description&quot;: &quot;A String&quot;, # Description of the Execution
              &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Execution. May be up to 128 Unicode characters.
              &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
              &quot;labels&quot;: { # The labels with user-defined metadata to organize your Executions. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Execution (System labels are excluded).
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;metadata&quot;: { # Properties of the Execution. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the Execution.
              &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
              &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in `schema_title` to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
              &quot;state&quot;: &quot;A String&quot;, # The state of this Execution. This is a property of the Execution, and does not imply or capture any ongoing process. This property is managed by clients (such as Vertex AI Pipelines) and the system does not prescribe or check the validity of state transitions.
              &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Execution was last updated.
            },
            &quot;executorDetail&quot;: { # The runtime detail of a pipeline executor. # Output only. The detailed execution info.
              &quot;containerDetail&quot;: { # The detail of a container execution. It contains the job names of the lifecycle of a container execution. # Output only. The detailed info for a container executor.
                &quot;failedMainJobs&quot;: [ # Output only. The names of the previously failed CustomJob for the main container executions. The list includes the all attempts in chronological order.
                  &quot;A String&quot;,
                ],
                &quot;failedPreCachingCheckJobs&quot;: [ # Output only. The names of the previously failed CustomJob for the pre-caching-check container executions. This job will be available if the PipelineJob.pipeline_spec specifies the `pre_caching_check` hook in the lifecycle events. The list includes the all attempts in chronological order.
                  &quot;A String&quot;,
                ],
                &quot;mainJob&quot;: &quot;A String&quot;, # Output only. The name of the CustomJob for the main container execution.
                &quot;preCachingCheckJob&quot;: &quot;A String&quot;, # Output only. The name of the CustomJob for the pre-caching-check container execution. This job will be available if the PipelineJob.pipeline_spec specifies the `pre_caching_check` hook in the lifecycle events.
              },
              &quot;customJobDetail&quot;: { # The detailed info for a custom job executor. # Output only. The detailed info for a custom job executor.
                &quot;failedJobs&quot;: [ # Output only. The names of the previously failed CustomJob. The list includes the all attempts in chronological order.
                  &quot;A String&quot;,
                ],
                &quot;job&quot;: &quot;A String&quot;, # Output only. The name of the CustomJob.
              },
            },
            &quot;inputs&quot;: { # Output only. The runtime input artifacts of the task.
              &quot;a_key&quot;: { # A list of artifact metadata.
                &quot;artifacts&quot;: [ # Output only. A list of artifact metadata.
                  { # Instance of a general artifact.
                    &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Artifact was created.
                    &quot;description&quot;: &quot;A String&quot;, # Description of the Artifact
                    &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Artifact. May be up to 128 Unicode characters.
                    &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
                    &quot;labels&quot;: { # The labels with user-defined metadata to organize your Artifacts. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Artifact (System labels are excluded).
                      &quot;a_key&quot;: &quot;A String&quot;,
                    },
                    &quot;metadata&quot;: { # Properties of the Artifact. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the Artifact.
                    &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
                    &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in schema_name to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
                    &quot;state&quot;: &quot;A String&quot;, # The state of this Artifact. This is a property of the Artifact, and does not imply or capture any ongoing process. This property is managed by clients (such as Vertex AI Pipelines), and the system does not prescribe or check the validity of state transitions.
                    &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Artifact was last updated.
                    &quot;uri&quot;: &quot;A String&quot;, # The uniform resource identifier of the artifact file. May be empty if there is no actual artifact file.
                  },
                ],
              },
            },
            &quot;outputs&quot;: { # Output only. The runtime output artifacts of the task.
              &quot;a_key&quot;: { # A list of artifact metadata.
                &quot;artifacts&quot;: [ # Output only. A list of artifact metadata.
                  { # Instance of a general artifact.
                    &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Artifact was created.
                    &quot;description&quot;: &quot;A String&quot;, # Description of the Artifact
                    &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Artifact. May be up to 128 Unicode characters.
                    &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
                    &quot;labels&quot;: { # The labels with user-defined metadata to organize your Artifacts. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Artifact (System labels are excluded).
                      &quot;a_key&quot;: &quot;A String&quot;,
                    },
                    &quot;metadata&quot;: { # Properties of the Artifact. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the Artifact.
                    &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
                    &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in schema_name to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
                    &quot;state&quot;: &quot;A String&quot;, # The state of this Artifact. This is a property of the Artifact, and does not imply or capture any ongoing process. This property is managed by clients (such as Vertex AI Pipelines), and the system does not prescribe or check the validity of state transitions.
                    &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Artifact was last updated.
                    &quot;uri&quot;: &quot;A String&quot;, # The uniform resource identifier of the artifact file. May be empty if there is no actual artifact file.
                  },
                ],
              },
            },
            &quot;parentTaskId&quot;: &quot;A String&quot;, # Output only. The id of the parent task if the task is within a component scope. Empty if the task is at the root level.
            &quot;pipelineTaskStatus&quot;: [ # Output only. A list of task status. This field keeps a record of task status evolving over time.
              { # A single record of the task status.
                &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. The error that occurred during the state. May be set when the state is any of the non-final state (PENDING/RUNNING/CANCELLING) or FAILED state. If the state is FAILED, the error here is final and not going to be retried. If the state is a non-final state, the error indicates a system-error being retried.
                  &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
                  &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
                    {
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
                    },
                  ],
                  &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
                },
                &quot;state&quot;: &quot;A String&quot;, # Output only. The state of the task.
                &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Update time of this status.
              },
            ],
            &quot;startTime&quot;: &quot;A String&quot;, # Output only. Task start time.
            &quot;state&quot;: &quot;A String&quot;, # Output only. State of the task.
            &quot;taskId&quot;: &quot;A String&quot;, # Output only. The system generated ID of the task.
            &quot;taskName&quot;: &quot;A String&quot;, # Output only. The user specified name of the task that is defined in pipeline_spec.
          },
        ],
      },
      &quot;labels&quot;: { # The labels with user-defined metadata to organize PipelineJob. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels. Note there is some reserved label key for Vertex AI Pipelines. - `vertex-ai-pipelines-run-billing-id`, user set value will get overrided.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
      &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the PipelineJob.
      &quot;network&quot;: &quot;A String&quot;, # The full name of the Compute Engine [network](/compute/docs/networks-and-firewalls#networks) to which the Pipeline Job&#x27;s workload should be peered. For example, `projects/12345/global/networks/myVPC`. [Format](/compute/docs/reference/rest/v1/networks/insert) is of the form `projects/{project}/global/networks/{network}`. Where {project} is a project number, as in `12345`, and {network} is a network name. Private services access must already be configured for the network. Pipeline job will apply the network configuration to the Google Cloud resources being launched, if applied, such as Vertex AI Training or Dataflow job. If left unspecified, the workload is not peered with any network.
      &quot;pipelineSpec&quot;: { # The spec of the pipeline.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;preflightValidations&quot;: True or False, # Optional. Whether to do component level validations before job creation.
      &quot;reservedIpRanges&quot;: [ # A list of names for the reserved ip ranges under the VPC network that can be used for this Pipeline Job&#x27;s workload. If set, we will deploy the Pipeline Job&#x27;s workload within the provided ip ranges. Otherwise, the job will be deployed to any ip ranges under the provided VPC network. Example: [&#x27;vertex-ai-ip-range&#x27;].
        &quot;A String&quot;,
      ],
      &quot;runtimeConfig&quot;: { # The runtime config of a PipelineJob. # Runtime config of the pipeline.
        &quot;failurePolicy&quot;: &quot;A String&quot;, # Represents the failure policy of a pipeline. Currently, the default of a pipeline is that the pipeline will continue to run until no more tasks can be executed, also known as PIPELINE_FAILURE_POLICY_FAIL_SLOW. However, if a pipeline is set to PIPELINE_FAILURE_POLICY_FAIL_FAST, it will stop scheduling any new tasks when a task has failed. Any scheduled tasks will continue to completion.
        &quot;gcsOutputDirectory&quot;: &quot;A String&quot;, # Required. A path in a Cloud Storage bucket, which will be treated as the root output directory of the pipeline. It is used by the system to generate the paths of output artifacts. The artifact paths are generated with a sub-path pattern `{job_id}/{task_id}/{output_key}` under the specified output directory. The service account specified in this pipeline must have the `storage.objects.get` and `storage.objects.create` permissions for this bucket.
        &quot;inputArtifacts&quot;: { # The runtime artifacts of the PipelineJob. The key will be the input artifact name and the value would be one of the InputArtifact.
          &quot;a_key&quot;: { # The type of an input artifact.
            &quot;artifactId&quot;: &quot;A String&quot;, # Artifact resource id from MLMD. Which is the last portion of an artifact resource name: `projects/{project}/locations/{location}/metadataStores/default/artifacts/{artifact_id}`. The artifact must stay within the same project, location and default metadatastore as the pipeline.
          },
        },
        &quot;parameterValues&quot;: { # The runtime parameters of the PipelineJob. The parameters will be passed into PipelineJob.pipeline_spec to replace the placeholders at runtime. This field is used by pipelines built using `PipelineJob.pipeline_spec.schema_version` 2.1.0, such as pipelines built using Kubeflow Pipelines SDK 1.9 or higher and the v2 DSL.
          &quot;a_key&quot;: &quot;&quot;,
        },
        &quot;parameters&quot;: { # Deprecated. Use RuntimeConfig.parameter_values instead. The runtime parameters of the PipelineJob. The parameters will be passed into PipelineJob.pipeline_spec to replace the placeholders at runtime. This field is used by pipelines built using `PipelineJob.pipeline_spec.schema_version` 2.0.0 or lower, such as pipelines built using Kubeflow Pipelines SDK 1.8 or lower.
          &quot;a_key&quot;: { # Value is the value of the field.
            &quot;doubleValue&quot;: 3.14, # A double value.
            &quot;intValue&quot;: &quot;A String&quot;, # An integer value.
            &quot;stringValue&quot;: &quot;A String&quot;, # A string value.
          },
        },
      },
      &quot;satisfiesPzi&quot;: True or False, # Output only. Reserved for future use.
      &quot;satisfiesPzs&quot;: True or False, # Output only. Reserved for future use.
      &quot;scheduleName&quot;: &quot;A String&quot;, # Output only. The schedule resource name. Only returned if the Pipeline is created by Schedule API.
      &quot;serviceAccount&quot;: &quot;A String&quot;, # The service account that the pipeline workload runs as. If not specified, the Compute Engine default service account in the project will be used. See https://cloud.google.com/compute/docs/access/service-accounts#default_service_account Users starting the pipeline must have the `iam.serviceAccounts.actAs` permission on this service account.
      &quot;startTime&quot;: &quot;A String&quot;, # Output only. Pipeline start time.
      &quot;state&quot;: &quot;A String&quot;, # Output only. The detailed state of the job.
      &quot;templateMetadata&quot;: { # Pipeline template metadata if PipelineJob.template_uri is from supported template registry. Currently, the only supported registry is Artifact Registry. # Output only. Pipeline template metadata. Will fill up fields if PipelineJob.template_uri is from supported template registry.
        &quot;version&quot;: &quot;A String&quot;, # The version_name in artifact registry. Will always be presented in output if the PipelineJob.template_uri is from supported template registry. Format is &quot;sha256:abcdef123456...&quot;.
      },
      &quot;templateUri&quot;: &quot;A String&quot;, # A template uri from where the PipelineJob.pipeline_spec, if empty, will be downloaded. Currently, only uri from Vertex Template Registry &amp; Gallery is supported. Reference to https://cloud.google.com/vertex-ai/docs/pipelines/create-pipeline-template.
      &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this PipelineJob was most recently updated.
    },
    &quot;pipelineJobId&quot;: &quot;A String&quot;, # The ID to use for the PipelineJob, which will become the final component of the PipelineJob name. If not provided, an ID will be automatically generated. This value should be less than 128 characters, and valid characters are `/a-z-/`.
  },
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule was created.
  &quot;cron&quot;: &quot;A String&quot;, # Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: &quot;CRON_TZ=${IANA_TIME_ZONE}&quot; or &quot;TZ=${IANA_TIME_ZONE}&quot;. The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, &quot;CRON_TZ=America/New_York 1 * * * *&quot;, or &quot;TZ=America/New_York 1 * * * *&quot;.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. User provided name of the Schedule. The name can be up to 128 characters long and can consist of any UTF-8 characters.
  &quot;endTime&quot;: &quot;A String&quot;, # Optional. Timestamp after which no new runs can be scheduled. If specified, The schedule will be completed when either end_time is reached or when scheduled_run_count &gt;= max_run_count. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
  &quot;lastPauseTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule was last paused. Unset if never paused.
  &quot;lastResumeTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule was last resumed. Unset if never resumed from pause.
  &quot;lastScheduledRunResponse&quot;: { # Status of a scheduled run. # Output only. Response of the last scheduled run. This is the response for starting the scheduled requests and not the execution of the operations/jobs created by the requests (if applicable). Unset if no run has been scheduled yet.
    &quot;runResponse&quot;: &quot;A String&quot;, # The response of the scheduled run.
    &quot;scheduledRunTime&quot;: &quot;A String&quot;, # The scheduled run time based on the user-specified schedule.
  },
  &quot;maxConcurrentRunCount&quot;: &quot;A String&quot;, # Required. Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the operations/jobs created by the requests (if applicable).
  &quot;maxRunCount&quot;: &quot;A String&quot;, # Optional. Maximum run count of the schedule. If specified, The schedule will be completed when either started_run_count &gt;= max_run_count or when end_time is reached. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
  &quot;name&quot;: &quot;A String&quot;, # Immutable. The resource name of the Schedule.
  &quot;nextRunTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule should schedule the next run. Having a next_run_time in the past means the runs are being started behind schedule.
  &quot;startTime&quot;: &quot;A String&quot;, # Optional. Timestamp after which the first run can be scheduled. Default to Schedule create time if not specified.
  &quot;startedRunCount&quot;: &quot;A String&quot;, # Output only. The number of runs started by this schedule.
  &quot;state&quot;: &quot;A String&quot;, # Output only. The state of this Schedule.
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule was updated.
}</pre>
</div>

<div class="method">
    <code class="details" id="delete">delete(name, x__xgafv=None)</code>
  <pre>Deletes a Schedule.

Args:
  name: string, Required. The name of the Schedule resource to be deleted. Format: `projects/{project}/locations/{location}/schedules/{schedule}` (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # This resource represents a long-running operation that is the result of a network API call.
  &quot;done&quot;: True or False, # If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The error result of the operation in case of failure or cancellation.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;metadata&quot;: { # Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
  &quot;name&quot;: &quot;A String&quot;, # The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
  &quot;response&quot;: { # The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="get">get(name, x__xgafv=None)</code>
  <pre>Gets a Schedule.

Args:
  name: string, Required. The name of the Schedule resource. Format: `projects/{project}/locations/{location}/schedules/{schedule}` (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # An instance of a Schedule periodically schedules runs to make API calls based on user specified time specification and API request type.
  &quot;allowQueueing&quot;: True or False, # Optional. Whether new scheduled runs can be queued when max_concurrent_runs limit is reached. If set to true, new runs will be queued instead of skipped. Default to false.
  &quot;catchUp&quot;: True or False, # Output only. Whether to backfill missed runs when the schedule is resumed from PAUSED state. If set to true, all missed runs will be scheduled. New runs will be scheduled after the backfill is complete. Default to false.
  &quot;createModelMonitoringJobRequest&quot;: { # Request message for ModelMonitoringService.CreateModelMonitoringJob. # Request for ModelMonitoringService.CreateModelMonitoringJob.
    &quot;modelMonitoringJob&quot;: { # Represents a model monitoring job that analyze dataset using different monitoring algorithm. # Required. The ModelMonitoringJob to create
      &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelMonitoringJob was created.
      &quot;displayName&quot;: &quot;A String&quot;, # The display name of the ModelMonitoringJob. The name can be up to 128 characters long and can consist of any UTF-8.
      &quot;jobExecutionDetail&quot;: { # Represent the execution details of the job. # Output only. Execution results for all the monitoring objectives.
        &quot;baselineDatasets&quot;: [ # Processed baseline datasets.
          { # Processed dataset information.
            &quot;location&quot;: &quot;A String&quot;, # Actual data location of the processed dataset.
            &quot;timeRange&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Dataset time range information if any.
              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end.
              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start.
            },
          },
        ],
        &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Additional job error status.
          &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
          &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
            {
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
            },
          ],
          &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
        },
        &quot;objectiveStatus&quot;: { # Status of data processing for each monitoring objective. Key is the objective.
          &quot;a_key&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
            &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
            &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
              {
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
              },
            ],
            &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
          },
        },
        &quot;targetDatasets&quot;: [ # Processed target datasets.
          { # Processed dataset information.
            &quot;location&quot;: &quot;A String&quot;, # Actual data location of the processed dataset.
            &quot;timeRange&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Dataset time range information if any.
              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end.
              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start.
            },
          },
        ],
      },
      &quot;modelMonitoringSpec&quot;: { # Monitoring monitoring job spec. It outlines the specifications for monitoring objectives, notifications, and result exports. # Monitoring monitoring job spec. It outlines the specifications for monitoring objectives, notifications, and result exports. If left blank, the default monitoring specifications from the top-level resource &#x27;ModelMonitor&#x27; will be applied. If provided, we will use the specification defined here rather than the default one.
        &quot;notificationSpec&quot;: { # Notification spec(email, notification channel) for model monitoring statistics/alerts. # The model monitoring notification spec.
          &quot;emailConfig&quot;: { # The config for email alerts. # Email alert config.
            &quot;userEmails&quot;: [ # The email addresses to send the alerts.
              &quot;A String&quot;,
            ],
          },
          &quot;enableCloudLogging&quot;: True or False, # Dump the anomalies to Cloud Logging. The anomalies will be put to json payload encoded from proto google.cloud.aiplatform.logging.ModelMonitoringAnomaliesLogEntry. This can be further sinked to Pub/Sub or any other services supported by Cloud Logging.
          &quot;notificationChannelConfigs&quot;: [ # Notification channel config.
            { # Google Cloud Notification Channel config.
              &quot;notificationChannel&quot;: &quot;A String&quot;, # Resource names of the NotificationChannels. Must be of the format `projects//notificationChannels/`
            },
          ],
        },
        &quot;objectiveSpec&quot;: { # Monitoring objectives spec. # The monitoring objective spec.
          &quot;baselineDataset&quot;: { # Model monitoring data input spec. # Baseline dataset. It could be the training dataset or production serving dataset from a previous period.
            &quot;batchPredictionOutput&quot;: { # Data from Vertex AI Batch prediction job output. # Vertex AI Batch prediction Job.
              &quot;batchPredictionJob&quot;: &quot;A String&quot;, # Vertex AI Batch prediction job resource name. The job must match the model version specified in [ModelMonitor].[model_monitoring_target].
            },
            &quot;columnizedDataset&quot;: { # Input dataset spec. # Columnized dataset.
              &quot;bigquerySource&quot;: { # Dataset spec for data sotred in BigQuery. # BigQuery data source.
                &quot;query&quot;: &quot;A String&quot;, # Standard SQL to be used instead of the `table_uri`.
                &quot;tableUri&quot;: &quot;A String&quot;, # BigQuery URI to a table, up to 2000 characters long. All the columns in the table will be selected. Accepted forms: * BigQuery path. For example: `bq://projectId.bqDatasetId.bqTableId`.
              },
              &quot;gcsSource&quot;: { # Dataset spec for data stored in Google Cloud Storage. # Google Cloud Storage data source.
                &quot;format&quot;: &quot;A String&quot;, # Data format of the dataset.
                &quot;gcsUri&quot;: &quot;A String&quot;, # Google Cloud Storage URI to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
              },
              &quot;timestampField&quot;: &quot;A String&quot;, # The timestamp field. Usually for serving data.
              &quot;vertexDataset&quot;: &quot;A String&quot;, # Resource name of the Vertex AI managed dataset.
            },
            &quot;timeInterval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # The time interval (pair of start_time and end_time) for which results should be returned.
              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end.
              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start.
            },
            &quot;timeOffset&quot;: { # Time offset setting. # The time offset setting for which results should be returned.
              &quot;offset&quot;: &quot;A String&quot;, # [offset] is the time difference from the cut-off time. For scheduled jobs, the cut-off time is the scheduled time. For non-scheduled jobs, it&#x27;s the time when the job was created. Currently we support the following format: &#x27;w|W&#x27;: Week, &#x27;d|D&#x27;: Day, &#x27;h|H&#x27;: Hour E.g. &#x27;1h&#x27; stands for 1 hour, &#x27;2d&#x27; stands for 2 days.
              &quot;window&quot;: &quot;A String&quot;, # [window] refers to the scope of data selected for analysis. It allows you to specify the quantity of data you wish to examine. Currently we support the following format: &#x27;w|W&#x27;: Week, &#x27;d|D&#x27;: Day, &#x27;h|H&#x27;: Hour E.g. &#x27;1h&#x27; stands for 1 hour, &#x27;2d&#x27; stands for 2 days.
            },
            &quot;vertexEndpointLogs&quot;: { # Data from Vertex AI Endpoint request response logging. # Vertex AI Endpoint request &amp; response logging.
              &quot;endpoints&quot;: [ # List of endpoint resource names. The endpoints must enable the logging with the [Endpoint].[request_response_logging_config], and must contain the deployed model corresponding to the model version specified in [ModelMonitor].[model_monitoring_target].
                &quot;A String&quot;,
              ],
            },
          },
          &quot;explanationSpec&quot;: { # Specification of Model explanation. # The explanation spec. This spec is required when the objectives spec includes feature attribution objectives.
            &quot;metadata&quot;: { # Metadata describing the Model&#x27;s input and output for explanation. # Optional. Metadata describing the Model&#x27;s input and output for explanation.
              &quot;featureAttributionsSchemaUri&quot;: &quot;A String&quot;, # Points to a YAML file stored on Google Cloud Storage describing the format of the feature attributions. The schema is defined as an OpenAPI 3.0.2 [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject). AutoML tabular Models always have this field populated by Vertex AI. Note: The URI given on output may be different, including the URI scheme, than the one given on input. The output URI will point to a location where the user only has a read access.
              &quot;inputs&quot;: { # Required. Map from feature names to feature input metadata. Keys are the name of the features. Values are the specification of the feature. An empty InputMetadata is valid. It describes a text feature which has the name specified as the key in ExplanationMetadata.inputs. The baseline of the empty feature is chosen by Vertex AI. For Vertex AI-provided Tensorflow images, the key can be any friendly name of the feature. Once specified, featureAttributions are keyed by this key (if not grouped with another feature). For custom images, the key must match with the key in instance.
                &quot;a_key&quot;: { # Metadata of the input of a feature. Fields other than InputMetadata.input_baselines are applicable only for Models that are using Vertex AI-provided images for Tensorflow.
                  &quot;denseShapeTensorName&quot;: &quot;A String&quot;, # Specifies the shape of the values of the input if the input is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
                  &quot;encodedBaselines&quot;: [ # A list of baselines for the encoded tensor. The shape of each baseline should match the shape of the encoded tensor. If a scalar is provided, Vertex AI broadcasts to the same shape as the encoded tensor.
                    &quot;&quot;,
                  ],
                  &quot;encodedTensorName&quot;: &quot;A String&quot;, # Encoded tensor is a transformation of the input tensor. Must be provided if choosing Integrated Gradients attribution or XRAI attribution and the input tensor is not differentiable. An encoded tensor is generated if the input tensor is encoded by a lookup table.
                  &quot;encoding&quot;: &quot;A String&quot;, # Defines how the feature is encoded into the input tensor. Defaults to IDENTITY.
                  &quot;featureValueDomain&quot;: { # Domain details of the input feature value. Provides numeric information about the feature, such as its range (min, max). If the feature has been pre-processed, for example with z-scoring, then it provides information about how to recover the original feature. For example, if the input feature is an image and it has been pre-processed to obtain 0-mean and stddev = 1 values, then original_mean, and original_stddev refer to the mean and stddev of the original feature (e.g. image tensor) from which input feature (with mean = 0 and stddev = 1) was obtained. # The domain details of the input feature value. Like min/max, original mean or standard deviation if normalized.
                    &quot;maxValue&quot;: 3.14, # The maximum permissible value for this feature.
                    &quot;minValue&quot;: 3.14, # The minimum permissible value for this feature.
                    &quot;originalMean&quot;: 3.14, # If this input feature has been normalized to a mean value of 0, the original_mean specifies the mean value of the domain prior to normalization.
                    &quot;originalStddev&quot;: 3.14, # If this input feature has been normalized to a standard deviation of 1.0, the original_stddev specifies the standard deviation of the domain prior to normalization.
                  },
                  &quot;groupName&quot;: &quot;A String&quot;, # Name of the group that the input belongs to. Features with the same group name will be treated as one feature when computing attributions. Features grouped together can have different shapes in value. If provided, there will be one single attribution generated in Attribution.feature_attributions, keyed by the group name.
                  &quot;indexFeatureMapping&quot;: [ # A list of feature names for each index in the input tensor. Required when the input InputMetadata.encoding is BAG_OF_FEATURES, BAG_OF_FEATURES_SPARSE, INDICATOR.
                    &quot;A String&quot;,
                  ],
                  &quot;indicesTensorName&quot;: &quot;A String&quot;, # Specifies the index of the values of the input tensor. Required when the input tensor is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
                  &quot;inputBaselines&quot;: [ # Baseline inputs for this feature. If no baseline is specified, Vertex AI chooses the baseline for this feature. If multiple baselines are specified, Vertex AI returns the average attributions across them in Attribution.feature_attributions. For Vertex AI-provided Tensorflow images (both 1.x and 2.x), the shape of each baseline must match the shape of the input tensor. If a scalar is provided, we broadcast to the same shape as the input tensor. For custom images, the element of the baselines must be in the same format as the feature&#x27;s input in the instance[]. The schema of any single instance may be specified via Endpoint&#x27;s DeployedModels&#x27; Model&#x27;s PredictSchemata&#x27;s instance_schema_uri.
                    &quot;&quot;,
                  ],
                  &quot;inputTensorName&quot;: &quot;A String&quot;, # Name of the input tensor for this feature. Required and is only applicable to Vertex AI-provided images for Tensorflow.
                  &quot;modality&quot;: &quot;A String&quot;, # Modality of the feature. Valid values are: numeric, image. Defaults to numeric.
                  &quot;visualization&quot;: { # Visualization configurations for image explanation. # Visualization configurations for image explanation.
                    &quot;clipPercentLowerbound&quot;: 3.14, # Excludes attributions below the specified percentile, from the highlighted areas. Defaults to 62.
                    &quot;clipPercentUpperbound&quot;: 3.14, # Excludes attributions above the specified percentile from the highlighted areas. Using the clip_percent_upperbound and clip_percent_lowerbound together can be useful for filtering out noise and making it easier to see areas of strong attribution. Defaults to 99.9.
                    &quot;colorMap&quot;: &quot;A String&quot;, # The color scheme used for the highlighted areas. Defaults to PINK_GREEN for Integrated Gradients attribution, which shows positive attributions in green and negative in pink. Defaults to VIRIDIS for XRAI attribution, which highlights the most influential regions in yellow and the least influential in blue.
                    &quot;overlayType&quot;: &quot;A String&quot;, # How the original image is displayed in the visualization. Adjusting the overlay can help increase visual clarity if the original image makes it difficult to view the visualization. Defaults to NONE.
                    &quot;polarity&quot;: &quot;A String&quot;, # Whether to only highlight pixels with positive contributions, negative or both. Defaults to POSITIVE.
                    &quot;type&quot;: &quot;A String&quot;, # Type of the image visualization. Only applicable to Integrated Gradients attribution. OUTLINES shows regions of attribution, while PIXELS shows per-pixel attribution. Defaults to OUTLINES.
                  },
                },
              },
              &quot;latentSpaceSource&quot;: &quot;A String&quot;, # Name of the source to generate embeddings for example based explanations.
              &quot;outputs&quot;: { # Required. Map from output names to output metadata. For Vertex AI-provided Tensorflow images, keys can be any user defined string that consists of any UTF-8 characters. For custom images, keys are the name of the output field in the prediction to be explained. Currently only one key is allowed.
                &quot;a_key&quot;: { # Metadata of the prediction output to be explained.
                  &quot;displayNameMappingKey&quot;: &quot;A String&quot;, # Specify a field name in the prediction to look for the display name. Use this if the prediction contains the display names for the outputs. The display names in the prediction must have the same shape of the outputs, so that it can be located by Attribution.output_index for a specific output.
                  &quot;indexDisplayNameMapping&quot;: &quot;&quot;, # Static mapping between the index and display name. Use this if the outputs are a deterministic n-dimensional array, e.g. a list of scores of all the classes in a pre-defined order for a multi-classification Model. It&#x27;s not feasible if the outputs are non-deterministic, e.g. the Model produces top-k classes or sort the outputs by their values. The shape of the value must be an n-dimensional array of strings. The number of dimensions must match that of the outputs to be explained. The Attribution.output_display_name is populated by locating in the mapping with Attribution.output_index.
                  &quot;outputTensorName&quot;: &quot;A String&quot;, # Name of the output tensor. Required and is only applicable to Vertex AI provided images for Tensorflow.
                },
              },
            },
            &quot;parameters&quot;: { # Parameters to configure explaining for Model&#x27;s predictions. # Required. Parameters that configure explaining of the Model&#x27;s predictions.
              &quot;examples&quot;: { # Example-based explainability that returns the nearest neighbors from the provided dataset. # Example-based explanations that returns the nearest neighbors from the provided dataset.
                &quot;exampleGcsSource&quot;: { # The Cloud Storage input instances. # The Cloud Storage input instances.
                  &quot;dataFormat&quot;: &quot;A String&quot;, # The format in which instances are given, if not specified, assume it&#x27;s JSONL format. Currently only JSONL format is supported.
                  &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage location for the input instances.
                    &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                      &quot;A String&quot;,
                    ],
                  },
                },
                &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage locations that contain the instances to be indexed for approximate nearest neighbor search.
                  &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                    &quot;A String&quot;,
                  ],
                },
                &quot;nearestNeighborSearchConfig&quot;: &quot;&quot;, # The full configuration for the generated index, the semantics are the same as metadata and should match [NearestNeighborSearchConfig](https://cloud.google.com/vertex-ai/docs/explainable-ai/configuring-explanations-example-based#nearest-neighbor-search-config).
                &quot;neighborCount&quot;: 42, # The number of neighbors to return when querying for examples.
                &quot;presets&quot;: { # Preset configuration for example-based explanations # Simplified preset configuration, which automatically sets configuration values based on the desired query speed-precision trade-off and modality.
                  &quot;modality&quot;: &quot;A String&quot;, # The modality of the uploaded model, which automatically configures the distance measurement and feature normalization for the underlying example index and queries. If your model does not precisely fit one of these types, it is okay to choose the closest type.
                  &quot;query&quot;: &quot;A String&quot;, # Preset option controlling parameters for speed-precision trade-off when querying for examples. If omitted, defaults to `PRECISE`.
                },
              },
              &quot;integratedGradientsAttribution&quot;: { # An attribution method that computes the Aumann-Shapley value taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365 # An attribution method that computes Aumann-Shapley values taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365
                &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for IG with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
                  &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
                },
                &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
                  &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
                    &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
                      { # Noise sigma for a single feature.
                        &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                        &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
                      },
                    ],
                  },
                  &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
                  &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
                },
                &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is within the desired error range. Valid range of its value is [1, 100], inclusively.
              },
              &quot;outputIndices&quot;: [ # If populated, only returns attributions that have output_index contained in output_indices. It must be an ndarray of integers, with the same shape of the output it&#x27;s explaining. If not populated, returns attributions for top_k indices of outputs. If neither top_k nor output_indices is populated, returns the argmax index of the outputs. Only applicable to Models that predict multiple outputs (e,g, multi-class Models that predict multiple classes).
                &quot;&quot;,
              ],
              &quot;sampledShapleyAttribution&quot;: { # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. Refer to this paper for model details: https://arxiv.org/abs/1306.4265.
                &quot;pathCount&quot;: 42, # Required. The number of feature permutations to consider when approximating the Shapley values. Valid range of its value is [1, 50], inclusively.
              },
              &quot;topK&quot;: 42, # If populated, returns attributions for top K indices of outputs (defaults to 1). Only applies to Models that predicts more than one outputs (e,g, multi-class Models). When set to -1, returns explanations for all outputs.
              &quot;xraiAttribution&quot;: { # An explanation method that redistributes Integrated Gradients attributions to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 Supported only by image Models. # An attribution method that redistributes Integrated Gradients attribution to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 XRAI currently performs better on natural images, like a picture of a house or an animal. If the images are taken in artificial environments, like a lab or manufacturing line, or from diagnostic equipment, like x-rays or quality-control cameras, use Integrated Gradients instead.
                &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for XRAI with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
                  &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
                },
                &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
                  &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
                    &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
                      { # Noise sigma for a single feature.
                        &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                        &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
                      },
                    ],
                  },
                  &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
                  &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
                },
                &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is met within the desired error range. Valid range of its value is [1, 100], inclusively.
              },
            },
          },
          &quot;tabularObjective&quot;: { # Tabular monitoring objective. # Tabular monitoring objective.
            &quot;featureAttributionSpec&quot;: { # Feature attribution monitoring spec. # Feature attribution monitoring spec.
              &quot;batchExplanationDedicatedResources&quot;: { # A description of resources that are used for performing batch operations, are dedicated to a Model, and need manual configuration. # The config of resources used by the Model Monitoring during the batch explanation for non-AutoML models. If not set, `n1-standard-2` machine type will be used by default.
                &quot;machineSpec&quot;: { # Specification of a single machine. # Required. Immutable. The specification of a single machine.
                  &quot;acceleratorCount&quot;: 42, # The number of accelerators to attach to the machine.
                  &quot;acceleratorType&quot;: &quot;A String&quot;, # Immutable. The type of accelerator(s) that may be attached to the machine as per accelerator_count.
                  &quot;machineType&quot;: &quot;A String&quot;, # Immutable. The type of the machine. See the [list of machine types supported for prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types) See the [list of machine types supported for custom training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types). For DeployedModel this field is optional, and the default value is `n1-standard-2`. For BatchPredictionJob or as part of WorkerPoolSpec this field is required.
                  &quot;reservationAffinity&quot;: { # A ReservationAffinity can be used to configure a Vertex AI resource (e.g., a DeployedModel) to draw its Compute Engine resources from a Shared Reservation, or exclusively from on-demand capacity. # Optional. Immutable. Configuration controlling how this resource pool consumes reservation.
                    &quot;key&quot;: &quot;A String&quot;, # Optional. Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, use `compute.googleapis.com/reservation-name` as the key and specify the name of your reservation as its value.
                    &quot;reservationAffinityType&quot;: &quot;A String&quot;, # Required. Specifies the reservation affinity type.
                    &quot;values&quot;: [ # Optional. Corresponds to the label values of a reservation resource. This must be the full resource name of the reservation.
                      &quot;A String&quot;,
                    ],
                  },
                  &quot;tpuTopology&quot;: &quot;A String&quot;, # Immutable. The topology of the TPUs. Corresponds to the TPU topologies available from GKE. (Example: tpu_topology: &quot;2x2x1&quot;).
                },
                &quot;maxReplicaCount&quot;: 42, # Immutable. The maximum number of machine replicas the batch operation may be scaled to. The default value is 10.
                &quot;startingReplicaCount&quot;: 42, # Immutable. The number of machine replicas used at the start of the batch operation. If not set, Vertex AI decides starting number, not greater than max_replica_count
              },
              &quot;defaultAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the features.
                &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
              },
              &quot;featureAlertConditions&quot;: { # Per feature alert condition will override default alert condition.
                &quot;a_key&quot;: { # Monitoring alert triggered condition.
                  &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
                },
              },
              &quot;features&quot;: [ # Feature names interested in monitoring. These should be a subset of the input feature names specified in the monitoring schema. If the field is not specified all features outlied in the monitoring schema will be used.
                &quot;A String&quot;,
              ],
            },
            &quot;featureDriftSpec&quot;: { # Data drift monitoring spec. Data drift measures the distribution distance between the current dataset and a baseline dataset. A typical use case is to detect data drift between the recent production serving dataset and the training dataset, or to compare the recent production dataset with a dataset from a previous period. # Input feature distribution drift monitoring spec.
              &quot;categoricalMetricType&quot;: &quot;A String&quot;, # Supported metrics type: * l_infinity * jensen_shannon_divergence
              &quot;defaultCategoricalAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the categorical features.
                &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
              },
              &quot;defaultNumericAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the numeric features.
                &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
              },
              &quot;featureAlertConditions&quot;: { # Per feature alert condition will override default alert condition.
                &quot;a_key&quot;: { # Monitoring alert triggered condition.
                  &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
                },
              },
              &quot;features&quot;: [ # Feature names / Prediction output names interested in monitoring. These should be a subset of the input feature names or prediction output names specified in the monitoring schema. If the field is not specified all features / prediction outputs outlied in the monitoring schema will be used.
                &quot;A String&quot;,
              ],
              &quot;numericMetricType&quot;: &quot;A String&quot;, # Supported metrics type: * jensen_shannon_divergence
            },
            &quot;predictionOutputDriftSpec&quot;: { # Data drift monitoring spec. Data drift measures the distribution distance between the current dataset and a baseline dataset. A typical use case is to detect data drift between the recent production serving dataset and the training dataset, or to compare the recent production dataset with a dataset from a previous period. # Prediction output distribution drift monitoring spec.
              &quot;categoricalMetricType&quot;: &quot;A String&quot;, # Supported metrics type: * l_infinity * jensen_shannon_divergence
              &quot;defaultCategoricalAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the categorical features.
                &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
              },
              &quot;defaultNumericAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the numeric features.
                &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
              },
              &quot;featureAlertConditions&quot;: { # Per feature alert condition will override default alert condition.
                &quot;a_key&quot;: { # Monitoring alert triggered condition.
                  &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
                },
              },
              &quot;features&quot;: [ # Feature names / Prediction output names interested in monitoring. These should be a subset of the input feature names or prediction output names specified in the monitoring schema. If the field is not specified all features / prediction outputs outlied in the monitoring schema will be used.
                &quot;A String&quot;,
              ],
              &quot;numericMetricType&quot;: &quot;A String&quot;, # Supported metrics type: * jensen_shannon_divergence
            },
          },
          &quot;targetDataset&quot;: { # Model monitoring data input spec. # Target dataset.
            &quot;batchPredictionOutput&quot;: { # Data from Vertex AI Batch prediction job output. # Vertex AI Batch prediction Job.
              &quot;batchPredictionJob&quot;: &quot;A String&quot;, # Vertex AI Batch prediction job resource name. The job must match the model version specified in [ModelMonitor].[model_monitoring_target].
            },
            &quot;columnizedDataset&quot;: { # Input dataset spec. # Columnized dataset.
              &quot;bigquerySource&quot;: { # Dataset spec for data sotred in BigQuery. # BigQuery data source.
                &quot;query&quot;: &quot;A String&quot;, # Standard SQL to be used instead of the `table_uri`.
                &quot;tableUri&quot;: &quot;A String&quot;, # BigQuery URI to a table, up to 2000 characters long. All the columns in the table will be selected. Accepted forms: * BigQuery path. For example: `bq://projectId.bqDatasetId.bqTableId`.
              },
              &quot;gcsSource&quot;: { # Dataset spec for data stored in Google Cloud Storage. # Google Cloud Storage data source.
                &quot;format&quot;: &quot;A String&quot;, # Data format of the dataset.
                &quot;gcsUri&quot;: &quot;A String&quot;, # Google Cloud Storage URI to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
              },
              &quot;timestampField&quot;: &quot;A String&quot;, # The timestamp field. Usually for serving data.
              &quot;vertexDataset&quot;: &quot;A String&quot;, # Resource name of the Vertex AI managed dataset.
            },
            &quot;timeInterval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # The time interval (pair of start_time and end_time) for which results should be returned.
              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end.
              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start.
            },
            &quot;timeOffset&quot;: { # Time offset setting. # The time offset setting for which results should be returned.
              &quot;offset&quot;: &quot;A String&quot;, # [offset] is the time difference from the cut-off time. For scheduled jobs, the cut-off time is the scheduled time. For non-scheduled jobs, it&#x27;s the time when the job was created. Currently we support the following format: &#x27;w|W&#x27;: Week, &#x27;d|D&#x27;: Day, &#x27;h|H&#x27;: Hour E.g. &#x27;1h&#x27; stands for 1 hour, &#x27;2d&#x27; stands for 2 days.
              &quot;window&quot;: &quot;A String&quot;, # [window] refers to the scope of data selected for analysis. It allows you to specify the quantity of data you wish to examine. Currently we support the following format: &#x27;w|W&#x27;: Week, &#x27;d|D&#x27;: Day, &#x27;h|H&#x27;: Hour E.g. &#x27;1h&#x27; stands for 1 hour, &#x27;2d&#x27; stands for 2 days.
            },
            &quot;vertexEndpointLogs&quot;: { # Data from Vertex AI Endpoint request response logging. # Vertex AI Endpoint request &amp; response logging.
              &quot;endpoints&quot;: [ # List of endpoint resource names. The endpoints must enable the logging with the [Endpoint].[request_response_logging_config], and must contain the deployed model corresponding to the model version specified in [ModelMonitor].[model_monitoring_target].
                &quot;A String&quot;,
              ],
            },
          },
        },
        &quot;outputSpec&quot;: { # Specification for the export destination of monitoring results, including metrics, logs, etc. # The Output destination spec for metrics, error logs, etc.
          &quot;gcsBaseDirectory&quot;: { # The Google Cloud Storage location where the output is to be written to. # Google Cloud Storage base folder path for metrics, error logs, etc.
            &quot;outputUriPrefix&quot;: &quot;A String&quot;, # Required. Google Cloud Storage URI to output directory. If the uri doesn&#x27;t end with &#x27;/&#x27;, a &#x27;/&#x27; will be automatically appended. The directory is created if it doesn&#x27;t exist.
          },
        },
      },
      &quot;name&quot;: &quot;A String&quot;, # Output only. Resource name of a ModelMonitoringJob. Format: `projects/{project_id}/locations/{location_id}/modelMonitors/{model_monitor_id}/modelMonitoringJobs/{model_monitoring_job_id}`
      &quot;schedule&quot;: &quot;A String&quot;, # Output only. Schedule resource name. It will only appear when this job is triggered by a schedule.
      &quot;scheduleTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelMonitoringJob was scheduled. It will only appear when this job is triggered by a schedule.
      &quot;state&quot;: &quot;A String&quot;, # Output only. The state of the monitoring job. * When the job is still creating, the state will be &#x27;JOB_STATE_PENDING&#x27;. * Once the job is successfully created, the state will be &#x27;JOB_STATE_RUNNING&#x27;. * Once the job is finished, the state will be one of &#x27;JOB_STATE_FAILED&#x27;, &#x27;JOB_STATE_SUCCEEDED&#x27;, &#x27;JOB_STATE_PARTIALLY_SUCCEEDED&#x27;.
      &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelMonitoringJob was updated most recently.
    },
    &quot;modelMonitoringJobId&quot;: &quot;A String&quot;, # Optional. The ID to use for the Model Monitoring Job, which will become the final component of the model monitoring job resource name. The maximum length is 63 characters, and valid characters are `/^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$/`.
    &quot;parent&quot;: &quot;A String&quot;, # Required. The parent of the ModelMonitoringJob. Format: `projects/{project}/locations/{location}/modelMoniitors/{model_monitor}`
  },
  &quot;createNotebookExecutionJobRequest&quot;: { # Request message for [NotebookService.CreateNotebookExecutionJob] # Request for NotebookService.CreateNotebookExecutionJob.
    &quot;notebookExecutionJob&quot;: { # NotebookExecutionJob represents an instance of a notebook execution. # Required. The NotebookExecutionJob to create.
      &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this NotebookExecutionJob was created.
      &quot;dataformRepositorySource&quot;: { # The Dataform Repository containing the input notebook. # The Dataform Repository pointing to a single file notebook repository.
        &quot;commitSha&quot;: &quot;A String&quot;, # The commit SHA to read repository with. If unset, the file will be read at HEAD.
        &quot;dataformRepositoryResourceName&quot;: &quot;A String&quot;, # The resource name of the Dataform Repository. Format: `projects/{project_id}/locations/{location}/repositories/{repository_id}`
      },
      &quot;directNotebookSource&quot;: { # The content of the input notebook in ipynb format. # The contents of an input notebook file.
        &quot;content&quot;: &quot;A String&quot;, # The base64-encoded contents of the input notebook file.
      },
      &quot;displayName&quot;: &quot;A String&quot;, # The display name of the NotebookExecutionJob. The name can be up to 128 characters long and can consist of any UTF-8 characters.
      &quot;encryptionSpec&quot;: { # Represents a customer-managed encryption key spec that can be applied to a top-level resource. # Customer-managed encryption key spec for the notebook execution job. This field is auto-populated if the NotebookRuntimeTemplate has an encryption spec.
        &quot;kmsKeyName&quot;: &quot;A String&quot;, # Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
      },
      &quot;executionTimeout&quot;: &quot;A String&quot;, # Max running time of the execution job in seconds (default 86400s / 24 hrs).
      &quot;executionUser&quot;: &quot;A String&quot;, # The user email to run the execution as. Only supported by Colab runtimes.
      &quot;gcsNotebookSource&quot;: { # The Cloud Storage uri for the input notebook. # The Cloud Storage url pointing to the ipynb file. Format: `gs://bucket/notebook_file.ipynb`
        &quot;generation&quot;: &quot;A String&quot;, # The version of the Cloud Storage object to read. If unset, the current version of the object is read. See https://cloud.google.com/storage/docs/metadata#generation-number.
        &quot;uri&quot;: &quot;A String&quot;, # The Cloud Storage uri pointing to the ipynb file. Format: `gs://bucket/notebook_file.ipynb`
      },
      &quot;gcsOutputUri&quot;: &quot;A String&quot;, # The Cloud Storage location to upload the result to. Format: `gs://bucket-name`
      &quot;jobState&quot;: &quot;A String&quot;, # Output only. The state of the NotebookExecutionJob.
      &quot;labels&quot;: { # The labels with user-defined metadata to organize NotebookExecutionJobs. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels. System reserved label keys are prefixed with &quot;aiplatform.googleapis.com/&quot; and are immutable.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
      &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of this NotebookExecutionJob. Format: `projects/{project_id}/locations/{location}/notebookExecutionJobs/{job_id}`
      &quot;notebookRuntimeTemplateResourceName&quot;: &quot;A String&quot;, # The NotebookRuntimeTemplate to source compute configuration from.
      &quot;scheduleResourceName&quot;: &quot;A String&quot;, # Output only. The Schedule resource name if this job is triggered by one. Format: `projects/{project_id}/locations/{location}/schedules/{schedule_id}`
      &quot;serviceAccount&quot;: &quot;A String&quot;, # The service account to run the execution as.
      &quot;status&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. Populated when the NotebookExecutionJob is completed. When there is an error during notebook execution, the error details are populated.
        &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
        &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
          {
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
          },
        ],
        &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
      },
      &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this NotebookExecutionJob was most recently updated.
    },
    &quot;notebookExecutionJobId&quot;: &quot;A String&quot;, # Optional. User specified ID for the NotebookExecutionJob.
    &quot;parent&quot;: &quot;A String&quot;, # Required. The resource name of the Location to create the NotebookExecutionJob. Format: `projects/{project}/locations/{location}`
  },
  &quot;createPipelineJobRequest&quot;: { # Request message for PipelineService.CreatePipelineJob. # Request for PipelineService.CreatePipelineJob. CreatePipelineJobRequest.parent field is required (format: projects/{project}/locations/{location}).
    &quot;parent&quot;: &quot;A String&quot;, # Required. The resource name of the Location to create the PipelineJob in. Format: `projects/{project}/locations/{location}`
    &quot;pipelineJob&quot;: { # An instance of a machine learning PipelineJob. # Required. The PipelineJob to create.
      &quot;createTime&quot;: &quot;A String&quot;, # Output only. Pipeline creation time.
      &quot;displayName&quot;: &quot;A String&quot;, # The display name of the Pipeline. The name can be up to 128 characters long and can consist of any UTF-8 characters.
      &quot;encryptionSpec&quot;: { # Represents a customer-managed encryption key spec that can be applied to a top-level resource. # Customer-managed encryption key spec for a pipelineJob. If set, this PipelineJob and all of its sub-resources will be secured by this key.
        &quot;kmsKeyName&quot;: &quot;A String&quot;, # Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
      },
      &quot;endTime&quot;: &quot;A String&quot;, # Output only. Pipeline end time.
      &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. The error that occurred during pipeline execution. Only populated when the pipeline&#x27;s state is FAILED or CANCELLED.
        &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
        &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
          {
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
          },
        ],
        &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
      },
      &quot;jobDetail&quot;: { # The runtime detail of PipelineJob. # Output only. The details of pipeline run. Not available in the list view.
        &quot;pipelineContext&quot;: { # Instance of a general context. # Output only. The context of the pipeline.
          &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Context was created.
          &quot;description&quot;: &quot;A String&quot;, # Description of the Context
          &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Context. May be up to 128 Unicode characters.
          &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
          &quot;labels&quot;: { # The labels with user-defined metadata to organize your Contexts. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Context (System labels are excluded).
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;metadata&quot;: { # Properties of the Context. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;name&quot;: &quot;A String&quot;, # Immutable. The resource name of the Context.
          &quot;parentContexts&quot;: [ # Output only. A list of resource names of Contexts that are parents of this Context. A Context may have at most 10 parent_contexts.
            &quot;A String&quot;,
          ],
          &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
          &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in schema_name to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
          &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Context was last updated.
        },
        &quot;pipelineRunContext&quot;: { # Instance of a general context. # Output only. The context of the current pipeline run.
          &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Context was created.
          &quot;description&quot;: &quot;A String&quot;, # Description of the Context
          &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Context. May be up to 128 Unicode characters.
          &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
          &quot;labels&quot;: { # The labels with user-defined metadata to organize your Contexts. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Context (System labels are excluded).
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;metadata&quot;: { # Properties of the Context. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;name&quot;: &quot;A String&quot;, # Immutable. The resource name of the Context.
          &quot;parentContexts&quot;: [ # Output only. A list of resource names of Contexts that are parents of this Context. A Context may have at most 10 parent_contexts.
            &quot;A String&quot;,
          ],
          &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
          &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in schema_name to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
          &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Context was last updated.
        },
        &quot;taskDetails&quot;: [ # Output only. The runtime details of the tasks under the pipeline.
          { # The runtime detail of a task execution.
            &quot;createTime&quot;: &quot;A String&quot;, # Output only. Task create time.
            &quot;endTime&quot;: &quot;A String&quot;, # Output only. Task end time.
            &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. The error that occurred during task execution. Only populated when the task&#x27;s state is FAILED or CANCELLED.
              &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
              &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
                {
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
                },
              ],
              &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
            },
            &quot;execution&quot;: { # Instance of a general execution. # Output only. The execution metadata of the task.
              &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Execution was created.
              &quot;description&quot;: &quot;A String&quot;, # Description of the Execution
              &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Execution. May be up to 128 Unicode characters.
              &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
              &quot;labels&quot;: { # The labels with user-defined metadata to organize your Executions. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Execution (System labels are excluded).
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;metadata&quot;: { # Properties of the Execution. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the Execution.
              &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
              &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in `schema_title` to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
              &quot;state&quot;: &quot;A String&quot;, # The state of this Execution. This is a property of the Execution, and does not imply or capture any ongoing process. This property is managed by clients (such as Vertex AI Pipelines) and the system does not prescribe or check the validity of state transitions.
              &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Execution was last updated.
            },
            &quot;executorDetail&quot;: { # The runtime detail of a pipeline executor. # Output only. The detailed execution info.
              &quot;containerDetail&quot;: { # The detail of a container execution. It contains the job names of the lifecycle of a container execution. # Output only. The detailed info for a container executor.
                &quot;failedMainJobs&quot;: [ # Output only. The names of the previously failed CustomJob for the main container executions. The list includes the all attempts in chronological order.
                  &quot;A String&quot;,
                ],
                &quot;failedPreCachingCheckJobs&quot;: [ # Output only. The names of the previously failed CustomJob for the pre-caching-check container executions. This job will be available if the PipelineJob.pipeline_spec specifies the `pre_caching_check` hook in the lifecycle events. The list includes the all attempts in chronological order.
                  &quot;A String&quot;,
                ],
                &quot;mainJob&quot;: &quot;A String&quot;, # Output only. The name of the CustomJob for the main container execution.
                &quot;preCachingCheckJob&quot;: &quot;A String&quot;, # Output only. The name of the CustomJob for the pre-caching-check container execution. This job will be available if the PipelineJob.pipeline_spec specifies the `pre_caching_check` hook in the lifecycle events.
              },
              &quot;customJobDetail&quot;: { # The detailed info for a custom job executor. # Output only. The detailed info for a custom job executor.
                &quot;failedJobs&quot;: [ # Output only. The names of the previously failed CustomJob. The list includes the all attempts in chronological order.
                  &quot;A String&quot;,
                ],
                &quot;job&quot;: &quot;A String&quot;, # Output only. The name of the CustomJob.
              },
            },
            &quot;inputs&quot;: { # Output only. The runtime input artifacts of the task.
              &quot;a_key&quot;: { # A list of artifact metadata.
                &quot;artifacts&quot;: [ # Output only. A list of artifact metadata.
                  { # Instance of a general artifact.
                    &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Artifact was created.
                    &quot;description&quot;: &quot;A String&quot;, # Description of the Artifact
                    &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Artifact. May be up to 128 Unicode characters.
                    &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
                    &quot;labels&quot;: { # The labels with user-defined metadata to organize your Artifacts. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Artifact (System labels are excluded).
                      &quot;a_key&quot;: &quot;A String&quot;,
                    },
                    &quot;metadata&quot;: { # Properties of the Artifact. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the Artifact.
                    &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
                    &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in schema_name to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
                    &quot;state&quot;: &quot;A String&quot;, # The state of this Artifact. This is a property of the Artifact, and does not imply or capture any ongoing process. This property is managed by clients (such as Vertex AI Pipelines), and the system does not prescribe or check the validity of state transitions.
                    &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Artifact was last updated.
                    &quot;uri&quot;: &quot;A String&quot;, # The uniform resource identifier of the artifact file. May be empty if there is no actual artifact file.
                  },
                ],
              },
            },
            &quot;outputs&quot;: { # Output only. The runtime output artifacts of the task.
              &quot;a_key&quot;: { # A list of artifact metadata.
                &quot;artifacts&quot;: [ # Output only. A list of artifact metadata.
                  { # Instance of a general artifact.
                    &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Artifact was created.
                    &quot;description&quot;: &quot;A String&quot;, # Description of the Artifact
                    &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Artifact. May be up to 128 Unicode characters.
                    &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
                    &quot;labels&quot;: { # The labels with user-defined metadata to organize your Artifacts. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Artifact (System labels are excluded).
                      &quot;a_key&quot;: &quot;A String&quot;,
                    },
                    &quot;metadata&quot;: { # Properties of the Artifact. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the Artifact.
                    &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
                    &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in schema_name to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
                    &quot;state&quot;: &quot;A String&quot;, # The state of this Artifact. This is a property of the Artifact, and does not imply or capture any ongoing process. This property is managed by clients (such as Vertex AI Pipelines), and the system does not prescribe or check the validity of state transitions.
                    &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Artifact was last updated.
                    &quot;uri&quot;: &quot;A String&quot;, # The uniform resource identifier of the artifact file. May be empty if there is no actual artifact file.
                  },
                ],
              },
            },
            &quot;parentTaskId&quot;: &quot;A String&quot;, # Output only. The id of the parent task if the task is within a component scope. Empty if the task is at the root level.
            &quot;pipelineTaskStatus&quot;: [ # Output only. A list of task status. This field keeps a record of task status evolving over time.
              { # A single record of the task status.
                &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. The error that occurred during the state. May be set when the state is any of the non-final state (PENDING/RUNNING/CANCELLING) or FAILED state. If the state is FAILED, the error here is final and not going to be retried. If the state is a non-final state, the error indicates a system-error being retried.
                  &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
                  &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
                    {
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
                    },
                  ],
                  &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
                },
                &quot;state&quot;: &quot;A String&quot;, # Output only. The state of the task.
                &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Update time of this status.
              },
            ],
            &quot;startTime&quot;: &quot;A String&quot;, # Output only. Task start time.
            &quot;state&quot;: &quot;A String&quot;, # Output only. State of the task.
            &quot;taskId&quot;: &quot;A String&quot;, # Output only. The system generated ID of the task.
            &quot;taskName&quot;: &quot;A String&quot;, # Output only. The user specified name of the task that is defined in pipeline_spec.
          },
        ],
      },
      &quot;labels&quot;: { # The labels with user-defined metadata to organize PipelineJob. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels. Note there is some reserved label key for Vertex AI Pipelines. - `vertex-ai-pipelines-run-billing-id`, user set value will get overrided.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
      &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the PipelineJob.
      &quot;network&quot;: &quot;A String&quot;, # The full name of the Compute Engine [network](/compute/docs/networks-and-firewalls#networks) to which the Pipeline Job&#x27;s workload should be peered. For example, `projects/12345/global/networks/myVPC`. [Format](/compute/docs/reference/rest/v1/networks/insert) is of the form `projects/{project}/global/networks/{network}`. Where {project} is a project number, as in `12345`, and {network} is a network name. Private services access must already be configured for the network. Pipeline job will apply the network configuration to the Google Cloud resources being launched, if applied, such as Vertex AI Training or Dataflow job. If left unspecified, the workload is not peered with any network.
      &quot;pipelineSpec&quot;: { # The spec of the pipeline.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;preflightValidations&quot;: True or False, # Optional. Whether to do component level validations before job creation.
      &quot;reservedIpRanges&quot;: [ # A list of names for the reserved ip ranges under the VPC network that can be used for this Pipeline Job&#x27;s workload. If set, we will deploy the Pipeline Job&#x27;s workload within the provided ip ranges. Otherwise, the job will be deployed to any ip ranges under the provided VPC network. Example: [&#x27;vertex-ai-ip-range&#x27;].
        &quot;A String&quot;,
      ],
      &quot;runtimeConfig&quot;: { # The runtime config of a PipelineJob. # Runtime config of the pipeline.
        &quot;failurePolicy&quot;: &quot;A String&quot;, # Represents the failure policy of a pipeline. Currently, the default of a pipeline is that the pipeline will continue to run until no more tasks can be executed, also known as PIPELINE_FAILURE_POLICY_FAIL_SLOW. However, if a pipeline is set to PIPELINE_FAILURE_POLICY_FAIL_FAST, it will stop scheduling any new tasks when a task has failed. Any scheduled tasks will continue to completion.
        &quot;gcsOutputDirectory&quot;: &quot;A String&quot;, # Required. A path in a Cloud Storage bucket, which will be treated as the root output directory of the pipeline. It is used by the system to generate the paths of output artifacts. The artifact paths are generated with a sub-path pattern `{job_id}/{task_id}/{output_key}` under the specified output directory. The service account specified in this pipeline must have the `storage.objects.get` and `storage.objects.create` permissions for this bucket.
        &quot;inputArtifacts&quot;: { # The runtime artifacts of the PipelineJob. The key will be the input artifact name and the value would be one of the InputArtifact.
          &quot;a_key&quot;: { # The type of an input artifact.
            &quot;artifactId&quot;: &quot;A String&quot;, # Artifact resource id from MLMD. Which is the last portion of an artifact resource name: `projects/{project}/locations/{location}/metadataStores/default/artifacts/{artifact_id}`. The artifact must stay within the same project, location and default metadatastore as the pipeline.
          },
        },
        &quot;parameterValues&quot;: { # The runtime parameters of the PipelineJob. The parameters will be passed into PipelineJob.pipeline_spec to replace the placeholders at runtime. This field is used by pipelines built using `PipelineJob.pipeline_spec.schema_version` 2.1.0, such as pipelines built using Kubeflow Pipelines SDK 1.9 or higher and the v2 DSL.
          &quot;a_key&quot;: &quot;&quot;,
        },
        &quot;parameters&quot;: { # Deprecated. Use RuntimeConfig.parameter_values instead. The runtime parameters of the PipelineJob. The parameters will be passed into PipelineJob.pipeline_spec to replace the placeholders at runtime. This field is used by pipelines built using `PipelineJob.pipeline_spec.schema_version` 2.0.0 or lower, such as pipelines built using Kubeflow Pipelines SDK 1.8 or lower.
          &quot;a_key&quot;: { # Value is the value of the field.
            &quot;doubleValue&quot;: 3.14, # A double value.
            &quot;intValue&quot;: &quot;A String&quot;, # An integer value.
            &quot;stringValue&quot;: &quot;A String&quot;, # A string value.
          },
        },
      },
      &quot;satisfiesPzi&quot;: True or False, # Output only. Reserved for future use.
      &quot;satisfiesPzs&quot;: True or False, # Output only. Reserved for future use.
      &quot;scheduleName&quot;: &quot;A String&quot;, # Output only. The schedule resource name. Only returned if the Pipeline is created by Schedule API.
      &quot;serviceAccount&quot;: &quot;A String&quot;, # The service account that the pipeline workload runs as. If not specified, the Compute Engine default service account in the project will be used. See https://cloud.google.com/compute/docs/access/service-accounts#default_service_account Users starting the pipeline must have the `iam.serviceAccounts.actAs` permission on this service account.
      &quot;startTime&quot;: &quot;A String&quot;, # Output only. Pipeline start time.
      &quot;state&quot;: &quot;A String&quot;, # Output only. The detailed state of the job.
      &quot;templateMetadata&quot;: { # Pipeline template metadata if PipelineJob.template_uri is from supported template registry. Currently, the only supported registry is Artifact Registry. # Output only. Pipeline template metadata. Will fill up fields if PipelineJob.template_uri is from supported template registry.
        &quot;version&quot;: &quot;A String&quot;, # The version_name in artifact registry. Will always be presented in output if the PipelineJob.template_uri is from supported template registry. Format is &quot;sha256:abcdef123456...&quot;.
      },
      &quot;templateUri&quot;: &quot;A String&quot;, # A template uri from where the PipelineJob.pipeline_spec, if empty, will be downloaded. Currently, only uri from Vertex Template Registry &amp; Gallery is supported. Reference to https://cloud.google.com/vertex-ai/docs/pipelines/create-pipeline-template.
      &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this PipelineJob was most recently updated.
    },
    &quot;pipelineJobId&quot;: &quot;A String&quot;, # The ID to use for the PipelineJob, which will become the final component of the PipelineJob name. If not provided, an ID will be automatically generated. This value should be less than 128 characters, and valid characters are `/a-z-/`.
  },
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule was created.
  &quot;cron&quot;: &quot;A String&quot;, # Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: &quot;CRON_TZ=${IANA_TIME_ZONE}&quot; or &quot;TZ=${IANA_TIME_ZONE}&quot;. The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, &quot;CRON_TZ=America/New_York 1 * * * *&quot;, or &quot;TZ=America/New_York 1 * * * *&quot;.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. User provided name of the Schedule. The name can be up to 128 characters long and can consist of any UTF-8 characters.
  &quot;endTime&quot;: &quot;A String&quot;, # Optional. Timestamp after which no new runs can be scheduled. If specified, The schedule will be completed when either end_time is reached or when scheduled_run_count &gt;= max_run_count. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
  &quot;lastPauseTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule was last paused. Unset if never paused.
  &quot;lastResumeTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule was last resumed. Unset if never resumed from pause.
  &quot;lastScheduledRunResponse&quot;: { # Status of a scheduled run. # Output only. Response of the last scheduled run. This is the response for starting the scheduled requests and not the execution of the operations/jobs created by the requests (if applicable). Unset if no run has been scheduled yet.
    &quot;runResponse&quot;: &quot;A String&quot;, # The response of the scheduled run.
    &quot;scheduledRunTime&quot;: &quot;A String&quot;, # The scheduled run time based on the user-specified schedule.
  },
  &quot;maxConcurrentRunCount&quot;: &quot;A String&quot;, # Required. Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the operations/jobs created by the requests (if applicable).
  &quot;maxRunCount&quot;: &quot;A String&quot;, # Optional. Maximum run count of the schedule. If specified, The schedule will be completed when either started_run_count &gt;= max_run_count or when end_time is reached. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
  &quot;name&quot;: &quot;A String&quot;, # Immutable. The resource name of the Schedule.
  &quot;nextRunTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule should schedule the next run. Having a next_run_time in the past means the runs are being started behind schedule.
  &quot;startTime&quot;: &quot;A String&quot;, # Optional. Timestamp after which the first run can be scheduled. Default to Schedule create time if not specified.
  &quot;startedRunCount&quot;: &quot;A String&quot;, # Output only. The number of runs started by this schedule.
  &quot;state&quot;: &quot;A String&quot;, # Output only. The state of this Schedule.
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule was updated.
}</pre>
</div>

<div class="method">
    <code class="details" id="list">list(parent, filter=None, orderBy=None, pageSize=None, pageToken=None, x__xgafv=None)</code>
  <pre>Lists Schedules in a Location.

Args:
  parent: string, Required. The resource name of the Location to list the Schedules from. Format: `projects/{project}/locations/{location}` (required)
  filter: string, Lists the Schedules that match the filter expression. The following fields are supported: * `display_name`: Supports `=`, `!=` comparisons, and `:` wildcard. * `state`: Supports `=` and `!=` comparisons. * `request`: Supports existence of the check. (e.g. `create_pipeline_job_request:*` --&gt; Schedule has create_pipeline_job_request). * `create_time`: Supports `=`, `!=`, `&lt;`, `&gt;`, `&lt;=`, and `&gt;=` comparisons. Values must be in RFC 3339 format. * `start_time`: Supports `=`, `!=`, `&lt;`, `&gt;`, `&lt;=`, and `&gt;=` comparisons. Values must be in RFC 3339 format. * `end_time`: Supports `=`, `!=`, `&lt;`, `&gt;`, `&lt;=`, `&gt;=` comparisons and `:*` existence check. Values must be in RFC 3339 format. * `next_run_time`: Supports `=`, `!=`, `&lt;`, `&gt;`, `&lt;=`, and `&gt;=` comparisons. Values must be in RFC 3339 format. Filter expressions can be combined together using logical operators (`NOT`, `AND` &amp; `OR`). The syntax to define filter expression is based on https://google.aip.dev/160. Examples: * `state=&quot;ACTIVE&quot; AND display_name:&quot;my_schedule_*&quot;` * `NOT display_name=&quot;my_schedule&quot;` * `create_time&gt;&quot;2021-05-18T00:00:00Z&quot;` * `end_time&gt;&quot;2021-05-18T00:00:00Z&quot; OR NOT end_time:*` * `create_pipeline_job_request:*`
  orderBy: string, A comma-separated list of fields to order by. The default sort order is in ascending order. Use &quot;desc&quot; after a field name for descending. You can have multiple order_by fields provided. For example, using &quot;create_time desc, end_time&quot; will order results by create time in descending order, and if there are multiple schedules having the same create time, order them by the end time in ascending order. If order_by is not specified, it will order by default with create_time in descending order. Supported fields: * `create_time` * `start_time` * `end_time` * `next_run_time`
  pageSize: integer, The standard list page size. Default to 100 if not specified.
  pageToken: string, The standard list page token. Typically obtained via ListSchedulesResponse.next_page_token of the previous ScheduleService.ListSchedules call.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response message for ScheduleService.ListSchedules
  &quot;nextPageToken&quot;: &quot;A String&quot;, # A token to retrieve the next page of results. Pass to ListSchedulesRequest.page_token to obtain that page.
  &quot;schedules&quot;: [ # List of Schedules in the requested page.
    { # An instance of a Schedule periodically schedules runs to make API calls based on user specified time specification and API request type.
      &quot;allowQueueing&quot;: True or False, # Optional. Whether new scheduled runs can be queued when max_concurrent_runs limit is reached. If set to true, new runs will be queued instead of skipped. Default to false.
      &quot;catchUp&quot;: True or False, # Output only. Whether to backfill missed runs when the schedule is resumed from PAUSED state. If set to true, all missed runs will be scheduled. New runs will be scheduled after the backfill is complete. Default to false.
      &quot;createModelMonitoringJobRequest&quot;: { # Request message for ModelMonitoringService.CreateModelMonitoringJob. # Request for ModelMonitoringService.CreateModelMonitoringJob.
        &quot;modelMonitoringJob&quot;: { # Represents a model monitoring job that analyze dataset using different monitoring algorithm. # Required. The ModelMonitoringJob to create
          &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelMonitoringJob was created.
          &quot;displayName&quot;: &quot;A String&quot;, # The display name of the ModelMonitoringJob. The name can be up to 128 characters long and can consist of any UTF-8.
          &quot;jobExecutionDetail&quot;: { # Represent the execution details of the job. # Output only. Execution results for all the monitoring objectives.
            &quot;baselineDatasets&quot;: [ # Processed baseline datasets.
              { # Processed dataset information.
                &quot;location&quot;: &quot;A String&quot;, # Actual data location of the processed dataset.
                &quot;timeRange&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Dataset time range information if any.
                  &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end.
                  &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start.
                },
              },
            ],
            &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Additional job error status.
              &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
              &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
                {
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
                },
              ],
              &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
            },
            &quot;objectiveStatus&quot;: { # Status of data processing for each monitoring objective. Key is the objective.
              &quot;a_key&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
                &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
                &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
                  {
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
                  },
                ],
                &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
              },
            },
            &quot;targetDatasets&quot;: [ # Processed target datasets.
              { # Processed dataset information.
                &quot;location&quot;: &quot;A String&quot;, # Actual data location of the processed dataset.
                &quot;timeRange&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Dataset time range information if any.
                  &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end.
                  &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start.
                },
              },
            ],
          },
          &quot;modelMonitoringSpec&quot;: { # Monitoring monitoring job spec. It outlines the specifications for monitoring objectives, notifications, and result exports. # Monitoring monitoring job spec. It outlines the specifications for monitoring objectives, notifications, and result exports. If left blank, the default monitoring specifications from the top-level resource &#x27;ModelMonitor&#x27; will be applied. If provided, we will use the specification defined here rather than the default one.
            &quot;notificationSpec&quot;: { # Notification spec(email, notification channel) for model monitoring statistics/alerts. # The model monitoring notification spec.
              &quot;emailConfig&quot;: { # The config for email alerts. # Email alert config.
                &quot;userEmails&quot;: [ # The email addresses to send the alerts.
                  &quot;A String&quot;,
                ],
              },
              &quot;enableCloudLogging&quot;: True or False, # Dump the anomalies to Cloud Logging. The anomalies will be put to json payload encoded from proto google.cloud.aiplatform.logging.ModelMonitoringAnomaliesLogEntry. This can be further sinked to Pub/Sub or any other services supported by Cloud Logging.
              &quot;notificationChannelConfigs&quot;: [ # Notification channel config.
                { # Google Cloud Notification Channel config.
                  &quot;notificationChannel&quot;: &quot;A String&quot;, # Resource names of the NotificationChannels. Must be of the format `projects//notificationChannels/`
                },
              ],
            },
            &quot;objectiveSpec&quot;: { # Monitoring objectives spec. # The monitoring objective spec.
              &quot;baselineDataset&quot;: { # Model monitoring data input spec. # Baseline dataset. It could be the training dataset or production serving dataset from a previous period.
                &quot;batchPredictionOutput&quot;: { # Data from Vertex AI Batch prediction job output. # Vertex AI Batch prediction Job.
                  &quot;batchPredictionJob&quot;: &quot;A String&quot;, # Vertex AI Batch prediction job resource name. The job must match the model version specified in [ModelMonitor].[model_monitoring_target].
                },
                &quot;columnizedDataset&quot;: { # Input dataset spec. # Columnized dataset.
                  &quot;bigquerySource&quot;: { # Dataset spec for data sotred in BigQuery. # BigQuery data source.
                    &quot;query&quot;: &quot;A String&quot;, # Standard SQL to be used instead of the `table_uri`.
                    &quot;tableUri&quot;: &quot;A String&quot;, # BigQuery URI to a table, up to 2000 characters long. All the columns in the table will be selected. Accepted forms: * BigQuery path. For example: `bq://projectId.bqDatasetId.bqTableId`.
                  },
                  &quot;gcsSource&quot;: { # Dataset spec for data stored in Google Cloud Storage. # Google Cloud Storage data source.
                    &quot;format&quot;: &quot;A String&quot;, # Data format of the dataset.
                    &quot;gcsUri&quot;: &quot;A String&quot;, # Google Cloud Storage URI to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                  },
                  &quot;timestampField&quot;: &quot;A String&quot;, # The timestamp field. Usually for serving data.
                  &quot;vertexDataset&quot;: &quot;A String&quot;, # Resource name of the Vertex AI managed dataset.
                },
                &quot;timeInterval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # The time interval (pair of start_time and end_time) for which results should be returned.
                  &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end.
                  &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start.
                },
                &quot;timeOffset&quot;: { # Time offset setting. # The time offset setting for which results should be returned.
                  &quot;offset&quot;: &quot;A String&quot;, # [offset] is the time difference from the cut-off time. For scheduled jobs, the cut-off time is the scheduled time. For non-scheduled jobs, it&#x27;s the time when the job was created. Currently we support the following format: &#x27;w|W&#x27;: Week, &#x27;d|D&#x27;: Day, &#x27;h|H&#x27;: Hour E.g. &#x27;1h&#x27; stands for 1 hour, &#x27;2d&#x27; stands for 2 days.
                  &quot;window&quot;: &quot;A String&quot;, # [window] refers to the scope of data selected for analysis. It allows you to specify the quantity of data you wish to examine. Currently we support the following format: &#x27;w|W&#x27;: Week, &#x27;d|D&#x27;: Day, &#x27;h|H&#x27;: Hour E.g. &#x27;1h&#x27; stands for 1 hour, &#x27;2d&#x27; stands for 2 days.
                },
                &quot;vertexEndpointLogs&quot;: { # Data from Vertex AI Endpoint request response logging. # Vertex AI Endpoint request &amp; response logging.
                  &quot;endpoints&quot;: [ # List of endpoint resource names. The endpoints must enable the logging with the [Endpoint].[request_response_logging_config], and must contain the deployed model corresponding to the model version specified in [ModelMonitor].[model_monitoring_target].
                    &quot;A String&quot;,
                  ],
                },
              },
              &quot;explanationSpec&quot;: { # Specification of Model explanation. # The explanation spec. This spec is required when the objectives spec includes feature attribution objectives.
                &quot;metadata&quot;: { # Metadata describing the Model&#x27;s input and output for explanation. # Optional. Metadata describing the Model&#x27;s input and output for explanation.
                  &quot;featureAttributionsSchemaUri&quot;: &quot;A String&quot;, # Points to a YAML file stored on Google Cloud Storage describing the format of the feature attributions. The schema is defined as an OpenAPI 3.0.2 [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject). AutoML tabular Models always have this field populated by Vertex AI. Note: The URI given on output may be different, including the URI scheme, than the one given on input. The output URI will point to a location where the user only has a read access.
                  &quot;inputs&quot;: { # Required. Map from feature names to feature input metadata. Keys are the name of the features. Values are the specification of the feature. An empty InputMetadata is valid. It describes a text feature which has the name specified as the key in ExplanationMetadata.inputs. The baseline of the empty feature is chosen by Vertex AI. For Vertex AI-provided Tensorflow images, the key can be any friendly name of the feature. Once specified, featureAttributions are keyed by this key (if not grouped with another feature). For custom images, the key must match with the key in instance.
                    &quot;a_key&quot;: { # Metadata of the input of a feature. Fields other than InputMetadata.input_baselines are applicable only for Models that are using Vertex AI-provided images for Tensorflow.
                      &quot;denseShapeTensorName&quot;: &quot;A String&quot;, # Specifies the shape of the values of the input if the input is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
                      &quot;encodedBaselines&quot;: [ # A list of baselines for the encoded tensor. The shape of each baseline should match the shape of the encoded tensor. If a scalar is provided, Vertex AI broadcasts to the same shape as the encoded tensor.
                        &quot;&quot;,
                      ],
                      &quot;encodedTensorName&quot;: &quot;A String&quot;, # Encoded tensor is a transformation of the input tensor. Must be provided if choosing Integrated Gradients attribution or XRAI attribution and the input tensor is not differentiable. An encoded tensor is generated if the input tensor is encoded by a lookup table.
                      &quot;encoding&quot;: &quot;A String&quot;, # Defines how the feature is encoded into the input tensor. Defaults to IDENTITY.
                      &quot;featureValueDomain&quot;: { # Domain details of the input feature value. Provides numeric information about the feature, such as its range (min, max). If the feature has been pre-processed, for example with z-scoring, then it provides information about how to recover the original feature. For example, if the input feature is an image and it has been pre-processed to obtain 0-mean and stddev = 1 values, then original_mean, and original_stddev refer to the mean and stddev of the original feature (e.g. image tensor) from which input feature (with mean = 0 and stddev = 1) was obtained. # The domain details of the input feature value. Like min/max, original mean or standard deviation if normalized.
                        &quot;maxValue&quot;: 3.14, # The maximum permissible value for this feature.
                        &quot;minValue&quot;: 3.14, # The minimum permissible value for this feature.
                        &quot;originalMean&quot;: 3.14, # If this input feature has been normalized to a mean value of 0, the original_mean specifies the mean value of the domain prior to normalization.
                        &quot;originalStddev&quot;: 3.14, # If this input feature has been normalized to a standard deviation of 1.0, the original_stddev specifies the standard deviation of the domain prior to normalization.
                      },
                      &quot;groupName&quot;: &quot;A String&quot;, # Name of the group that the input belongs to. Features with the same group name will be treated as one feature when computing attributions. Features grouped together can have different shapes in value. If provided, there will be one single attribution generated in Attribution.feature_attributions, keyed by the group name.
                      &quot;indexFeatureMapping&quot;: [ # A list of feature names for each index in the input tensor. Required when the input InputMetadata.encoding is BAG_OF_FEATURES, BAG_OF_FEATURES_SPARSE, INDICATOR.
                        &quot;A String&quot;,
                      ],
                      &quot;indicesTensorName&quot;: &quot;A String&quot;, # Specifies the index of the values of the input tensor. Required when the input tensor is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
                      &quot;inputBaselines&quot;: [ # Baseline inputs for this feature. If no baseline is specified, Vertex AI chooses the baseline for this feature. If multiple baselines are specified, Vertex AI returns the average attributions across them in Attribution.feature_attributions. For Vertex AI-provided Tensorflow images (both 1.x and 2.x), the shape of each baseline must match the shape of the input tensor. If a scalar is provided, we broadcast to the same shape as the input tensor. For custom images, the element of the baselines must be in the same format as the feature&#x27;s input in the instance[]. The schema of any single instance may be specified via Endpoint&#x27;s DeployedModels&#x27; Model&#x27;s PredictSchemata&#x27;s instance_schema_uri.
                        &quot;&quot;,
                      ],
                      &quot;inputTensorName&quot;: &quot;A String&quot;, # Name of the input tensor for this feature. Required and is only applicable to Vertex AI-provided images for Tensorflow.
                      &quot;modality&quot;: &quot;A String&quot;, # Modality of the feature. Valid values are: numeric, image. Defaults to numeric.
                      &quot;visualization&quot;: { # Visualization configurations for image explanation. # Visualization configurations for image explanation.
                        &quot;clipPercentLowerbound&quot;: 3.14, # Excludes attributions below the specified percentile, from the highlighted areas. Defaults to 62.
                        &quot;clipPercentUpperbound&quot;: 3.14, # Excludes attributions above the specified percentile from the highlighted areas. Using the clip_percent_upperbound and clip_percent_lowerbound together can be useful for filtering out noise and making it easier to see areas of strong attribution. Defaults to 99.9.
                        &quot;colorMap&quot;: &quot;A String&quot;, # The color scheme used for the highlighted areas. Defaults to PINK_GREEN for Integrated Gradients attribution, which shows positive attributions in green and negative in pink. Defaults to VIRIDIS for XRAI attribution, which highlights the most influential regions in yellow and the least influential in blue.
                        &quot;overlayType&quot;: &quot;A String&quot;, # How the original image is displayed in the visualization. Adjusting the overlay can help increase visual clarity if the original image makes it difficult to view the visualization. Defaults to NONE.
                        &quot;polarity&quot;: &quot;A String&quot;, # Whether to only highlight pixels with positive contributions, negative or both. Defaults to POSITIVE.
                        &quot;type&quot;: &quot;A String&quot;, # Type of the image visualization. Only applicable to Integrated Gradients attribution. OUTLINES shows regions of attribution, while PIXELS shows per-pixel attribution. Defaults to OUTLINES.
                      },
                    },
                  },
                  &quot;latentSpaceSource&quot;: &quot;A String&quot;, # Name of the source to generate embeddings for example based explanations.
                  &quot;outputs&quot;: { # Required. Map from output names to output metadata. For Vertex AI-provided Tensorflow images, keys can be any user defined string that consists of any UTF-8 characters. For custom images, keys are the name of the output field in the prediction to be explained. Currently only one key is allowed.
                    &quot;a_key&quot;: { # Metadata of the prediction output to be explained.
                      &quot;displayNameMappingKey&quot;: &quot;A String&quot;, # Specify a field name in the prediction to look for the display name. Use this if the prediction contains the display names for the outputs. The display names in the prediction must have the same shape of the outputs, so that it can be located by Attribution.output_index for a specific output.
                      &quot;indexDisplayNameMapping&quot;: &quot;&quot;, # Static mapping between the index and display name. Use this if the outputs are a deterministic n-dimensional array, e.g. a list of scores of all the classes in a pre-defined order for a multi-classification Model. It&#x27;s not feasible if the outputs are non-deterministic, e.g. the Model produces top-k classes or sort the outputs by their values. The shape of the value must be an n-dimensional array of strings. The number of dimensions must match that of the outputs to be explained. The Attribution.output_display_name is populated by locating in the mapping with Attribution.output_index.
                      &quot;outputTensorName&quot;: &quot;A String&quot;, # Name of the output tensor. Required and is only applicable to Vertex AI provided images for Tensorflow.
                    },
                  },
                },
                &quot;parameters&quot;: { # Parameters to configure explaining for Model&#x27;s predictions. # Required. Parameters that configure explaining of the Model&#x27;s predictions.
                  &quot;examples&quot;: { # Example-based explainability that returns the nearest neighbors from the provided dataset. # Example-based explanations that returns the nearest neighbors from the provided dataset.
                    &quot;exampleGcsSource&quot;: { # The Cloud Storage input instances. # The Cloud Storage input instances.
                      &quot;dataFormat&quot;: &quot;A String&quot;, # The format in which instances are given, if not specified, assume it&#x27;s JSONL format. Currently only JSONL format is supported.
                      &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage location for the input instances.
                        &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                    &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage locations that contain the instances to be indexed for approximate nearest neighbor search.
                      &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                        &quot;A String&quot;,
                      ],
                    },
                    &quot;nearestNeighborSearchConfig&quot;: &quot;&quot;, # The full configuration for the generated index, the semantics are the same as metadata and should match [NearestNeighborSearchConfig](https://cloud.google.com/vertex-ai/docs/explainable-ai/configuring-explanations-example-based#nearest-neighbor-search-config).
                    &quot;neighborCount&quot;: 42, # The number of neighbors to return when querying for examples.
                    &quot;presets&quot;: { # Preset configuration for example-based explanations # Simplified preset configuration, which automatically sets configuration values based on the desired query speed-precision trade-off and modality.
                      &quot;modality&quot;: &quot;A String&quot;, # The modality of the uploaded model, which automatically configures the distance measurement and feature normalization for the underlying example index and queries. If your model does not precisely fit one of these types, it is okay to choose the closest type.
                      &quot;query&quot;: &quot;A String&quot;, # Preset option controlling parameters for speed-precision trade-off when querying for examples. If omitted, defaults to `PRECISE`.
                    },
                  },
                  &quot;integratedGradientsAttribution&quot;: { # An attribution method that computes the Aumann-Shapley value taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365 # An attribution method that computes Aumann-Shapley values taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365
                    &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for IG with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
                      &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
                    },
                    &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
                      &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
                        &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
                          { # Noise sigma for a single feature.
                            &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                            &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
                          },
                        ],
                      },
                      &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
                      &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
                    },
                    &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is within the desired error range. Valid range of its value is [1, 100], inclusively.
                  },
                  &quot;outputIndices&quot;: [ # If populated, only returns attributions that have output_index contained in output_indices. It must be an ndarray of integers, with the same shape of the output it&#x27;s explaining. If not populated, returns attributions for top_k indices of outputs. If neither top_k nor output_indices is populated, returns the argmax index of the outputs. Only applicable to Models that predict multiple outputs (e,g, multi-class Models that predict multiple classes).
                    &quot;&quot;,
                  ],
                  &quot;sampledShapleyAttribution&quot;: { # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. Refer to this paper for model details: https://arxiv.org/abs/1306.4265.
                    &quot;pathCount&quot;: 42, # Required. The number of feature permutations to consider when approximating the Shapley values. Valid range of its value is [1, 50], inclusively.
                  },
                  &quot;topK&quot;: 42, # If populated, returns attributions for top K indices of outputs (defaults to 1). Only applies to Models that predicts more than one outputs (e,g, multi-class Models). When set to -1, returns explanations for all outputs.
                  &quot;xraiAttribution&quot;: { # An explanation method that redistributes Integrated Gradients attributions to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 Supported only by image Models. # An attribution method that redistributes Integrated Gradients attribution to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 XRAI currently performs better on natural images, like a picture of a house or an animal. If the images are taken in artificial environments, like a lab or manufacturing line, or from diagnostic equipment, like x-rays or quality-control cameras, use Integrated Gradients instead.
                    &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for XRAI with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
                      &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
                    },
                    &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
                      &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
                        &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
                          { # Noise sigma for a single feature.
                            &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                            &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
                          },
                        ],
                      },
                      &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
                      &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
                    },
                    &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is met within the desired error range. Valid range of its value is [1, 100], inclusively.
                  },
                },
              },
              &quot;tabularObjective&quot;: { # Tabular monitoring objective. # Tabular monitoring objective.
                &quot;featureAttributionSpec&quot;: { # Feature attribution monitoring spec. # Feature attribution monitoring spec.
                  &quot;batchExplanationDedicatedResources&quot;: { # A description of resources that are used for performing batch operations, are dedicated to a Model, and need manual configuration. # The config of resources used by the Model Monitoring during the batch explanation for non-AutoML models. If not set, `n1-standard-2` machine type will be used by default.
                    &quot;machineSpec&quot;: { # Specification of a single machine. # Required. Immutable. The specification of a single machine.
                      &quot;acceleratorCount&quot;: 42, # The number of accelerators to attach to the machine.
                      &quot;acceleratorType&quot;: &quot;A String&quot;, # Immutable. The type of accelerator(s) that may be attached to the machine as per accelerator_count.
                      &quot;machineType&quot;: &quot;A String&quot;, # Immutable. The type of the machine. See the [list of machine types supported for prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types) See the [list of machine types supported for custom training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types). For DeployedModel this field is optional, and the default value is `n1-standard-2`. For BatchPredictionJob or as part of WorkerPoolSpec this field is required.
                      &quot;reservationAffinity&quot;: { # A ReservationAffinity can be used to configure a Vertex AI resource (e.g., a DeployedModel) to draw its Compute Engine resources from a Shared Reservation, or exclusively from on-demand capacity. # Optional. Immutable. Configuration controlling how this resource pool consumes reservation.
                        &quot;key&quot;: &quot;A String&quot;, # Optional. Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, use `compute.googleapis.com/reservation-name` as the key and specify the name of your reservation as its value.
                        &quot;reservationAffinityType&quot;: &quot;A String&quot;, # Required. Specifies the reservation affinity type.
                        &quot;values&quot;: [ # Optional. Corresponds to the label values of a reservation resource. This must be the full resource name of the reservation.
                          &quot;A String&quot;,
                        ],
                      },
                      &quot;tpuTopology&quot;: &quot;A String&quot;, # Immutable. The topology of the TPUs. Corresponds to the TPU topologies available from GKE. (Example: tpu_topology: &quot;2x2x1&quot;).
                    },
                    &quot;maxReplicaCount&quot;: 42, # Immutable. The maximum number of machine replicas the batch operation may be scaled to. The default value is 10.
                    &quot;startingReplicaCount&quot;: 42, # Immutable. The number of machine replicas used at the start of the batch operation. If not set, Vertex AI decides starting number, not greater than max_replica_count
                  },
                  &quot;defaultAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the features.
                    &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
                  },
                  &quot;featureAlertConditions&quot;: { # Per feature alert condition will override default alert condition.
                    &quot;a_key&quot;: { # Monitoring alert triggered condition.
                      &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
                    },
                  },
                  &quot;features&quot;: [ # Feature names interested in monitoring. These should be a subset of the input feature names specified in the monitoring schema. If the field is not specified all features outlied in the monitoring schema will be used.
                    &quot;A String&quot;,
                  ],
                },
                &quot;featureDriftSpec&quot;: { # Data drift monitoring spec. Data drift measures the distribution distance between the current dataset and a baseline dataset. A typical use case is to detect data drift between the recent production serving dataset and the training dataset, or to compare the recent production dataset with a dataset from a previous period. # Input feature distribution drift monitoring spec.
                  &quot;categoricalMetricType&quot;: &quot;A String&quot;, # Supported metrics type: * l_infinity * jensen_shannon_divergence
                  &quot;defaultCategoricalAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the categorical features.
                    &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
                  },
                  &quot;defaultNumericAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the numeric features.
                    &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
                  },
                  &quot;featureAlertConditions&quot;: { # Per feature alert condition will override default alert condition.
                    &quot;a_key&quot;: { # Monitoring alert triggered condition.
                      &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
                    },
                  },
                  &quot;features&quot;: [ # Feature names / Prediction output names interested in monitoring. These should be a subset of the input feature names or prediction output names specified in the monitoring schema. If the field is not specified all features / prediction outputs outlied in the monitoring schema will be used.
                    &quot;A String&quot;,
                  ],
                  &quot;numericMetricType&quot;: &quot;A String&quot;, # Supported metrics type: * jensen_shannon_divergence
                },
                &quot;predictionOutputDriftSpec&quot;: { # Data drift monitoring spec. Data drift measures the distribution distance between the current dataset and a baseline dataset. A typical use case is to detect data drift between the recent production serving dataset and the training dataset, or to compare the recent production dataset with a dataset from a previous period. # Prediction output distribution drift monitoring spec.
                  &quot;categoricalMetricType&quot;: &quot;A String&quot;, # Supported metrics type: * l_infinity * jensen_shannon_divergence
                  &quot;defaultCategoricalAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the categorical features.
                    &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
                  },
                  &quot;defaultNumericAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the numeric features.
                    &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
                  },
                  &quot;featureAlertConditions&quot;: { # Per feature alert condition will override default alert condition.
                    &quot;a_key&quot;: { # Monitoring alert triggered condition.
                      &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
                    },
                  },
                  &quot;features&quot;: [ # Feature names / Prediction output names interested in monitoring. These should be a subset of the input feature names or prediction output names specified in the monitoring schema. If the field is not specified all features / prediction outputs outlied in the monitoring schema will be used.
                    &quot;A String&quot;,
                  ],
                  &quot;numericMetricType&quot;: &quot;A String&quot;, # Supported metrics type: * jensen_shannon_divergence
                },
              },
              &quot;targetDataset&quot;: { # Model monitoring data input spec. # Target dataset.
                &quot;batchPredictionOutput&quot;: { # Data from Vertex AI Batch prediction job output. # Vertex AI Batch prediction Job.
                  &quot;batchPredictionJob&quot;: &quot;A String&quot;, # Vertex AI Batch prediction job resource name. The job must match the model version specified in [ModelMonitor].[model_monitoring_target].
                },
                &quot;columnizedDataset&quot;: { # Input dataset spec. # Columnized dataset.
                  &quot;bigquerySource&quot;: { # Dataset spec for data sotred in BigQuery. # BigQuery data source.
                    &quot;query&quot;: &quot;A String&quot;, # Standard SQL to be used instead of the `table_uri`.
                    &quot;tableUri&quot;: &quot;A String&quot;, # BigQuery URI to a table, up to 2000 characters long. All the columns in the table will be selected. Accepted forms: * BigQuery path. For example: `bq://projectId.bqDatasetId.bqTableId`.
                  },
                  &quot;gcsSource&quot;: { # Dataset spec for data stored in Google Cloud Storage. # Google Cloud Storage data source.
                    &quot;format&quot;: &quot;A String&quot;, # Data format of the dataset.
                    &quot;gcsUri&quot;: &quot;A String&quot;, # Google Cloud Storage URI to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                  },
                  &quot;timestampField&quot;: &quot;A String&quot;, # The timestamp field. Usually for serving data.
                  &quot;vertexDataset&quot;: &quot;A String&quot;, # Resource name of the Vertex AI managed dataset.
                },
                &quot;timeInterval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # The time interval (pair of start_time and end_time) for which results should be returned.
                  &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end.
                  &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start.
                },
                &quot;timeOffset&quot;: { # Time offset setting. # The time offset setting for which results should be returned.
                  &quot;offset&quot;: &quot;A String&quot;, # [offset] is the time difference from the cut-off time. For scheduled jobs, the cut-off time is the scheduled time. For non-scheduled jobs, it&#x27;s the time when the job was created. Currently we support the following format: &#x27;w|W&#x27;: Week, &#x27;d|D&#x27;: Day, &#x27;h|H&#x27;: Hour E.g. &#x27;1h&#x27; stands for 1 hour, &#x27;2d&#x27; stands for 2 days.
                  &quot;window&quot;: &quot;A String&quot;, # [window] refers to the scope of data selected for analysis. It allows you to specify the quantity of data you wish to examine. Currently we support the following format: &#x27;w|W&#x27;: Week, &#x27;d|D&#x27;: Day, &#x27;h|H&#x27;: Hour E.g. &#x27;1h&#x27; stands for 1 hour, &#x27;2d&#x27; stands for 2 days.
                },
                &quot;vertexEndpointLogs&quot;: { # Data from Vertex AI Endpoint request response logging. # Vertex AI Endpoint request &amp; response logging.
                  &quot;endpoints&quot;: [ # List of endpoint resource names. The endpoints must enable the logging with the [Endpoint].[request_response_logging_config], and must contain the deployed model corresponding to the model version specified in [ModelMonitor].[model_monitoring_target].
                    &quot;A String&quot;,
                  ],
                },
              },
            },
            &quot;outputSpec&quot;: { # Specification for the export destination of monitoring results, including metrics, logs, etc. # The Output destination spec for metrics, error logs, etc.
              &quot;gcsBaseDirectory&quot;: { # The Google Cloud Storage location where the output is to be written to. # Google Cloud Storage base folder path for metrics, error logs, etc.
                &quot;outputUriPrefix&quot;: &quot;A String&quot;, # Required. Google Cloud Storage URI to output directory. If the uri doesn&#x27;t end with &#x27;/&#x27;, a &#x27;/&#x27; will be automatically appended. The directory is created if it doesn&#x27;t exist.
              },
            },
          },
          &quot;name&quot;: &quot;A String&quot;, # Output only. Resource name of a ModelMonitoringJob. Format: `projects/{project_id}/locations/{location_id}/modelMonitors/{model_monitor_id}/modelMonitoringJobs/{model_monitoring_job_id}`
          &quot;schedule&quot;: &quot;A String&quot;, # Output only. Schedule resource name. It will only appear when this job is triggered by a schedule.
          &quot;scheduleTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelMonitoringJob was scheduled. It will only appear when this job is triggered by a schedule.
          &quot;state&quot;: &quot;A String&quot;, # Output only. The state of the monitoring job. * When the job is still creating, the state will be &#x27;JOB_STATE_PENDING&#x27;. * Once the job is successfully created, the state will be &#x27;JOB_STATE_RUNNING&#x27;. * Once the job is finished, the state will be one of &#x27;JOB_STATE_FAILED&#x27;, &#x27;JOB_STATE_SUCCEEDED&#x27;, &#x27;JOB_STATE_PARTIALLY_SUCCEEDED&#x27;.
          &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelMonitoringJob was updated most recently.
        },
        &quot;modelMonitoringJobId&quot;: &quot;A String&quot;, # Optional. The ID to use for the Model Monitoring Job, which will become the final component of the model monitoring job resource name. The maximum length is 63 characters, and valid characters are `/^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$/`.
        &quot;parent&quot;: &quot;A String&quot;, # Required. The parent of the ModelMonitoringJob. Format: `projects/{project}/locations/{location}/modelMoniitors/{model_monitor}`
      },
      &quot;createNotebookExecutionJobRequest&quot;: { # Request message for [NotebookService.CreateNotebookExecutionJob] # Request for NotebookService.CreateNotebookExecutionJob.
        &quot;notebookExecutionJob&quot;: { # NotebookExecutionJob represents an instance of a notebook execution. # Required. The NotebookExecutionJob to create.
          &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this NotebookExecutionJob was created.
          &quot;dataformRepositorySource&quot;: { # The Dataform Repository containing the input notebook. # The Dataform Repository pointing to a single file notebook repository.
            &quot;commitSha&quot;: &quot;A String&quot;, # The commit SHA to read repository with. If unset, the file will be read at HEAD.
            &quot;dataformRepositoryResourceName&quot;: &quot;A String&quot;, # The resource name of the Dataform Repository. Format: `projects/{project_id}/locations/{location}/repositories/{repository_id}`
          },
          &quot;directNotebookSource&quot;: { # The content of the input notebook in ipynb format. # The contents of an input notebook file.
            &quot;content&quot;: &quot;A String&quot;, # The base64-encoded contents of the input notebook file.
          },
          &quot;displayName&quot;: &quot;A String&quot;, # The display name of the NotebookExecutionJob. The name can be up to 128 characters long and can consist of any UTF-8 characters.
          &quot;encryptionSpec&quot;: { # Represents a customer-managed encryption key spec that can be applied to a top-level resource. # Customer-managed encryption key spec for the notebook execution job. This field is auto-populated if the NotebookRuntimeTemplate has an encryption spec.
            &quot;kmsKeyName&quot;: &quot;A String&quot;, # Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
          },
          &quot;executionTimeout&quot;: &quot;A String&quot;, # Max running time of the execution job in seconds (default 86400s / 24 hrs).
          &quot;executionUser&quot;: &quot;A String&quot;, # The user email to run the execution as. Only supported by Colab runtimes.
          &quot;gcsNotebookSource&quot;: { # The Cloud Storage uri for the input notebook. # The Cloud Storage url pointing to the ipynb file. Format: `gs://bucket/notebook_file.ipynb`
            &quot;generation&quot;: &quot;A String&quot;, # The version of the Cloud Storage object to read. If unset, the current version of the object is read. See https://cloud.google.com/storage/docs/metadata#generation-number.
            &quot;uri&quot;: &quot;A String&quot;, # The Cloud Storage uri pointing to the ipynb file. Format: `gs://bucket/notebook_file.ipynb`
          },
          &quot;gcsOutputUri&quot;: &quot;A String&quot;, # The Cloud Storage location to upload the result to. Format: `gs://bucket-name`
          &quot;jobState&quot;: &quot;A String&quot;, # Output only. The state of the NotebookExecutionJob.
          &quot;labels&quot;: { # The labels with user-defined metadata to organize NotebookExecutionJobs. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels. System reserved label keys are prefixed with &quot;aiplatform.googleapis.com/&quot; and are immutable.
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of this NotebookExecutionJob. Format: `projects/{project_id}/locations/{location}/notebookExecutionJobs/{job_id}`
          &quot;notebookRuntimeTemplateResourceName&quot;: &quot;A String&quot;, # The NotebookRuntimeTemplate to source compute configuration from.
          &quot;scheduleResourceName&quot;: &quot;A String&quot;, # Output only. The Schedule resource name if this job is triggered by one. Format: `projects/{project_id}/locations/{location}/schedules/{schedule_id}`
          &quot;serviceAccount&quot;: &quot;A String&quot;, # The service account to run the execution as.
          &quot;status&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. Populated when the NotebookExecutionJob is completed. When there is an error during notebook execution, the error details are populated.
            &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
            &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
              {
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
              },
            ],
            &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
          },
          &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this NotebookExecutionJob was most recently updated.
        },
        &quot;notebookExecutionJobId&quot;: &quot;A String&quot;, # Optional. User specified ID for the NotebookExecutionJob.
        &quot;parent&quot;: &quot;A String&quot;, # Required. The resource name of the Location to create the NotebookExecutionJob. Format: `projects/{project}/locations/{location}`
      },
      &quot;createPipelineJobRequest&quot;: { # Request message for PipelineService.CreatePipelineJob. # Request for PipelineService.CreatePipelineJob. CreatePipelineJobRequest.parent field is required (format: projects/{project}/locations/{location}).
        &quot;parent&quot;: &quot;A String&quot;, # Required. The resource name of the Location to create the PipelineJob in. Format: `projects/{project}/locations/{location}`
        &quot;pipelineJob&quot;: { # An instance of a machine learning PipelineJob. # Required. The PipelineJob to create.
          &quot;createTime&quot;: &quot;A String&quot;, # Output only. Pipeline creation time.
          &quot;displayName&quot;: &quot;A String&quot;, # The display name of the Pipeline. The name can be up to 128 characters long and can consist of any UTF-8 characters.
          &quot;encryptionSpec&quot;: { # Represents a customer-managed encryption key spec that can be applied to a top-level resource. # Customer-managed encryption key spec for a pipelineJob. If set, this PipelineJob and all of its sub-resources will be secured by this key.
            &quot;kmsKeyName&quot;: &quot;A String&quot;, # Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
          },
          &quot;endTime&quot;: &quot;A String&quot;, # Output only. Pipeline end time.
          &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. The error that occurred during pipeline execution. Only populated when the pipeline&#x27;s state is FAILED or CANCELLED.
            &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
            &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
              {
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
              },
            ],
            &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
          },
          &quot;jobDetail&quot;: { # The runtime detail of PipelineJob. # Output only. The details of pipeline run. Not available in the list view.
            &quot;pipelineContext&quot;: { # Instance of a general context. # Output only. The context of the pipeline.
              &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Context was created.
              &quot;description&quot;: &quot;A String&quot;, # Description of the Context
              &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Context. May be up to 128 Unicode characters.
              &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
              &quot;labels&quot;: { # The labels with user-defined metadata to organize your Contexts. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Context (System labels are excluded).
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;metadata&quot;: { # Properties of the Context. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;name&quot;: &quot;A String&quot;, # Immutable. The resource name of the Context.
              &quot;parentContexts&quot;: [ # Output only. A list of resource names of Contexts that are parents of this Context. A Context may have at most 10 parent_contexts.
                &quot;A String&quot;,
              ],
              &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
              &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in schema_name to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
              &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Context was last updated.
            },
            &quot;pipelineRunContext&quot;: { # Instance of a general context. # Output only. The context of the current pipeline run.
              &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Context was created.
              &quot;description&quot;: &quot;A String&quot;, # Description of the Context
              &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Context. May be up to 128 Unicode characters.
              &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
              &quot;labels&quot;: { # The labels with user-defined metadata to organize your Contexts. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Context (System labels are excluded).
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;metadata&quot;: { # Properties of the Context. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;name&quot;: &quot;A String&quot;, # Immutable. The resource name of the Context.
              &quot;parentContexts&quot;: [ # Output only. A list of resource names of Contexts that are parents of this Context. A Context may have at most 10 parent_contexts.
                &quot;A String&quot;,
              ],
              &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
              &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in schema_name to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
              &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Context was last updated.
            },
            &quot;taskDetails&quot;: [ # Output only. The runtime details of the tasks under the pipeline.
              { # The runtime detail of a task execution.
                &quot;createTime&quot;: &quot;A String&quot;, # Output only. Task create time.
                &quot;endTime&quot;: &quot;A String&quot;, # Output only. Task end time.
                &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. The error that occurred during task execution. Only populated when the task&#x27;s state is FAILED or CANCELLED.
                  &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
                  &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
                    {
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
                    },
                  ],
                  &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
                },
                &quot;execution&quot;: { # Instance of a general execution. # Output only. The execution metadata of the task.
                  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Execution was created.
                  &quot;description&quot;: &quot;A String&quot;, # Description of the Execution
                  &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Execution. May be up to 128 Unicode characters.
                  &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
                  &quot;labels&quot;: { # The labels with user-defined metadata to organize your Executions. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Execution (System labels are excluded).
                    &quot;a_key&quot;: &quot;A String&quot;,
                  },
                  &quot;metadata&quot;: { # Properties of the Execution. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                  &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the Execution.
                  &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
                  &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in `schema_title` to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
                  &quot;state&quot;: &quot;A String&quot;, # The state of this Execution. This is a property of the Execution, and does not imply or capture any ongoing process. This property is managed by clients (such as Vertex AI Pipelines) and the system does not prescribe or check the validity of state transitions.
                  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Execution was last updated.
                },
                &quot;executorDetail&quot;: { # The runtime detail of a pipeline executor. # Output only. The detailed execution info.
                  &quot;containerDetail&quot;: { # The detail of a container execution. It contains the job names of the lifecycle of a container execution. # Output only. The detailed info for a container executor.
                    &quot;failedMainJobs&quot;: [ # Output only. The names of the previously failed CustomJob for the main container executions. The list includes the all attempts in chronological order.
                      &quot;A String&quot;,
                    ],
                    &quot;failedPreCachingCheckJobs&quot;: [ # Output only. The names of the previously failed CustomJob for the pre-caching-check container executions. This job will be available if the PipelineJob.pipeline_spec specifies the `pre_caching_check` hook in the lifecycle events. The list includes the all attempts in chronological order.
                      &quot;A String&quot;,
                    ],
                    &quot;mainJob&quot;: &quot;A String&quot;, # Output only. The name of the CustomJob for the main container execution.
                    &quot;preCachingCheckJob&quot;: &quot;A String&quot;, # Output only. The name of the CustomJob for the pre-caching-check container execution. This job will be available if the PipelineJob.pipeline_spec specifies the `pre_caching_check` hook in the lifecycle events.
                  },
                  &quot;customJobDetail&quot;: { # The detailed info for a custom job executor. # Output only. The detailed info for a custom job executor.
                    &quot;failedJobs&quot;: [ # Output only. The names of the previously failed CustomJob. The list includes the all attempts in chronological order.
                      &quot;A String&quot;,
                    ],
                    &quot;job&quot;: &quot;A String&quot;, # Output only. The name of the CustomJob.
                  },
                },
                &quot;inputs&quot;: { # Output only. The runtime input artifacts of the task.
                  &quot;a_key&quot;: { # A list of artifact metadata.
                    &quot;artifacts&quot;: [ # Output only. A list of artifact metadata.
                      { # Instance of a general artifact.
                        &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Artifact was created.
                        &quot;description&quot;: &quot;A String&quot;, # Description of the Artifact
                        &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Artifact. May be up to 128 Unicode characters.
                        &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
                        &quot;labels&quot;: { # The labels with user-defined metadata to organize your Artifacts. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Artifact (System labels are excluded).
                          &quot;a_key&quot;: &quot;A String&quot;,
                        },
                        &quot;metadata&quot;: { # Properties of the Artifact. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                        &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the Artifact.
                        &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
                        &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in schema_name to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
                        &quot;state&quot;: &quot;A String&quot;, # The state of this Artifact. This is a property of the Artifact, and does not imply or capture any ongoing process. This property is managed by clients (such as Vertex AI Pipelines), and the system does not prescribe or check the validity of state transitions.
                        &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Artifact was last updated.
                        &quot;uri&quot;: &quot;A String&quot;, # The uniform resource identifier of the artifact file. May be empty if there is no actual artifact file.
                      },
                    ],
                  },
                },
                &quot;outputs&quot;: { # Output only. The runtime output artifacts of the task.
                  &quot;a_key&quot;: { # A list of artifact metadata.
                    &quot;artifacts&quot;: [ # Output only. A list of artifact metadata.
                      { # Instance of a general artifact.
                        &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Artifact was created.
                        &quot;description&quot;: &quot;A String&quot;, # Description of the Artifact
                        &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Artifact. May be up to 128 Unicode characters.
                        &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
                        &quot;labels&quot;: { # The labels with user-defined metadata to organize your Artifacts. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Artifact (System labels are excluded).
                          &quot;a_key&quot;: &quot;A String&quot;,
                        },
                        &quot;metadata&quot;: { # Properties of the Artifact. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                        &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the Artifact.
                        &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
                        &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in schema_name to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
                        &quot;state&quot;: &quot;A String&quot;, # The state of this Artifact. This is a property of the Artifact, and does not imply or capture any ongoing process. This property is managed by clients (such as Vertex AI Pipelines), and the system does not prescribe or check the validity of state transitions.
                        &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Artifact was last updated.
                        &quot;uri&quot;: &quot;A String&quot;, # The uniform resource identifier of the artifact file. May be empty if there is no actual artifact file.
                      },
                    ],
                  },
                },
                &quot;parentTaskId&quot;: &quot;A String&quot;, # Output only. The id of the parent task if the task is within a component scope. Empty if the task is at the root level.
                &quot;pipelineTaskStatus&quot;: [ # Output only. A list of task status. This field keeps a record of task status evolving over time.
                  { # A single record of the task status.
                    &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. The error that occurred during the state. May be set when the state is any of the non-final state (PENDING/RUNNING/CANCELLING) or FAILED state. If the state is FAILED, the error here is final and not going to be retried. If the state is a non-final state, the error indicates a system-error being retried.
                      &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
                      &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
                        {
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
                        },
                      ],
                      &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
                    },
                    &quot;state&quot;: &quot;A String&quot;, # Output only. The state of the task.
                    &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Update time of this status.
                  },
                ],
                &quot;startTime&quot;: &quot;A String&quot;, # Output only. Task start time.
                &quot;state&quot;: &quot;A String&quot;, # Output only. State of the task.
                &quot;taskId&quot;: &quot;A String&quot;, # Output only. The system generated ID of the task.
                &quot;taskName&quot;: &quot;A String&quot;, # Output only. The user specified name of the task that is defined in pipeline_spec.
              },
            ],
          },
          &quot;labels&quot;: { # The labels with user-defined metadata to organize PipelineJob. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels. Note there is some reserved label key for Vertex AI Pipelines. - `vertex-ai-pipelines-run-billing-id`, user set value will get overrided.
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the PipelineJob.
          &quot;network&quot;: &quot;A String&quot;, # The full name of the Compute Engine [network](/compute/docs/networks-and-firewalls#networks) to which the Pipeline Job&#x27;s workload should be peered. For example, `projects/12345/global/networks/myVPC`. [Format](/compute/docs/reference/rest/v1/networks/insert) is of the form `projects/{project}/global/networks/{network}`. Where {project} is a project number, as in `12345`, and {network} is a network name. Private services access must already be configured for the network. Pipeline job will apply the network configuration to the Google Cloud resources being launched, if applied, such as Vertex AI Training or Dataflow job. If left unspecified, the workload is not peered with any network.
          &quot;pipelineSpec&quot;: { # The spec of the pipeline.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;preflightValidations&quot;: True or False, # Optional. Whether to do component level validations before job creation.
          &quot;reservedIpRanges&quot;: [ # A list of names for the reserved ip ranges under the VPC network that can be used for this Pipeline Job&#x27;s workload. If set, we will deploy the Pipeline Job&#x27;s workload within the provided ip ranges. Otherwise, the job will be deployed to any ip ranges under the provided VPC network. Example: [&#x27;vertex-ai-ip-range&#x27;].
            &quot;A String&quot;,
          ],
          &quot;runtimeConfig&quot;: { # The runtime config of a PipelineJob. # Runtime config of the pipeline.
            &quot;failurePolicy&quot;: &quot;A String&quot;, # Represents the failure policy of a pipeline. Currently, the default of a pipeline is that the pipeline will continue to run until no more tasks can be executed, also known as PIPELINE_FAILURE_POLICY_FAIL_SLOW. However, if a pipeline is set to PIPELINE_FAILURE_POLICY_FAIL_FAST, it will stop scheduling any new tasks when a task has failed. Any scheduled tasks will continue to completion.
            &quot;gcsOutputDirectory&quot;: &quot;A String&quot;, # Required. A path in a Cloud Storage bucket, which will be treated as the root output directory of the pipeline. It is used by the system to generate the paths of output artifacts. The artifact paths are generated with a sub-path pattern `{job_id}/{task_id}/{output_key}` under the specified output directory. The service account specified in this pipeline must have the `storage.objects.get` and `storage.objects.create` permissions for this bucket.
            &quot;inputArtifacts&quot;: { # The runtime artifacts of the PipelineJob. The key will be the input artifact name and the value would be one of the InputArtifact.
              &quot;a_key&quot;: { # The type of an input artifact.
                &quot;artifactId&quot;: &quot;A String&quot;, # Artifact resource id from MLMD. Which is the last portion of an artifact resource name: `projects/{project}/locations/{location}/metadataStores/default/artifacts/{artifact_id}`. The artifact must stay within the same project, location and default metadatastore as the pipeline.
              },
            },
            &quot;parameterValues&quot;: { # The runtime parameters of the PipelineJob. The parameters will be passed into PipelineJob.pipeline_spec to replace the placeholders at runtime. This field is used by pipelines built using `PipelineJob.pipeline_spec.schema_version` 2.1.0, such as pipelines built using Kubeflow Pipelines SDK 1.9 or higher and the v2 DSL.
              &quot;a_key&quot;: &quot;&quot;,
            },
            &quot;parameters&quot;: { # Deprecated. Use RuntimeConfig.parameter_values instead. The runtime parameters of the PipelineJob. The parameters will be passed into PipelineJob.pipeline_spec to replace the placeholders at runtime. This field is used by pipelines built using `PipelineJob.pipeline_spec.schema_version` 2.0.0 or lower, such as pipelines built using Kubeflow Pipelines SDK 1.8 or lower.
              &quot;a_key&quot;: { # Value is the value of the field.
                &quot;doubleValue&quot;: 3.14, # A double value.
                &quot;intValue&quot;: &quot;A String&quot;, # An integer value.
                &quot;stringValue&quot;: &quot;A String&quot;, # A string value.
              },
            },
          },
          &quot;satisfiesPzi&quot;: True or False, # Output only. Reserved for future use.
          &quot;satisfiesPzs&quot;: True or False, # Output only. Reserved for future use.
          &quot;scheduleName&quot;: &quot;A String&quot;, # Output only. The schedule resource name. Only returned if the Pipeline is created by Schedule API.
          &quot;serviceAccount&quot;: &quot;A String&quot;, # The service account that the pipeline workload runs as. If not specified, the Compute Engine default service account in the project will be used. See https://cloud.google.com/compute/docs/access/service-accounts#default_service_account Users starting the pipeline must have the `iam.serviceAccounts.actAs` permission on this service account.
          &quot;startTime&quot;: &quot;A String&quot;, # Output only. Pipeline start time.
          &quot;state&quot;: &quot;A String&quot;, # Output only. The detailed state of the job.
          &quot;templateMetadata&quot;: { # Pipeline template metadata if PipelineJob.template_uri is from supported template registry. Currently, the only supported registry is Artifact Registry. # Output only. Pipeline template metadata. Will fill up fields if PipelineJob.template_uri is from supported template registry.
            &quot;version&quot;: &quot;A String&quot;, # The version_name in artifact registry. Will always be presented in output if the PipelineJob.template_uri is from supported template registry. Format is &quot;sha256:abcdef123456...&quot;.
          },
          &quot;templateUri&quot;: &quot;A String&quot;, # A template uri from where the PipelineJob.pipeline_spec, if empty, will be downloaded. Currently, only uri from Vertex Template Registry &amp; Gallery is supported. Reference to https://cloud.google.com/vertex-ai/docs/pipelines/create-pipeline-template.
          &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this PipelineJob was most recently updated.
        },
        &quot;pipelineJobId&quot;: &quot;A String&quot;, # The ID to use for the PipelineJob, which will become the final component of the PipelineJob name. If not provided, an ID will be automatically generated. This value should be less than 128 characters, and valid characters are `/a-z-/`.
      },
      &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule was created.
      &quot;cron&quot;: &quot;A String&quot;, # Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: &quot;CRON_TZ=${IANA_TIME_ZONE}&quot; or &quot;TZ=${IANA_TIME_ZONE}&quot;. The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, &quot;CRON_TZ=America/New_York 1 * * * *&quot;, or &quot;TZ=America/New_York 1 * * * *&quot;.
      &quot;displayName&quot;: &quot;A String&quot;, # Required. User provided name of the Schedule. The name can be up to 128 characters long and can consist of any UTF-8 characters.
      &quot;endTime&quot;: &quot;A String&quot;, # Optional. Timestamp after which no new runs can be scheduled. If specified, The schedule will be completed when either end_time is reached or when scheduled_run_count &gt;= max_run_count. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
      &quot;lastPauseTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule was last paused. Unset if never paused.
      &quot;lastResumeTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule was last resumed. Unset if never resumed from pause.
      &quot;lastScheduledRunResponse&quot;: { # Status of a scheduled run. # Output only. Response of the last scheduled run. This is the response for starting the scheduled requests and not the execution of the operations/jobs created by the requests (if applicable). Unset if no run has been scheduled yet.
        &quot;runResponse&quot;: &quot;A String&quot;, # The response of the scheduled run.
        &quot;scheduledRunTime&quot;: &quot;A String&quot;, # The scheduled run time based on the user-specified schedule.
      },
      &quot;maxConcurrentRunCount&quot;: &quot;A String&quot;, # Required. Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the operations/jobs created by the requests (if applicable).
      &quot;maxRunCount&quot;: &quot;A String&quot;, # Optional. Maximum run count of the schedule. If specified, The schedule will be completed when either started_run_count &gt;= max_run_count or when end_time is reached. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
      &quot;name&quot;: &quot;A String&quot;, # Immutable. The resource name of the Schedule.
      &quot;nextRunTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule should schedule the next run. Having a next_run_time in the past means the runs are being started behind schedule.
      &quot;startTime&quot;: &quot;A String&quot;, # Optional. Timestamp after which the first run can be scheduled. Default to Schedule create time if not specified.
      &quot;startedRunCount&quot;: &quot;A String&quot;, # Output only. The number of runs started by this schedule.
      &quot;state&quot;: &quot;A String&quot;, # Output only. The state of this Schedule.
      &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule was updated.
    },
  ],
}</pre>
</div>

<div class="method">
    <code class="details" id="list_next">list_next()</code>
  <pre>Retrieves the next page of results.

        Args:
          previous_request: The request for the previous page. (required)
          previous_response: The response from the request for the previous page. (required)

        Returns:
          A request object that you can call &#x27;execute()&#x27; on to request the next
          page. Returns None if there are no more items in the collection.
        </pre>
</div>

<div class="method">
    <code class="details" id="patch">patch(name, body=None, updateMask=None, x__xgafv=None)</code>
  <pre>Updates an active or paused Schedule. When the Schedule is updated, new runs will be scheduled starting from the updated next execution time after the update time based on the time_specification in the updated Schedule. All unstarted runs before the update time will be skipped while already created runs will NOT be paused or canceled.

Args:
  name: string, Immutable. The resource name of the Schedule. (required)
  body: object, The request body.
    The object takes the form of:

{ # An instance of a Schedule periodically schedules runs to make API calls based on user specified time specification and API request type.
  &quot;allowQueueing&quot;: True or False, # Optional. Whether new scheduled runs can be queued when max_concurrent_runs limit is reached. If set to true, new runs will be queued instead of skipped. Default to false.
  &quot;catchUp&quot;: True or False, # Output only. Whether to backfill missed runs when the schedule is resumed from PAUSED state. If set to true, all missed runs will be scheduled. New runs will be scheduled after the backfill is complete. Default to false.
  &quot;createModelMonitoringJobRequest&quot;: { # Request message for ModelMonitoringService.CreateModelMonitoringJob. # Request for ModelMonitoringService.CreateModelMonitoringJob.
    &quot;modelMonitoringJob&quot;: { # Represents a model monitoring job that analyze dataset using different monitoring algorithm. # Required. The ModelMonitoringJob to create
      &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelMonitoringJob was created.
      &quot;displayName&quot;: &quot;A String&quot;, # The display name of the ModelMonitoringJob. The name can be up to 128 characters long and can consist of any UTF-8.
      &quot;jobExecutionDetail&quot;: { # Represent the execution details of the job. # Output only. Execution results for all the monitoring objectives.
        &quot;baselineDatasets&quot;: [ # Processed baseline datasets.
          { # Processed dataset information.
            &quot;location&quot;: &quot;A String&quot;, # Actual data location of the processed dataset.
            &quot;timeRange&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Dataset time range information if any.
              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end.
              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start.
            },
          },
        ],
        &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Additional job error status.
          &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
          &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
            {
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
            },
          ],
          &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
        },
        &quot;objectiveStatus&quot;: { # Status of data processing for each monitoring objective. Key is the objective.
          &quot;a_key&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
            &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
            &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
              {
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
              },
            ],
            &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
          },
        },
        &quot;targetDatasets&quot;: [ # Processed target datasets.
          { # Processed dataset information.
            &quot;location&quot;: &quot;A String&quot;, # Actual data location of the processed dataset.
            &quot;timeRange&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Dataset time range information if any.
              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end.
              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start.
            },
          },
        ],
      },
      &quot;modelMonitoringSpec&quot;: { # Monitoring monitoring job spec. It outlines the specifications for monitoring objectives, notifications, and result exports. # Monitoring monitoring job spec. It outlines the specifications for monitoring objectives, notifications, and result exports. If left blank, the default monitoring specifications from the top-level resource &#x27;ModelMonitor&#x27; will be applied. If provided, we will use the specification defined here rather than the default one.
        &quot;notificationSpec&quot;: { # Notification spec(email, notification channel) for model monitoring statistics/alerts. # The model monitoring notification spec.
          &quot;emailConfig&quot;: { # The config for email alerts. # Email alert config.
            &quot;userEmails&quot;: [ # The email addresses to send the alerts.
              &quot;A String&quot;,
            ],
          },
          &quot;enableCloudLogging&quot;: True or False, # Dump the anomalies to Cloud Logging. The anomalies will be put to json payload encoded from proto google.cloud.aiplatform.logging.ModelMonitoringAnomaliesLogEntry. This can be further sinked to Pub/Sub or any other services supported by Cloud Logging.
          &quot;notificationChannelConfigs&quot;: [ # Notification channel config.
            { # Google Cloud Notification Channel config.
              &quot;notificationChannel&quot;: &quot;A String&quot;, # Resource names of the NotificationChannels. Must be of the format `projects//notificationChannels/`
            },
          ],
        },
        &quot;objectiveSpec&quot;: { # Monitoring objectives spec. # The monitoring objective spec.
          &quot;baselineDataset&quot;: { # Model monitoring data input spec. # Baseline dataset. It could be the training dataset or production serving dataset from a previous period.
            &quot;batchPredictionOutput&quot;: { # Data from Vertex AI Batch prediction job output. # Vertex AI Batch prediction Job.
              &quot;batchPredictionJob&quot;: &quot;A String&quot;, # Vertex AI Batch prediction job resource name. The job must match the model version specified in [ModelMonitor].[model_monitoring_target].
            },
            &quot;columnizedDataset&quot;: { # Input dataset spec. # Columnized dataset.
              &quot;bigquerySource&quot;: { # Dataset spec for data sotred in BigQuery. # BigQuery data source.
                &quot;query&quot;: &quot;A String&quot;, # Standard SQL to be used instead of the `table_uri`.
                &quot;tableUri&quot;: &quot;A String&quot;, # BigQuery URI to a table, up to 2000 characters long. All the columns in the table will be selected. Accepted forms: * BigQuery path. For example: `bq://projectId.bqDatasetId.bqTableId`.
              },
              &quot;gcsSource&quot;: { # Dataset spec for data stored in Google Cloud Storage. # Google Cloud Storage data source.
                &quot;format&quot;: &quot;A String&quot;, # Data format of the dataset.
                &quot;gcsUri&quot;: &quot;A String&quot;, # Google Cloud Storage URI to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
              },
              &quot;timestampField&quot;: &quot;A String&quot;, # The timestamp field. Usually for serving data.
              &quot;vertexDataset&quot;: &quot;A String&quot;, # Resource name of the Vertex AI managed dataset.
            },
            &quot;timeInterval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # The time interval (pair of start_time and end_time) for which results should be returned.
              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end.
              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start.
            },
            &quot;timeOffset&quot;: { # Time offset setting. # The time offset setting for which results should be returned.
              &quot;offset&quot;: &quot;A String&quot;, # [offset] is the time difference from the cut-off time. For scheduled jobs, the cut-off time is the scheduled time. For non-scheduled jobs, it&#x27;s the time when the job was created. Currently we support the following format: &#x27;w|W&#x27;: Week, &#x27;d|D&#x27;: Day, &#x27;h|H&#x27;: Hour E.g. &#x27;1h&#x27; stands for 1 hour, &#x27;2d&#x27; stands for 2 days.
              &quot;window&quot;: &quot;A String&quot;, # [window] refers to the scope of data selected for analysis. It allows you to specify the quantity of data you wish to examine. Currently we support the following format: &#x27;w|W&#x27;: Week, &#x27;d|D&#x27;: Day, &#x27;h|H&#x27;: Hour E.g. &#x27;1h&#x27; stands for 1 hour, &#x27;2d&#x27; stands for 2 days.
            },
            &quot;vertexEndpointLogs&quot;: { # Data from Vertex AI Endpoint request response logging. # Vertex AI Endpoint request &amp; response logging.
              &quot;endpoints&quot;: [ # List of endpoint resource names. The endpoints must enable the logging with the [Endpoint].[request_response_logging_config], and must contain the deployed model corresponding to the model version specified in [ModelMonitor].[model_monitoring_target].
                &quot;A String&quot;,
              ],
            },
          },
          &quot;explanationSpec&quot;: { # Specification of Model explanation. # The explanation spec. This spec is required when the objectives spec includes feature attribution objectives.
            &quot;metadata&quot;: { # Metadata describing the Model&#x27;s input and output for explanation. # Optional. Metadata describing the Model&#x27;s input and output for explanation.
              &quot;featureAttributionsSchemaUri&quot;: &quot;A String&quot;, # Points to a YAML file stored on Google Cloud Storage describing the format of the feature attributions. The schema is defined as an OpenAPI 3.0.2 [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject). AutoML tabular Models always have this field populated by Vertex AI. Note: The URI given on output may be different, including the URI scheme, than the one given on input. The output URI will point to a location where the user only has a read access.
              &quot;inputs&quot;: { # Required. Map from feature names to feature input metadata. Keys are the name of the features. Values are the specification of the feature. An empty InputMetadata is valid. It describes a text feature which has the name specified as the key in ExplanationMetadata.inputs. The baseline of the empty feature is chosen by Vertex AI. For Vertex AI-provided Tensorflow images, the key can be any friendly name of the feature. Once specified, featureAttributions are keyed by this key (if not grouped with another feature). For custom images, the key must match with the key in instance.
                &quot;a_key&quot;: { # Metadata of the input of a feature. Fields other than InputMetadata.input_baselines are applicable only for Models that are using Vertex AI-provided images for Tensorflow.
                  &quot;denseShapeTensorName&quot;: &quot;A String&quot;, # Specifies the shape of the values of the input if the input is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
                  &quot;encodedBaselines&quot;: [ # A list of baselines for the encoded tensor. The shape of each baseline should match the shape of the encoded tensor. If a scalar is provided, Vertex AI broadcasts to the same shape as the encoded tensor.
                    &quot;&quot;,
                  ],
                  &quot;encodedTensorName&quot;: &quot;A String&quot;, # Encoded tensor is a transformation of the input tensor. Must be provided if choosing Integrated Gradients attribution or XRAI attribution and the input tensor is not differentiable. An encoded tensor is generated if the input tensor is encoded by a lookup table.
                  &quot;encoding&quot;: &quot;A String&quot;, # Defines how the feature is encoded into the input tensor. Defaults to IDENTITY.
                  &quot;featureValueDomain&quot;: { # Domain details of the input feature value. Provides numeric information about the feature, such as its range (min, max). If the feature has been pre-processed, for example with z-scoring, then it provides information about how to recover the original feature. For example, if the input feature is an image and it has been pre-processed to obtain 0-mean and stddev = 1 values, then original_mean, and original_stddev refer to the mean and stddev of the original feature (e.g. image tensor) from which input feature (with mean = 0 and stddev = 1) was obtained. # The domain details of the input feature value. Like min/max, original mean or standard deviation if normalized.
                    &quot;maxValue&quot;: 3.14, # The maximum permissible value for this feature.
                    &quot;minValue&quot;: 3.14, # The minimum permissible value for this feature.
                    &quot;originalMean&quot;: 3.14, # If this input feature has been normalized to a mean value of 0, the original_mean specifies the mean value of the domain prior to normalization.
                    &quot;originalStddev&quot;: 3.14, # If this input feature has been normalized to a standard deviation of 1.0, the original_stddev specifies the standard deviation of the domain prior to normalization.
                  },
                  &quot;groupName&quot;: &quot;A String&quot;, # Name of the group that the input belongs to. Features with the same group name will be treated as one feature when computing attributions. Features grouped together can have different shapes in value. If provided, there will be one single attribution generated in Attribution.feature_attributions, keyed by the group name.
                  &quot;indexFeatureMapping&quot;: [ # A list of feature names for each index in the input tensor. Required when the input InputMetadata.encoding is BAG_OF_FEATURES, BAG_OF_FEATURES_SPARSE, INDICATOR.
                    &quot;A String&quot;,
                  ],
                  &quot;indicesTensorName&quot;: &quot;A String&quot;, # Specifies the index of the values of the input tensor. Required when the input tensor is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
                  &quot;inputBaselines&quot;: [ # Baseline inputs for this feature. If no baseline is specified, Vertex AI chooses the baseline for this feature. If multiple baselines are specified, Vertex AI returns the average attributions across them in Attribution.feature_attributions. For Vertex AI-provided Tensorflow images (both 1.x and 2.x), the shape of each baseline must match the shape of the input tensor. If a scalar is provided, we broadcast to the same shape as the input tensor. For custom images, the element of the baselines must be in the same format as the feature&#x27;s input in the instance[]. The schema of any single instance may be specified via Endpoint&#x27;s DeployedModels&#x27; Model&#x27;s PredictSchemata&#x27;s instance_schema_uri.
                    &quot;&quot;,
                  ],
                  &quot;inputTensorName&quot;: &quot;A String&quot;, # Name of the input tensor for this feature. Required and is only applicable to Vertex AI-provided images for Tensorflow.
                  &quot;modality&quot;: &quot;A String&quot;, # Modality of the feature. Valid values are: numeric, image. Defaults to numeric.
                  &quot;visualization&quot;: { # Visualization configurations for image explanation. # Visualization configurations for image explanation.
                    &quot;clipPercentLowerbound&quot;: 3.14, # Excludes attributions below the specified percentile, from the highlighted areas. Defaults to 62.
                    &quot;clipPercentUpperbound&quot;: 3.14, # Excludes attributions above the specified percentile from the highlighted areas. Using the clip_percent_upperbound and clip_percent_lowerbound together can be useful for filtering out noise and making it easier to see areas of strong attribution. Defaults to 99.9.
                    &quot;colorMap&quot;: &quot;A String&quot;, # The color scheme used for the highlighted areas. Defaults to PINK_GREEN for Integrated Gradients attribution, which shows positive attributions in green and negative in pink. Defaults to VIRIDIS for XRAI attribution, which highlights the most influential regions in yellow and the least influential in blue.
                    &quot;overlayType&quot;: &quot;A String&quot;, # How the original image is displayed in the visualization. Adjusting the overlay can help increase visual clarity if the original image makes it difficult to view the visualization. Defaults to NONE.
                    &quot;polarity&quot;: &quot;A String&quot;, # Whether to only highlight pixels with positive contributions, negative or both. Defaults to POSITIVE.
                    &quot;type&quot;: &quot;A String&quot;, # Type of the image visualization. Only applicable to Integrated Gradients attribution. OUTLINES shows regions of attribution, while PIXELS shows per-pixel attribution. Defaults to OUTLINES.
                  },
                },
              },
              &quot;latentSpaceSource&quot;: &quot;A String&quot;, # Name of the source to generate embeddings for example based explanations.
              &quot;outputs&quot;: { # Required. Map from output names to output metadata. For Vertex AI-provided Tensorflow images, keys can be any user defined string that consists of any UTF-8 characters. For custom images, keys are the name of the output field in the prediction to be explained. Currently only one key is allowed.
                &quot;a_key&quot;: { # Metadata of the prediction output to be explained.
                  &quot;displayNameMappingKey&quot;: &quot;A String&quot;, # Specify a field name in the prediction to look for the display name. Use this if the prediction contains the display names for the outputs. The display names in the prediction must have the same shape of the outputs, so that it can be located by Attribution.output_index for a specific output.
                  &quot;indexDisplayNameMapping&quot;: &quot;&quot;, # Static mapping between the index and display name. Use this if the outputs are a deterministic n-dimensional array, e.g. a list of scores of all the classes in a pre-defined order for a multi-classification Model. It&#x27;s not feasible if the outputs are non-deterministic, e.g. the Model produces top-k classes or sort the outputs by their values. The shape of the value must be an n-dimensional array of strings. The number of dimensions must match that of the outputs to be explained. The Attribution.output_display_name is populated by locating in the mapping with Attribution.output_index.
                  &quot;outputTensorName&quot;: &quot;A String&quot;, # Name of the output tensor. Required and is only applicable to Vertex AI provided images for Tensorflow.
                },
              },
            },
            &quot;parameters&quot;: { # Parameters to configure explaining for Model&#x27;s predictions. # Required. Parameters that configure explaining of the Model&#x27;s predictions.
              &quot;examples&quot;: { # Example-based explainability that returns the nearest neighbors from the provided dataset. # Example-based explanations that returns the nearest neighbors from the provided dataset.
                &quot;exampleGcsSource&quot;: { # The Cloud Storage input instances. # The Cloud Storage input instances.
                  &quot;dataFormat&quot;: &quot;A String&quot;, # The format in which instances are given, if not specified, assume it&#x27;s JSONL format. Currently only JSONL format is supported.
                  &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage location for the input instances.
                    &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                      &quot;A String&quot;,
                    ],
                  },
                },
                &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage locations that contain the instances to be indexed for approximate nearest neighbor search.
                  &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                    &quot;A String&quot;,
                  ],
                },
                &quot;nearestNeighborSearchConfig&quot;: &quot;&quot;, # The full configuration for the generated index, the semantics are the same as metadata and should match [NearestNeighborSearchConfig](https://cloud.google.com/vertex-ai/docs/explainable-ai/configuring-explanations-example-based#nearest-neighbor-search-config).
                &quot;neighborCount&quot;: 42, # The number of neighbors to return when querying for examples.
                &quot;presets&quot;: { # Preset configuration for example-based explanations # Simplified preset configuration, which automatically sets configuration values based on the desired query speed-precision trade-off and modality.
                  &quot;modality&quot;: &quot;A String&quot;, # The modality of the uploaded model, which automatically configures the distance measurement and feature normalization for the underlying example index and queries. If your model does not precisely fit one of these types, it is okay to choose the closest type.
                  &quot;query&quot;: &quot;A String&quot;, # Preset option controlling parameters for speed-precision trade-off when querying for examples. If omitted, defaults to `PRECISE`.
                },
              },
              &quot;integratedGradientsAttribution&quot;: { # An attribution method that computes the Aumann-Shapley value taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365 # An attribution method that computes Aumann-Shapley values taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365
                &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for IG with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
                  &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
                },
                &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
                  &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
                    &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
                      { # Noise sigma for a single feature.
                        &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                        &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
                      },
                    ],
                  },
                  &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
                  &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
                },
                &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is within the desired error range. Valid range of its value is [1, 100], inclusively.
              },
              &quot;outputIndices&quot;: [ # If populated, only returns attributions that have output_index contained in output_indices. It must be an ndarray of integers, with the same shape of the output it&#x27;s explaining. If not populated, returns attributions for top_k indices of outputs. If neither top_k nor output_indices is populated, returns the argmax index of the outputs. Only applicable to Models that predict multiple outputs (e,g, multi-class Models that predict multiple classes).
                &quot;&quot;,
              ],
              &quot;sampledShapleyAttribution&quot;: { # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. Refer to this paper for model details: https://arxiv.org/abs/1306.4265.
                &quot;pathCount&quot;: 42, # Required. The number of feature permutations to consider when approximating the Shapley values. Valid range of its value is [1, 50], inclusively.
              },
              &quot;topK&quot;: 42, # If populated, returns attributions for top K indices of outputs (defaults to 1). Only applies to Models that predicts more than one outputs (e,g, multi-class Models). When set to -1, returns explanations for all outputs.
              &quot;xraiAttribution&quot;: { # An explanation method that redistributes Integrated Gradients attributions to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 Supported only by image Models. # An attribution method that redistributes Integrated Gradients attribution to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 XRAI currently performs better on natural images, like a picture of a house or an animal. If the images are taken in artificial environments, like a lab or manufacturing line, or from diagnostic equipment, like x-rays or quality-control cameras, use Integrated Gradients instead.
                &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for XRAI with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
                  &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
                },
                &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
                  &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
                    &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
                      { # Noise sigma for a single feature.
                        &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                        &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
                      },
                    ],
                  },
                  &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
                  &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
                },
                &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is met within the desired error range. Valid range of its value is [1, 100], inclusively.
              },
            },
          },
          &quot;tabularObjective&quot;: { # Tabular monitoring objective. # Tabular monitoring objective.
            &quot;featureAttributionSpec&quot;: { # Feature attribution monitoring spec. # Feature attribution monitoring spec.
              &quot;batchExplanationDedicatedResources&quot;: { # A description of resources that are used for performing batch operations, are dedicated to a Model, and need manual configuration. # The config of resources used by the Model Monitoring during the batch explanation for non-AutoML models. If not set, `n1-standard-2` machine type will be used by default.
                &quot;machineSpec&quot;: { # Specification of a single machine. # Required. Immutable. The specification of a single machine.
                  &quot;acceleratorCount&quot;: 42, # The number of accelerators to attach to the machine.
                  &quot;acceleratorType&quot;: &quot;A String&quot;, # Immutable. The type of accelerator(s) that may be attached to the machine as per accelerator_count.
                  &quot;machineType&quot;: &quot;A String&quot;, # Immutable. The type of the machine. See the [list of machine types supported for prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types) See the [list of machine types supported for custom training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types). For DeployedModel this field is optional, and the default value is `n1-standard-2`. For BatchPredictionJob or as part of WorkerPoolSpec this field is required.
                  &quot;reservationAffinity&quot;: { # A ReservationAffinity can be used to configure a Vertex AI resource (e.g., a DeployedModel) to draw its Compute Engine resources from a Shared Reservation, or exclusively from on-demand capacity. # Optional. Immutable. Configuration controlling how this resource pool consumes reservation.
                    &quot;key&quot;: &quot;A String&quot;, # Optional. Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, use `compute.googleapis.com/reservation-name` as the key and specify the name of your reservation as its value.
                    &quot;reservationAffinityType&quot;: &quot;A String&quot;, # Required. Specifies the reservation affinity type.
                    &quot;values&quot;: [ # Optional. Corresponds to the label values of a reservation resource. This must be the full resource name of the reservation.
                      &quot;A String&quot;,
                    ],
                  },
                  &quot;tpuTopology&quot;: &quot;A String&quot;, # Immutable. The topology of the TPUs. Corresponds to the TPU topologies available from GKE. (Example: tpu_topology: &quot;2x2x1&quot;).
                },
                &quot;maxReplicaCount&quot;: 42, # Immutable. The maximum number of machine replicas the batch operation may be scaled to. The default value is 10.
                &quot;startingReplicaCount&quot;: 42, # Immutable. The number of machine replicas used at the start of the batch operation. If not set, Vertex AI decides starting number, not greater than max_replica_count
              },
              &quot;defaultAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the features.
                &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
              },
              &quot;featureAlertConditions&quot;: { # Per feature alert condition will override default alert condition.
                &quot;a_key&quot;: { # Monitoring alert triggered condition.
                  &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
                },
              },
              &quot;features&quot;: [ # Feature names interested in monitoring. These should be a subset of the input feature names specified in the monitoring schema. If the field is not specified all features outlied in the monitoring schema will be used.
                &quot;A String&quot;,
              ],
            },
            &quot;featureDriftSpec&quot;: { # Data drift monitoring spec. Data drift measures the distribution distance between the current dataset and a baseline dataset. A typical use case is to detect data drift between the recent production serving dataset and the training dataset, or to compare the recent production dataset with a dataset from a previous period. # Input feature distribution drift monitoring spec.
              &quot;categoricalMetricType&quot;: &quot;A String&quot;, # Supported metrics type: * l_infinity * jensen_shannon_divergence
              &quot;defaultCategoricalAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the categorical features.
                &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
              },
              &quot;defaultNumericAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the numeric features.
                &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
              },
              &quot;featureAlertConditions&quot;: { # Per feature alert condition will override default alert condition.
                &quot;a_key&quot;: { # Monitoring alert triggered condition.
                  &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
                },
              },
              &quot;features&quot;: [ # Feature names / Prediction output names interested in monitoring. These should be a subset of the input feature names or prediction output names specified in the monitoring schema. If the field is not specified all features / prediction outputs outlied in the monitoring schema will be used.
                &quot;A String&quot;,
              ],
              &quot;numericMetricType&quot;: &quot;A String&quot;, # Supported metrics type: * jensen_shannon_divergence
            },
            &quot;predictionOutputDriftSpec&quot;: { # Data drift monitoring spec. Data drift measures the distribution distance between the current dataset and a baseline dataset. A typical use case is to detect data drift between the recent production serving dataset and the training dataset, or to compare the recent production dataset with a dataset from a previous period. # Prediction output distribution drift monitoring spec.
              &quot;categoricalMetricType&quot;: &quot;A String&quot;, # Supported metrics type: * l_infinity * jensen_shannon_divergence
              &quot;defaultCategoricalAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the categorical features.
                &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
              },
              &quot;defaultNumericAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the numeric features.
                &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
              },
              &quot;featureAlertConditions&quot;: { # Per feature alert condition will override default alert condition.
                &quot;a_key&quot;: { # Monitoring alert triggered condition.
                  &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
                },
              },
              &quot;features&quot;: [ # Feature names / Prediction output names interested in monitoring. These should be a subset of the input feature names or prediction output names specified in the monitoring schema. If the field is not specified all features / prediction outputs outlied in the monitoring schema will be used.
                &quot;A String&quot;,
              ],
              &quot;numericMetricType&quot;: &quot;A String&quot;, # Supported metrics type: * jensen_shannon_divergence
            },
          },
          &quot;targetDataset&quot;: { # Model monitoring data input spec. # Target dataset.
            &quot;batchPredictionOutput&quot;: { # Data from Vertex AI Batch prediction job output. # Vertex AI Batch prediction Job.
              &quot;batchPredictionJob&quot;: &quot;A String&quot;, # Vertex AI Batch prediction job resource name. The job must match the model version specified in [ModelMonitor].[model_monitoring_target].
            },
            &quot;columnizedDataset&quot;: { # Input dataset spec. # Columnized dataset.
              &quot;bigquerySource&quot;: { # Dataset spec for data sotred in BigQuery. # BigQuery data source.
                &quot;query&quot;: &quot;A String&quot;, # Standard SQL to be used instead of the `table_uri`.
                &quot;tableUri&quot;: &quot;A String&quot;, # BigQuery URI to a table, up to 2000 characters long. All the columns in the table will be selected. Accepted forms: * BigQuery path. For example: `bq://projectId.bqDatasetId.bqTableId`.
              },
              &quot;gcsSource&quot;: { # Dataset spec for data stored in Google Cloud Storage. # Google Cloud Storage data source.
                &quot;format&quot;: &quot;A String&quot;, # Data format of the dataset.
                &quot;gcsUri&quot;: &quot;A String&quot;, # Google Cloud Storage URI to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
              },
              &quot;timestampField&quot;: &quot;A String&quot;, # The timestamp field. Usually for serving data.
              &quot;vertexDataset&quot;: &quot;A String&quot;, # Resource name of the Vertex AI managed dataset.
            },
            &quot;timeInterval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # The time interval (pair of start_time and end_time) for which results should be returned.
              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end.
              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start.
            },
            &quot;timeOffset&quot;: { # Time offset setting. # The time offset setting for which results should be returned.
              &quot;offset&quot;: &quot;A String&quot;, # [offset] is the time difference from the cut-off time. For scheduled jobs, the cut-off time is the scheduled time. For non-scheduled jobs, it&#x27;s the time when the job was created. Currently we support the following format: &#x27;w|W&#x27;: Week, &#x27;d|D&#x27;: Day, &#x27;h|H&#x27;: Hour E.g. &#x27;1h&#x27; stands for 1 hour, &#x27;2d&#x27; stands for 2 days.
              &quot;window&quot;: &quot;A String&quot;, # [window] refers to the scope of data selected for analysis. It allows you to specify the quantity of data you wish to examine. Currently we support the following format: &#x27;w|W&#x27;: Week, &#x27;d|D&#x27;: Day, &#x27;h|H&#x27;: Hour E.g. &#x27;1h&#x27; stands for 1 hour, &#x27;2d&#x27; stands for 2 days.
            },
            &quot;vertexEndpointLogs&quot;: { # Data from Vertex AI Endpoint request response logging. # Vertex AI Endpoint request &amp; response logging.
              &quot;endpoints&quot;: [ # List of endpoint resource names. The endpoints must enable the logging with the [Endpoint].[request_response_logging_config], and must contain the deployed model corresponding to the model version specified in [ModelMonitor].[model_monitoring_target].
                &quot;A String&quot;,
              ],
            },
          },
        },
        &quot;outputSpec&quot;: { # Specification for the export destination of monitoring results, including metrics, logs, etc. # The Output destination spec for metrics, error logs, etc.
          &quot;gcsBaseDirectory&quot;: { # The Google Cloud Storage location where the output is to be written to. # Google Cloud Storage base folder path for metrics, error logs, etc.
            &quot;outputUriPrefix&quot;: &quot;A String&quot;, # Required. Google Cloud Storage URI to output directory. If the uri doesn&#x27;t end with &#x27;/&#x27;, a &#x27;/&#x27; will be automatically appended. The directory is created if it doesn&#x27;t exist.
          },
        },
      },
      &quot;name&quot;: &quot;A String&quot;, # Output only. Resource name of a ModelMonitoringJob. Format: `projects/{project_id}/locations/{location_id}/modelMonitors/{model_monitor_id}/modelMonitoringJobs/{model_monitoring_job_id}`
      &quot;schedule&quot;: &quot;A String&quot;, # Output only. Schedule resource name. It will only appear when this job is triggered by a schedule.
      &quot;scheduleTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelMonitoringJob was scheduled. It will only appear when this job is triggered by a schedule.
      &quot;state&quot;: &quot;A String&quot;, # Output only. The state of the monitoring job. * When the job is still creating, the state will be &#x27;JOB_STATE_PENDING&#x27;. * Once the job is successfully created, the state will be &#x27;JOB_STATE_RUNNING&#x27;. * Once the job is finished, the state will be one of &#x27;JOB_STATE_FAILED&#x27;, &#x27;JOB_STATE_SUCCEEDED&#x27;, &#x27;JOB_STATE_PARTIALLY_SUCCEEDED&#x27;.
      &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelMonitoringJob was updated most recently.
    },
    &quot;modelMonitoringJobId&quot;: &quot;A String&quot;, # Optional. The ID to use for the Model Monitoring Job, which will become the final component of the model monitoring job resource name. The maximum length is 63 characters, and valid characters are `/^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$/`.
    &quot;parent&quot;: &quot;A String&quot;, # Required. The parent of the ModelMonitoringJob. Format: `projects/{project}/locations/{location}/modelMoniitors/{model_monitor}`
  },
  &quot;createNotebookExecutionJobRequest&quot;: { # Request message for [NotebookService.CreateNotebookExecutionJob] # Request for NotebookService.CreateNotebookExecutionJob.
    &quot;notebookExecutionJob&quot;: { # NotebookExecutionJob represents an instance of a notebook execution. # Required. The NotebookExecutionJob to create.
      &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this NotebookExecutionJob was created.
      &quot;dataformRepositorySource&quot;: { # The Dataform Repository containing the input notebook. # The Dataform Repository pointing to a single file notebook repository.
        &quot;commitSha&quot;: &quot;A String&quot;, # The commit SHA to read repository with. If unset, the file will be read at HEAD.
        &quot;dataformRepositoryResourceName&quot;: &quot;A String&quot;, # The resource name of the Dataform Repository. Format: `projects/{project_id}/locations/{location}/repositories/{repository_id}`
      },
      &quot;directNotebookSource&quot;: { # The content of the input notebook in ipynb format. # The contents of an input notebook file.
        &quot;content&quot;: &quot;A String&quot;, # The base64-encoded contents of the input notebook file.
      },
      &quot;displayName&quot;: &quot;A String&quot;, # The display name of the NotebookExecutionJob. The name can be up to 128 characters long and can consist of any UTF-8 characters.
      &quot;encryptionSpec&quot;: { # Represents a customer-managed encryption key spec that can be applied to a top-level resource. # Customer-managed encryption key spec for the notebook execution job. This field is auto-populated if the NotebookRuntimeTemplate has an encryption spec.
        &quot;kmsKeyName&quot;: &quot;A String&quot;, # Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
      },
      &quot;executionTimeout&quot;: &quot;A String&quot;, # Max running time of the execution job in seconds (default 86400s / 24 hrs).
      &quot;executionUser&quot;: &quot;A String&quot;, # The user email to run the execution as. Only supported by Colab runtimes.
      &quot;gcsNotebookSource&quot;: { # The Cloud Storage uri for the input notebook. # The Cloud Storage url pointing to the ipynb file. Format: `gs://bucket/notebook_file.ipynb`
        &quot;generation&quot;: &quot;A String&quot;, # The version of the Cloud Storage object to read. If unset, the current version of the object is read. See https://cloud.google.com/storage/docs/metadata#generation-number.
        &quot;uri&quot;: &quot;A String&quot;, # The Cloud Storage uri pointing to the ipynb file. Format: `gs://bucket/notebook_file.ipynb`
      },
      &quot;gcsOutputUri&quot;: &quot;A String&quot;, # The Cloud Storage location to upload the result to. Format: `gs://bucket-name`
      &quot;jobState&quot;: &quot;A String&quot;, # Output only. The state of the NotebookExecutionJob.
      &quot;labels&quot;: { # The labels with user-defined metadata to organize NotebookExecutionJobs. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels. System reserved label keys are prefixed with &quot;aiplatform.googleapis.com/&quot; and are immutable.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
      &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of this NotebookExecutionJob. Format: `projects/{project_id}/locations/{location}/notebookExecutionJobs/{job_id}`
      &quot;notebookRuntimeTemplateResourceName&quot;: &quot;A String&quot;, # The NotebookRuntimeTemplate to source compute configuration from.
      &quot;scheduleResourceName&quot;: &quot;A String&quot;, # Output only. The Schedule resource name if this job is triggered by one. Format: `projects/{project_id}/locations/{location}/schedules/{schedule_id}`
      &quot;serviceAccount&quot;: &quot;A String&quot;, # The service account to run the execution as.
      &quot;status&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. Populated when the NotebookExecutionJob is completed. When there is an error during notebook execution, the error details are populated.
        &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
        &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
          {
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
          },
        ],
        &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
      },
      &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this NotebookExecutionJob was most recently updated.
    },
    &quot;notebookExecutionJobId&quot;: &quot;A String&quot;, # Optional. User specified ID for the NotebookExecutionJob.
    &quot;parent&quot;: &quot;A String&quot;, # Required. The resource name of the Location to create the NotebookExecutionJob. Format: `projects/{project}/locations/{location}`
  },
  &quot;createPipelineJobRequest&quot;: { # Request message for PipelineService.CreatePipelineJob. # Request for PipelineService.CreatePipelineJob. CreatePipelineJobRequest.parent field is required (format: projects/{project}/locations/{location}).
    &quot;parent&quot;: &quot;A String&quot;, # Required. The resource name of the Location to create the PipelineJob in. Format: `projects/{project}/locations/{location}`
    &quot;pipelineJob&quot;: { # An instance of a machine learning PipelineJob. # Required. The PipelineJob to create.
      &quot;createTime&quot;: &quot;A String&quot;, # Output only. Pipeline creation time.
      &quot;displayName&quot;: &quot;A String&quot;, # The display name of the Pipeline. The name can be up to 128 characters long and can consist of any UTF-8 characters.
      &quot;encryptionSpec&quot;: { # Represents a customer-managed encryption key spec that can be applied to a top-level resource. # Customer-managed encryption key spec for a pipelineJob. If set, this PipelineJob and all of its sub-resources will be secured by this key.
        &quot;kmsKeyName&quot;: &quot;A String&quot;, # Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
      },
      &quot;endTime&quot;: &quot;A String&quot;, # Output only. Pipeline end time.
      &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. The error that occurred during pipeline execution. Only populated when the pipeline&#x27;s state is FAILED or CANCELLED.
        &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
        &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
          {
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
          },
        ],
        &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
      },
      &quot;jobDetail&quot;: { # The runtime detail of PipelineJob. # Output only. The details of pipeline run. Not available in the list view.
        &quot;pipelineContext&quot;: { # Instance of a general context. # Output only. The context of the pipeline.
          &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Context was created.
          &quot;description&quot;: &quot;A String&quot;, # Description of the Context
          &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Context. May be up to 128 Unicode characters.
          &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
          &quot;labels&quot;: { # The labels with user-defined metadata to organize your Contexts. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Context (System labels are excluded).
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;metadata&quot;: { # Properties of the Context. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;name&quot;: &quot;A String&quot;, # Immutable. The resource name of the Context.
          &quot;parentContexts&quot;: [ # Output only. A list of resource names of Contexts that are parents of this Context. A Context may have at most 10 parent_contexts.
            &quot;A String&quot;,
          ],
          &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
          &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in schema_name to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
          &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Context was last updated.
        },
        &quot;pipelineRunContext&quot;: { # Instance of a general context. # Output only. The context of the current pipeline run.
          &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Context was created.
          &quot;description&quot;: &quot;A String&quot;, # Description of the Context
          &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Context. May be up to 128 Unicode characters.
          &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
          &quot;labels&quot;: { # The labels with user-defined metadata to organize your Contexts. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Context (System labels are excluded).
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;metadata&quot;: { # Properties of the Context. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;name&quot;: &quot;A String&quot;, # Immutable. The resource name of the Context.
          &quot;parentContexts&quot;: [ # Output only. A list of resource names of Contexts that are parents of this Context. A Context may have at most 10 parent_contexts.
            &quot;A String&quot;,
          ],
          &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
          &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in schema_name to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
          &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Context was last updated.
        },
        &quot;taskDetails&quot;: [ # Output only. The runtime details of the tasks under the pipeline.
          { # The runtime detail of a task execution.
            &quot;createTime&quot;: &quot;A String&quot;, # Output only. Task create time.
            &quot;endTime&quot;: &quot;A String&quot;, # Output only. Task end time.
            &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. The error that occurred during task execution. Only populated when the task&#x27;s state is FAILED or CANCELLED.
              &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
              &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
                {
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
                },
              ],
              &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
            },
            &quot;execution&quot;: { # Instance of a general execution. # Output only. The execution metadata of the task.
              &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Execution was created.
              &quot;description&quot;: &quot;A String&quot;, # Description of the Execution
              &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Execution. May be up to 128 Unicode characters.
              &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
              &quot;labels&quot;: { # The labels with user-defined metadata to organize your Executions. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Execution (System labels are excluded).
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;metadata&quot;: { # Properties of the Execution. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the Execution.
              &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
              &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in `schema_title` to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
              &quot;state&quot;: &quot;A String&quot;, # The state of this Execution. This is a property of the Execution, and does not imply or capture any ongoing process. This property is managed by clients (such as Vertex AI Pipelines) and the system does not prescribe or check the validity of state transitions.
              &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Execution was last updated.
            },
            &quot;executorDetail&quot;: { # The runtime detail of a pipeline executor. # Output only. The detailed execution info.
              &quot;containerDetail&quot;: { # The detail of a container execution. It contains the job names of the lifecycle of a container execution. # Output only. The detailed info for a container executor.
                &quot;failedMainJobs&quot;: [ # Output only. The names of the previously failed CustomJob for the main container executions. The list includes the all attempts in chronological order.
                  &quot;A String&quot;,
                ],
                &quot;failedPreCachingCheckJobs&quot;: [ # Output only. The names of the previously failed CustomJob for the pre-caching-check container executions. This job will be available if the PipelineJob.pipeline_spec specifies the `pre_caching_check` hook in the lifecycle events. The list includes the all attempts in chronological order.
                  &quot;A String&quot;,
                ],
                &quot;mainJob&quot;: &quot;A String&quot;, # Output only. The name of the CustomJob for the main container execution.
                &quot;preCachingCheckJob&quot;: &quot;A String&quot;, # Output only. The name of the CustomJob for the pre-caching-check container execution. This job will be available if the PipelineJob.pipeline_spec specifies the `pre_caching_check` hook in the lifecycle events.
              },
              &quot;customJobDetail&quot;: { # The detailed info for a custom job executor. # Output only. The detailed info for a custom job executor.
                &quot;failedJobs&quot;: [ # Output only. The names of the previously failed CustomJob. The list includes the all attempts in chronological order.
                  &quot;A String&quot;,
                ],
                &quot;job&quot;: &quot;A String&quot;, # Output only. The name of the CustomJob.
              },
            },
            &quot;inputs&quot;: { # Output only. The runtime input artifacts of the task.
              &quot;a_key&quot;: { # A list of artifact metadata.
                &quot;artifacts&quot;: [ # Output only. A list of artifact metadata.
                  { # Instance of a general artifact.
                    &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Artifact was created.
                    &quot;description&quot;: &quot;A String&quot;, # Description of the Artifact
                    &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Artifact. May be up to 128 Unicode characters.
                    &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
                    &quot;labels&quot;: { # The labels with user-defined metadata to organize your Artifacts. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Artifact (System labels are excluded).
                      &quot;a_key&quot;: &quot;A String&quot;,
                    },
                    &quot;metadata&quot;: { # Properties of the Artifact. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the Artifact.
                    &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
                    &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in schema_name to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
                    &quot;state&quot;: &quot;A String&quot;, # The state of this Artifact. This is a property of the Artifact, and does not imply or capture any ongoing process. This property is managed by clients (such as Vertex AI Pipelines), and the system does not prescribe or check the validity of state transitions.
                    &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Artifact was last updated.
                    &quot;uri&quot;: &quot;A String&quot;, # The uniform resource identifier of the artifact file. May be empty if there is no actual artifact file.
                  },
                ],
              },
            },
            &quot;outputs&quot;: { # Output only. The runtime output artifacts of the task.
              &quot;a_key&quot;: { # A list of artifact metadata.
                &quot;artifacts&quot;: [ # Output only. A list of artifact metadata.
                  { # Instance of a general artifact.
                    &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Artifact was created.
                    &quot;description&quot;: &quot;A String&quot;, # Description of the Artifact
                    &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Artifact. May be up to 128 Unicode characters.
                    &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
                    &quot;labels&quot;: { # The labels with user-defined metadata to organize your Artifacts. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Artifact (System labels are excluded).
                      &quot;a_key&quot;: &quot;A String&quot;,
                    },
                    &quot;metadata&quot;: { # Properties of the Artifact. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the Artifact.
                    &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
                    &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in schema_name to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
                    &quot;state&quot;: &quot;A String&quot;, # The state of this Artifact. This is a property of the Artifact, and does not imply or capture any ongoing process. This property is managed by clients (such as Vertex AI Pipelines), and the system does not prescribe or check the validity of state transitions.
                    &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Artifact was last updated.
                    &quot;uri&quot;: &quot;A String&quot;, # The uniform resource identifier of the artifact file. May be empty if there is no actual artifact file.
                  },
                ],
              },
            },
            &quot;parentTaskId&quot;: &quot;A String&quot;, # Output only. The id of the parent task if the task is within a component scope. Empty if the task is at the root level.
            &quot;pipelineTaskStatus&quot;: [ # Output only. A list of task status. This field keeps a record of task status evolving over time.
              { # A single record of the task status.
                &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. The error that occurred during the state. May be set when the state is any of the non-final state (PENDING/RUNNING/CANCELLING) or FAILED state. If the state is FAILED, the error here is final and not going to be retried. If the state is a non-final state, the error indicates a system-error being retried.
                  &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
                  &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
                    {
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
                    },
                  ],
                  &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
                },
                &quot;state&quot;: &quot;A String&quot;, # Output only. The state of the task.
                &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Update time of this status.
              },
            ],
            &quot;startTime&quot;: &quot;A String&quot;, # Output only. Task start time.
            &quot;state&quot;: &quot;A String&quot;, # Output only. State of the task.
            &quot;taskId&quot;: &quot;A String&quot;, # Output only. The system generated ID of the task.
            &quot;taskName&quot;: &quot;A String&quot;, # Output only. The user specified name of the task that is defined in pipeline_spec.
          },
        ],
      },
      &quot;labels&quot;: { # The labels with user-defined metadata to organize PipelineJob. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels. Note there is some reserved label key for Vertex AI Pipelines. - `vertex-ai-pipelines-run-billing-id`, user set value will get overrided.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
      &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the PipelineJob.
      &quot;network&quot;: &quot;A String&quot;, # The full name of the Compute Engine [network](/compute/docs/networks-and-firewalls#networks) to which the Pipeline Job&#x27;s workload should be peered. For example, `projects/12345/global/networks/myVPC`. [Format](/compute/docs/reference/rest/v1/networks/insert) is of the form `projects/{project}/global/networks/{network}`. Where {project} is a project number, as in `12345`, and {network} is a network name. Private services access must already be configured for the network. Pipeline job will apply the network configuration to the Google Cloud resources being launched, if applied, such as Vertex AI Training or Dataflow job. If left unspecified, the workload is not peered with any network.
      &quot;pipelineSpec&quot;: { # The spec of the pipeline.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;preflightValidations&quot;: True or False, # Optional. Whether to do component level validations before job creation.
      &quot;reservedIpRanges&quot;: [ # A list of names for the reserved ip ranges under the VPC network that can be used for this Pipeline Job&#x27;s workload. If set, we will deploy the Pipeline Job&#x27;s workload within the provided ip ranges. Otherwise, the job will be deployed to any ip ranges under the provided VPC network. Example: [&#x27;vertex-ai-ip-range&#x27;].
        &quot;A String&quot;,
      ],
      &quot;runtimeConfig&quot;: { # The runtime config of a PipelineJob. # Runtime config of the pipeline.
        &quot;failurePolicy&quot;: &quot;A String&quot;, # Represents the failure policy of a pipeline. Currently, the default of a pipeline is that the pipeline will continue to run until no more tasks can be executed, also known as PIPELINE_FAILURE_POLICY_FAIL_SLOW. However, if a pipeline is set to PIPELINE_FAILURE_POLICY_FAIL_FAST, it will stop scheduling any new tasks when a task has failed. Any scheduled tasks will continue to completion.
        &quot;gcsOutputDirectory&quot;: &quot;A String&quot;, # Required. A path in a Cloud Storage bucket, which will be treated as the root output directory of the pipeline. It is used by the system to generate the paths of output artifacts. The artifact paths are generated with a sub-path pattern `{job_id}/{task_id}/{output_key}` under the specified output directory. The service account specified in this pipeline must have the `storage.objects.get` and `storage.objects.create` permissions for this bucket.
        &quot;inputArtifacts&quot;: { # The runtime artifacts of the PipelineJob. The key will be the input artifact name and the value would be one of the InputArtifact.
          &quot;a_key&quot;: { # The type of an input artifact.
            &quot;artifactId&quot;: &quot;A String&quot;, # Artifact resource id from MLMD. Which is the last portion of an artifact resource name: `projects/{project}/locations/{location}/metadataStores/default/artifacts/{artifact_id}`. The artifact must stay within the same project, location and default metadatastore as the pipeline.
          },
        },
        &quot;parameterValues&quot;: { # The runtime parameters of the PipelineJob. The parameters will be passed into PipelineJob.pipeline_spec to replace the placeholders at runtime. This field is used by pipelines built using `PipelineJob.pipeline_spec.schema_version` 2.1.0, such as pipelines built using Kubeflow Pipelines SDK 1.9 or higher and the v2 DSL.
          &quot;a_key&quot;: &quot;&quot;,
        },
        &quot;parameters&quot;: { # Deprecated. Use RuntimeConfig.parameter_values instead. The runtime parameters of the PipelineJob. The parameters will be passed into PipelineJob.pipeline_spec to replace the placeholders at runtime. This field is used by pipelines built using `PipelineJob.pipeline_spec.schema_version` 2.0.0 or lower, such as pipelines built using Kubeflow Pipelines SDK 1.8 or lower.
          &quot;a_key&quot;: { # Value is the value of the field.
            &quot;doubleValue&quot;: 3.14, # A double value.
            &quot;intValue&quot;: &quot;A String&quot;, # An integer value.
            &quot;stringValue&quot;: &quot;A String&quot;, # A string value.
          },
        },
      },
      &quot;satisfiesPzi&quot;: True or False, # Output only. Reserved for future use.
      &quot;satisfiesPzs&quot;: True or False, # Output only. Reserved for future use.
      &quot;scheduleName&quot;: &quot;A String&quot;, # Output only. The schedule resource name. Only returned if the Pipeline is created by Schedule API.
      &quot;serviceAccount&quot;: &quot;A String&quot;, # The service account that the pipeline workload runs as. If not specified, the Compute Engine default service account in the project will be used. See https://cloud.google.com/compute/docs/access/service-accounts#default_service_account Users starting the pipeline must have the `iam.serviceAccounts.actAs` permission on this service account.
      &quot;startTime&quot;: &quot;A String&quot;, # Output only. Pipeline start time.
      &quot;state&quot;: &quot;A String&quot;, # Output only. The detailed state of the job.
      &quot;templateMetadata&quot;: { # Pipeline template metadata if PipelineJob.template_uri is from supported template registry. Currently, the only supported registry is Artifact Registry. # Output only. Pipeline template metadata. Will fill up fields if PipelineJob.template_uri is from supported template registry.
        &quot;version&quot;: &quot;A String&quot;, # The version_name in artifact registry. Will always be presented in output if the PipelineJob.template_uri is from supported template registry. Format is &quot;sha256:abcdef123456...&quot;.
      },
      &quot;templateUri&quot;: &quot;A String&quot;, # A template uri from where the PipelineJob.pipeline_spec, if empty, will be downloaded. Currently, only uri from Vertex Template Registry &amp; Gallery is supported. Reference to https://cloud.google.com/vertex-ai/docs/pipelines/create-pipeline-template.
      &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this PipelineJob was most recently updated.
    },
    &quot;pipelineJobId&quot;: &quot;A String&quot;, # The ID to use for the PipelineJob, which will become the final component of the PipelineJob name. If not provided, an ID will be automatically generated. This value should be less than 128 characters, and valid characters are `/a-z-/`.
  },
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule was created.
  &quot;cron&quot;: &quot;A String&quot;, # Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: &quot;CRON_TZ=${IANA_TIME_ZONE}&quot; or &quot;TZ=${IANA_TIME_ZONE}&quot;. The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, &quot;CRON_TZ=America/New_York 1 * * * *&quot;, or &quot;TZ=America/New_York 1 * * * *&quot;.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. User provided name of the Schedule. The name can be up to 128 characters long and can consist of any UTF-8 characters.
  &quot;endTime&quot;: &quot;A String&quot;, # Optional. Timestamp after which no new runs can be scheduled. If specified, The schedule will be completed when either end_time is reached or when scheduled_run_count &gt;= max_run_count. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
  &quot;lastPauseTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule was last paused. Unset if never paused.
  &quot;lastResumeTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule was last resumed. Unset if never resumed from pause.
  &quot;lastScheduledRunResponse&quot;: { # Status of a scheduled run. # Output only. Response of the last scheduled run. This is the response for starting the scheduled requests and not the execution of the operations/jobs created by the requests (if applicable). Unset if no run has been scheduled yet.
    &quot;runResponse&quot;: &quot;A String&quot;, # The response of the scheduled run.
    &quot;scheduledRunTime&quot;: &quot;A String&quot;, # The scheduled run time based on the user-specified schedule.
  },
  &quot;maxConcurrentRunCount&quot;: &quot;A String&quot;, # Required. Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the operations/jobs created by the requests (if applicable).
  &quot;maxRunCount&quot;: &quot;A String&quot;, # Optional. Maximum run count of the schedule. If specified, The schedule will be completed when either started_run_count &gt;= max_run_count or when end_time is reached. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
  &quot;name&quot;: &quot;A String&quot;, # Immutable. The resource name of the Schedule.
  &quot;nextRunTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule should schedule the next run. Having a next_run_time in the past means the runs are being started behind schedule.
  &quot;startTime&quot;: &quot;A String&quot;, # Optional. Timestamp after which the first run can be scheduled. Default to Schedule create time if not specified.
  &quot;startedRunCount&quot;: &quot;A String&quot;, # Output only. The number of runs started by this schedule.
  &quot;state&quot;: &quot;A String&quot;, # Output only. The state of this Schedule.
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule was updated.
}

  updateMask: string, Required. The update mask applies to the resource. See google.protobuf.FieldMask.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # An instance of a Schedule periodically schedules runs to make API calls based on user specified time specification and API request type.
  &quot;allowQueueing&quot;: True or False, # Optional. Whether new scheduled runs can be queued when max_concurrent_runs limit is reached. If set to true, new runs will be queued instead of skipped. Default to false.
  &quot;catchUp&quot;: True or False, # Output only. Whether to backfill missed runs when the schedule is resumed from PAUSED state. If set to true, all missed runs will be scheduled. New runs will be scheduled after the backfill is complete. Default to false.
  &quot;createModelMonitoringJobRequest&quot;: { # Request message for ModelMonitoringService.CreateModelMonitoringJob. # Request for ModelMonitoringService.CreateModelMonitoringJob.
    &quot;modelMonitoringJob&quot;: { # Represents a model monitoring job that analyze dataset using different monitoring algorithm. # Required. The ModelMonitoringJob to create
      &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelMonitoringJob was created.
      &quot;displayName&quot;: &quot;A String&quot;, # The display name of the ModelMonitoringJob. The name can be up to 128 characters long and can consist of any UTF-8.
      &quot;jobExecutionDetail&quot;: { # Represent the execution details of the job. # Output only. Execution results for all the monitoring objectives.
        &quot;baselineDatasets&quot;: [ # Processed baseline datasets.
          { # Processed dataset information.
            &quot;location&quot;: &quot;A String&quot;, # Actual data location of the processed dataset.
            &quot;timeRange&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Dataset time range information if any.
              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end.
              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start.
            },
          },
        ],
        &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Additional job error status.
          &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
          &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
            {
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
            },
          ],
          &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
        },
        &quot;objectiveStatus&quot;: { # Status of data processing for each monitoring objective. Key is the objective.
          &quot;a_key&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
            &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
            &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
              {
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
              },
            ],
            &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
          },
        },
        &quot;targetDatasets&quot;: [ # Processed target datasets.
          { # Processed dataset information.
            &quot;location&quot;: &quot;A String&quot;, # Actual data location of the processed dataset.
            &quot;timeRange&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # Dataset time range information if any.
              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end.
              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start.
            },
          },
        ],
      },
      &quot;modelMonitoringSpec&quot;: { # Monitoring monitoring job spec. It outlines the specifications for monitoring objectives, notifications, and result exports. # Monitoring monitoring job spec. It outlines the specifications for monitoring objectives, notifications, and result exports. If left blank, the default monitoring specifications from the top-level resource &#x27;ModelMonitor&#x27; will be applied. If provided, we will use the specification defined here rather than the default one.
        &quot;notificationSpec&quot;: { # Notification spec(email, notification channel) for model monitoring statistics/alerts. # The model monitoring notification spec.
          &quot;emailConfig&quot;: { # The config for email alerts. # Email alert config.
            &quot;userEmails&quot;: [ # The email addresses to send the alerts.
              &quot;A String&quot;,
            ],
          },
          &quot;enableCloudLogging&quot;: True or False, # Dump the anomalies to Cloud Logging. The anomalies will be put to json payload encoded from proto google.cloud.aiplatform.logging.ModelMonitoringAnomaliesLogEntry. This can be further sinked to Pub/Sub or any other services supported by Cloud Logging.
          &quot;notificationChannelConfigs&quot;: [ # Notification channel config.
            { # Google Cloud Notification Channel config.
              &quot;notificationChannel&quot;: &quot;A String&quot;, # Resource names of the NotificationChannels. Must be of the format `projects//notificationChannels/`
            },
          ],
        },
        &quot;objectiveSpec&quot;: { # Monitoring objectives spec. # The monitoring objective spec.
          &quot;baselineDataset&quot;: { # Model monitoring data input spec. # Baseline dataset. It could be the training dataset or production serving dataset from a previous period.
            &quot;batchPredictionOutput&quot;: { # Data from Vertex AI Batch prediction job output. # Vertex AI Batch prediction Job.
              &quot;batchPredictionJob&quot;: &quot;A String&quot;, # Vertex AI Batch prediction job resource name. The job must match the model version specified in [ModelMonitor].[model_monitoring_target].
            },
            &quot;columnizedDataset&quot;: { # Input dataset spec. # Columnized dataset.
              &quot;bigquerySource&quot;: { # Dataset spec for data sotred in BigQuery. # BigQuery data source.
                &quot;query&quot;: &quot;A String&quot;, # Standard SQL to be used instead of the `table_uri`.
                &quot;tableUri&quot;: &quot;A String&quot;, # BigQuery URI to a table, up to 2000 characters long. All the columns in the table will be selected. Accepted forms: * BigQuery path. For example: `bq://projectId.bqDatasetId.bqTableId`.
              },
              &quot;gcsSource&quot;: { # Dataset spec for data stored in Google Cloud Storage. # Google Cloud Storage data source.
                &quot;format&quot;: &quot;A String&quot;, # Data format of the dataset.
                &quot;gcsUri&quot;: &quot;A String&quot;, # Google Cloud Storage URI to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
              },
              &quot;timestampField&quot;: &quot;A String&quot;, # The timestamp field. Usually for serving data.
              &quot;vertexDataset&quot;: &quot;A String&quot;, # Resource name of the Vertex AI managed dataset.
            },
            &quot;timeInterval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # The time interval (pair of start_time and end_time) for which results should be returned.
              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end.
              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start.
            },
            &quot;timeOffset&quot;: { # Time offset setting. # The time offset setting for which results should be returned.
              &quot;offset&quot;: &quot;A String&quot;, # [offset] is the time difference from the cut-off time. For scheduled jobs, the cut-off time is the scheduled time. For non-scheduled jobs, it&#x27;s the time when the job was created. Currently we support the following format: &#x27;w|W&#x27;: Week, &#x27;d|D&#x27;: Day, &#x27;h|H&#x27;: Hour E.g. &#x27;1h&#x27; stands for 1 hour, &#x27;2d&#x27; stands for 2 days.
              &quot;window&quot;: &quot;A String&quot;, # [window] refers to the scope of data selected for analysis. It allows you to specify the quantity of data you wish to examine. Currently we support the following format: &#x27;w|W&#x27;: Week, &#x27;d|D&#x27;: Day, &#x27;h|H&#x27;: Hour E.g. &#x27;1h&#x27; stands for 1 hour, &#x27;2d&#x27; stands for 2 days.
            },
            &quot;vertexEndpointLogs&quot;: { # Data from Vertex AI Endpoint request response logging. # Vertex AI Endpoint request &amp; response logging.
              &quot;endpoints&quot;: [ # List of endpoint resource names. The endpoints must enable the logging with the [Endpoint].[request_response_logging_config], and must contain the deployed model corresponding to the model version specified in [ModelMonitor].[model_monitoring_target].
                &quot;A String&quot;,
              ],
            },
          },
          &quot;explanationSpec&quot;: { # Specification of Model explanation. # The explanation spec. This spec is required when the objectives spec includes feature attribution objectives.
            &quot;metadata&quot;: { # Metadata describing the Model&#x27;s input and output for explanation. # Optional. Metadata describing the Model&#x27;s input and output for explanation.
              &quot;featureAttributionsSchemaUri&quot;: &quot;A String&quot;, # Points to a YAML file stored on Google Cloud Storage describing the format of the feature attributions. The schema is defined as an OpenAPI 3.0.2 [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject). AutoML tabular Models always have this field populated by Vertex AI. Note: The URI given on output may be different, including the URI scheme, than the one given on input. The output URI will point to a location where the user only has a read access.
              &quot;inputs&quot;: { # Required. Map from feature names to feature input metadata. Keys are the name of the features. Values are the specification of the feature. An empty InputMetadata is valid. It describes a text feature which has the name specified as the key in ExplanationMetadata.inputs. The baseline of the empty feature is chosen by Vertex AI. For Vertex AI-provided Tensorflow images, the key can be any friendly name of the feature. Once specified, featureAttributions are keyed by this key (if not grouped with another feature). For custom images, the key must match with the key in instance.
                &quot;a_key&quot;: { # Metadata of the input of a feature. Fields other than InputMetadata.input_baselines are applicable only for Models that are using Vertex AI-provided images for Tensorflow.
                  &quot;denseShapeTensorName&quot;: &quot;A String&quot;, # Specifies the shape of the values of the input if the input is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
                  &quot;encodedBaselines&quot;: [ # A list of baselines for the encoded tensor. The shape of each baseline should match the shape of the encoded tensor. If a scalar is provided, Vertex AI broadcasts to the same shape as the encoded tensor.
                    &quot;&quot;,
                  ],
                  &quot;encodedTensorName&quot;: &quot;A String&quot;, # Encoded tensor is a transformation of the input tensor. Must be provided if choosing Integrated Gradients attribution or XRAI attribution and the input tensor is not differentiable. An encoded tensor is generated if the input tensor is encoded by a lookup table.
                  &quot;encoding&quot;: &quot;A String&quot;, # Defines how the feature is encoded into the input tensor. Defaults to IDENTITY.
                  &quot;featureValueDomain&quot;: { # Domain details of the input feature value. Provides numeric information about the feature, such as its range (min, max). If the feature has been pre-processed, for example with z-scoring, then it provides information about how to recover the original feature. For example, if the input feature is an image and it has been pre-processed to obtain 0-mean and stddev = 1 values, then original_mean, and original_stddev refer to the mean and stddev of the original feature (e.g. image tensor) from which input feature (with mean = 0 and stddev = 1) was obtained. # The domain details of the input feature value. Like min/max, original mean or standard deviation if normalized.
                    &quot;maxValue&quot;: 3.14, # The maximum permissible value for this feature.
                    &quot;minValue&quot;: 3.14, # The minimum permissible value for this feature.
                    &quot;originalMean&quot;: 3.14, # If this input feature has been normalized to a mean value of 0, the original_mean specifies the mean value of the domain prior to normalization.
                    &quot;originalStddev&quot;: 3.14, # If this input feature has been normalized to a standard deviation of 1.0, the original_stddev specifies the standard deviation of the domain prior to normalization.
                  },
                  &quot;groupName&quot;: &quot;A String&quot;, # Name of the group that the input belongs to. Features with the same group name will be treated as one feature when computing attributions. Features grouped together can have different shapes in value. If provided, there will be one single attribution generated in Attribution.feature_attributions, keyed by the group name.
                  &quot;indexFeatureMapping&quot;: [ # A list of feature names for each index in the input tensor. Required when the input InputMetadata.encoding is BAG_OF_FEATURES, BAG_OF_FEATURES_SPARSE, INDICATOR.
                    &quot;A String&quot;,
                  ],
                  &quot;indicesTensorName&quot;: &quot;A String&quot;, # Specifies the index of the values of the input tensor. Required when the input tensor is a sparse representation. Refer to Tensorflow documentation for more details: https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
                  &quot;inputBaselines&quot;: [ # Baseline inputs for this feature. If no baseline is specified, Vertex AI chooses the baseline for this feature. If multiple baselines are specified, Vertex AI returns the average attributions across them in Attribution.feature_attributions. For Vertex AI-provided Tensorflow images (both 1.x and 2.x), the shape of each baseline must match the shape of the input tensor. If a scalar is provided, we broadcast to the same shape as the input tensor. For custom images, the element of the baselines must be in the same format as the feature&#x27;s input in the instance[]. The schema of any single instance may be specified via Endpoint&#x27;s DeployedModels&#x27; Model&#x27;s PredictSchemata&#x27;s instance_schema_uri.
                    &quot;&quot;,
                  ],
                  &quot;inputTensorName&quot;: &quot;A String&quot;, # Name of the input tensor for this feature. Required and is only applicable to Vertex AI-provided images for Tensorflow.
                  &quot;modality&quot;: &quot;A String&quot;, # Modality of the feature. Valid values are: numeric, image. Defaults to numeric.
                  &quot;visualization&quot;: { # Visualization configurations for image explanation. # Visualization configurations for image explanation.
                    &quot;clipPercentLowerbound&quot;: 3.14, # Excludes attributions below the specified percentile, from the highlighted areas. Defaults to 62.
                    &quot;clipPercentUpperbound&quot;: 3.14, # Excludes attributions above the specified percentile from the highlighted areas. Using the clip_percent_upperbound and clip_percent_lowerbound together can be useful for filtering out noise and making it easier to see areas of strong attribution. Defaults to 99.9.
                    &quot;colorMap&quot;: &quot;A String&quot;, # The color scheme used for the highlighted areas. Defaults to PINK_GREEN for Integrated Gradients attribution, which shows positive attributions in green and negative in pink. Defaults to VIRIDIS for XRAI attribution, which highlights the most influential regions in yellow and the least influential in blue.
                    &quot;overlayType&quot;: &quot;A String&quot;, # How the original image is displayed in the visualization. Adjusting the overlay can help increase visual clarity if the original image makes it difficult to view the visualization. Defaults to NONE.
                    &quot;polarity&quot;: &quot;A String&quot;, # Whether to only highlight pixels with positive contributions, negative or both. Defaults to POSITIVE.
                    &quot;type&quot;: &quot;A String&quot;, # Type of the image visualization. Only applicable to Integrated Gradients attribution. OUTLINES shows regions of attribution, while PIXELS shows per-pixel attribution. Defaults to OUTLINES.
                  },
                },
              },
              &quot;latentSpaceSource&quot;: &quot;A String&quot;, # Name of the source to generate embeddings for example based explanations.
              &quot;outputs&quot;: { # Required. Map from output names to output metadata. For Vertex AI-provided Tensorflow images, keys can be any user defined string that consists of any UTF-8 characters. For custom images, keys are the name of the output field in the prediction to be explained. Currently only one key is allowed.
                &quot;a_key&quot;: { # Metadata of the prediction output to be explained.
                  &quot;displayNameMappingKey&quot;: &quot;A String&quot;, # Specify a field name in the prediction to look for the display name. Use this if the prediction contains the display names for the outputs. The display names in the prediction must have the same shape of the outputs, so that it can be located by Attribution.output_index for a specific output.
                  &quot;indexDisplayNameMapping&quot;: &quot;&quot;, # Static mapping between the index and display name. Use this if the outputs are a deterministic n-dimensional array, e.g. a list of scores of all the classes in a pre-defined order for a multi-classification Model. It&#x27;s not feasible if the outputs are non-deterministic, e.g. the Model produces top-k classes or sort the outputs by their values. The shape of the value must be an n-dimensional array of strings. The number of dimensions must match that of the outputs to be explained. The Attribution.output_display_name is populated by locating in the mapping with Attribution.output_index.
                  &quot;outputTensorName&quot;: &quot;A String&quot;, # Name of the output tensor. Required and is only applicable to Vertex AI provided images for Tensorflow.
                },
              },
            },
            &quot;parameters&quot;: { # Parameters to configure explaining for Model&#x27;s predictions. # Required. Parameters that configure explaining of the Model&#x27;s predictions.
              &quot;examples&quot;: { # Example-based explainability that returns the nearest neighbors from the provided dataset. # Example-based explanations that returns the nearest neighbors from the provided dataset.
                &quot;exampleGcsSource&quot;: { # The Cloud Storage input instances. # The Cloud Storage input instances.
                  &quot;dataFormat&quot;: &quot;A String&quot;, # The format in which instances are given, if not specified, assume it&#x27;s JSONL format. Currently only JSONL format is supported.
                  &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage location for the input instances.
                    &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                      &quot;A String&quot;,
                    ],
                  },
                },
                &quot;gcsSource&quot;: { # The Google Cloud Storage location for the input content. # The Cloud Storage locations that contain the instances to be indexed for approximate nearest neighbor search.
                  &quot;uris&quot;: [ # Required. Google Cloud Storage URI(-s) to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
                    &quot;A String&quot;,
                  ],
                },
                &quot;nearestNeighborSearchConfig&quot;: &quot;&quot;, # The full configuration for the generated index, the semantics are the same as metadata and should match [NearestNeighborSearchConfig](https://cloud.google.com/vertex-ai/docs/explainable-ai/configuring-explanations-example-based#nearest-neighbor-search-config).
                &quot;neighborCount&quot;: 42, # The number of neighbors to return when querying for examples.
                &quot;presets&quot;: { # Preset configuration for example-based explanations # Simplified preset configuration, which automatically sets configuration values based on the desired query speed-precision trade-off and modality.
                  &quot;modality&quot;: &quot;A String&quot;, # The modality of the uploaded model, which automatically configures the distance measurement and feature normalization for the underlying example index and queries. If your model does not precisely fit one of these types, it is okay to choose the closest type.
                  &quot;query&quot;: &quot;A String&quot;, # Preset option controlling parameters for speed-precision trade-off when querying for examples. If omitted, defaults to `PRECISE`.
                },
              },
              &quot;integratedGradientsAttribution&quot;: { # An attribution method that computes the Aumann-Shapley value taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365 # An attribution method that computes Aumann-Shapley values taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1703.01365
                &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for IG with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
                  &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
                },
                &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
                  &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
                    &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
                      { # Noise sigma for a single feature.
                        &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                        &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
                      },
                    ],
                  },
                  &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
                  &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
                },
                &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is within the desired error range. Valid range of its value is [1, 100], inclusively.
              },
              &quot;outputIndices&quot;: [ # If populated, only returns attributions that have output_index contained in output_indices. It must be an ndarray of integers, with the same shape of the output it&#x27;s explaining. If not populated, returns attributions for top_k indices of outputs. If neither top_k nor output_indices is populated, returns the argmax index of the outputs. Only applicable to Models that predict multiple outputs (e,g, multi-class Models that predict multiple classes).
                &quot;&quot;,
              ],
              &quot;sampledShapleyAttribution&quot;: { # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. # An attribution method that approximates Shapley values for features that contribute to the label being predicted. A sampling strategy is used to approximate the value rather than considering all subsets of features. Refer to this paper for model details: https://arxiv.org/abs/1306.4265.
                &quot;pathCount&quot;: 42, # Required. The number of feature permutations to consider when approximating the Shapley values. Valid range of its value is [1, 50], inclusively.
              },
              &quot;topK&quot;: 42, # If populated, returns attributions for top K indices of outputs (defaults to 1). Only applies to Models that predicts more than one outputs (e,g, multi-class Models). When set to -1, returns explanations for all outputs.
              &quot;xraiAttribution&quot;: { # An explanation method that redistributes Integrated Gradients attributions to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 Supported only by image Models. # An attribution method that redistributes Integrated Gradients attribution to segmented regions, taking advantage of the model&#x27;s fully differentiable structure. Refer to this paper for more details: https://arxiv.org/abs/1906.02825 XRAI currently performs better on natural images, like a picture of a house or an animal. If the images are taken in artificial environments, like a lab or manufacturing line, or from diagnostic equipment, like x-rays or quality-control cameras, use Integrated Gradients instead.
                &quot;blurBaselineConfig&quot;: { # Config for blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383 # Config for XRAI with blur baseline. When enabled, a linear path from the maximally blurred image to the input image is created. Using a blurred baseline instead of zero (black image) is motivated by the BlurIG approach explained here: https://arxiv.org/abs/2004.03383
                  &quot;maxBlurSigma&quot;: 3.14, # The standard deviation of the blur kernel for the blurred baseline. The same blurring parameter is used for both the height and the width dimension. If not set, the method defaults to the zero (i.e. black for images) baseline.
                },
                &quot;smoothGradConfig&quot;: { # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf # Config for SmoothGrad approximation of gradients. When enabled, the gradients are approximated by averaging the gradients from noisy samples in the vicinity of the inputs. Adding noise can help improve the computed gradients. Refer to this paper for more details: https://arxiv.org/pdf/1706.03825.pdf
                  &quot;featureNoiseSigma&quot;: { # Noise sigma by features. Noise sigma represents the standard deviation of the gaussian kernel that will be used to add noise to interpolated inputs prior to computing gradients. # This is similar to noise_sigma, but provides additional flexibility. A separate noise sigma can be provided for each feature, which is useful if their distributions are different. No noise is added to features that are not set. If this field is unset, noise_sigma will be used for all features.
                    &quot;noiseSigma&quot;: [ # Noise sigma per feature. No noise is added to features that are not set.
                      { # Noise sigma for a single feature.
                        &quot;name&quot;: &quot;A String&quot;, # The name of the input feature for which noise sigma is provided. The features are defined in explanation metadata inputs.
                        &quot;sigma&quot;: 3.14, # This represents the standard deviation of the Gaussian kernel that will be used to add noise to the feature prior to computing gradients. Similar to noise_sigma but represents the noise added to the current feature. Defaults to 0.1.
                      },
                    ],
                  },
                  &quot;noiseSigma&quot;: 3.14, # This is a single float value and will be used to add noise to all the features. Use this field when all features are normalized to have the same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where features are normalized to have 0-mean and 1-variance. Learn more about [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization). For best results the recommended value is about 10% - 20% of the standard deviation of the input feature. Refer to section 3.2 of the SmoothGrad paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the distribution is different per feature, set feature_noise_sigma instead for each feature.
                  &quot;noisySampleCount&quot;: 42, # The number of gradient samples to use for approximation. The higher this number, the more accurate the gradient is, but the runtime complexity increases by this factor as well. Valid range of its value is [1, 50]. Defaults to 3.
                },
                &quot;stepCount&quot;: 42, # Required. The number of steps for approximating the path integral. A good value to start is 50 and gradually increase until the sum to diff property is met within the desired error range. Valid range of its value is [1, 100], inclusively.
              },
            },
          },
          &quot;tabularObjective&quot;: { # Tabular monitoring objective. # Tabular monitoring objective.
            &quot;featureAttributionSpec&quot;: { # Feature attribution monitoring spec. # Feature attribution monitoring spec.
              &quot;batchExplanationDedicatedResources&quot;: { # A description of resources that are used for performing batch operations, are dedicated to a Model, and need manual configuration. # The config of resources used by the Model Monitoring during the batch explanation for non-AutoML models. If not set, `n1-standard-2` machine type will be used by default.
                &quot;machineSpec&quot;: { # Specification of a single machine. # Required. Immutable. The specification of a single machine.
                  &quot;acceleratorCount&quot;: 42, # The number of accelerators to attach to the machine.
                  &quot;acceleratorType&quot;: &quot;A String&quot;, # Immutable. The type of accelerator(s) that may be attached to the machine as per accelerator_count.
                  &quot;machineType&quot;: &quot;A String&quot;, # Immutable. The type of the machine. See the [list of machine types supported for prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types) See the [list of machine types supported for custom training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types). For DeployedModel this field is optional, and the default value is `n1-standard-2`. For BatchPredictionJob or as part of WorkerPoolSpec this field is required.
                  &quot;reservationAffinity&quot;: { # A ReservationAffinity can be used to configure a Vertex AI resource (e.g., a DeployedModel) to draw its Compute Engine resources from a Shared Reservation, or exclusively from on-demand capacity. # Optional. Immutable. Configuration controlling how this resource pool consumes reservation.
                    &quot;key&quot;: &quot;A String&quot;, # Optional. Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, use `compute.googleapis.com/reservation-name` as the key and specify the name of your reservation as its value.
                    &quot;reservationAffinityType&quot;: &quot;A String&quot;, # Required. Specifies the reservation affinity type.
                    &quot;values&quot;: [ # Optional. Corresponds to the label values of a reservation resource. This must be the full resource name of the reservation.
                      &quot;A String&quot;,
                    ],
                  },
                  &quot;tpuTopology&quot;: &quot;A String&quot;, # Immutable. The topology of the TPUs. Corresponds to the TPU topologies available from GKE. (Example: tpu_topology: &quot;2x2x1&quot;).
                },
                &quot;maxReplicaCount&quot;: 42, # Immutable. The maximum number of machine replicas the batch operation may be scaled to. The default value is 10.
                &quot;startingReplicaCount&quot;: 42, # Immutable. The number of machine replicas used at the start of the batch operation. If not set, Vertex AI decides starting number, not greater than max_replica_count
              },
              &quot;defaultAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the features.
                &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
              },
              &quot;featureAlertConditions&quot;: { # Per feature alert condition will override default alert condition.
                &quot;a_key&quot;: { # Monitoring alert triggered condition.
                  &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
                },
              },
              &quot;features&quot;: [ # Feature names interested in monitoring. These should be a subset of the input feature names specified in the monitoring schema. If the field is not specified all features outlied in the monitoring schema will be used.
                &quot;A String&quot;,
              ],
            },
            &quot;featureDriftSpec&quot;: { # Data drift monitoring spec. Data drift measures the distribution distance between the current dataset and a baseline dataset. A typical use case is to detect data drift between the recent production serving dataset and the training dataset, or to compare the recent production dataset with a dataset from a previous period. # Input feature distribution drift monitoring spec.
              &quot;categoricalMetricType&quot;: &quot;A String&quot;, # Supported metrics type: * l_infinity * jensen_shannon_divergence
              &quot;defaultCategoricalAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the categorical features.
                &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
              },
              &quot;defaultNumericAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the numeric features.
                &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
              },
              &quot;featureAlertConditions&quot;: { # Per feature alert condition will override default alert condition.
                &quot;a_key&quot;: { # Monitoring alert triggered condition.
                  &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
                },
              },
              &quot;features&quot;: [ # Feature names / Prediction output names interested in monitoring. These should be a subset of the input feature names or prediction output names specified in the monitoring schema. If the field is not specified all features / prediction outputs outlied in the monitoring schema will be used.
                &quot;A String&quot;,
              ],
              &quot;numericMetricType&quot;: &quot;A String&quot;, # Supported metrics type: * jensen_shannon_divergence
            },
            &quot;predictionOutputDriftSpec&quot;: { # Data drift monitoring spec. Data drift measures the distribution distance between the current dataset and a baseline dataset. A typical use case is to detect data drift between the recent production serving dataset and the training dataset, or to compare the recent production dataset with a dataset from a previous period. # Prediction output distribution drift monitoring spec.
              &quot;categoricalMetricType&quot;: &quot;A String&quot;, # Supported metrics type: * l_infinity * jensen_shannon_divergence
              &quot;defaultCategoricalAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the categorical features.
                &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
              },
              &quot;defaultNumericAlertCondition&quot;: { # Monitoring alert triggered condition. # Default alert condition for all the numeric features.
                &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
              },
              &quot;featureAlertConditions&quot;: { # Per feature alert condition will override default alert condition.
                &quot;a_key&quot;: { # Monitoring alert triggered condition.
                  &quot;threshold&quot;: 3.14, # A condition that compares a stats value against a threshold. Alert will be triggered if value above the threshold.
                },
              },
              &quot;features&quot;: [ # Feature names / Prediction output names interested in monitoring. These should be a subset of the input feature names or prediction output names specified in the monitoring schema. If the field is not specified all features / prediction outputs outlied in the monitoring schema will be used.
                &quot;A String&quot;,
              ],
              &quot;numericMetricType&quot;: &quot;A String&quot;, # Supported metrics type: * jensen_shannon_divergence
            },
          },
          &quot;targetDataset&quot;: { # Model monitoring data input spec. # Target dataset.
            &quot;batchPredictionOutput&quot;: { # Data from Vertex AI Batch prediction job output. # Vertex AI Batch prediction Job.
              &quot;batchPredictionJob&quot;: &quot;A String&quot;, # Vertex AI Batch prediction job resource name. The job must match the model version specified in [ModelMonitor].[model_monitoring_target].
            },
            &quot;columnizedDataset&quot;: { # Input dataset spec. # Columnized dataset.
              &quot;bigquerySource&quot;: { # Dataset spec for data sotred in BigQuery. # BigQuery data source.
                &quot;query&quot;: &quot;A String&quot;, # Standard SQL to be used instead of the `table_uri`.
                &quot;tableUri&quot;: &quot;A String&quot;, # BigQuery URI to a table, up to 2000 characters long. All the columns in the table will be selected. Accepted forms: * BigQuery path. For example: `bq://projectId.bqDatasetId.bqTableId`.
              },
              &quot;gcsSource&quot;: { # Dataset spec for data stored in Google Cloud Storage. # Google Cloud Storage data source.
                &quot;format&quot;: &quot;A String&quot;, # Data format of the dataset.
                &quot;gcsUri&quot;: &quot;A String&quot;, # Google Cloud Storage URI to the input file(s). May contain wildcards. For more information on wildcards, see https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
              },
              &quot;timestampField&quot;: &quot;A String&quot;, # The timestamp field. Usually for serving data.
              &quot;vertexDataset&quot;: &quot;A String&quot;, # Resource name of the Vertex AI managed dataset.
            },
            &quot;timeInterval&quot;: { # Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time. # The time interval (pair of start_time and end_time) for which results should be returned.
              &quot;endTime&quot;: &quot;A String&quot;, # Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end.
              &quot;startTime&quot;: &quot;A String&quot;, # Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start.
            },
            &quot;timeOffset&quot;: { # Time offset setting. # The time offset setting for which results should be returned.
              &quot;offset&quot;: &quot;A String&quot;, # [offset] is the time difference from the cut-off time. For scheduled jobs, the cut-off time is the scheduled time. For non-scheduled jobs, it&#x27;s the time when the job was created. Currently we support the following format: &#x27;w|W&#x27;: Week, &#x27;d|D&#x27;: Day, &#x27;h|H&#x27;: Hour E.g. &#x27;1h&#x27; stands for 1 hour, &#x27;2d&#x27; stands for 2 days.
              &quot;window&quot;: &quot;A String&quot;, # [window] refers to the scope of data selected for analysis. It allows you to specify the quantity of data you wish to examine. Currently we support the following format: &#x27;w|W&#x27;: Week, &#x27;d|D&#x27;: Day, &#x27;h|H&#x27;: Hour E.g. &#x27;1h&#x27; stands for 1 hour, &#x27;2d&#x27; stands for 2 days.
            },
            &quot;vertexEndpointLogs&quot;: { # Data from Vertex AI Endpoint request response logging. # Vertex AI Endpoint request &amp; response logging.
              &quot;endpoints&quot;: [ # List of endpoint resource names. The endpoints must enable the logging with the [Endpoint].[request_response_logging_config], and must contain the deployed model corresponding to the model version specified in [ModelMonitor].[model_monitoring_target].
                &quot;A String&quot;,
              ],
            },
          },
        },
        &quot;outputSpec&quot;: { # Specification for the export destination of monitoring results, including metrics, logs, etc. # The Output destination spec for metrics, error logs, etc.
          &quot;gcsBaseDirectory&quot;: { # The Google Cloud Storage location where the output is to be written to. # Google Cloud Storage base folder path for metrics, error logs, etc.
            &quot;outputUriPrefix&quot;: &quot;A String&quot;, # Required. Google Cloud Storage URI to output directory. If the uri doesn&#x27;t end with &#x27;/&#x27;, a &#x27;/&#x27; will be automatically appended. The directory is created if it doesn&#x27;t exist.
          },
        },
      },
      &quot;name&quot;: &quot;A String&quot;, # Output only. Resource name of a ModelMonitoringJob. Format: `projects/{project_id}/locations/{location_id}/modelMonitors/{model_monitor_id}/modelMonitoringJobs/{model_monitoring_job_id}`
      &quot;schedule&quot;: &quot;A String&quot;, # Output only. Schedule resource name. It will only appear when this job is triggered by a schedule.
      &quot;scheduleTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelMonitoringJob was scheduled. It will only appear when this job is triggered by a schedule.
      &quot;state&quot;: &quot;A String&quot;, # Output only. The state of the monitoring job. * When the job is still creating, the state will be &#x27;JOB_STATE_PENDING&#x27;. * Once the job is successfully created, the state will be &#x27;JOB_STATE_RUNNING&#x27;. * Once the job is finished, the state will be one of &#x27;JOB_STATE_FAILED&#x27;, &#x27;JOB_STATE_SUCCEEDED&#x27;, &#x27;JOB_STATE_PARTIALLY_SUCCEEDED&#x27;.
      &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this ModelMonitoringJob was updated most recently.
    },
    &quot;modelMonitoringJobId&quot;: &quot;A String&quot;, # Optional. The ID to use for the Model Monitoring Job, which will become the final component of the model monitoring job resource name. The maximum length is 63 characters, and valid characters are `/^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$/`.
    &quot;parent&quot;: &quot;A String&quot;, # Required. The parent of the ModelMonitoringJob. Format: `projects/{project}/locations/{location}/modelMoniitors/{model_monitor}`
  },
  &quot;createNotebookExecutionJobRequest&quot;: { # Request message for [NotebookService.CreateNotebookExecutionJob] # Request for NotebookService.CreateNotebookExecutionJob.
    &quot;notebookExecutionJob&quot;: { # NotebookExecutionJob represents an instance of a notebook execution. # Required. The NotebookExecutionJob to create.
      &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this NotebookExecutionJob was created.
      &quot;dataformRepositorySource&quot;: { # The Dataform Repository containing the input notebook. # The Dataform Repository pointing to a single file notebook repository.
        &quot;commitSha&quot;: &quot;A String&quot;, # The commit SHA to read repository with. If unset, the file will be read at HEAD.
        &quot;dataformRepositoryResourceName&quot;: &quot;A String&quot;, # The resource name of the Dataform Repository. Format: `projects/{project_id}/locations/{location}/repositories/{repository_id}`
      },
      &quot;directNotebookSource&quot;: { # The content of the input notebook in ipynb format. # The contents of an input notebook file.
        &quot;content&quot;: &quot;A String&quot;, # The base64-encoded contents of the input notebook file.
      },
      &quot;displayName&quot;: &quot;A String&quot;, # The display name of the NotebookExecutionJob. The name can be up to 128 characters long and can consist of any UTF-8 characters.
      &quot;encryptionSpec&quot;: { # Represents a customer-managed encryption key spec that can be applied to a top-level resource. # Customer-managed encryption key spec for the notebook execution job. This field is auto-populated if the NotebookRuntimeTemplate has an encryption spec.
        &quot;kmsKeyName&quot;: &quot;A String&quot;, # Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
      },
      &quot;executionTimeout&quot;: &quot;A String&quot;, # Max running time of the execution job in seconds (default 86400s / 24 hrs).
      &quot;executionUser&quot;: &quot;A String&quot;, # The user email to run the execution as. Only supported by Colab runtimes.
      &quot;gcsNotebookSource&quot;: { # The Cloud Storage uri for the input notebook. # The Cloud Storage url pointing to the ipynb file. Format: `gs://bucket/notebook_file.ipynb`
        &quot;generation&quot;: &quot;A String&quot;, # The version of the Cloud Storage object to read. If unset, the current version of the object is read. See https://cloud.google.com/storage/docs/metadata#generation-number.
        &quot;uri&quot;: &quot;A String&quot;, # The Cloud Storage uri pointing to the ipynb file. Format: `gs://bucket/notebook_file.ipynb`
      },
      &quot;gcsOutputUri&quot;: &quot;A String&quot;, # The Cloud Storage location to upload the result to. Format: `gs://bucket-name`
      &quot;jobState&quot;: &quot;A String&quot;, # Output only. The state of the NotebookExecutionJob.
      &quot;labels&quot;: { # The labels with user-defined metadata to organize NotebookExecutionJobs. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels. System reserved label keys are prefixed with &quot;aiplatform.googleapis.com/&quot; and are immutable.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
      &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of this NotebookExecutionJob. Format: `projects/{project_id}/locations/{location}/notebookExecutionJobs/{job_id}`
      &quot;notebookRuntimeTemplateResourceName&quot;: &quot;A String&quot;, # The NotebookRuntimeTemplate to source compute configuration from.
      &quot;scheduleResourceName&quot;: &quot;A String&quot;, # Output only. The Schedule resource name if this job is triggered by one. Format: `projects/{project_id}/locations/{location}/schedules/{schedule_id}`
      &quot;serviceAccount&quot;: &quot;A String&quot;, # The service account to run the execution as.
      &quot;status&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. Populated when the NotebookExecutionJob is completed. When there is an error during notebook execution, the error details are populated.
        &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
        &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
          {
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
          },
        ],
        &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
      },
      &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this NotebookExecutionJob was most recently updated.
    },
    &quot;notebookExecutionJobId&quot;: &quot;A String&quot;, # Optional. User specified ID for the NotebookExecutionJob.
    &quot;parent&quot;: &quot;A String&quot;, # Required. The resource name of the Location to create the NotebookExecutionJob. Format: `projects/{project}/locations/{location}`
  },
  &quot;createPipelineJobRequest&quot;: { # Request message for PipelineService.CreatePipelineJob. # Request for PipelineService.CreatePipelineJob. CreatePipelineJobRequest.parent field is required (format: projects/{project}/locations/{location}).
    &quot;parent&quot;: &quot;A String&quot;, # Required. The resource name of the Location to create the PipelineJob in. Format: `projects/{project}/locations/{location}`
    &quot;pipelineJob&quot;: { # An instance of a machine learning PipelineJob. # Required. The PipelineJob to create.
      &quot;createTime&quot;: &quot;A String&quot;, # Output only. Pipeline creation time.
      &quot;displayName&quot;: &quot;A String&quot;, # The display name of the Pipeline. The name can be up to 128 characters long and can consist of any UTF-8 characters.
      &quot;encryptionSpec&quot;: { # Represents a customer-managed encryption key spec that can be applied to a top-level resource. # Customer-managed encryption key spec for a pipelineJob. If set, this PipelineJob and all of its sub-resources will be secured by this key.
        &quot;kmsKeyName&quot;: &quot;A String&quot;, # Required. The Cloud KMS resource identifier of the customer managed encryption key used to protect a resource. Has the form: `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`. The key needs to be in the same region as where the compute resource is created.
      },
      &quot;endTime&quot;: &quot;A String&quot;, # Output only. Pipeline end time.
      &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. The error that occurred during pipeline execution. Only populated when the pipeline&#x27;s state is FAILED or CANCELLED.
        &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
        &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
          {
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
          },
        ],
        &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
      },
      &quot;jobDetail&quot;: { # The runtime detail of PipelineJob. # Output only. The details of pipeline run. Not available in the list view.
        &quot;pipelineContext&quot;: { # Instance of a general context. # Output only. The context of the pipeline.
          &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Context was created.
          &quot;description&quot;: &quot;A String&quot;, # Description of the Context
          &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Context. May be up to 128 Unicode characters.
          &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
          &quot;labels&quot;: { # The labels with user-defined metadata to organize your Contexts. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Context (System labels are excluded).
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;metadata&quot;: { # Properties of the Context. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;name&quot;: &quot;A String&quot;, # Immutable. The resource name of the Context.
          &quot;parentContexts&quot;: [ # Output only. A list of resource names of Contexts that are parents of this Context. A Context may have at most 10 parent_contexts.
            &quot;A String&quot;,
          ],
          &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
          &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in schema_name to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
          &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Context was last updated.
        },
        &quot;pipelineRunContext&quot;: { # Instance of a general context. # Output only. The context of the current pipeline run.
          &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Context was created.
          &quot;description&quot;: &quot;A String&quot;, # Description of the Context
          &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Context. May be up to 128 Unicode characters.
          &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
          &quot;labels&quot;: { # The labels with user-defined metadata to organize your Contexts. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Context (System labels are excluded).
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;metadata&quot;: { # Properties of the Context. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;name&quot;: &quot;A String&quot;, # Immutable. The resource name of the Context.
          &quot;parentContexts&quot;: [ # Output only. A list of resource names of Contexts that are parents of this Context. A Context may have at most 10 parent_contexts.
            &quot;A String&quot;,
          ],
          &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
          &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in schema_name to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
          &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Context was last updated.
        },
        &quot;taskDetails&quot;: [ # Output only. The runtime details of the tasks under the pipeline.
          { # The runtime detail of a task execution.
            &quot;createTime&quot;: &quot;A String&quot;, # Output only. Task create time.
            &quot;endTime&quot;: &quot;A String&quot;, # Output only. Task end time.
            &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. The error that occurred during task execution. Only populated when the task&#x27;s state is FAILED or CANCELLED.
              &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
              &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
                {
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
                },
              ],
              &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
            },
            &quot;execution&quot;: { # Instance of a general execution. # Output only. The execution metadata of the task.
              &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Execution was created.
              &quot;description&quot;: &quot;A String&quot;, # Description of the Execution
              &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Execution. May be up to 128 Unicode characters.
              &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
              &quot;labels&quot;: { # The labels with user-defined metadata to organize your Executions. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Execution (System labels are excluded).
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;metadata&quot;: { # Properties of the Execution. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the Execution.
              &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
              &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in `schema_title` to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
              &quot;state&quot;: &quot;A String&quot;, # The state of this Execution. This is a property of the Execution, and does not imply or capture any ongoing process. This property is managed by clients (such as Vertex AI Pipelines) and the system does not prescribe or check the validity of state transitions.
              &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Execution was last updated.
            },
            &quot;executorDetail&quot;: { # The runtime detail of a pipeline executor. # Output only. The detailed execution info.
              &quot;containerDetail&quot;: { # The detail of a container execution. It contains the job names of the lifecycle of a container execution. # Output only. The detailed info for a container executor.
                &quot;failedMainJobs&quot;: [ # Output only. The names of the previously failed CustomJob for the main container executions. The list includes the all attempts in chronological order.
                  &quot;A String&quot;,
                ],
                &quot;failedPreCachingCheckJobs&quot;: [ # Output only. The names of the previously failed CustomJob for the pre-caching-check container executions. This job will be available if the PipelineJob.pipeline_spec specifies the `pre_caching_check` hook in the lifecycle events. The list includes the all attempts in chronological order.
                  &quot;A String&quot;,
                ],
                &quot;mainJob&quot;: &quot;A String&quot;, # Output only. The name of the CustomJob for the main container execution.
                &quot;preCachingCheckJob&quot;: &quot;A String&quot;, # Output only. The name of the CustomJob for the pre-caching-check container execution. This job will be available if the PipelineJob.pipeline_spec specifies the `pre_caching_check` hook in the lifecycle events.
              },
              &quot;customJobDetail&quot;: { # The detailed info for a custom job executor. # Output only. The detailed info for a custom job executor.
                &quot;failedJobs&quot;: [ # Output only. The names of the previously failed CustomJob. The list includes the all attempts in chronological order.
                  &quot;A String&quot;,
                ],
                &quot;job&quot;: &quot;A String&quot;, # Output only. The name of the CustomJob.
              },
            },
            &quot;inputs&quot;: { # Output only. The runtime input artifacts of the task.
              &quot;a_key&quot;: { # A list of artifact metadata.
                &quot;artifacts&quot;: [ # Output only. A list of artifact metadata.
                  { # Instance of a general artifact.
                    &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Artifact was created.
                    &quot;description&quot;: &quot;A String&quot;, # Description of the Artifact
                    &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Artifact. May be up to 128 Unicode characters.
                    &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
                    &quot;labels&quot;: { # The labels with user-defined metadata to organize your Artifacts. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Artifact (System labels are excluded).
                      &quot;a_key&quot;: &quot;A String&quot;,
                    },
                    &quot;metadata&quot;: { # Properties of the Artifact. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the Artifact.
                    &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
                    &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in schema_name to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
                    &quot;state&quot;: &quot;A String&quot;, # The state of this Artifact. This is a property of the Artifact, and does not imply or capture any ongoing process. This property is managed by clients (such as Vertex AI Pipelines), and the system does not prescribe or check the validity of state transitions.
                    &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Artifact was last updated.
                    &quot;uri&quot;: &quot;A String&quot;, # The uniform resource identifier of the artifact file. May be empty if there is no actual artifact file.
                  },
                ],
              },
            },
            &quot;outputs&quot;: { # Output only. The runtime output artifacts of the task.
              &quot;a_key&quot;: { # A list of artifact metadata.
                &quot;artifacts&quot;: [ # Output only. A list of artifact metadata.
                  { # Instance of a general artifact.
                    &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Artifact was created.
                    &quot;description&quot;: &quot;A String&quot;, # Description of the Artifact
                    &quot;displayName&quot;: &quot;A String&quot;, # User provided display name of the Artifact. May be up to 128 Unicode characters.
                    &quot;etag&quot;: &quot;A String&quot;, # An eTag used to perform consistent read-modify-write updates. If not set, a blind &quot;overwrite&quot; update happens.
                    &quot;labels&quot;: { # The labels with user-defined metadata to organize your Artifacts. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. No more than 64 user labels can be associated with one Artifact (System labels are excluded).
                      &quot;a_key&quot;: &quot;A String&quot;,
                    },
                    &quot;metadata&quot;: { # Properties of the Artifact. Top level metadata keys&#x27; heading and trailing spaces will be trimmed. The size of this field should not exceed 200KB.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the Artifact.
                    &quot;schemaTitle&quot;: &quot;A String&quot;, # The title of the schema describing the metadata. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
                    &quot;schemaVersion&quot;: &quot;A String&quot;, # The version of the schema in schema_name to use. Schema title and version is expected to be registered in earlier Create Schema calls. And both are used together as unique identifiers to identify schemas within the local metadata store.
                    &quot;state&quot;: &quot;A String&quot;, # The state of this Artifact. This is a property of the Artifact, and does not imply or capture any ongoing process. This property is managed by clients (such as Vertex AI Pipelines), and the system does not prescribe or check the validity of state transitions.
                    &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Artifact was last updated.
                    &quot;uri&quot;: &quot;A String&quot;, # The uniform resource identifier of the artifact file. May be empty if there is no actual artifact file.
                  },
                ],
              },
            },
            &quot;parentTaskId&quot;: &quot;A String&quot;, # Output only. The id of the parent task if the task is within a component scope. Empty if the task is at the root level.
            &quot;pipelineTaskStatus&quot;: [ # Output only. A list of task status. This field keeps a record of task status evolving over time.
              { # A single record of the task status.
                &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Output only. The error that occurred during the state. May be set when the state is any of the non-final state (PENDING/RUNNING/CANCELLING) or FAILED state. If the state is FAILED, the error here is final and not going to be retried. If the state is a non-final state, the error indicates a system-error being retried.
                  &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
                  &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
                    {
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
                    },
                  ],
                  &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
                },
                &quot;state&quot;: &quot;A String&quot;, # Output only. The state of the task.
                &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Update time of this status.
              },
            ],
            &quot;startTime&quot;: &quot;A String&quot;, # Output only. Task start time.
            &quot;state&quot;: &quot;A String&quot;, # Output only. State of the task.
            &quot;taskId&quot;: &quot;A String&quot;, # Output only. The system generated ID of the task.
            &quot;taskName&quot;: &quot;A String&quot;, # Output only. The user specified name of the task that is defined in pipeline_spec.
          },
        ],
      },
      &quot;labels&quot;: { # The labels with user-defined metadata to organize PipelineJob. Label keys and values can be no longer than 64 characters (Unicode codepoints), can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. See https://goo.gl/xmQnxf for more information and examples of labels. Note there is some reserved label key for Vertex AI Pipelines. - `vertex-ai-pipelines-run-billing-id`, user set value will get overrided.
        &quot;a_key&quot;: &quot;A String&quot;,
      },
      &quot;name&quot;: &quot;A String&quot;, # Output only. The resource name of the PipelineJob.
      &quot;network&quot;: &quot;A String&quot;, # The full name of the Compute Engine [network](/compute/docs/networks-and-firewalls#networks) to which the Pipeline Job&#x27;s workload should be peered. For example, `projects/12345/global/networks/myVPC`. [Format](/compute/docs/reference/rest/v1/networks/insert) is of the form `projects/{project}/global/networks/{network}`. Where {project} is a project number, as in `12345`, and {network} is a network name. Private services access must already be configured for the network. Pipeline job will apply the network configuration to the Google Cloud resources being launched, if applied, such as Vertex AI Training or Dataflow job. If left unspecified, the workload is not peered with any network.
      &quot;pipelineSpec&quot;: { # The spec of the pipeline.
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
      },
      &quot;preflightValidations&quot;: True or False, # Optional. Whether to do component level validations before job creation.
      &quot;reservedIpRanges&quot;: [ # A list of names for the reserved ip ranges under the VPC network that can be used for this Pipeline Job&#x27;s workload. If set, we will deploy the Pipeline Job&#x27;s workload within the provided ip ranges. Otherwise, the job will be deployed to any ip ranges under the provided VPC network. Example: [&#x27;vertex-ai-ip-range&#x27;].
        &quot;A String&quot;,
      ],
      &quot;runtimeConfig&quot;: { # The runtime config of a PipelineJob. # Runtime config of the pipeline.
        &quot;failurePolicy&quot;: &quot;A String&quot;, # Represents the failure policy of a pipeline. Currently, the default of a pipeline is that the pipeline will continue to run until no more tasks can be executed, also known as PIPELINE_FAILURE_POLICY_FAIL_SLOW. However, if a pipeline is set to PIPELINE_FAILURE_POLICY_FAIL_FAST, it will stop scheduling any new tasks when a task has failed. Any scheduled tasks will continue to completion.
        &quot;gcsOutputDirectory&quot;: &quot;A String&quot;, # Required. A path in a Cloud Storage bucket, which will be treated as the root output directory of the pipeline. It is used by the system to generate the paths of output artifacts. The artifact paths are generated with a sub-path pattern `{job_id}/{task_id}/{output_key}` under the specified output directory. The service account specified in this pipeline must have the `storage.objects.get` and `storage.objects.create` permissions for this bucket.
        &quot;inputArtifacts&quot;: { # The runtime artifacts of the PipelineJob. The key will be the input artifact name and the value would be one of the InputArtifact.
          &quot;a_key&quot;: { # The type of an input artifact.
            &quot;artifactId&quot;: &quot;A String&quot;, # Artifact resource id from MLMD. Which is the last portion of an artifact resource name: `projects/{project}/locations/{location}/metadataStores/default/artifacts/{artifact_id}`. The artifact must stay within the same project, location and default metadatastore as the pipeline.
          },
        },
        &quot;parameterValues&quot;: { # The runtime parameters of the PipelineJob. The parameters will be passed into PipelineJob.pipeline_spec to replace the placeholders at runtime. This field is used by pipelines built using `PipelineJob.pipeline_spec.schema_version` 2.1.0, such as pipelines built using Kubeflow Pipelines SDK 1.9 or higher and the v2 DSL.
          &quot;a_key&quot;: &quot;&quot;,
        },
        &quot;parameters&quot;: { # Deprecated. Use RuntimeConfig.parameter_values instead. The runtime parameters of the PipelineJob. The parameters will be passed into PipelineJob.pipeline_spec to replace the placeholders at runtime. This field is used by pipelines built using `PipelineJob.pipeline_spec.schema_version` 2.0.0 or lower, such as pipelines built using Kubeflow Pipelines SDK 1.8 or lower.
          &quot;a_key&quot;: { # Value is the value of the field.
            &quot;doubleValue&quot;: 3.14, # A double value.
            &quot;intValue&quot;: &quot;A String&quot;, # An integer value.
            &quot;stringValue&quot;: &quot;A String&quot;, # A string value.
          },
        },
      },
      &quot;satisfiesPzi&quot;: True or False, # Output only. Reserved for future use.
      &quot;satisfiesPzs&quot;: True or False, # Output only. Reserved for future use.
      &quot;scheduleName&quot;: &quot;A String&quot;, # Output only. The schedule resource name. Only returned if the Pipeline is created by Schedule API.
      &quot;serviceAccount&quot;: &quot;A String&quot;, # The service account that the pipeline workload runs as. If not specified, the Compute Engine default service account in the project will be used. See https://cloud.google.com/compute/docs/access/service-accounts#default_service_account Users starting the pipeline must have the `iam.serviceAccounts.actAs` permission on this service account.
      &quot;startTime&quot;: &quot;A String&quot;, # Output only. Pipeline start time.
      &quot;state&quot;: &quot;A String&quot;, # Output only. The detailed state of the job.
      &quot;templateMetadata&quot;: { # Pipeline template metadata if PipelineJob.template_uri is from supported template registry. Currently, the only supported registry is Artifact Registry. # Output only. Pipeline template metadata. Will fill up fields if PipelineJob.template_uri is from supported template registry.
        &quot;version&quot;: &quot;A String&quot;, # The version_name in artifact registry. Will always be presented in output if the PipelineJob.template_uri is from supported template registry. Format is &quot;sha256:abcdef123456...&quot;.
      },
      &quot;templateUri&quot;: &quot;A String&quot;, # A template uri from where the PipelineJob.pipeline_spec, if empty, will be downloaded. Currently, only uri from Vertex Template Registry &amp; Gallery is supported. Reference to https://cloud.google.com/vertex-ai/docs/pipelines/create-pipeline-template.
      &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this PipelineJob was most recently updated.
    },
    &quot;pipelineJobId&quot;: &quot;A String&quot;, # The ID to use for the PipelineJob, which will become the final component of the PipelineJob name. If not provided, an ID will be automatically generated. This value should be less than 128 characters, and valid characters are `/a-z-/`.
  },
  &quot;createTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule was created.
  &quot;cron&quot;: &quot;A String&quot;, # Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled runs. To explicitly set a timezone to the cron tab, apply a prefix in the cron tab: &quot;CRON_TZ=${IANA_TIME_ZONE}&quot; or &quot;TZ=${IANA_TIME_ZONE}&quot;. The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database. For example, &quot;CRON_TZ=America/New_York 1 * * * *&quot;, or &quot;TZ=America/New_York 1 * * * *&quot;.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. User provided name of the Schedule. The name can be up to 128 characters long and can consist of any UTF-8 characters.
  &quot;endTime&quot;: &quot;A String&quot;, # Optional. Timestamp after which no new runs can be scheduled. If specified, The schedule will be completed when either end_time is reached or when scheduled_run_count &gt;= max_run_count. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
  &quot;lastPauseTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule was last paused. Unset if never paused.
  &quot;lastResumeTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule was last resumed. Unset if never resumed from pause.
  &quot;lastScheduledRunResponse&quot;: { # Status of a scheduled run. # Output only. Response of the last scheduled run. This is the response for starting the scheduled requests and not the execution of the operations/jobs created by the requests (if applicable). Unset if no run has been scheduled yet.
    &quot;runResponse&quot;: &quot;A String&quot;, # The response of the scheduled run.
    &quot;scheduledRunTime&quot;: &quot;A String&quot;, # The scheduled run time based on the user-specified schedule.
  },
  &quot;maxConcurrentRunCount&quot;: &quot;A String&quot;, # Required. Maximum number of runs that can be started concurrently for this Schedule. This is the limit for starting the scheduled requests and not the execution of the operations/jobs created by the requests (if applicable).
  &quot;maxRunCount&quot;: &quot;A String&quot;, # Optional. Maximum run count of the schedule. If specified, The schedule will be completed when either started_run_count &gt;= max_run_count or when end_time is reached. If not specified, new runs will keep getting scheduled until this Schedule is paused or deleted. Already scheduled runs will be allowed to complete. Unset if not specified.
  &quot;name&quot;: &quot;A String&quot;, # Immutable. The resource name of the Schedule.
  &quot;nextRunTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule should schedule the next run. Having a next_run_time in the past means the runs are being started behind schedule.
  &quot;startTime&quot;: &quot;A String&quot;, # Optional. Timestamp after which the first run can be scheduled. Default to Schedule create time if not specified.
  &quot;startedRunCount&quot;: &quot;A String&quot;, # Output only. The number of runs started by this schedule.
  &quot;state&quot;: &quot;A String&quot;, # Output only. The state of this Schedule.
  &quot;updateTime&quot;: &quot;A String&quot;, # Output only. Timestamp when this Schedule was updated.
}</pre>
</div>

<div class="method">
    <code class="details" id="pause">pause(name, body=None, x__xgafv=None)</code>
  <pre>Pauses a Schedule. Will mark Schedule.state to &#x27;PAUSED&#x27;. If the schedule is paused, no new runs will be created. Already created runs will NOT be paused or canceled.

Args:
  name: string, Required. The name of the Schedule resource to be paused. Format: `projects/{project}/locations/{location}/schedules/{schedule}` (required)
  body: object, The request body.
    The object takes the form of:

{ # Request message for ScheduleService.PauseSchedule.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
}</pre>
</div>

<div class="method">
    <code class="details" id="resume">resume(name, body=None, x__xgafv=None)</code>
  <pre>Resumes a paused Schedule to start scheduling new runs. Will mark Schedule.state to &#x27;ACTIVE&#x27;. Only paused Schedule can be resumed. When the Schedule is resumed, new runs will be scheduled starting from the next execution time after the current time based on the time_specification in the Schedule. If Schedule.catchUp is set up true, all missed runs will be scheduled for backfill first.

Args:
  name: string, Required. The name of the Schedule resource to be resumed. Format: `projects/{project}/locations/{location}/schedules/{schedule}` (required)
  body: object, The request body.
    The object takes the form of:

{ # Request message for ScheduleService.ResumeSchedule.
  &quot;catchUp&quot;: True or False, # Optional. Whether to backfill missed runs when the schedule is resumed from PAUSED state. If set to true, all missed runs will be scheduled. New runs will be scheduled after the backfill is complete. This will also update Schedule.catch_up field. Default to false.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
}</pre>
</div>

</body></html>