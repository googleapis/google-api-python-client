<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="monitoring_v3.html">Cloud Monitoring API</a> . <a href="monitoring_v3.services.html">services</a> . <a href="monitoring_v3.services.serviceLevelObjectives.html">serviceLevelObjectives</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#create">create(parent, body=None, serviceLevelObjectiveId=None, x__xgafv=None)</a></code></p>
<p class="firstline">Create a ServiceLevelObjective for the given Service.</p>
<p class="toc_element">
  <code><a href="#delete">delete(name, x__xgafv=None)</a></code></p>
<p class="firstline">Delete the given ServiceLevelObjective.</p>
<p class="toc_element">
  <code><a href="#get">get(name, view=None, x__xgafv=None)</a></code></p>
<p class="firstline">Get a ServiceLevelObjective by name.</p>
<p class="toc_element">
  <code><a href="#list">list(parent, filter=None, pageSize=None, pageToken=None, view=None, x__xgafv=None)</a></code></p>
<p class="firstline">List the ServiceLevelObjectives for the given Service.</p>
<p class="toc_element">
  <code><a href="#list_next">list_next(previous_request, previous_response)</a></code></p>
<p class="firstline">Retrieves the next page of results.</p>
<p class="toc_element">
  <code><a href="#patch">patch(name, body=None, updateMask=None, x__xgafv=None)</a></code></p>
<p class="firstline">Update the given ServiceLevelObjective.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="create">create(parent, body=None, serviceLevelObjectiveId=None, x__xgafv=None)</code>
  <pre>Create a ServiceLevelObjective for the given Service.

Args:
  parent: string, Required. Resource name of the parent Service. The format is: projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]  (required)
  body: object, The request body.
    The object takes the form of:

{ # A Service-Level Objective (SLO) describes a level of desired good service. It consists of a service-level indicator (SLI), a performance goal, and a period over which the objective is to be evaluated against that goal. The SLO can use SLIs defined in a number of different manners. Typical SLOs might include &quot;99% of requests in each rolling week have latency below 200 milliseconds&quot; or &quot;99.5% of requests in each calendar month return successfully.&quot;
  &quot;calendarPeriod&quot;: &quot;A String&quot;, # A calendar period, semantically &quot;since the start of the current &quot;. At this time, only DAY, WEEK, FORTNIGHT, and MONTH are supported.
  &quot;displayName&quot;: &quot;A String&quot;, # Name used for UI elements listing this SLO.
  &quot;goal&quot;: 3.14, # The fraction of service that must be good in order for this objective to be met. 0 &lt; goal &lt;= 0.999.
  &quot;name&quot;: &quot;A String&quot;, # Resource name for this ServiceLevelObjective. The format is: projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
  &quot;rollingPeriod&quot;: &quot;A String&quot;, # A rolling time period, semantically &quot;in the past &quot;. Must be an integer multiple of 1 day no larger than 30 days.
  &quot;serviceLevelIndicator&quot;: { # A Service-Level Indicator (SLI) describes the &quot;performance&quot; of a service. For some services, the SLI is well-defined. In such cases, the SLI can be described easily by referencing the well-known SLI and providing the needed parameters. Alternatively, a &quot;custom&quot; SLI can be defined with a query to the underlying metric store. An SLI is defined to be good_service / total_service over any queried time interval. The value of performance always falls into the range 0 &lt;= performance &lt;= 1. A custom SLI describes how to compute this ratio, whether this is by dividing values from a pair of time series, cutting a Distribution into good and bad counts, or counting time windows in which the service complies with a criterion. For separation of concerns, a single Service-Level Indicator measures performance for only one aspect of service quality, such as fraction of successful queries or fast-enough queries. # The definition of good service, used to measure and calculate the quality of the Service&#x27;s performance with respect to a single aspect of service quality.
    &quot;basicSli&quot;: { # An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service. # Basic SLI on a well-known service type.
      &quot;availability&quot;: { # Future parameters for the availability SLI. # Good service is defined to be the count of requests made to this service that return successfully.
      },
      &quot;latency&quot;: { # Parameters for a latency threshold SLI. # Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
        &quot;threshold&quot;: &quot;A String&quot;, # Good service is defined to be the count of requests made to this service that return in no more than threshold.
      },
      &quot;location&quot;: [ # OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don&#x27;t support breaking down by location, setting this field will result in an error.
        &quot;A String&quot;,
      ],
      &quot;method&quot;: [ # OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service&#x27;s methods. For service types that don&#x27;t support breaking down by method, setting this field will result in an error.
        &quot;A String&quot;,
      ],
      &quot;version&quot;: [ # OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don&#x27;t support breaking down by version, setting this field will result in an error.
        &quot;A String&quot;,
      ],
    },
    &quot;requestBased&quot;: { # Service Level Indicators for which atomic units of service are counted directly. # Request-based SLIs
      &quot;distributionCut&quot;: { # A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the count of values x in the Distribution such that range.min &lt;= x &lt; range.max. # distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
        &quot;distributionFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
        &quot;range&quot;: { # Range of numerical values, inclusive of min and exclusive of max. If the open range &quot;&lt; range.max&quot; is desired, set range.min = -infinity. If the open range &quot;&gt;= range.min&quot; is desired, set range.max = infinity. # Range of values considered &quot;good.&quot; For a one-sided range, set one bound to an infinite value.
          &quot;max&quot;: 3.14, # Range maximum.
          &quot;min&quot;: 3.14, # Range minimum.
        },
      },
      &quot;goodTotalRatio&quot;: { # A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed. # good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
        &quot;badServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        &quot;goodServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        &quot;totalServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
      },
    },
    &quot;windowsBased&quot;: { # A WindowsBasedSli defines good_service as the count of time windows for which the provided service was of good quality. Criteria for determining if service was good are embedded in the window_criterion. # Windows-based SLIs
      &quot;goodBadMetricFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries with ValueType = BOOL. The window is good if any true values appear in the window.
      &quot;goodTotalRatioThreshold&quot;: { # A PerformanceThreshold is used when each window is good when that window has a sufficiently high performance. # A window is good if its performance is high enough.
        &quot;basicSliPerformance&quot;: { # An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service. # BasicSli to evaluate to judge window quality.
          &quot;availability&quot;: { # Future parameters for the availability SLI. # Good service is defined to be the count of requests made to this service that return successfully.
          },
          &quot;latency&quot;: { # Parameters for a latency threshold SLI. # Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
            &quot;threshold&quot;: &quot;A String&quot;, # Good service is defined to be the count of requests made to this service that return in no more than threshold.
          },
          &quot;location&quot;: [ # OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don&#x27;t support breaking down by location, setting this field will result in an error.
            &quot;A String&quot;,
          ],
          &quot;method&quot;: [ # OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service&#x27;s methods. For service types that don&#x27;t support breaking down by method, setting this field will result in an error.
            &quot;A String&quot;,
          ],
          &quot;version&quot;: [ # OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don&#x27;t support breaking down by version, setting this field will result in an error.
            &quot;A String&quot;,
          ],
        },
        &quot;performance&quot;: { # Service Level Indicators for which atomic units of service are counted directly. # RequestBasedSli to evaluate to judge window quality.
          &quot;distributionCut&quot;: { # A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the count of values x in the Distribution such that range.min &lt;= x &lt; range.max. # distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
            &quot;distributionFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
            &quot;range&quot;: { # Range of numerical values, inclusive of min and exclusive of max. If the open range &quot;&lt; range.max&quot; is desired, set range.min = -infinity. If the open range &quot;&gt;= range.min&quot; is desired, set range.max = infinity. # Range of values considered &quot;good.&quot; For a one-sided range, set one bound to an infinite value.
              &quot;max&quot;: 3.14, # Range maximum.
              &quot;min&quot;: 3.14, # Range minimum.
            },
          },
          &quot;goodTotalRatio&quot;: { # A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed. # good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
            &quot;badServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
            &quot;goodServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
            &quot;totalServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
          },
        },
        &quot;threshold&quot;: 3.14, # If window performance &gt;= threshold, the window is counted as good.
      },
      &quot;metricMeanInRange&quot;: { # A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min &lt;= x &lt; range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE. # A window is good if the metric&#x27;s value is in a good range, averaged across returned streams.
        &quot;range&quot;: { # Range of numerical values, inclusive of min and exclusive of max. If the open range &quot;&lt; range.max&quot; is desired, set range.min = -infinity. If the open range &quot;&gt;= range.min&quot; is desired, set range.max = infinity. # Range of values considered &quot;good.&quot; For a one-sided range, set one bound to an infinite value.
          &quot;max&quot;: 3.14, # Range maximum.
          &quot;min&quot;: 3.14, # Range minimum.
        },
        &quot;timeSeries&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
      },
      &quot;metricSumInRange&quot;: { # A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min &lt;= x &lt; range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE. # A window is good if the metric&#x27;s value is in a good range, summed across returned streams.
        &quot;range&quot;: { # Range of numerical values, inclusive of min and exclusive of max. If the open range &quot;&lt; range.max&quot; is desired, set range.min = -infinity. If the open range &quot;&gt;= range.min&quot; is desired, set range.max = infinity. # Range of values considered &quot;good.&quot; For a one-sided range, set one bound to an infinite value.
          &quot;max&quot;: 3.14, # Range maximum.
          &quot;min&quot;: 3.14, # Range minimum.
        },
        &quot;timeSeries&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
      },
      &quot;windowPeriod&quot;: &quot;A String&quot;, # Duration over which window quality is evaluated. Must be an integer fraction of a day and at least 60s.
    },
  },
}

  serviceLevelObjectiveId: string, Optional. The ServiceLevelObjective id to use for this ServiceLevelObjective. If omitted, an id will be generated instead. Must match the pattern [a-z0-9\-]+
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A Service-Level Objective (SLO) describes a level of desired good service. It consists of a service-level indicator (SLI), a performance goal, and a period over which the objective is to be evaluated against that goal. The SLO can use SLIs defined in a number of different manners. Typical SLOs might include &quot;99% of requests in each rolling week have latency below 200 milliseconds&quot; or &quot;99.5% of requests in each calendar month return successfully.&quot;
  &quot;calendarPeriod&quot;: &quot;A String&quot;, # A calendar period, semantically &quot;since the start of the current &quot;. At this time, only DAY, WEEK, FORTNIGHT, and MONTH are supported.
  &quot;displayName&quot;: &quot;A String&quot;, # Name used for UI elements listing this SLO.
  &quot;goal&quot;: 3.14, # The fraction of service that must be good in order for this objective to be met. 0 &lt; goal &lt;= 0.999.
  &quot;name&quot;: &quot;A String&quot;, # Resource name for this ServiceLevelObjective. The format is: projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
  &quot;rollingPeriod&quot;: &quot;A String&quot;, # A rolling time period, semantically &quot;in the past &quot;. Must be an integer multiple of 1 day no larger than 30 days.
  &quot;serviceLevelIndicator&quot;: { # A Service-Level Indicator (SLI) describes the &quot;performance&quot; of a service. For some services, the SLI is well-defined. In such cases, the SLI can be described easily by referencing the well-known SLI and providing the needed parameters. Alternatively, a &quot;custom&quot; SLI can be defined with a query to the underlying metric store. An SLI is defined to be good_service / total_service over any queried time interval. The value of performance always falls into the range 0 &lt;= performance &lt;= 1. A custom SLI describes how to compute this ratio, whether this is by dividing values from a pair of time series, cutting a Distribution into good and bad counts, or counting time windows in which the service complies with a criterion. For separation of concerns, a single Service-Level Indicator measures performance for only one aspect of service quality, such as fraction of successful queries or fast-enough queries. # The definition of good service, used to measure and calculate the quality of the Service&#x27;s performance with respect to a single aspect of service quality.
    &quot;basicSli&quot;: { # An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service. # Basic SLI on a well-known service type.
      &quot;availability&quot;: { # Future parameters for the availability SLI. # Good service is defined to be the count of requests made to this service that return successfully.
      },
      &quot;latency&quot;: { # Parameters for a latency threshold SLI. # Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
        &quot;threshold&quot;: &quot;A String&quot;, # Good service is defined to be the count of requests made to this service that return in no more than threshold.
      },
      &quot;location&quot;: [ # OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don&#x27;t support breaking down by location, setting this field will result in an error.
        &quot;A String&quot;,
      ],
      &quot;method&quot;: [ # OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service&#x27;s methods. For service types that don&#x27;t support breaking down by method, setting this field will result in an error.
        &quot;A String&quot;,
      ],
      &quot;version&quot;: [ # OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don&#x27;t support breaking down by version, setting this field will result in an error.
        &quot;A String&quot;,
      ],
    },
    &quot;requestBased&quot;: { # Service Level Indicators for which atomic units of service are counted directly. # Request-based SLIs
      &quot;distributionCut&quot;: { # A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the count of values x in the Distribution such that range.min &lt;= x &lt; range.max. # distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
        &quot;distributionFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
        &quot;range&quot;: { # Range of numerical values, inclusive of min and exclusive of max. If the open range &quot;&lt; range.max&quot; is desired, set range.min = -infinity. If the open range &quot;&gt;= range.min&quot; is desired, set range.max = infinity. # Range of values considered &quot;good.&quot; For a one-sided range, set one bound to an infinite value.
          &quot;max&quot;: 3.14, # Range maximum.
          &quot;min&quot;: 3.14, # Range minimum.
        },
      },
      &quot;goodTotalRatio&quot;: { # A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed. # good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
        &quot;badServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        &quot;goodServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        &quot;totalServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
      },
    },
    &quot;windowsBased&quot;: { # A WindowsBasedSli defines good_service as the count of time windows for which the provided service was of good quality. Criteria for determining if service was good are embedded in the window_criterion. # Windows-based SLIs
      &quot;goodBadMetricFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries with ValueType = BOOL. The window is good if any true values appear in the window.
      &quot;goodTotalRatioThreshold&quot;: { # A PerformanceThreshold is used when each window is good when that window has a sufficiently high performance. # A window is good if its performance is high enough.
        &quot;basicSliPerformance&quot;: { # An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service. # BasicSli to evaluate to judge window quality.
          &quot;availability&quot;: { # Future parameters for the availability SLI. # Good service is defined to be the count of requests made to this service that return successfully.
          },
          &quot;latency&quot;: { # Parameters for a latency threshold SLI. # Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
            &quot;threshold&quot;: &quot;A String&quot;, # Good service is defined to be the count of requests made to this service that return in no more than threshold.
          },
          &quot;location&quot;: [ # OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don&#x27;t support breaking down by location, setting this field will result in an error.
            &quot;A String&quot;,
          ],
          &quot;method&quot;: [ # OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service&#x27;s methods. For service types that don&#x27;t support breaking down by method, setting this field will result in an error.
            &quot;A String&quot;,
          ],
          &quot;version&quot;: [ # OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don&#x27;t support breaking down by version, setting this field will result in an error.
            &quot;A String&quot;,
          ],
        },
        &quot;performance&quot;: { # Service Level Indicators for which atomic units of service are counted directly. # RequestBasedSli to evaluate to judge window quality.
          &quot;distributionCut&quot;: { # A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the count of values x in the Distribution such that range.min &lt;= x &lt; range.max. # distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
            &quot;distributionFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
            &quot;range&quot;: { # Range of numerical values, inclusive of min and exclusive of max. If the open range &quot;&lt; range.max&quot; is desired, set range.min = -infinity. If the open range &quot;&gt;= range.min&quot; is desired, set range.max = infinity. # Range of values considered &quot;good.&quot; For a one-sided range, set one bound to an infinite value.
              &quot;max&quot;: 3.14, # Range maximum.
              &quot;min&quot;: 3.14, # Range minimum.
            },
          },
          &quot;goodTotalRatio&quot;: { # A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed. # good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
            &quot;badServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
            &quot;goodServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
            &quot;totalServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
          },
        },
        &quot;threshold&quot;: 3.14, # If window performance &gt;= threshold, the window is counted as good.
      },
      &quot;metricMeanInRange&quot;: { # A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min &lt;= x &lt; range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE. # A window is good if the metric&#x27;s value is in a good range, averaged across returned streams.
        &quot;range&quot;: { # Range of numerical values, inclusive of min and exclusive of max. If the open range &quot;&lt; range.max&quot; is desired, set range.min = -infinity. If the open range &quot;&gt;= range.min&quot; is desired, set range.max = infinity. # Range of values considered &quot;good.&quot; For a one-sided range, set one bound to an infinite value.
          &quot;max&quot;: 3.14, # Range maximum.
          &quot;min&quot;: 3.14, # Range minimum.
        },
        &quot;timeSeries&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
      },
      &quot;metricSumInRange&quot;: { # A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min &lt;= x &lt; range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE. # A window is good if the metric&#x27;s value is in a good range, summed across returned streams.
        &quot;range&quot;: { # Range of numerical values, inclusive of min and exclusive of max. If the open range &quot;&lt; range.max&quot; is desired, set range.min = -infinity. If the open range &quot;&gt;= range.min&quot; is desired, set range.max = infinity. # Range of values considered &quot;good.&quot; For a one-sided range, set one bound to an infinite value.
          &quot;max&quot;: 3.14, # Range maximum.
          &quot;min&quot;: 3.14, # Range minimum.
        },
        &quot;timeSeries&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
      },
      &quot;windowPeriod&quot;: &quot;A String&quot;, # Duration over which window quality is evaluated. Must be an integer fraction of a day and at least 60s.
    },
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="delete">delete(name, x__xgafv=None)</code>
  <pre>Delete the given ServiceLevelObjective.

Args:
  name: string, Required. Resource name of the ServiceLevelObjective to delete. The format is: projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]  (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } The JSON representation for Empty is empty JSON object {}.
}</pre>
</div>

<div class="method">
    <code class="details" id="get">get(name, view=None, x__xgafv=None)</code>
  <pre>Get a ServiceLevelObjective by name.

Args:
  name: string, Required. Resource name of the ServiceLevelObjective to get. The format is: projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]  (required)
  view: string, View of the ServiceLevelObjective to return. If DEFAULT, return the ServiceLevelObjective as originally defined. If EXPLICIT and the ServiceLevelObjective is defined in terms of a BasicSli, replace the BasicSli with a RequestBasedSli spelling out how the SLI is computed.
    Allowed values
      VIEW_UNSPECIFIED - Same as FULL.
      FULL - Return the embedded ServiceLevelIndicator in the form in which it was defined. If it was defined using a BasicSli, return that BasicSli.
      EXPLICIT - For ServiceLevelIndicators using BasicSli articulation, instead return the ServiceLevelIndicator with its mode of computation fully spelled out as a RequestBasedSli. For ServiceLevelIndicators using RequestBasedSli or WindowsBasedSli, return the ServiceLevelIndicator as it was provided.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A Service-Level Objective (SLO) describes a level of desired good service. It consists of a service-level indicator (SLI), a performance goal, and a period over which the objective is to be evaluated against that goal. The SLO can use SLIs defined in a number of different manners. Typical SLOs might include &quot;99% of requests in each rolling week have latency below 200 milliseconds&quot; or &quot;99.5% of requests in each calendar month return successfully.&quot;
  &quot;calendarPeriod&quot;: &quot;A String&quot;, # A calendar period, semantically &quot;since the start of the current &quot;. At this time, only DAY, WEEK, FORTNIGHT, and MONTH are supported.
  &quot;displayName&quot;: &quot;A String&quot;, # Name used for UI elements listing this SLO.
  &quot;goal&quot;: 3.14, # The fraction of service that must be good in order for this objective to be met. 0 &lt; goal &lt;= 0.999.
  &quot;name&quot;: &quot;A String&quot;, # Resource name for this ServiceLevelObjective. The format is: projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
  &quot;rollingPeriod&quot;: &quot;A String&quot;, # A rolling time period, semantically &quot;in the past &quot;. Must be an integer multiple of 1 day no larger than 30 days.
  &quot;serviceLevelIndicator&quot;: { # A Service-Level Indicator (SLI) describes the &quot;performance&quot; of a service. For some services, the SLI is well-defined. In such cases, the SLI can be described easily by referencing the well-known SLI and providing the needed parameters. Alternatively, a &quot;custom&quot; SLI can be defined with a query to the underlying metric store. An SLI is defined to be good_service / total_service over any queried time interval. The value of performance always falls into the range 0 &lt;= performance &lt;= 1. A custom SLI describes how to compute this ratio, whether this is by dividing values from a pair of time series, cutting a Distribution into good and bad counts, or counting time windows in which the service complies with a criterion. For separation of concerns, a single Service-Level Indicator measures performance for only one aspect of service quality, such as fraction of successful queries or fast-enough queries. # The definition of good service, used to measure and calculate the quality of the Service&#x27;s performance with respect to a single aspect of service quality.
    &quot;basicSli&quot;: { # An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service. # Basic SLI on a well-known service type.
      &quot;availability&quot;: { # Future parameters for the availability SLI. # Good service is defined to be the count of requests made to this service that return successfully.
      },
      &quot;latency&quot;: { # Parameters for a latency threshold SLI. # Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
        &quot;threshold&quot;: &quot;A String&quot;, # Good service is defined to be the count of requests made to this service that return in no more than threshold.
      },
      &quot;location&quot;: [ # OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don&#x27;t support breaking down by location, setting this field will result in an error.
        &quot;A String&quot;,
      ],
      &quot;method&quot;: [ # OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service&#x27;s methods. For service types that don&#x27;t support breaking down by method, setting this field will result in an error.
        &quot;A String&quot;,
      ],
      &quot;version&quot;: [ # OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don&#x27;t support breaking down by version, setting this field will result in an error.
        &quot;A String&quot;,
      ],
    },
    &quot;requestBased&quot;: { # Service Level Indicators for which atomic units of service are counted directly. # Request-based SLIs
      &quot;distributionCut&quot;: { # A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the count of values x in the Distribution such that range.min &lt;= x &lt; range.max. # distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
        &quot;distributionFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
        &quot;range&quot;: { # Range of numerical values, inclusive of min and exclusive of max. If the open range &quot;&lt; range.max&quot; is desired, set range.min = -infinity. If the open range &quot;&gt;= range.min&quot; is desired, set range.max = infinity. # Range of values considered &quot;good.&quot; For a one-sided range, set one bound to an infinite value.
          &quot;max&quot;: 3.14, # Range maximum.
          &quot;min&quot;: 3.14, # Range minimum.
        },
      },
      &quot;goodTotalRatio&quot;: { # A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed. # good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
        &quot;badServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        &quot;goodServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        &quot;totalServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
      },
    },
    &quot;windowsBased&quot;: { # A WindowsBasedSli defines good_service as the count of time windows for which the provided service was of good quality. Criteria for determining if service was good are embedded in the window_criterion. # Windows-based SLIs
      &quot;goodBadMetricFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries with ValueType = BOOL. The window is good if any true values appear in the window.
      &quot;goodTotalRatioThreshold&quot;: { # A PerformanceThreshold is used when each window is good when that window has a sufficiently high performance. # A window is good if its performance is high enough.
        &quot;basicSliPerformance&quot;: { # An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service. # BasicSli to evaluate to judge window quality.
          &quot;availability&quot;: { # Future parameters for the availability SLI. # Good service is defined to be the count of requests made to this service that return successfully.
          },
          &quot;latency&quot;: { # Parameters for a latency threshold SLI. # Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
            &quot;threshold&quot;: &quot;A String&quot;, # Good service is defined to be the count of requests made to this service that return in no more than threshold.
          },
          &quot;location&quot;: [ # OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don&#x27;t support breaking down by location, setting this field will result in an error.
            &quot;A String&quot;,
          ],
          &quot;method&quot;: [ # OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service&#x27;s methods. For service types that don&#x27;t support breaking down by method, setting this field will result in an error.
            &quot;A String&quot;,
          ],
          &quot;version&quot;: [ # OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don&#x27;t support breaking down by version, setting this field will result in an error.
            &quot;A String&quot;,
          ],
        },
        &quot;performance&quot;: { # Service Level Indicators for which atomic units of service are counted directly. # RequestBasedSli to evaluate to judge window quality.
          &quot;distributionCut&quot;: { # A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the count of values x in the Distribution such that range.min &lt;= x &lt; range.max. # distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
            &quot;distributionFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
            &quot;range&quot;: { # Range of numerical values, inclusive of min and exclusive of max. If the open range &quot;&lt; range.max&quot; is desired, set range.min = -infinity. If the open range &quot;&gt;= range.min&quot; is desired, set range.max = infinity. # Range of values considered &quot;good.&quot; For a one-sided range, set one bound to an infinite value.
              &quot;max&quot;: 3.14, # Range maximum.
              &quot;min&quot;: 3.14, # Range minimum.
            },
          },
          &quot;goodTotalRatio&quot;: { # A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed. # good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
            &quot;badServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
            &quot;goodServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
            &quot;totalServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
          },
        },
        &quot;threshold&quot;: 3.14, # If window performance &gt;= threshold, the window is counted as good.
      },
      &quot;metricMeanInRange&quot;: { # A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min &lt;= x &lt; range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE. # A window is good if the metric&#x27;s value is in a good range, averaged across returned streams.
        &quot;range&quot;: { # Range of numerical values, inclusive of min and exclusive of max. If the open range &quot;&lt; range.max&quot; is desired, set range.min = -infinity. If the open range &quot;&gt;= range.min&quot; is desired, set range.max = infinity. # Range of values considered &quot;good.&quot; For a one-sided range, set one bound to an infinite value.
          &quot;max&quot;: 3.14, # Range maximum.
          &quot;min&quot;: 3.14, # Range minimum.
        },
        &quot;timeSeries&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
      },
      &quot;metricSumInRange&quot;: { # A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min &lt;= x &lt; range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE. # A window is good if the metric&#x27;s value is in a good range, summed across returned streams.
        &quot;range&quot;: { # Range of numerical values, inclusive of min and exclusive of max. If the open range &quot;&lt; range.max&quot; is desired, set range.min = -infinity. If the open range &quot;&gt;= range.min&quot; is desired, set range.max = infinity. # Range of values considered &quot;good.&quot; For a one-sided range, set one bound to an infinite value.
          &quot;max&quot;: 3.14, # Range maximum.
          &quot;min&quot;: 3.14, # Range minimum.
        },
        &quot;timeSeries&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
      },
      &quot;windowPeriod&quot;: &quot;A String&quot;, # Duration over which window quality is evaluated. Must be an integer fraction of a day and at least 60s.
    },
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="list">list(parent, filter=None, pageSize=None, pageToken=None, view=None, x__xgafv=None)</code>
  <pre>List the ServiceLevelObjectives for the given Service.

Args:
  parent: string, Required. Resource name of the parent containing the listed SLOs, either a project or a Monitoring Workspace. The formats are: projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID] workspaces/[HOST_PROJECT_ID_OR_NUMBER]/services/-  (required)
  filter: string, A filter specifying what ServiceLevelObjectives to return.
  pageSize: integer, A non-negative number that is the maximum number of results to return. When 0, use default page size.
  pageToken: string, If this field is not empty then it must contain the nextPageToken value returned by a previous call to this method. Using this field causes the method to return additional results from the previous method call.
  view: string, View of the ServiceLevelObjectives to return. If DEFAULT, return each ServiceLevelObjective as originally defined. If EXPLICIT and the ServiceLevelObjective is defined in terms of a BasicSli, replace the BasicSli with a RequestBasedSli spelling out how the SLI is computed.
    Allowed values
      VIEW_UNSPECIFIED - Same as FULL.
      FULL - Return the embedded ServiceLevelIndicator in the form in which it was defined. If it was defined using a BasicSli, return that BasicSli.
      EXPLICIT - For ServiceLevelIndicators using BasicSli articulation, instead return the ServiceLevelIndicator with its mode of computation fully spelled out as a RequestBasedSli. For ServiceLevelIndicators using RequestBasedSli or WindowsBasedSli, return the ServiceLevelIndicator as it was provided.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The ListServiceLevelObjectives response.
  &quot;nextPageToken&quot;: &quot;A String&quot;, # If there are more results than have been returned, then this field is set to a non-empty value. To see the additional results, use that value as page_token in the next call to this method.
  &quot;serviceLevelObjectives&quot;: [ # The ServiceLevelObjectives matching the specified filter.
    { # A Service-Level Objective (SLO) describes a level of desired good service. It consists of a service-level indicator (SLI), a performance goal, and a period over which the objective is to be evaluated against that goal. The SLO can use SLIs defined in a number of different manners. Typical SLOs might include &quot;99% of requests in each rolling week have latency below 200 milliseconds&quot; or &quot;99.5% of requests in each calendar month return successfully.&quot;
      &quot;calendarPeriod&quot;: &quot;A String&quot;, # A calendar period, semantically &quot;since the start of the current &quot;. At this time, only DAY, WEEK, FORTNIGHT, and MONTH are supported.
      &quot;displayName&quot;: &quot;A String&quot;, # Name used for UI elements listing this SLO.
      &quot;goal&quot;: 3.14, # The fraction of service that must be good in order for this objective to be met. 0 &lt; goal &lt;= 0.999.
      &quot;name&quot;: &quot;A String&quot;, # Resource name for this ServiceLevelObjective. The format is: projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
      &quot;rollingPeriod&quot;: &quot;A String&quot;, # A rolling time period, semantically &quot;in the past &quot;. Must be an integer multiple of 1 day no larger than 30 days.
      &quot;serviceLevelIndicator&quot;: { # A Service-Level Indicator (SLI) describes the &quot;performance&quot; of a service. For some services, the SLI is well-defined. In such cases, the SLI can be described easily by referencing the well-known SLI and providing the needed parameters. Alternatively, a &quot;custom&quot; SLI can be defined with a query to the underlying metric store. An SLI is defined to be good_service / total_service over any queried time interval. The value of performance always falls into the range 0 &lt;= performance &lt;= 1. A custom SLI describes how to compute this ratio, whether this is by dividing values from a pair of time series, cutting a Distribution into good and bad counts, or counting time windows in which the service complies with a criterion. For separation of concerns, a single Service-Level Indicator measures performance for only one aspect of service quality, such as fraction of successful queries or fast-enough queries. # The definition of good service, used to measure and calculate the quality of the Service&#x27;s performance with respect to a single aspect of service quality.
        &quot;basicSli&quot;: { # An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service. # Basic SLI on a well-known service type.
          &quot;availability&quot;: { # Future parameters for the availability SLI. # Good service is defined to be the count of requests made to this service that return successfully.
          },
          &quot;latency&quot;: { # Parameters for a latency threshold SLI. # Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
            &quot;threshold&quot;: &quot;A String&quot;, # Good service is defined to be the count of requests made to this service that return in no more than threshold.
          },
          &quot;location&quot;: [ # OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don&#x27;t support breaking down by location, setting this field will result in an error.
            &quot;A String&quot;,
          ],
          &quot;method&quot;: [ # OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service&#x27;s methods. For service types that don&#x27;t support breaking down by method, setting this field will result in an error.
            &quot;A String&quot;,
          ],
          &quot;version&quot;: [ # OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don&#x27;t support breaking down by version, setting this field will result in an error.
            &quot;A String&quot;,
          ],
        },
        &quot;requestBased&quot;: { # Service Level Indicators for which atomic units of service are counted directly. # Request-based SLIs
          &quot;distributionCut&quot;: { # A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the count of values x in the Distribution such that range.min &lt;= x &lt; range.max. # distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
            &quot;distributionFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
            &quot;range&quot;: { # Range of numerical values, inclusive of min and exclusive of max. If the open range &quot;&lt; range.max&quot; is desired, set range.min = -infinity. If the open range &quot;&gt;= range.min&quot; is desired, set range.max = infinity. # Range of values considered &quot;good.&quot; For a one-sided range, set one bound to an infinite value.
              &quot;max&quot;: 3.14, # Range maximum.
              &quot;min&quot;: 3.14, # Range minimum.
            },
          },
          &quot;goodTotalRatio&quot;: { # A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed. # good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
            &quot;badServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
            &quot;goodServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
            &quot;totalServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
          },
        },
        &quot;windowsBased&quot;: { # A WindowsBasedSli defines good_service as the count of time windows for which the provided service was of good quality. Criteria for determining if service was good are embedded in the window_criterion. # Windows-based SLIs
          &quot;goodBadMetricFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries with ValueType = BOOL. The window is good if any true values appear in the window.
          &quot;goodTotalRatioThreshold&quot;: { # A PerformanceThreshold is used when each window is good when that window has a sufficiently high performance. # A window is good if its performance is high enough.
            &quot;basicSliPerformance&quot;: { # An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service. # BasicSli to evaluate to judge window quality.
              &quot;availability&quot;: { # Future parameters for the availability SLI. # Good service is defined to be the count of requests made to this service that return successfully.
              },
              &quot;latency&quot;: { # Parameters for a latency threshold SLI. # Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
                &quot;threshold&quot;: &quot;A String&quot;, # Good service is defined to be the count of requests made to this service that return in no more than threshold.
              },
              &quot;location&quot;: [ # OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don&#x27;t support breaking down by location, setting this field will result in an error.
                &quot;A String&quot;,
              ],
              &quot;method&quot;: [ # OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service&#x27;s methods. For service types that don&#x27;t support breaking down by method, setting this field will result in an error.
                &quot;A String&quot;,
              ],
              &quot;version&quot;: [ # OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don&#x27;t support breaking down by version, setting this field will result in an error.
                &quot;A String&quot;,
              ],
            },
            &quot;performance&quot;: { # Service Level Indicators for which atomic units of service are counted directly. # RequestBasedSli to evaluate to judge window quality.
              &quot;distributionCut&quot;: { # A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the count of values x in the Distribution such that range.min &lt;= x &lt; range.max. # distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
                &quot;distributionFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
                &quot;range&quot;: { # Range of numerical values, inclusive of min and exclusive of max. If the open range &quot;&lt; range.max&quot; is desired, set range.min = -infinity. If the open range &quot;&gt;= range.min&quot; is desired, set range.max = infinity. # Range of values considered &quot;good.&quot; For a one-sided range, set one bound to an infinite value.
                  &quot;max&quot;: 3.14, # Range maximum.
                  &quot;min&quot;: 3.14, # Range minimum.
                },
              },
              &quot;goodTotalRatio&quot;: { # A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed. # good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
                &quot;badServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
                &quot;goodServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
                &quot;totalServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
              },
            },
            &quot;threshold&quot;: 3.14, # If window performance &gt;= threshold, the window is counted as good.
          },
          &quot;metricMeanInRange&quot;: { # A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min &lt;= x &lt; range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE. # A window is good if the metric&#x27;s value is in a good range, averaged across returned streams.
            &quot;range&quot;: { # Range of numerical values, inclusive of min and exclusive of max. If the open range &quot;&lt; range.max&quot; is desired, set range.min = -infinity. If the open range &quot;&gt;= range.min&quot; is desired, set range.max = infinity. # Range of values considered &quot;good.&quot; For a one-sided range, set one bound to an infinite value.
              &quot;max&quot;: 3.14, # Range maximum.
              &quot;min&quot;: 3.14, # Range minimum.
            },
            &quot;timeSeries&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
          },
          &quot;metricSumInRange&quot;: { # A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min &lt;= x &lt; range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE. # A window is good if the metric&#x27;s value is in a good range, summed across returned streams.
            &quot;range&quot;: { # Range of numerical values, inclusive of min and exclusive of max. If the open range &quot;&lt; range.max&quot; is desired, set range.min = -infinity. If the open range &quot;&gt;= range.min&quot; is desired, set range.max = infinity. # Range of values considered &quot;good.&quot; For a one-sided range, set one bound to an infinite value.
              &quot;max&quot;: 3.14, # Range maximum.
              &quot;min&quot;: 3.14, # Range minimum.
            },
            &quot;timeSeries&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
          },
          &quot;windowPeriod&quot;: &quot;A String&quot;, # Duration over which window quality is evaluated. Must be an integer fraction of a day and at least 60s.
        },
      },
    },
  ],
}</pre>
</div>

<div class="method">
    <code class="details" id="list_next">list_next(previous_request, previous_response)</code>
  <pre>Retrieves the next page of results.

Args:
  previous_request: The request for the previous page. (required)
  previous_response: The response from the request for the previous page. (required)

Returns:
  A request object that you can call &#x27;execute()&#x27; on to request the next
  page. Returns None if there are no more items in the collection.
    </pre>
</div>

<div class="method">
    <code class="details" id="patch">patch(name, body=None, updateMask=None, x__xgafv=None)</code>
  <pre>Update the given ServiceLevelObjective.

Args:
  name: string, Resource name for this ServiceLevelObjective. The format is: projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]  (required)
  body: object, The request body.
    The object takes the form of:

{ # A Service-Level Objective (SLO) describes a level of desired good service. It consists of a service-level indicator (SLI), a performance goal, and a period over which the objective is to be evaluated against that goal. The SLO can use SLIs defined in a number of different manners. Typical SLOs might include &quot;99% of requests in each rolling week have latency below 200 milliseconds&quot; or &quot;99.5% of requests in each calendar month return successfully.&quot;
  &quot;calendarPeriod&quot;: &quot;A String&quot;, # A calendar period, semantically &quot;since the start of the current &quot;. At this time, only DAY, WEEK, FORTNIGHT, and MONTH are supported.
  &quot;displayName&quot;: &quot;A String&quot;, # Name used for UI elements listing this SLO.
  &quot;goal&quot;: 3.14, # The fraction of service that must be good in order for this objective to be met. 0 &lt; goal &lt;= 0.999.
  &quot;name&quot;: &quot;A String&quot;, # Resource name for this ServiceLevelObjective. The format is: projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
  &quot;rollingPeriod&quot;: &quot;A String&quot;, # A rolling time period, semantically &quot;in the past &quot;. Must be an integer multiple of 1 day no larger than 30 days.
  &quot;serviceLevelIndicator&quot;: { # A Service-Level Indicator (SLI) describes the &quot;performance&quot; of a service. For some services, the SLI is well-defined. In such cases, the SLI can be described easily by referencing the well-known SLI and providing the needed parameters. Alternatively, a &quot;custom&quot; SLI can be defined with a query to the underlying metric store. An SLI is defined to be good_service / total_service over any queried time interval. The value of performance always falls into the range 0 &lt;= performance &lt;= 1. A custom SLI describes how to compute this ratio, whether this is by dividing values from a pair of time series, cutting a Distribution into good and bad counts, or counting time windows in which the service complies with a criterion. For separation of concerns, a single Service-Level Indicator measures performance for only one aspect of service quality, such as fraction of successful queries or fast-enough queries. # The definition of good service, used to measure and calculate the quality of the Service&#x27;s performance with respect to a single aspect of service quality.
    &quot;basicSli&quot;: { # An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service. # Basic SLI on a well-known service type.
      &quot;availability&quot;: { # Future parameters for the availability SLI. # Good service is defined to be the count of requests made to this service that return successfully.
      },
      &quot;latency&quot;: { # Parameters for a latency threshold SLI. # Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
        &quot;threshold&quot;: &quot;A String&quot;, # Good service is defined to be the count of requests made to this service that return in no more than threshold.
      },
      &quot;location&quot;: [ # OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don&#x27;t support breaking down by location, setting this field will result in an error.
        &quot;A String&quot;,
      ],
      &quot;method&quot;: [ # OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service&#x27;s methods. For service types that don&#x27;t support breaking down by method, setting this field will result in an error.
        &quot;A String&quot;,
      ],
      &quot;version&quot;: [ # OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don&#x27;t support breaking down by version, setting this field will result in an error.
        &quot;A String&quot;,
      ],
    },
    &quot;requestBased&quot;: { # Service Level Indicators for which atomic units of service are counted directly. # Request-based SLIs
      &quot;distributionCut&quot;: { # A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the count of values x in the Distribution such that range.min &lt;= x &lt; range.max. # distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
        &quot;distributionFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
        &quot;range&quot;: { # Range of numerical values, inclusive of min and exclusive of max. If the open range &quot;&lt; range.max&quot; is desired, set range.min = -infinity. If the open range &quot;&gt;= range.min&quot; is desired, set range.max = infinity. # Range of values considered &quot;good.&quot; For a one-sided range, set one bound to an infinite value.
          &quot;max&quot;: 3.14, # Range maximum.
          &quot;min&quot;: 3.14, # Range minimum.
        },
      },
      &quot;goodTotalRatio&quot;: { # A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed. # good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
        &quot;badServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        &quot;goodServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        &quot;totalServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
      },
    },
    &quot;windowsBased&quot;: { # A WindowsBasedSli defines good_service as the count of time windows for which the provided service was of good quality. Criteria for determining if service was good are embedded in the window_criterion. # Windows-based SLIs
      &quot;goodBadMetricFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries with ValueType = BOOL. The window is good if any true values appear in the window.
      &quot;goodTotalRatioThreshold&quot;: { # A PerformanceThreshold is used when each window is good when that window has a sufficiently high performance. # A window is good if its performance is high enough.
        &quot;basicSliPerformance&quot;: { # An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service. # BasicSli to evaluate to judge window quality.
          &quot;availability&quot;: { # Future parameters for the availability SLI. # Good service is defined to be the count of requests made to this service that return successfully.
          },
          &quot;latency&quot;: { # Parameters for a latency threshold SLI. # Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
            &quot;threshold&quot;: &quot;A String&quot;, # Good service is defined to be the count of requests made to this service that return in no more than threshold.
          },
          &quot;location&quot;: [ # OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don&#x27;t support breaking down by location, setting this field will result in an error.
            &quot;A String&quot;,
          ],
          &quot;method&quot;: [ # OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service&#x27;s methods. For service types that don&#x27;t support breaking down by method, setting this field will result in an error.
            &quot;A String&quot;,
          ],
          &quot;version&quot;: [ # OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don&#x27;t support breaking down by version, setting this field will result in an error.
            &quot;A String&quot;,
          ],
        },
        &quot;performance&quot;: { # Service Level Indicators for which atomic units of service are counted directly. # RequestBasedSli to evaluate to judge window quality.
          &quot;distributionCut&quot;: { # A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the count of values x in the Distribution such that range.min &lt;= x &lt; range.max. # distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
            &quot;distributionFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
            &quot;range&quot;: { # Range of numerical values, inclusive of min and exclusive of max. If the open range &quot;&lt; range.max&quot; is desired, set range.min = -infinity. If the open range &quot;&gt;= range.min&quot; is desired, set range.max = infinity. # Range of values considered &quot;good.&quot; For a one-sided range, set one bound to an infinite value.
              &quot;max&quot;: 3.14, # Range maximum.
              &quot;min&quot;: 3.14, # Range minimum.
            },
          },
          &quot;goodTotalRatio&quot;: { # A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed. # good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
            &quot;badServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
            &quot;goodServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
            &quot;totalServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
          },
        },
        &quot;threshold&quot;: 3.14, # If window performance &gt;= threshold, the window is counted as good.
      },
      &quot;metricMeanInRange&quot;: { # A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min &lt;= x &lt; range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE. # A window is good if the metric&#x27;s value is in a good range, averaged across returned streams.
        &quot;range&quot;: { # Range of numerical values, inclusive of min and exclusive of max. If the open range &quot;&lt; range.max&quot; is desired, set range.min = -infinity. If the open range &quot;&gt;= range.min&quot; is desired, set range.max = infinity. # Range of values considered &quot;good.&quot; For a one-sided range, set one bound to an infinite value.
          &quot;max&quot;: 3.14, # Range maximum.
          &quot;min&quot;: 3.14, # Range minimum.
        },
        &quot;timeSeries&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
      },
      &quot;metricSumInRange&quot;: { # A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min &lt;= x &lt; range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE. # A window is good if the metric&#x27;s value is in a good range, summed across returned streams.
        &quot;range&quot;: { # Range of numerical values, inclusive of min and exclusive of max. If the open range &quot;&lt; range.max&quot; is desired, set range.min = -infinity. If the open range &quot;&gt;= range.min&quot; is desired, set range.max = infinity. # Range of values considered &quot;good.&quot; For a one-sided range, set one bound to an infinite value.
          &quot;max&quot;: 3.14, # Range maximum.
          &quot;min&quot;: 3.14, # Range minimum.
        },
        &quot;timeSeries&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
      },
      &quot;windowPeriod&quot;: &quot;A String&quot;, # Duration over which window quality is evaluated. Must be an integer fraction of a day and at least 60s.
    },
  },
}

  updateMask: string, A set of field paths defining which fields to use for the update.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A Service-Level Objective (SLO) describes a level of desired good service. It consists of a service-level indicator (SLI), a performance goal, and a period over which the objective is to be evaluated against that goal. The SLO can use SLIs defined in a number of different manners. Typical SLOs might include &quot;99% of requests in each rolling week have latency below 200 milliseconds&quot; or &quot;99.5% of requests in each calendar month return successfully.&quot;
  &quot;calendarPeriod&quot;: &quot;A String&quot;, # A calendar period, semantically &quot;since the start of the current &quot;. At this time, only DAY, WEEK, FORTNIGHT, and MONTH are supported.
  &quot;displayName&quot;: &quot;A String&quot;, # Name used for UI elements listing this SLO.
  &quot;goal&quot;: 3.14, # The fraction of service that must be good in order for this objective to be met. 0 &lt; goal &lt;= 0.999.
  &quot;name&quot;: &quot;A String&quot;, # Resource name for this ServiceLevelObjective. The format is: projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
  &quot;rollingPeriod&quot;: &quot;A String&quot;, # A rolling time period, semantically &quot;in the past &quot;. Must be an integer multiple of 1 day no larger than 30 days.
  &quot;serviceLevelIndicator&quot;: { # A Service-Level Indicator (SLI) describes the &quot;performance&quot; of a service. For some services, the SLI is well-defined. In such cases, the SLI can be described easily by referencing the well-known SLI and providing the needed parameters. Alternatively, a &quot;custom&quot; SLI can be defined with a query to the underlying metric store. An SLI is defined to be good_service / total_service over any queried time interval. The value of performance always falls into the range 0 &lt;= performance &lt;= 1. A custom SLI describes how to compute this ratio, whether this is by dividing values from a pair of time series, cutting a Distribution into good and bad counts, or counting time windows in which the service complies with a criterion. For separation of concerns, a single Service-Level Indicator measures performance for only one aspect of service quality, such as fraction of successful queries or fast-enough queries. # The definition of good service, used to measure and calculate the quality of the Service&#x27;s performance with respect to a single aspect of service quality.
    &quot;basicSli&quot;: { # An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service. # Basic SLI on a well-known service type.
      &quot;availability&quot;: { # Future parameters for the availability SLI. # Good service is defined to be the count of requests made to this service that return successfully.
      },
      &quot;latency&quot;: { # Parameters for a latency threshold SLI. # Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
        &quot;threshold&quot;: &quot;A String&quot;, # Good service is defined to be the count of requests made to this service that return in no more than threshold.
      },
      &quot;location&quot;: [ # OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don&#x27;t support breaking down by location, setting this field will result in an error.
        &quot;A String&quot;,
      ],
      &quot;method&quot;: [ # OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service&#x27;s methods. For service types that don&#x27;t support breaking down by method, setting this field will result in an error.
        &quot;A String&quot;,
      ],
      &quot;version&quot;: [ # OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don&#x27;t support breaking down by version, setting this field will result in an error.
        &quot;A String&quot;,
      ],
    },
    &quot;requestBased&quot;: { # Service Level Indicators for which atomic units of service are counted directly. # Request-based SLIs
      &quot;distributionCut&quot;: { # A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the count of values x in the Distribution such that range.min &lt;= x &lt; range.max. # distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
        &quot;distributionFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
        &quot;range&quot;: { # Range of numerical values, inclusive of min and exclusive of max. If the open range &quot;&lt; range.max&quot; is desired, set range.min = -infinity. If the open range &quot;&gt;= range.min&quot; is desired, set range.max = infinity. # Range of values considered &quot;good.&quot; For a one-sided range, set one bound to an infinite value.
          &quot;max&quot;: 3.14, # Range maximum.
          &quot;min&quot;: 3.14, # Range minimum.
        },
      },
      &quot;goodTotalRatio&quot;: { # A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed. # good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
        &quot;badServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        &quot;goodServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
        &quot;totalServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
      },
    },
    &quot;windowsBased&quot;: { # A WindowsBasedSli defines good_service as the count of time windows for which the provided service was of good quality. Criteria for determining if service was good are embedded in the window_criterion. # Windows-based SLIs
      &quot;goodBadMetricFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries with ValueType = BOOL. The window is good if any true values appear in the window.
      &quot;goodTotalRatioThreshold&quot;: { # A PerformanceThreshold is used when each window is good when that window has a sufficiently high performance. # A window is good if its performance is high enough.
        &quot;basicSliPerformance&quot;: { # An SLI measuring performance on a well-known service type. Performance will be computed on the basis of pre-defined metrics. The type of the service_resource determines the metrics to use and the service_resource.labels and metric_labels are used to construct a monitoring filter to filter that metric down to just the data relevant to this service. # BasicSli to evaluate to judge window quality.
          &quot;availability&quot;: { # Future parameters for the availability SLI. # Good service is defined to be the count of requests made to this service that return successfully.
          },
          &quot;latency&quot;: { # Parameters for a latency threshold SLI. # Good service is defined to be the count of requests made to this service that are fast enough with respect to latency.threshold.
            &quot;threshold&quot;: &quot;A String&quot;, # Good service is defined to be the count of requests made to this service that return in no more than threshold.
          },
          &quot;location&quot;: [ # OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don&#x27;t support breaking down by location, setting this field will result in an error.
            &quot;A String&quot;,
          ],
          &quot;method&quot;: [ # OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service&#x27;s methods. For service types that don&#x27;t support breaking down by method, setting this field will result in an error.
            &quot;A String&quot;,
          ],
          &quot;version&quot;: [ # OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don&#x27;t support breaking down by version, setting this field will result in an error.
            &quot;A String&quot;,
          ],
        },
        &quot;performance&quot;: { # Service Level Indicators for which atomic units of service are counted directly. # RequestBasedSli to evaluate to judge window quality.
          &quot;distributionCut&quot;: { # A DistributionCut defines a TimeSeries and thresholds used for measuring good service and total service. The TimeSeries must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE. The computed good_service will be the count of values x in the Distribution such that range.min &lt;= x &lt; range.max. # distribution_cut is used when good_service is a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution.
            &quot;distributionFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries aggregating values. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
            &quot;range&quot;: { # Range of numerical values, inclusive of min and exclusive of max. If the open range &quot;&lt; range.max&quot; is desired, set range.min = -infinity. If the open range &quot;&gt;= range.min&quot; is desired, set range.max = infinity. # Range of values considered &quot;good.&quot; For a one-sided range, set one bound to an infinite value.
              &quot;max&quot;: 3.14, # Range maximum.
              &quot;min&quot;: 3.14, # Range minimum.
            },
          },
          &quot;goodTotalRatio&quot;: { # A TimeSeriesRatio specifies two TimeSeries to use for computing the good_service / total_service ratio. The specified TimeSeries must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. The TimeSeriesRatio must specify exactly two of good, bad, and total, and the relationship good_service + bad_service = total_service will be assumed. # good_total_ratio is used when the ratio of good_service to total_service is computed from two TimeSeries.
            &quot;badServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
            &quot;goodServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
            &quot;totalServiceFilter&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying a TimeSeries quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE.
          },
        },
        &quot;threshold&quot;: 3.14, # If window performance &gt;= threshold, the window is counted as good.
      },
      &quot;metricMeanInRange&quot;: { # A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min &lt;= x &lt; range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE. # A window is good if the metric&#x27;s value is in a good range, averaged across returned streams.
        &quot;range&quot;: { # Range of numerical values, inclusive of min and exclusive of max. If the open range &quot;&lt; range.max&quot; is desired, set range.min = -infinity. If the open range &quot;&gt;= range.min&quot; is desired, set range.max = infinity. # Range of values considered &quot;good.&quot; For a one-sided range, set one bound to an infinite value.
          &quot;max&quot;: 3.14, # Range maximum.
          &quot;min&quot;: 3.14, # Range minimum.
        },
        &quot;timeSeries&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
      },
      &quot;metricSumInRange&quot;: { # A MetricRange is used when each window is good when the value x of a single TimeSeries satisfies range.min &lt;= x &lt; range.max. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE. # A window is good if the metric&#x27;s value is in a good range, summed across returned streams.
        &quot;range&quot;: { # Range of numerical values, inclusive of min and exclusive of max. If the open range &quot;&lt; range.max&quot; is desired, set range.min = -infinity. If the open range &quot;&gt;= range.min&quot; is desired, set range.max = infinity. # Range of values considered &quot;good.&quot; For a one-sided range, set one bound to an infinite value.
          &quot;max&quot;: 3.14, # Range maximum.
          &quot;min&quot;: 3.14, # Range minimum.
        },
        &quot;timeSeries&quot;: &quot;A String&quot;, # A monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) specifying the TimeSeries to use for evaluating window quality.
      },
      &quot;windowPeriod&quot;: &quot;A String&quot;, # Duration over which window quality is evaluated. Must be an integer fraction of a day and at least 60s.
    },
  },
}</pre>
</div>

</body></html>